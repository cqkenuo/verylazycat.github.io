<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-06-09T10:42:45+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lazycat</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;

&lt;iframe
  src=&quot;https://music.163.com/outchain/player?type=0&amp;id=161689985&amp;auto=0&amp;height=32&quot;
  width=100%
  height=52
  frameborder=&quot;no&quot;
  border=&quot;0&quot;
  marginwidth=&quot;0&quot;
  marginheight=&quot;0&quot;
&gt;&lt;/iframe&gt;
</subtitle><entry><title type="html">linux编程-进程间通信</title><link href="http://localhost:4000/_posts/2020-06-09-linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="alternate" type="text/html" title="linux编程-进程间通信" /><published>2020-06-09T00:00:00+08:00</published><updated>2020-06-09T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-09-linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;管道&quot;&gt;管道&lt;/h1&gt;

&lt;h2 id=&quot;内核提供单工自同步机制&quot;&gt;内核提供,单工,自同步机制&lt;/h2&gt;

&lt;h2 id=&quot;匿名管道&quot;&gt;匿名管道&lt;/h2&gt;

&lt;p&gt;pipe&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;create pipe&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int pipe(int pipefd[2]);
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include &amp;lt;fcntl.h&amp;gt;              /* Obtain O_* constant definitions */
#include &amp;lt;unistd.h&amp;gt;
int pipe2(int pipefd[2], int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;命名管道&quot;&gt;命名管道&lt;/h2&gt;

&lt;h1 id=&quot;xsi&quot;&gt;XSI&lt;/h1&gt;

&lt;p&gt;IPC -&amp;gt; Internet Process Communication&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;ipcs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;key:ftok&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;convert  a pathname and a project identifier to a System V IPC key&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
key_t ftok(const char *pathname, int proj_id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Message Queues&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;msgget&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;get a System V message queue identifier&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/msg.h&amp;gt;
int msgget(key_t key, int msgflg);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;msgop&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;System V message queue operations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/msg.h&amp;gt;
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
int msgflg);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;msgctl&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;System V message control operations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/msg.h&amp;gt;
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Semaphore Arrays&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;semget&lt;/li&gt;
  &lt;li&gt;semop&lt;/li&gt;
  &lt;li&gt;semctl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Shared Memory&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;shmget&lt;/li&gt;
  &lt;li&gt;shmop&lt;/li&gt;
  &lt;li&gt;shmctl&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;网络套接字socket&quot;&gt;网络套接字socket&lt;/h1&gt;

&lt;h2 id=&quot;字节序问题&quot;&gt;字节序问题&lt;/h2&gt;

&lt;p&gt;大端:低地址放高字节&lt;/p&gt;

&lt;p&gt;小端:低地址放低字节&lt;/p&gt;

&lt;h2 id=&quot;报式套接字&quot;&gt;报式套接字&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;socket&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;create an endpoint for communication&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */
#include &amp;lt;sys/socket.h&amp;gt;
int socket(int domain, int type, int protocol);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;bind&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;bind a name to a socket&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */
#include &amp;lt;sys/socket.h&amp;gt;
int bind(int sockfd, const struct sockaddr *addr,
socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;sendto&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;send a message on a socket&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;rcvfrom&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;inet_pton&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;convert IPv4 and IPv6 addresses from text to binary form&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;arpa/inet.h&amp;gt;
int inet_pton(int af, const char *src, void *dst);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;inet_ntop&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;convert IPv4 and IPv6 addresses from binary to text form&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;arpa/inet.h&amp;gt;
const char *inet_ntop(int af, const void *src,
char *dst, socklen_t size);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;getsockopt&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;setsockopt&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;get and set options on sockets&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */
#include &amp;lt;sys/socket.h&amp;gt;
int getsockopt(int sockfd, int level, int optname,
void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname,
const void *optval, socklen_t optlen);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;多点通讯&quot;&gt;多点通讯&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;广播
    &lt;ul&gt;
      &lt;li&gt;全网广播&lt;/li&gt;
      &lt;li&gt;子网广播&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;多播/组播&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;流式套接字&quot;&gt;流式套接字&lt;/h2&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">虚拟内存</title><link href="http://localhost:4000/_posts/2020-06-08-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" rel="alternate" type="text/html" title="虚拟内存" /><published>2020-06-08T00:00:00+08:00</published><updated>2020-06-08T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-08-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;概念&quot;&gt;概念&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;现代所有用于一般应用的操作系统都对普通的应用程序使用虚拟内存技术，老一些的操作系统，如DOS和1980年代的Windows，或者那些1960年代的大型机，一般都没有虚拟内存的功能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在很久以前,程序指令所访问的内存地址就是物理内存地址,也就是不得不把程序的全部装进内存当中，然后运行。&lt;/p&gt;

&lt;p&gt;物理内存其实就是插在计算机主板内存槽上的实际物理内存，CPU可以直接进行寻址。物理内存的容量是固定的，但是寻址空间却取决于cpu地址线条数，如32位机，则寻址空间为2^32 = 4G，所以最大支只持4G的寻址空间，即使插了8G的内存条也只能使用4G内存;&lt;/p&gt;

&lt;h1 id=&quot;直接使用物理内存产生的问题&quot;&gt;直接使用物理内存产生的问题&lt;/h1&gt;

&lt;p&gt;在这种直接使用物理内存的状态下就会产生一些问题:&lt;/p&gt;

&lt;h2 id=&quot;内存空间利用率的问题&quot;&gt;内存空间利用率的问题&lt;/h2&gt;

&lt;p&gt;各个进程对内存的使用会导致内存碎片化，当要用malloc分配一块很大的内存空间时，可能会出现虽然有足够多的空闲物理内存，却没有足够大的连续空闲内存这种情况，东一块西一块的内存碎片就被浪费掉了&lt;/p&gt;

&lt;h2 id=&quot;读写内存的安全性问题&quot;&gt;读写内存的安全性问题&lt;/h2&gt;

&lt;p&gt;物理内存本身是不限制访问的，任何地址都可以读写，而现代操作系统需要实现不同的页面具有不同的访问权限，例如只读的数据等等&lt;/p&gt;

&lt;h2 id=&quot;进程间的安全问题&quot;&gt;进程间的安全问题&lt;/h2&gt;

&lt;p&gt;各个进程之间没有独立的地址空间，一个进程由于执行错误指令或是恶意代码都可以直接修改其它进程的数据，甚至修改内核地址空间的数据，这是操作系统所不愿看到的&lt;/p&gt;

&lt;h2 id=&quot;内存读写的效率问题&quot;&gt;内存读写的效率问题&lt;/h2&gt;

&lt;p&gt;当多个进程同时运行，需要分配给进程的内存总和大于实际可用的物理内存时，需要将其他程序暂时拷贝到硬盘当中，然后将新的程序装入内存运行。由于大量的数据频繁装入装出，内存的使用效率会非常低&lt;/p&gt;

&lt;h1 id=&quot;什么是虚拟内存&quot;&gt;什么是虚拟内存&lt;/h1&gt;

&lt;p&gt;每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，虚拟的意思就是，其实这个地址空间时不存在的，仅仅是每个进程“认为”自己拥有4G的内存，而实际上，它用了多少空间，操作系统就在磁盘上划出多少空间给它，等到进程真正运行的时候，需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行数据拷贝&lt;/p&gt;

&lt;p&gt;更准确一点的说，系统将虚拟内存分割为称为虚拟页(Virtual Page,VP)的大小固定的块，每个虚拟页的大小为P =  2^p字节，类似地，物理内存被分割为物理页(Physical Page,PP)，大小也为P字节（物理页也称为页帧(page frame)）&lt;/p&gt;

&lt;p&gt;在任意时刻，虚拟页面都分为互不相交的三种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;未分配的：系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间&lt;/li&gt;
  &lt;li&gt;未缓存的：没有缓存在物理存储器中的已分配页&lt;/li&gt;
  &lt;li&gt;缓存的：当前缓存在物理存储器中的已分配页&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图是一个示例：&lt;img src=&quot;/img/虚拟存储器.jpg&quot; alt=&quot;虚拟存储器&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个示例展示了一个有8个虚拟页的小虚拟存储器，虚拟页0和3还没有被分配，因此在磁盘上还不存在。虚拟页1、4和6被缓存在物理存储器中。页2、5和7已经被分配了，但是当前并未缓存在主存中&lt;/p&gt;

&lt;p&gt;操作系统向进程描述了一个完整的连续的虚拟地址空间供进程使用，但是在物理内存中进程数据的存储采用离散式存储(提高内存利用率)，但是其实虚拟内存和物理内存之间的关系并不像上图中那样直接，其中还需要使用页表映射虚拟地址与物理地址的映射关系，并且通过页表实现内存访问控制。&lt;/p&gt;

&lt;h1 id=&quot;页表&quot;&gt;页表&lt;/h1&gt;

&lt;p&gt;页表是一种特殊的数据结构，存放着各个虚拟页的状态，是否映射，是否缓存.。进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，这就需要用页表来记录。页表的每一个表项分为两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址(如果在的话)。当进程访问某个虚拟地址，就会先去看页表，如果发现对应的数据不在物理内存中，则发生缺页异常。&lt;/p&gt;

&lt;p&gt;缺页异常的事等下再说，先体会一下虚拟内存究竟是如何通过页表与物理内存联系起来的，再看一个示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/页表.jpg&quot; alt=&quot;页表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中展示了一个页表的基本组织结构，页表就是一个页表条目(Page Table  Entry,PTE)的数组，每个PTE由一个有效位(valid  bit)和一个地址组成，有效位表明了该虚拟页当前是否存在于物理内存中，如果有效位是1，该PTE中就会存储物理内存中相应的物理页的起始地址。如果有效位是0，且PTE中的地址为null，这表示这个虚拟页还未被分配，而如果有效位是0且PTE中有地址，那么这个地址指向该虚拟页在磁盘上的起始位置&lt;/p&gt;

&lt;p&gt;上图的示例展示了一个有8个虚拟页和4个物理页的系统的页表，四个虚拟页（VP1、VP2、VP4和VP7）当前存储于物理内存中，两个页（VP0和VP5）还未被分配（也就是什么都没存的虚拟内存，在磁盘和物理内存中都不存在这个空间），而剩下的页（VP3和VP6）已经被分配了，但是还未缓存进物理内存（也就是存在于磁盘上）&lt;/p&gt;

&lt;p&gt;在上面的过程中，CPU读包含在VP1中的一个数据时，地址翻译硬件将虚拟地址作为一个索引找到页表中的PTE 2，然后再从PTE 2中保存的物理地址从真正的物理内存中读到这个数据，在有效位为1的PTE中成功找到对应的物理页就称之为页命中&lt;/p&gt;

&lt;p&gt;而当试图访问一个有效位为0，但PTE中又保存了地址的虚拟内存中的数据时（也就是VP3和VP6的情况，数据保存在磁盘中），就是DRAM缓存不命中，一般将这种状况称为缺页异常(page  fault)。触发缺页异常后，系统会调用内核中的缺页异常处理程序，该程序会选择一个牺牲页(牺牲页的选择有具体的算法，在这里不做讨论)，在此例中就是存放在PP3中的VP4，内核将修改后的VP4重新拷贝回磁盘，并且修改VP4中的页表条目，将有效位改成0，反映出VP4不再存在于物理内存中这一事实。接下来，内核从磁盘拷贝VP3到存储器中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，再次从试图访问该虚拟地址开始，这时有效位是1，于是正常页命中，从物理地址中读取内存&lt;/p&gt;

&lt;h1 id=&quot;虚拟内存的工作原理&quot;&gt;虚拟内存的工作原理&lt;/h1&gt;

&lt;p&gt;当一个进程试图访问虚拟地址空间中的某个数据时，会经历下面两种情况的过程:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CPU想访问某个虚拟内存地址，找到进程对应的页表中的条目，判断有效位， 如果有效位为1，说明在页表条目中的物理内存地址不为空，根据物理内存地址，访问物理内存中的内容，返回&lt;/li&gt;
  &lt;li&gt;CPU想访问某个虚拟内存地址，找到进程对应的页表中的条目，判断有效位，如果有效位为0，但页表条目中还有地址，这个地址是磁盘空间的地址，这时触发缺页异常，系统把物理内存中的一些数据拷贝到磁盘上，腾出所需的空间，并且更新页表。此时重新执行访问之前虚拟内存的指令，就会发现变成了情况1.&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="操作系统" /><summary type="html">[toc]</summary></entry><entry><title type="html">进程虚拟地址空间区域划分</title><link href="http://localhost:4000/_posts/2020-06-08-%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/" rel="alternate" type="text/html" title="进程虚拟地址空间区域划分" /><published>2020-06-08T00:00:00+08:00</published><updated>2020-06-08T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-08-%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;首先要知道一点，程序由磁盘加载到内存时是不可能直接加载到物理内存当中的，这里的原因以及物理内存和虚拟内存的区别与联系在本篇先不做讨论&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;本篇接下来所讨论的范围在x86体系32位Linux环境下&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux系统会给当前每一个进程分配一个2^32位大小(4G)的一块空间，这块空间就叫做进程的虚拟地址空间&lt;/p&gt;

&lt;p&gt;这里附上IBM公司关于&lt;strong&gt;虚拟&lt;/strong&gt;的解释:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;它存在，你看得见，它是物理的&lt;/li&gt;
  &lt;li&gt;它存在，你看不见，它是透明的&lt;/li&gt;
  &lt;li&gt;它不存在，你看得见，它是虚拟的&lt;/li&gt;
  &lt;li&gt;它不存在，你看不见，它被删除&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这块空间的内容如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/内存空间.png&quot; alt=&quot;内存空间&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来分别阐述每块空间的作用:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从0x00000000到0x08048000的这段空间是预留的，是不能访问的，例如对空指针进行访问程序就会崩溃&lt;/li&gt;
  &lt;li&gt;程序运行时产生的指令就放在.text段（代码段）。这一段同时也保存了只读数据（read only data），例如char* p = “hello world”中的”hello world”，在这里，当想进行*p = ‘a’操作时可以通过编译但运行会崩溃（在比较新的c++编译器中不允许用普通指针指向常量字符串），因为该段是只能读但不能写的。&lt;/li&gt;
  &lt;li&gt;.data存放了初始化了的且初始化的值不为0的数据&lt;/li&gt;
  &lt;li&gt;.bss存放未初始化及初始化为0的数据,打印未初始化的全局变量会看到值为0，因为存放于.bss段，操作系统会将.bss段的数据全部赋值为0&lt;/li&gt;
  &lt;li&gt;堆（heap），在《深入理解计算机系统》中的名称是运行时堆（由malloc创建），也就是说这里的堆空间是暂时没有的，当程序运行，new或malloc之后才会分配堆内存，由低地址向高地址增长&lt;/li&gt;
  &lt;li&gt;加载共享库，也就是动态链接库，Windows下是&lt;em&gt;.dll,Linux下是&lt;/em&gt;so&lt;/li&gt;
  &lt;li&gt;stack 函数运行或产生线程时，每一个函数/线程独有的栈空间，由高地址向低地址增长的&lt;/li&gt;
  &lt;li&gt;命令行参数和环境变量，命令行参数如main函数传参，环境变量如搜索头文件、库文件时默认的路径&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过分析具体代码的方式体会虚拟地址空间的划分:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int g_data1 = 10;
int g_data2 = 0;
int g_data3;

static int g_data4 = 11;
static int g_data5 = 0;
static int g_data6;

int main(){
    int a = 12;
    int b = 0;
    int c;

    static int e = 13;
    static int f = 0;
    static int g;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的程序中，所有的全局变量（g_data），不管是普通的还是静态（static）的，每一个在编译后的符号表中都会产生符号，他们叫做数据。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;g_data1和g_data4都是初始化了的且初始化的值不为0的，所以它们放在.data段&lt;/li&gt;
  &lt;li&gt;g_data3和g_data6都是未初始化的，g_data2和g_data5虽然已经初始化但初始化值为0，所以它们都放在.bss段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而在main函数中，a、b、c三个局部变量并不会在符号表中产生符号，它们生成的是指令，例如int a = 12;在x86架构的汇编中产生的是mov dword ptr[a],0Ch指令，也就是将0Ch(12)移入a的内存，所以它们三个其实是放在指令段（.text）的
main函数中的e、f、g三个静态局部变量也是放在数据段的，但是程序启动时不会初始化，当程序运行到该条语句时才会初始化，它们的存储位置与全局变量相同&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;e是初始化且不为0的，放在.data段&lt;/li&gt;
  &lt;li&gt;f虽然初始化但初始化值为0，g未初始化，所以都放在.bss段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这里，如果打印c，c的值不会为0，而打印g的值为0，原因就是g存放在.bss段，操作系统自动赋初值为0了.&lt;/p&gt;

&lt;p&gt;同时这里理解时可能会产生一个问题，通常我们说局部变量是在栈上，为什么这里说是指令保存在指令段呢？事实上，int a = 12这句代码在编译时产生的是一条指令，这个指令保存在.text段，而在运行时，系统会在当前进程的栈上给函数开辟一个栈帧，该指令运行时会在栈上开辟一段4个字节的空间存放“12”这个整数&lt;/p&gt;

&lt;p&gt;同时对于这一部分也要注意，每一个进程的用户空间是私有的，但是内核空间是共享的。这也就是进程间通信比较困难的原因，而进程间通信方式的一种，匿名管道通信其实就是在内核空间中划分出一片内存，每个进程就都可以在这片空间写入数据给其他进程看，由此实现通信的目的&lt;/p&gt;</content><author><name></name></author><category term="操作系统" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程-高级IO</title><link href="http://localhost:4000/_posts/2020-06-06-linux%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO/" rel="alternate" type="text/html" title="linux编程-高级IO" /><published>2020-06-06T00:00:00+08:00</published><updated>2020-06-06T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-06-linux%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;非阻塞io&quot;&gt;非阻塞IO&lt;/h1&gt;

&lt;h2 id=&quot;非阻塞io概念&quot;&gt;非阻塞IO概念&lt;/h2&gt;

&lt;p&gt;简单流程:自然流程是结构化的&lt;/p&gt;

&lt;p&gt;复杂流程:自然流程不是结构化的&lt;/p&gt;

&lt;h2 id=&quot;io多路转接&quot;&gt;IO多路转接&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;select&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;synchronous I/O  multiplexing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* According to POSIX.1-2001, POSIX.1-2008 */
#include &amp;lt;sys/select.h&amp;gt;
/* According to earlier standards */
#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int select(int nfds, fd_set *readfds, fd_set *writefds,
fd_set *exceptfds, struct timeval *timeout);
void FD_CLR(int fd, fd_set *set);
int  FD_ISSET(int fd, fd_set *set);
void FD_SET(int fd, fd_set *set);
void FD_ZERO(fd_set *set);
#include &amp;lt;sys/select.h&amp;gt;
int pselect(int nfds, fd_set *readfds, fd_set *writefds,
fd_set *exceptfds, const struct timespec *timeout,
const sigset_t *sigmask);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;poll&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;wait for some event on a file descriptor&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;poll.h&amp;gt;
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;
int ppoll(struct pollfd *fds, nfds_t nfds,
const struct timespec *tmo_p, const sigset_t *sigmask);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;epoll&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;I/O event notification facility&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查看机制&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;man 7 epoll
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;其他读写函数&quot;&gt;其他读写函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;readv&lt;/li&gt;
  &lt;li&gt;writev&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;read or write data into multiple buffers&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/uio.h&amp;gt;
ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
ssize_t preadv(int fd, const struct iovec *iov, int iovcnt,
off_t offset);
ssize_t pwritev(int fd, const struct iovec *iov, int iovcnt,
off_t offset);
ssize_t preadv2(int fd, const struct iovec *iov, int iovcnt,
off_t offset, int flags);
ssize_t pwritev2(int fd, const struct iovec *iov, int iovcnt,
off_t offset, int flags);
struct iovec {
               void  *iov_base;    /* Starting address */
               size_t iov_len;     /* Number of bytes to transfer */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;存储映射io&quot;&gt;存储映射IO&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;mmap&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;map or unmap files or devices into memory&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/mman.h&amp;gt;
void *mmap(void *addr, size_t length, int prot, int flags,
int fd, off_t offset);
int munmap(void *addr, size_t length);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;文件锁&quot;&gt;文件锁&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;lockf&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;test or remove a POSIX lock on an open file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int lockf(int fd, int cmd, off_t len);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;flock&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;apply or remove an advisory lock on an open file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/file.h&amp;gt;
int flock(int fd, int operation);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;有限状态机编程&quot;&gt;有限状态机编程&lt;/h1&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">排序算法</title><link href="http://localhost:4000/_posts/2020-06-06-%E6%8E%92%E5%BA%8F/" rel="alternate" type="text/html" title="排序算法" /><published>2020-06-06T00:00:00+08:00</published><updated>2020-06-06T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E6%8E%92%E5%BA%8F</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-06-%E6%8E%92%E5%BA%8F/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/冒泡排序.webp&quot; alt=&quot;冒泡排序&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void BubbleSort(int *array,int length)
{
    if (array == NULL)
    {
        fprintf(stderr,&quot;empty\n&quot;);
        exit(1);
    }
    int temp = 0;
    for (size_t i = 0; i &amp;lt; length; i++)
    {
        for (size_t j = i+1; j &amp;lt; length; j++)
        {
            if (array[i] &amp;gt; array[j])
            {
                temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            } 
        }          
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;选择排序&quot;&gt;选择排序&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;在一个长度为 N 的无序数组中，第一次遍历 n-1 个数找到最小的和第一个数交换。&lt;/li&gt;
  &lt;li&gt;第二次从下一个数开始遍历 n-2 个数，找到最小的数和第二个数交换。&lt;/li&gt;
  &lt;li&gt;重复以上操作直到第 n-1 次遍历最小的数和第 n-1 个数交换，排序完成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/选择排序.gif&quot; alt=&quot;选择排序&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void SelectSort(int *array,int length)
{
    if (array == NULL || length == 0)
    {
        fprintf(stderr,&quot;empty\n&quot;);
        exit(1);
    }
    for (size_t i = 0; i &amp;lt; length; i++)
    {
        int MinKey = array[i];
        for (size_t j = i; j &amp;lt; length; j++)
        {
            if (MinKey &amp;gt; array[j])
            {
                int temp = array[j];
                array[j] = MinKey;
                MinKey = temp;
            } 
        }
           array[i] = MinKey;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;快速排序&quot;&gt;快速排序&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先设定一个分界值，通过该分界值将数组分成左右两部分。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/快速排序.gif&quot; alt=&quot;快速排序&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="算法" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程-并发</title><link href="http://localhost:4000/_posts/2020-05-30-linux%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91/" rel="alternate" type="text/html" title="linux编程-并发" /><published>2020-05-30T00:00:00+08:00</published><updated>2020-05-30T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-30-linux%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;信号&quot;&gt;信号&lt;/h1&gt;

&lt;h2 id=&quot;信号概念&quot;&gt;信号概念&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;同步:&lt;/p&gt;

  &lt;p&gt;异步:&lt;/p&gt;

  &lt;p&gt;异步事件的处理:查询法,通知法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;信号是软件的&lt;code&gt;中断&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;signal&quot;&gt;signal&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;void(&lt;em&gt;signal(intosignum,void (&lt;/em&gt;func)(int)))(int)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;信号会打断阻塞的系统调用&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;信号不可靠&quot;&gt;信号不可靠&lt;/h2&gt;

&lt;h2 id=&quot;可重入函数&quot;&gt;可重入函数&lt;/h2&gt;

&lt;p&gt;所有的系统调用都是可重入的,一部分库函数也可以重入,如memcpy&lt;/p&gt;

&lt;h2 id=&quot;信号响应过程&quot;&gt;信号响应过程&lt;/h2&gt;

&lt;h2 id=&quot;常用函数&quot;&gt;常用函数&lt;/h2&gt;

&lt;h3 id=&quot;kill&quot;&gt;kill&lt;/h3&gt;

&lt;p&gt;send signal to a process&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
int kill(pid_t pid, int sig);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;raise&quot;&gt;raise&lt;/h3&gt;

&lt;p&gt;send a signal to the caller&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int raise(int sig);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;alarm&quot;&gt;alarm&lt;/h3&gt;

&lt;p&gt;set an alarm clock for delivery of a signal&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
unsigned int alarm(unsigned int seconds);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;pause&quot;&gt;pause&lt;/h3&gt;

&lt;p&gt;wait for signal&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int pause(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;setitimer&quot;&gt;setitimer&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/time.h&amp;gt;
int getitimer(int which, struct itimerval *curr_value);
int setitimer(int which, const struct itimerval *new_value,
struct itimerval *old_value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽量用setitimer不要alarm&lt;/p&gt;

&lt;h3 id=&quot;abort&quot;&gt;abort&lt;/h3&gt;

&lt;p&gt;cause abnormal process termination&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
void abort(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;system&quot;&gt;system&lt;/h3&gt;

&lt;p&gt;execute a shell command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int system(const char *command);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;During  execution  of  the command, SIGCHLD will be blocked, and SIGINT
       and SIGQUIT will be ignored, in the process that calls system()  (these
       signals  will  be  handled according to their defaults inside the child
       process that executes command)&lt;/p&gt;

&lt;h3 id=&quot;sleep&quot;&gt;sleep&lt;/h3&gt;

&lt;p&gt;sleep for a specified number of seconds&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
unsigned int sleep(unsigned int seconds);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;信号集&quot;&gt;信号集&lt;/h2&gt;

&lt;p&gt;sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX sig‐nal set operations&lt;/p&gt;

&lt;p&gt;类型:sigset_t&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
int sigismember(const sigset_t *set, int signum);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;sigpending&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigpending(sigset_t *set);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;信号屏蔽字pending集的处理&quot;&gt;信号屏蔽字/pending集的处理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;sigprocmask&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;sigprocmask, rt_sigprocmask - examine and change blocked signals&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
/* Prototype for the glibc wrapper function */
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
/* Prototype for the underlying system call */
int rt_sigprocmask(int how, const kernel_sigset_t *set,
kernel_sigset_t *oldset, size_t sigsetsize);
/* Prototype for the legacy system call (deprecated) */
int sigprocmask(int how, const old_kernel_sigset_t *set,
old_kernel_sigset_t *oldset);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;联系mask和pending的位图,理解原理&lt;/p&gt;

&lt;h2 id=&quot;扩展函数&quot;&gt;扩展函数&lt;/h2&gt;

&lt;h3 id=&quot;sigsuspend&quot;&gt;sigsuspend&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigsuspend(const sigset_t *mask);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sigaction&quot;&gt;sigaction&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigaction(int signum, const struct sigaction *act,
struct sigaction *oldact);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;实时信号&quot;&gt;实时信号&lt;/h2&gt;

&lt;h1 id=&quot;线程&quot;&gt;线程&lt;/h1&gt;

&lt;h2 id=&quot;线程概念&quot;&gt;线程概念&lt;/h2&gt;

&lt;p&gt;posix标准&lt;/p&gt;

&lt;p&gt;openmp线程&lt;/p&gt;

&lt;p&gt;线程标识:pthread_t&lt;/p&gt;

&lt;p&gt;pthread_equal&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;compare thread IDs&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_equal(pthread_t t1, pthread_t t2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pthread_self&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;obtain ID of the calling thread&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
pthread_t pthread_self(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;线程创建&quot;&gt;线程创建&lt;/h2&gt;

&lt;p&gt;pthread_create&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;create a new thread&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
void *(*start_routine) (void *), void *arg);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程的调度取决于调度器策略&lt;/p&gt;

&lt;h2 id=&quot;线程终止&quot;&gt;线程终止&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;线程从启动例程返回,返回值就是线程的退出码&lt;/li&gt;
  &lt;li&gt;线程可以被同一进程中的其他线程取消&lt;/li&gt;
  &lt;li&gt;线程调用&lt;code&gt;pthread_exi&lt;/code&gt;t函数&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
void pthread_exit(void *retval);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pthread_join&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_join(pthread_t thread, void **retval);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;线程的取消选项&quot;&gt;线程的取消选项&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_cancel&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;send a cancellation request to a thread&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_cancel(pthread_t thread);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;可取消状态&lt;/li&gt;
  &lt;li&gt;取消类型(推迟取消)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;取消点必须是系统调用&lt;/p&gt;

&lt;h2 id=&quot;栈清理&quot;&gt;栈清理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_cleanup_push&lt;/li&gt;
  &lt;li&gt;pthread_cleanup_pop&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;类似钩子函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancel-lation clean-up handlers&lt;/p&gt;

&lt;p&gt;必须匹配使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
void pthread_cleanup_push(void (*routine)(void *),
void *arg);
void pthread_cleanup_pop(int execute);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;线程同步&quot;&gt;线程同步&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ubuntu 环境需要安装:sudo apt-get install glibc-doc&lt;/p&gt;

  &lt;p&gt;sudo apt-get install manpages-posix-dev&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;互斥量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
pthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;
int  pthread_mutex_init(pthread_mutex_t  *mutex,  const  pthread_mutex‐
attr_t *mutexattr);
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
int pthread_mutex_destroy(pthread_mutex_t *mutex);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件变量&lt;/p&gt;

&lt;p&gt;类型:pthread_conf_t&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_cond_init&lt;/li&gt;
  &lt;li&gt;pthread_cond_signal&lt;/li&gt;
  &lt;li&gt;pthread_cond_broadcast&lt;/li&gt;
  &lt;li&gt;pthread_cond_wait&lt;/li&gt;
  &lt;li&gt;pthread_cond_timedwait&lt;/li&gt;
  &lt;li&gt;pthread_cond_destroy&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int    pthread_cond_init(pthread_cond_t    *cond,    pthread_condattr_t
*cond_attr);
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int   pthread_cond_timedwait(pthread_cond_t   *cond,    pthread_mutex_t
*mutex, const struct timespec *abstime);
int pthread_cond_destroy(pthread_cond_t *cond);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;信号量&lt;/p&gt;

&lt;p&gt;读写锁&lt;/p&gt;

&lt;p&gt;读锁-&amp;gt;共享锁;&lt;/p&gt;

&lt;p&gt;写锁-&amp;gt;互斥锁&lt;/p&gt;

&lt;h2 id=&quot;线程属性&quot;&gt;线程属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_attr_init&lt;/li&gt;
  &lt;li&gt;pthread_attr_destroy&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_attr_init(pthread_attr_t *attr);
int pthread_attr_destroy(pthread_attr_t *attr);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;pthread_attr_init, pthread_attr_destroy - initialize and destroy thread attributes object&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;详细参考 SEE ALSO&lt;/p&gt;

&lt;h2 id=&quot;线程同步属性&quot;&gt;线程同步属性&lt;/h2&gt;

&lt;p&gt;互斥量属性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_mutexattr_init&lt;/li&gt;
  &lt;li&gt;pthread_mutexattr_destroy&lt;/li&gt;
  &lt;li&gt;pthread_mutexattr_settype&lt;/li&gt;
  &lt;li&gt;pthread_mutexattr_gettype&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_mutexattr_init(pthread_mutexattr_t *attr);
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind);
int  pthread_mutexattr_gettype(const  pthread_mutexattr_t  *attr,   int
*kind);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;clone&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;create a child process&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define _GNU_SOURCE
#include &amp;lt;sched.h&amp;gt;
int clone(int (*fn)(void *), void *child_stack,
int flags, void *arg, ...
/* pid_t *ptid, void *newtls, pid_t *ctid */ );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件变量属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int    pthread_cond_init(pthread_cond_t    *cond,    pthread_condattr_t
*cond_attr);
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int   pthread_cond_timedwait(pthread_cond_t   *cond,    pthread_mutex_t
*mutex, const struct timespec *abstime);
int pthread_cond_destroy(pthread_cond_t *cond);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;更多参考SEE ALSO&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;重入&quot;&gt;重入&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;POSIX标准规定发布的库要支持并发,如果不支持,函数名称要体现出来&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;多线程中的io&quot;&gt;多线程中的IO&lt;/h3&gt;

&lt;h3 id=&quot;线程与信号&quot;&gt;线程与信号&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_sigmask&lt;/li&gt;
  &lt;li&gt;sigwait&lt;/li&gt;
  &lt;li&gt;pthread_kill&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigwait(const sigset_t *set, int *sig);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int pthread_kill(pthread_t thread, int sig);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;线程与fork&quot;&gt;线程与fork&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;openmp标准&quot;&gt;openmp标准&lt;/h2&gt;

&lt;p&gt;www.OpenMP.org&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
int main(int argc, char const *argv[])
{
#pragma omp parallel
{
        puts(&quot;hello&quot;);
        puts(&quot;world&quot;);
}
         exit(0);
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">KMP算法</title><link href="http://localhost:4000/_posts/2020-05-26-KMP%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html" title="KMP算法" /><published>2020-05-26T00:00:00+08:00</published><updated>2020-05-26T00:00:00+08:00</updated><id>http://localhost:4000/_posts/KMP%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-26-KMP%E7%AE%97%E6%B3%95/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;bf&quot;&gt;BF&lt;/h1&gt;

&lt;p&gt;Brute-Force(BF) 算法又称naive算法，是对字符串子串搜索最简单明了的算法。其主旨就是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不处理模式串&lt;/li&gt;
  &lt;li&gt;模式串从目标串&lt;strong&gt;第一个元素&lt;/strong&gt;起逐一匹配&lt;/li&gt;
  &lt;li&gt;发现无法匹配，模式串匹配右移一位，从下一位目标串元素重新初始逐一元素匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/BF.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然简单易懂，但是同时也导致了复杂度较高，最慢的情形其复杂度可以到达O（模式串长 * 目标串长）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/BF_LOW.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;kmp&quot;&gt;&lt;strong&gt;KMP&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;但是如果仔细观察，可以发现&lt;strong&gt;模式串&lt;/strong&gt;本身是可以自带一些&lt;strong&gt;可被预先计算出&lt;/strong&gt;的&lt;strong&gt;可用于加速匹配的信息&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;当模式串的第K位失配时，前K-1位必然是匹配的，如果直接整体后移一位重新从头开始匹配那之前的那些&lt;strong&gt;已经匹配的信息&lt;/strong&gt;就被浪费了。于是我们可以寻找&lt;strong&gt;最大的必定不需要再匹配的串&lt;/strong&gt;，那这个串是什么呢？&lt;/p&gt;

&lt;p&gt;很显然，这个串就是[1,K-1]位串中&lt;strong&gt;最大且相同&lt;/strong&gt;的&lt;strong&gt;头尾&lt;/strong&gt;串（S）。当失配发生，可以直接&lt;strong&gt;保持目标串中的失配元素不变&lt;/strong&gt;，移动模式串，K-1-S串长个单位重新匹配，这就是KMP算法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/KMP.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么要移动K-1-S串长个单位？失配元素前方一共有K-1个元素，最大相同头尾串长为S。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/KMP2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;若移动小于K-1-S长度(例如K-1-S-1 = K - 1 - (S+1))，则必然无法匹配，因为不存在&lt;strong&gt;更大&lt;/strong&gt;的相同首尾串，如下图中（bab不是相同首尾串，故必然不匹配）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/KMP3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;若移动大于K-1-S长度(例如K-1-S+1 = K - 1 - (S-1))，有可能匹配（当S-1同样是相同子串时），但是可能会因为多移动了位数而遗漏结果。&lt;/p&gt;

&lt;p&gt;KMP算法本身比较好理解，而关于KMP的实现需要引入一个Next数组（由模式串预处理出的数组），Next数组的本身的算法则很难理解&lt;/p&gt;

&lt;h1 id=&quot;next数组&quot;&gt;&lt;strong&gt;Next数组&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Next数组的含义很直观，就是&lt;strong&gt;第几个元素失配时应该右移模式串重新匹配第几个元素&lt;/strong&gt;（不同的教材采用的首元素索引序号不同有的是0有的是1，这也是Next数组算法难以理解的一大原因，所以文中讨论索引序号都直接使用的是&lt;strong&gt;第&lt;/strong&gt;几个元素）。&lt;/p&gt;

&lt;p&gt;Next数组的算法步骤如下图所示，在我们逐步讨论完其算法过程后再会看这张动图或许你会有更深刻地理解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/next.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;逐步讨论&quot;&gt;&lt;strong&gt;逐步讨论&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;对于模式串的首个元素的Next值，约定为&lt;strong&gt;首元素索引值 - 1&lt;/strong&gt;，这么做仅仅是为了&lt;strong&gt;方便实现递归算法&lt;/strong&gt;。这个值&lt;strong&gt;不一定只为首元素的Next值&lt;/strong&gt;，经过优化后可能为其他元素的Next值，这个值（首元素索引 - 1）的含义是：&lt;/p&gt;

&lt;p&gt;将&lt;strong&gt;模式串&lt;/strong&gt;的&lt;strong&gt;首元素&lt;/strong&gt;移动到&lt;strong&gt;失配元素后一位&lt;/strong&gt;并从首元素开始，重新匹配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/next2.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;kmp实现&quot;&gt;KMP实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// T 模式串， S目标串， pos第几个字符之后搜索
// 约定索引起始值为1
void Index_KMP(SString S, SString T, int pos){
   // i 目标串指针，j 模式串指针
    i = pos; j = 1;
    // 只要指针没有溢出对应的串
    while( i &amp;lt;= length(S) &amp;amp;&amp;amp; j &amp;lt;= length(T)){
        // 如果将要和 目标串元素 匹配的元素是模式串首元素前一位的元素
        // 或者
        // 当前目标串元素 和 模式串元素可以匹配
        // if (j == first_indexof(T) - 1 || S[i] == T[j]){
        if(j == 0 || S[i] == T[j]){
           // 指针各自右移一位
            ++i;
            ++j;
        }else{
            // 发生了失配，查Next数组移动模式串指针
            j = next[j];
        }
    }
    if (j &amp;gt; length(T)){
        // 如果模式串指针溢出了（模式串指针匹配完毕了所有模式串中的元素）
       return i - length(T);
    }
    else return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;next&quot;&gt;next&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// T 模式串， next Next数组
// 约定索引起始值为1
void get_next(SString T, int &amp;amp;next[]){
    // i 计算每一个元素Next值的指针，它只可能右移用于计算下一个元素的Next值
    // j 用于指向 无法找到头尾串时 的递归回溯的元素 
    // 初始化第一个元素的Next值
    i = 1; next[1] = 0; j = 0;
    while(i &amp;lt; length(T)){
        // 如果递归回溯到第一个元素，它的next值为0，就无法继续回溯 -&amp;gt; 下一位元素的 Next值 就会等于 第一个元素的索引（1 即 0 + 1）
        // 如果 当前元素 等于 当前元素Next值对应的元素 -&amp;gt; 下一个元素的 Next值 就会等于 当前元素的Next值 + 1
        if (j == 0 || T[i] == T[j]){
            ++i; ++j; next[i] = j;
        }
        else{
            // 否则递归回溯j，将其指向更小的一个同首尾的子串的尾部 + 1
            j = next[j];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;nextval&quot;&gt;&lt;strong&gt;Nextval&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;(以下的讨论假设不需要递归以简化讨论过程)&lt;/p&gt;

&lt;p&gt;优化Next，当第&lt;code&gt;i+1&lt;/code&gt;位失配的时候。通常，我们按照算法会比较 &lt;code&gt;T[i]&lt;/code&gt; 和 &lt;code&gt;T[next[i]]&lt;/code&gt;，若它们相同则将&lt;code&gt;Next[i+1]&lt;/code&gt;设置成&lt;code&gt;Next[i] + 1&lt;/code&gt;。但是，如果 &lt;code&gt;T[Next[i] + 1]&lt;/code&gt;和失配元素（&lt;code&gt;T[i+1]&lt;/code&gt;）相同时，这样设置则是多余的（Next元素的含义就是，某个元素失配时用哪个元素补充匹配，若补充匹配的元素和失配元素相同则这样设置是多余的）。所以，此时应该把&lt;code&gt;Next[i+1]&lt;/code&gt;设置成&lt;code&gt;Next[Next[i] + 1]&lt;/code&gt;，就是当&lt;code&gt;Next[i]+1&lt;/code&gt;失配时应该用哪个元素补充匹配。&lt;/p&gt;

&lt;p&gt;那为什么&lt;code&gt;T[Next[Next[i] + 1]]&lt;/code&gt;不会等于&lt;code&gt;T[i+1]&lt;/code&gt;呢？因为按照这样的算法&lt;strong&gt;递推&lt;/strong&gt;是从第一个元素开始计算，可以确保除了当前失配的元素以外，&lt;strong&gt;之前的任意一个元素（索引为m）&lt;/strong&gt;都不可能等于&lt;code&gt;T[Next[m]+1]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// T 模式串， next Next数组
// 约定索引起始值为1
void get_nextval(SString T, int &amp;amp;nextval[]){
    // i 计算每一个元素Next值的指针，它只可能右移用于计算下一个元素的Next值
    // j 用于指向 无法找到头尾串时 的递归回溯的元素 
    // 初始化第一个元素的Next值
    i = 1; nextval[1] = 0; j = 0;
    while(i &amp;lt; length(T)){
        // 如果递归回溯到第一个元素，它的next值为0，就无法继续回溯 
        // 如果 当前元素 等于 当前元素Next值对应的元素 
        if (j == 0 || T[i] == T[j]){
            ++i; ++j; 
            if(T[i] != T[j]){
                // 如果替补匹配的值不等于当前失配值,则设置它的索引为Next值
               nextval[i] = j;
            }
          else{
                // 否则设置它的Next值为当前失配值的Next值
                nextval[i] = next[j];
            }
        }
        else{
            // 否则递归回溯j，将其指向更小的一个同首尾的子串的尾部 + 1
            j = nextval[j];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/next3.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="算法" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程-进程基础</title><link href="http://localhost:4000/_posts/2020-05-25-linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/" rel="alternate" type="text/html" title="linux编程-进程基础" /><published>2020-05-25T00:00:00+08:00</published><updated>2020-05-25T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-25-linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;进程标示符pid&quot;&gt;进程标示符pid&lt;/h1&gt;

&lt;p&gt;类型:pid_t&lt;/p&gt;

&lt;p&gt;命令:ps&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;getpid&lt;/li&gt;
  &lt;li&gt;getppid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t getpid(void);
pid_t getppid(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;进程产生&quot;&gt;进程产生&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;fork&lt;/li&gt;
  &lt;li&gt;vfork&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t fork(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t vfork(void);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
vfork():
Since glibc 2.12:
(_XOPEN_SOURCE &amp;gt;= 500) &amp;amp;&amp;amp; ! (_POSIX_C_SOURCE &amp;gt;= 200809L)
|| /* Since glibc 2.19: */ _DEFAULT_SOURCE
|| /* Glibc versions &amp;lt;= 2.19: */ _BSD_SOURCE
Before glibc 2.12:
_BSD_SOURCE || _XOPEN_SOURCE &amp;gt;= 500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fork()  creates  a new process by duplicating the calling process.  The
       new process is referred to as the child process.  The  calling  process
       is referred to as the parent process.&lt;/p&gt;

&lt;p&gt;fork后父子进程区别:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;返回值不同&lt;/li&gt;
  &lt;li&gt;pid不同,ppid不同&lt;/li&gt;
  &lt;li&gt;未决信号和文件锁不继承&lt;/li&gt;
  &lt;li&gt;资源利用量清0&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;init进程:1号,是所有的进程的祖先进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;调度器的调度策略决定那个进程先运行&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在fork之前,尽量刷新所有的流:fflush&lt;很重要&gt;&lt;/很重要&gt;&lt;/p&gt;

&lt;h1 id=&quot;进程消亡以及资源释放&quot;&gt;进程消亡以及资源释放&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;wait&lt;/li&gt;
  &lt;li&gt;waitpid&lt;/li&gt;
  &lt;li&gt;waitid&lt;/li&gt;
  &lt;li&gt;wait3&lt;/li&gt;
  &lt;li&gt;wait4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
pid_t wait(int *wstatus);
pid_t waitpid(pid_t pid, int *wstatus, int options);
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
/* This is the glibc and POSIX interface; see
NOTES for information on the raw system call. */
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
waitid():
Since glibc 2.26: _XOPEN_SOURCE &amp;gt;= 500 ||
_POSIX_C_SOURCE &amp;gt;= 200809L
Glibc 2.25 and earlier:
_XOPEN_SOURCE
|| /* Since glibc 2.12: */ _POSIX_C_SOURCE &amp;gt;= 200809L
|| /* Glibc versions &amp;lt;= 2.19: */ _BSD_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;exec函数族&quot;&gt;exec函数族&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
extern char **environ;
int execl(const char *path, const char *arg, ...
/* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
/* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
/*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
char *const envp[]);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
execvpe(): _GNU_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;用户权限以及组权限&quot;&gt;用户权限以及组权限&lt;/h1&gt;

&lt;p&gt;u+s&lt;/p&gt;

&lt;p&gt;g+s&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;getuid&lt;/li&gt;
  &lt;li&gt;geteuid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
uid_t getuid(void);
uid_t geteuid(void);
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
gid_t getgid(void);
gid_t getegid(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;setuid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int setuid(uid_t uid);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;setgid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int setgid(gid_t gid);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;setreuid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int setreuid(uid_t ruid, uid_t euid);
int setregid(gid_t rgid, gid_t egid);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;解释器文件&quot;&gt;解释器文件&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;system&quot;&gt;system&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int system(const char *command);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fork&lt;/code&gt;+&lt;code&gt;exec&lt;/code&gt;+&lt;code&gt;wait&lt;/code&gt;封装&lt;/p&gt;

&lt;h1 id=&quot;进程会计&quot;&gt;进程会计&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;acct&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int acct(const char *filename);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不是标准,了解即可&lt;/p&gt;

&lt;h1 id=&quot;进程时间&quot;&gt;进程时间&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;times&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/times.h&amp;gt;
clock_t times(struct tms *buf);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;守护进程&quot;&gt;守护进程&lt;/h1&gt;

&lt;p&gt;session:sid&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;setsid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t setsid(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;getpgrp&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int setpgid(pid_t pid, pid_t pgid);
pid_t getpgid(pid_t pid);
pid_t getpgrp(void);                 /* POSIX.1 version */
pid_t getpgrp(pid_t pid);            /* BSD version */
int setpgrp(void);                   /* System V version */
int setpgrp(pid_t pid, pid_t pgid);  /* BSD version */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单实例守护进程:锁文件:/var/run/name.pid&lt;/p&gt;

&lt;p&gt;启动脚本文件: /etc/rc*…&lt;/p&gt;

&lt;h1 id=&quot;系统日志&quot;&gt;系统日志&lt;/h1&gt;

&lt;p&gt;syslogd服务&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;openlog&lt;/li&gt;
  &lt;li&gt;syslog&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;syslog.h&amp;gt;
void openlog(const char *ident, int option, int facility);
void syslog(int priority, const char *format, ...);
void closelog(void);
void vsyslog(int priority, const char *format, va_list ap);
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程-文件系统</title><link href="http://localhost:4000/_posts/2020-05-22-linux%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" rel="alternate" type="text/html" title="linux编程-文件系统" /><published>2020-05-22T00:00:00+08:00</published><updated>2020-05-22T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-22-linux%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;文件系统&quot;&gt;文件系统&lt;/h1&gt;

&lt;h2 id=&quot;获取文件属性&quot;&gt;获取文件属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;stat&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;stat, fstat, lstat, fstatat - get file status&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
            int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;stat结构体&quot;&gt;stat结构体&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct stat {
dev_t     st_dev;         /* ID of device containing file */
ino_t     st_ino;         /* Inode number */
mode_t    st_mode;        /* File type and mode */
nlink_t   st_nlink;       /* Number of hard links */
uid_t     st_uid;         /* User ID of owner */
gid_t     st_gid;         /* Group ID of owner */
dev_t     st_rdev;        /* Device ID (if special file) */
off_t     st_size;        /* Total size, in bytes */
blksize_t st_blksize;     /* Block size for filesystem I/O */
blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

/* Since Linux 2.6, the kernel supports nanosecond
precision for the following timestamp fields.
For the details before Linux 2.6, see NOTES. */

struct timespec st_atim;  /* Time of last access */
struct timespec st_mtim;  /* Time of last modification */
struct timespec st_ctim;  /* Time of last status change */

#define st_atime st_atim.tv_sec      /* Backward compatibility */
#define st_mtime st_mtim.tv_sec
#define st_ctime st_ctim.tv_sec
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取文件大小测试程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
//获取文件大小函数
static off_t flen(const char *filename)
{
    //获取文件属性
    struct stat fileinfo;
    if(stat(filename,&amp;amp;fileinfo) &amp;lt; 0)
    {
        perror(&quot;stat()&quot;);
        exit(1);
    }
    return fileinfo.st_size;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在 Linux 系统中，一个文件实际占用了多大的磁盘空间要看 st_blocks 的数量，而不是看 st_size 的大小&lt;/strong&gt;;一般情况下文件系统的一个 block 的大小为 4KB，而每个 st_blocks 是 512B，所以一个有效文件站用磁盘空间最小的大小为 8 个 st_blocks&lt;/p&gt;

&lt;p&gt;空洞文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt; int fd;
    fd = open(argv[1],O_WRONLY|O_CREAT|O_TRUNC,0600);
    if(fd  &amp;lt; 0)
    {
        perror(&quot;open()&quot;);
        exit(0);
    }
    //偏移
//带上LL单位
    lseek(fd,5LL*1024LL*1024LL*1024LL - 1LL,SEEK_SET);
    write(fd,&quot;&quot;,1);
    close(fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mode_t    st_mode&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;权限和文件类型，位图，权限位9位，类型3位，u+s 1位，g+s 1位，粘滞位(T位)1位。位图是用一位或几位数据表示某种状态
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件类型:&lt;code&gt;dcb-lsp&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;d&lt;/th&gt;
      &lt;th&gt;目录&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;c&lt;/td&gt;
      &lt;td&gt;字符快设备文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;b&lt;/td&gt;
      &lt;td&gt;块文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;普通文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;l&lt;/td&gt;
      &lt;td&gt;符号链接文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s&lt;/td&gt;
      &lt;td&gt;套接字文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;p&lt;/td&gt;
      &lt;td&gt;管道文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;文件权限更改&quot;&gt;文件权限更改&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;chmod&lt;/li&gt;
  &lt;li&gt;fchmod&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/stat.h&amp;gt;
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;粘住位&quot;&gt;粘住位&lt;/h2&gt;

&lt;p&gt;t位&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;文件系统:&lt;code&gt;FAT&lt;/code&gt;,&lt;code&gt;UFS&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;硬链接符号链接&quot;&gt;硬链接&amp;amp;符号链接&lt;/h2&gt;

&lt;p&gt;硬链接与目录项是同义词,且建立硬链接有限制,不能给分区建立,不能给目录建立;符号链接优点:可跨分区,可以给目录建立&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;link&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int link(const char *oldpath, const char *newpath);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;unistd.h&amp;gt;
int linkat(int olddirfd, const char *oldpath,
           int newdirfd, const char *newpath, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;unlink&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int unlink(const char *pathname);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;unistd.h&amp;gt;
int unlinkat(int dirfd, const char *pathname, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;remove&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;remove a file or directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int remove(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rename&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int rename(const char *oldpath, const char *newpath);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;stdio.h&amp;gt;
int renameat(int olddirfd, const char *oldpath,
int newdirfd, const char *newpath);
int renameat2(int olddirfd, const char *oldpath,
int newdirfd, const char *newpath, unsigned int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;文件时间&quot;&gt;文件时间&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;utime&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;utime.h&amp;gt;
int utime(const char *filename, const struct utimbuf *times);
#include &amp;lt;sys/time.h&amp;gt;
int utimes(const char *filename, const struct timeval times[2]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;目录创建删除&quot;&gt;目录创建&amp;amp;删除&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
int mkdir(const char *pathname, mode_t mode);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int mkdirat(int dirfd, const char *pathname, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rmdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int rmdir(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;修改工作路径&quot;&gt;修改工作路径&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;chdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int chdir(const char *path);
int fchdir(int fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;突破安全限制,有缺陷&lt;/p&gt;

&lt;h2 id=&quot;获取当前工作路径&quot;&gt;获取当前工作路径&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;getcwd&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
char *getcwd(char *buf, size_t size);
char *getwd(char *buf);
char *get_current_dir_name(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;目录glob函数&quot;&gt;目录glob函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;glob&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;find pathnames &lt;code&gt;matching a pattern&lt;/code&gt;, free memory from
       glob()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;glob.h&amp;gt;
int glob(const char *pattern, int flags,
int (*errfunc) (const char *epath, int eerrno),
glob_t *pglob);
void globfree(glob_t *pglob);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;glob.h&amp;gt;
//匹配的文件
#define PAT &quot;/etc/a*.conf&quot;
//返回错误的函数
int errfunc_(const char *epath,int eerror)
{
    puts(epath);
    fprintf(stderr,&quot;error msg:%s\n&quot;,strerror(eerror));
    return 0;
}
int main(int argc, char const *argv[])
{
    glob_t       globres;
    int err = 0;
    err = glob(PAT,0,NULL,&amp;amp;globres);
    if(err)
    {
        printf(&quot;error code = %d\n&quot;,err);
        exit(1);
    }
    for (size_t i = 0; i &amp;lt; globres.gl_pathc; i++)
    {
        puts(globres.gl_pathv[i]);
    }
    globfree(&amp;amp;globres);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;opendir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
DIR *opendir(const char *name);
DIR *fdopendir(int fd);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
fdopendir():
Since glibc 2.10:
_POSIX_C_SOURCE &amp;gt;= 200809L
Before glibc 2.10:
_GNU_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;closedir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
int closedir(DIR *dirp);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;readdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;dirent.h&amp;gt;
struct dirent *readdir(DIR *dirp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dirent结构体&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct dirent {
               ino_t          d_ino;       /* Inode number */
               off_t          d_off;       /* Not an offset; see below */
               unsigned short d_reclen;    /* Length of this record */
               unsigned char  d_type;      /* Type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* Null-terminated filename */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取文件名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
#define PAT &quot;/etc&quot;
int main(int argc, char const *argv[])
{
    DIR *dp;
    struct dirent *cur;
    dp = opendir(PAT);
    if(dp == NULL)
    {
        perror(&quot;opendir&quot;);
        exit(1);
    }
    while ((cur = readdir(dp)) != NULL)
    {
         puts(cur-&amp;gt;d_name);
    }
    closedir(dp);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rewenddir&lt;/li&gt;
  &lt;li&gt;seekdir&lt;/li&gt;
  &lt;li&gt;telldir&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;系统数据文件和信息&quot;&gt;系统数据文件和信息&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/passwd&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;getpwuid&lt;/li&gt;
      &lt;li&gt;getpwnam&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;pwd.h&amp;gt;
struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);
int getpwnam_r(const char *name, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
int getpwuid_r(uid_t uid, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;passwd结构体&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct passwd {
               char   *pw_name;       /* username */
               char   *pw_passwd;     /* user password */
               uid_t   pw_uid;        /* user ID */
               gid_t   pw_gid;        /* group ID */
               char   *pw_gecos;      /* user information */
               char   *pw_dir;        /* home directory */
               char   *pw_shell;      /* shell program */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;/etc/group
    &lt;ul&gt;
      &lt;li&gt;getgrgid&lt;/li&gt;
      &lt;li&gt;getgrgrnam&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/shadow&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;getspnam&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;shadow.h&amp;gt;
struct spwd *getspnam(const char *name);
struct spwd *getspent(void);
void setspent(void);
void endspent(void);
struct spwd *fgetspent(FILE *stream);
struct spwd *sgetspent(const char *s);
int putspent(const struct spwd *p, FILE *stream);
int lckpwdf(void);
int ulckpwdf(void);
/* GNU extension */
#include &amp;lt;shadow.h&amp;gt;
int getspent_r(struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int getspnam_r(const char *name, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int fgetspent_r(FILE *stream, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int sgetspent_r(const char *s, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;spwd结构体&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct spwd {
               char *sp_namp;     /* Login name */
               char *sp_pwdp;     /* Encrypted password */
               long  sp_lstchg;   /* Date of last change
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               long  sp_min;      /* Min # of days between changes */
               long  sp_max;      /* Max # of days between changes */
               long  sp_warn;     /* # of days before password expires
                                     to warn user to change it */
               long  sp_inact;    /* # of days after password expires
                                     until account is disabled */
               long  sp_expire;   /* Date when account expires
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               unsigned long sp_flag;  /* Reserved */
           };
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;crypt&lt;/p&gt;

        &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define _XOPEN_SOURCE       /* See feature_test_macros(7) */
#include &amp;lt;unistd.h&amp;gt;
char *crypt(const char *key, const char *salt);
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &amp;lt;crypt.h&amp;gt;
char *crypt_r(const char *key, const char *salt,
struct crypt_data *data);
Link with -lcrypt.
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;getpass&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
char *getpass(const char *prompt);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时间戳&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;time&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
time_t time(time_t *tloc);
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;gmtime&lt;/li&gt;
      &lt;li&gt;localtime&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);
char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);
struct tm *gmtime(const time_t *timep);
struct tm *gmtime_r(const time_t *timep, struct tm *result);
struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);
time_t mktime(struct tm *tm);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;tm结构体&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct tm {
               int tm_sec;    /* Seconds (0-60) */
               int tm_min;    /* Minutes (0-59) */
               int tm_hour;   /* Hours (0-23) */
               int tm_mday;   /* Day of the month (1-31) */
               int tm_mon;    /* Month (0-11) */
               int tm_year;   /* Year - 1900 */
               int tm_wday;   /* Day of the week (0-6, Sunday = 0) */
               int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */
               int tm_isdst;  /* Daylight saving time */
           };
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;strftime&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
size_t strftime(char *s, size_t max, const char *format,
const struct tm *tm);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;进程环境&quot;&gt;进程环境&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;main函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main(int argc,char *argv[])
//其实还有第三个参数,环境变量
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;进程的终止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正常终止:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;main函数返回&lt;/li&gt;
  &lt;li&gt;调用exit&lt;/li&gt;
  &lt;li&gt;调用_exit或者_Exit&lt;/li&gt;
  &lt;li&gt;最后一个线程从其启动例程饭后&lt;/li&gt;
  &lt;li&gt;最后一个线程调用pthread_exit&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常终止:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调用abort&lt;/li&gt;
  &lt;li&gt;接到一个信号并终止&lt;/li&gt;
  &lt;li&gt;最后一个线程对其取消请求做出响应&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;钩子函数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;atexit&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int atexit(void (*function)(void));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;命令行参数分析&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;getopt&lt;/li&gt;
      &lt;li&gt;getopt_long&lt;/li&gt;
    &lt;/ol&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int getopt(int argc, char * const argv[],
const char *optstring);
extern char *optarg;
extern int optind, opterr, optopt;
#include &amp;lt;getopt.h&amp;gt;
int getopt_long(int argc, char * const argv[],
const char *optstring,
const struct option *longopts, int *longindex);
int getopt_long_only(int argc, char * const argv[],
const char *optstring,
const struct option *longopts, int *longindex);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;环境变量&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;environ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;extern char **environ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
char *getenv(const char *name);
char *secure_getenv(const char *name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;setenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;putenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int putenv(char *string);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;c程序的存储空间布局&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;pmap&lt;/code&gt;命令查看&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;库&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;动态库&lt;/li&gt;
  &lt;li&gt;静态库&lt;/li&gt;
  &lt;li&gt;手工装载库&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;dlopen&lt;/p&gt;

&lt;p&gt;dlclose&lt;/p&gt;

&lt;p&gt;dlerror&lt;/p&gt;

&lt;p&gt;dlsym&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;dlfcn.h&amp;gt;
void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlmopen (Lmid_t lmid, const char *filename, int flags);
Link with -ldl.   
    #include &amp;lt;dlfcn.h&amp;gt;
    void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlmopen (Lmid_t lmid, const char *filename, int flags);
#include &amp;lt;dlfcn.h&amp;gt;
char *dlerror(void);
void *dlsym(void *handle, const char *symbol);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlvsym(void *handle, char *symbol, char *version);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
       #include &amp;lt;stdlib.h&amp;gt;
       #include &amp;lt;dlfcn.h&amp;gt;
       #include &amp;lt;gnu/lib-names.h&amp;gt;  /* Defines LIBM_SO (which will be a
                                      string such as &quot;libm.so.6&quot;) */
       int
       main(void)
       {
           void *handle;
           double (*cosine)(double);
           char *error;

           handle = dlopen(LIBM_SO, RTLD_LAZY);
           if (!handle) {
               fprintf(stderr, &quot;%s\n&quot;, dlerror());
               exit(EXIT_FAILURE);
           }

           dlerror();    /* Clear any existing error */

           cosine = (double (*)(double)) dlsym(handle, &quot;cos&quot;);

           /* According to the ISO C standard, casting between function
              pointers and 'void *', as done above, produces undefined results.
              POSIX.1-2003 and POSIX.1-2008 accepted this state of affairs and
              proposed the following workaround:

                  *(void **) (&amp;amp;cosine) = dlsym(handle, &quot;cos&quot;);

              This (clumsy) cast conforms with the ISO C standard and will
              avoid any compiler warnings.

              The 2013 Technical Corrigendum to POSIX.1-2008 (a.k.a.
              POSIX.1-2013) improved matters by requiring that conforming
              implementations support casting 'void *' to a function pointer.
              Nevertheless, some compilers (e.g., gcc with the '-pedantic'
              option) may complain about the cast used in this program. */

           error = dlerror();
           if (error != NULL) {
               fprintf(stderr, &quot;%s\n&quot;, error);
               exit(EXIT_FAILURE);
           }

           printf(&quot;%f\n&quot;, (*cosine)(2.0));
           dlclose(handle);
           exit(EXIT_SUCCESS);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;函数跳转&lt;/p&gt;

    &lt;p&gt;setjmp&lt;/p&gt;

    &lt;p&gt;longjmp&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;资源获取及控制&lt;/p&gt;

    &lt;p&gt;getrlimit&lt;/p&gt;

    &lt;p&gt;setrlimit&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;sys/resource.h&amp;gt;
int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);
int prlimit(pid_t pid, int resource, const struct rlimit *new_limit,
struct rlimit *old_limit);
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">HashMap实现原理</title><link href="http://localhost:4000/_posts/2020-05-21-HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86;/" rel="alternate" type="text/html" title="HashMap实现原理" /><published>2020-05-21T00:00:00+08:00</published><updated>2020-05-21T00:00:00+08:00</updated><id>http://localhost:4000/_posts/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86;</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-21-HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86;/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;哈希表&quot;&gt;哈希表&lt;/h1&gt;

&lt;p&gt;在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;数组&lt;/code&gt;&lt;/strong&gt;：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;线性链表&lt;/code&gt;&lt;/strong&gt;：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;二叉树&lt;/code&gt;&lt;/strong&gt;：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;哈希表&lt;/code&gt;&lt;/strong&gt;：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。&lt;/p&gt;

&lt;p&gt;我们知道，数据结构的物理存储结构只有两种：&lt;strong&gt;顺序存储结构&lt;/strong&gt;和&lt;strong&gt;链式存储结构&lt;/strong&gt;（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，&lt;strong&gt;哈希表的主干就是数组&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。
&lt;script type=&quot;math/tex&quot;&gt;存储位置 = f(关键字)&lt;/script&gt;
其中，这个函数f一般称为&lt;strong&gt;哈希函数&lt;/strong&gt;，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/hashF.png&quot; alt=&quot;hashF&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。&lt;/p&gt;

&lt;h2 id=&quot;哈希冲突&quot;&gt;&lt;strong&gt;哈希冲突&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的&lt;strong&gt;哈希冲突&lt;/strong&gt;，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 &lt;strong&gt;计算简单&lt;/strong&gt;和&lt;strong&gt;散列地址分布均匀,&lt;/strong&gt;但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是&lt;strong&gt;数组+链表&lt;/strong&gt;的方式&lt;/p&gt;

&lt;h1 id=&quot;hashmap实现原理&quot;&gt;HashMap实现原理&lt;/h1&gt;

&lt;p&gt;HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂
transient Entry&amp;lt;K,V&amp;gt;[] table = (Entry&amp;lt;K,V&amp;gt;[]) EMPTY_TABLE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Entry是HashMap中的一个静态内部类。代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;static class Entry&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
    final K key;
    V value;
    Entry&amp;lt;K,V&amp;gt; next;//存储指向下一个Entry的引用，单链表结构
    int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算

    /**
         * Creates new entry.
         */
    Entry(int h, K k, V v, Entry&amp;lt;K,V&amp;gt; n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HashMap的整体结构如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/HashMap.png&quot; alt=&quot;HashMap&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其他几个重要字段&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//实际存储的key-value键值对的个数
transient int size;
//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到
int threshold;
//负载因子，代表了table的填充度有多少，默认是0.75
final float loadFactor;
//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException
transient int modCount;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值&lt;/p&gt;

&lt;p&gt;initialCapacity默认为16，loadFactory默认为0.75&lt;/p&gt;

&lt;p&gt;我们看下其中一个&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public HashMap(int initialCapacity, float loadFactor) {　　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&amp;lt;&amp;lt;30(230)
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);

        this.loadFactor = loadFactor;
        threshold = initialCapacity;　　　　　
        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面这段代码我们可以看出，&lt;strong&gt;在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;OK,接下来我们来看看put操作的实现吧&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public V put(K key, V value) {
        //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&amp;lt;&amp;lt;4(24=16)
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
       //如果key为null，存储位置为table[0]或table[0]的冲突链上
        if (key == null)
            return putForNullKey(value);
        int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀
        int i = indexFor(hash, table.length);//获取在table中的实际位置
        for (Entry&amp;lt;K,V&amp;gt; e = table[i]; e != null; e = e.next) {
        //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value
            Object k;
            if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }
        modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败
        addEntry(hash, key, value, i);//新增一个entry
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先来看看inflateTable这个方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private void inflateTable(int toSize) {
        int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂
        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1
        table = new Entry[capacity];
        initHashSeedAsNeeded(capacity);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static int roundUpToPowerOf2(int number) {
        // assert number &amp;gt;= 0 : &quot;number must be non-negative&quot;;
        return number &amp;gt;= MAXIMUM_CAPACITY
                ? MAXIMUM_CAPACITY
                : (number &amp;gt; 1) ? Integer.highestOneBit((number - 1) &amp;lt;&amp;lt; 1) : 1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.&lt;/p&gt;

&lt;p&gt;hash函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀
final int hash(Object k) {
        int h = hashSeed;
        if (0 != h &amp;amp;&amp;amp; k instanceof String) {
            return sun.misc.Hashing.stringHash32((String) k);
        }

        h ^= k.hashCode();

        h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12);
        return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
     * 返回数组下标
     */
    static int indexFor(int h, int length) {
        return h &amp;amp; (length-1);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;h&amp;amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;        1  0  0  1  0
    &amp;amp;   0  1  1  1  1
    __________________
        0  0  0  1  0    = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）&lt;/p&gt;

&lt;p&gt;所以最终存储位置的确定流程是这样的:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/hashcode.png&quot; alt=&quot;hashcode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再来看看addEntry的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (null != table[bucketIndex])) {
            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作&lt;/p&gt;

&lt;h1 id=&quot;为何hashmap的数组长度一定是2的次幂&quot;&gt;为何HashMap的数组长度一定是2的次幂&lt;/h1&gt;

&lt;p&gt;我们来继续看上面提到的resize方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;void resize(int newCapacity) {
        Entry[] oldTable = table;
        int oldCapacity = oldTable.length;
        if (oldCapacity == MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return;
        }

        Entry[] newTable = new Entry[newCapacity];
        transfer(newTable, initHashSeedAsNeeded(newCapacity));
        table = newTable;
        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;　　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）
        for (Entry&amp;lt;K,V&amp;gt; e : table) {
            while(null != e) {
                Entry&amp;lt;K,V&amp;gt; next = e.next;
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                int i = indexFor(e.hash, newCapacity);　　　　　　　　　 //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。&lt;/p&gt;

&lt;p&gt;hashMap的数组长度一定保持2的次幂，比如16的二进制表示为  10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过  h&amp;amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/h&amp;amp;length.png&quot; alt=&quot;h&amp;amp;length&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161115215812138-679881037.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/&amp;amp;2.png&quot; alt=&quot;&amp;amp;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们看到，上面的&amp;amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/&amp;amp;3.png&quot; alt=&quot;&amp;amp;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。&lt;/p&gt;

&lt;p&gt;get方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public V get(Object key) {　　　　 //如果key为null,则直接去table[0]处去检索即可。
        if (key == null)
            return getForNullKey();
        Entry&amp;lt;K,V&amp;gt; entry = getEntry(key);
        return null == entry ? null : entry.getValue();
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;final Entry&amp;lt;K,V&amp;gt; getEntry(Object key) {
            
        if (size == 0) {
            return null;
        }
        //通过key的hashcode值计算hash值
        int hash = (key == null) ? 0 : hash(key);
        //indexFor (hash&amp;amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录
        for (Entry&amp;lt;K,V&amp;gt; e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            if (e.hash == hash &amp;amp;&amp;amp; 
                ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                return e;
        }
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，get方法的实现相对简单，key(hashcode)–&amp;gt;hash–&amp;gt;indexFor–&amp;gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash ==  hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。&lt;/p&gt;

&lt;h1 id=&quot;重写equals方法需同时重写hashcode方法&quot;&gt;重写equals方法需同时重写hashCode方法&lt;/h1&gt;

&lt;p&gt;关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * Created by chengxiao on 2016/11/15.
 */
public class MyTest {
    private static class Person{
        int idCard;
        String name;

        public Person(int idCard, String name) {
            this.idCard = idCard;
            this.name = name;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()){
                return false;
            }
            Person person = (Person) o;
            //两个对象是否等值，通过idCard来确定
            return this.idCard == person.idCard;
        }

    }
    public static void main(String []args){
        HashMap&amp;lt;Person,String&amp;gt; map = new HashMap&amp;lt;Person, String&amp;gt;();
        Person person = new Person(1234,&quot;乔峰&quot;);
        //put到hashmap中去
        map.put(person,&quot;天龙八部&quot;);
        //get取出，从逻辑上讲应该能输出“天龙八部”
        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际输出结果:null&lt;/p&gt;

&lt;p&gt;如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&amp;gt;hash–&amp;gt;indexFor–&amp;gt;最终索引位置 ，而通过key取出value的时候  key(hashcode1)–&amp;gt;hash–&amp;gt;indexFor–&amp;gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）&lt;/p&gt;

&lt;p&gt;　　所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。&lt;/p&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">[toc]</summary></entry></feed>