<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-06-04T10:51:13+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lazycat</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;

&lt;iframe
  src=&quot;https://music.163.com/outchain/player?type=0&amp;id=161689985&amp;auto=0&amp;height=32&quot;
  width=100%
  height=52
  frameborder=&quot;no&quot;
  border=&quot;0&quot;
  marginwidth=&quot;0&quot;
  marginheight=&quot;0&quot;
&gt;&lt;/iframe&gt;
</subtitle><entry><title type="html">linux编程-并发</title><link href="http://localhost:4000/_posts/2020-05-30-linux%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91/" rel="alternate" type="text/html" title="linux编程-并发" /><published>2020-05-30T00:00:00+08:00</published><updated>2020-05-30T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-30-linux%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;信号&quot;&gt;信号&lt;/h1&gt;

&lt;h2 id=&quot;信号概念&quot;&gt;信号概念&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;同步:&lt;/p&gt;

  &lt;p&gt;异步:&lt;/p&gt;

  &lt;p&gt;异步事件的处理:查询法,通知法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;信号是软件的&lt;code&gt;中断&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;signal&quot;&gt;signal&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;void(&lt;em&gt;signal(intosignum,void (&lt;/em&gt;func)(int)))(int)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;信号会打断阻塞的系统调用&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;信号不可靠&quot;&gt;信号不可靠&lt;/h2&gt;

&lt;h2 id=&quot;可重入函数&quot;&gt;可重入函数&lt;/h2&gt;

&lt;p&gt;所有的系统调用都是可重入的,一部分库函数也可以重入,如memcpy&lt;/p&gt;

&lt;h2 id=&quot;信号响应过程&quot;&gt;信号响应过程&lt;/h2&gt;

&lt;h2 id=&quot;常用函数&quot;&gt;常用函数&lt;/h2&gt;

&lt;h3 id=&quot;kill&quot;&gt;kill&lt;/h3&gt;

&lt;p&gt;send signal to a process&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
int kill(pid_t pid, int sig);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;raise&quot;&gt;raise&lt;/h3&gt;

&lt;p&gt;send a signal to the caller&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int raise(int sig);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;alarm&quot;&gt;alarm&lt;/h3&gt;

&lt;p&gt;set an alarm clock for delivery of a signal&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
unsigned int alarm(unsigned int seconds);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;pause&quot;&gt;pause&lt;/h3&gt;

&lt;p&gt;wait for signal&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int pause(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;setitimer&quot;&gt;setitimer&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/time.h&amp;gt;
int getitimer(int which, struct itimerval *curr_value);
int setitimer(int which, const struct itimerval *new_value,
struct itimerval *old_value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽量用setitimer不要alarm&lt;/p&gt;

&lt;h3 id=&quot;abort&quot;&gt;abort&lt;/h3&gt;

&lt;p&gt;cause abnormal process termination&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
void abort(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;system&quot;&gt;system&lt;/h3&gt;

&lt;p&gt;execute a shell command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int system(const char *command);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;During  execution  of  the command, SIGCHLD will be blocked, and SIGINT
       and SIGQUIT will be ignored, in the process that calls system()  (these
       signals  will  be  handled according to their defaults inside the child
       process that executes command)&lt;/p&gt;

&lt;h3 id=&quot;sleep&quot;&gt;sleep&lt;/h3&gt;

&lt;p&gt;sleep for a specified number of seconds&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
unsigned int sleep(unsigned int seconds);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;信号集&quot;&gt;信号集&lt;/h2&gt;

&lt;p&gt;sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX sig‐nal set operations&lt;/p&gt;

&lt;p&gt;类型:sigset_t&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
int sigismember(const sigset_t *set, int signum);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;sigpending&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigpending(sigset_t *set);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;信号屏蔽字pending集的处理&quot;&gt;信号屏蔽字/pending集的处理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;sigprocmask&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;sigprocmask, rt_sigprocmask - examine and change blocked signals&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
/* Prototype for the glibc wrapper function */
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
/* Prototype for the underlying system call */
int rt_sigprocmask(int how, const kernel_sigset_t *set,
kernel_sigset_t *oldset, size_t sigsetsize);
/* Prototype for the legacy system call (deprecated) */
int sigprocmask(int how, const old_kernel_sigset_t *set,
old_kernel_sigset_t *oldset);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;联系mask和pending的位图,理解原理&lt;/p&gt;

&lt;h2 id=&quot;扩展函数&quot;&gt;扩展函数&lt;/h2&gt;

&lt;h3 id=&quot;sigsuspend&quot;&gt;sigsuspend&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigsuspend(const sigset_t *mask);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sigaction&quot;&gt;sigaction&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigaction(int signum, const struct sigaction *act,
struct sigaction *oldact);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;实时信号&quot;&gt;实时信号&lt;/h2&gt;

&lt;h1 id=&quot;线程&quot;&gt;线程&lt;/h1&gt;

&lt;h2 id=&quot;线程概念&quot;&gt;线程概念&lt;/h2&gt;

&lt;p&gt;posix标准&lt;/p&gt;

&lt;p&gt;openmp线程&lt;/p&gt;

&lt;p&gt;线程标识:pthread_t&lt;/p&gt;

&lt;p&gt;pthread_equal&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;compare thread IDs&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_equal(pthread_t t1, pthread_t t2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pthread_self&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;obtain ID of the calling thread&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
pthread_t pthread_self(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;线程创建&quot;&gt;线程创建&lt;/h2&gt;

&lt;p&gt;pthread_create&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;create a new thread&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
void *(*start_routine) (void *), void *arg);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程的调度取决于调度器策略&lt;/p&gt;

&lt;h2 id=&quot;线程终止&quot;&gt;线程终止&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;线程从启动例程返回,返回值就是线程的退出码&lt;/li&gt;
  &lt;li&gt;线程可以被同一进程中的其他线程取消&lt;/li&gt;
  &lt;li&gt;线程调用&lt;code&gt;pthread_exi&lt;/code&gt;t函数&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
void pthread_exit(void *retval);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pthread_join&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_join(pthread_t thread, void **retval);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;线程的取消选项&quot;&gt;线程的取消选项&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_cancel&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;send a cancellation request to a thread&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_cancel(pthread_t thread);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;可取消状态&lt;/li&gt;
  &lt;li&gt;取消类型(推迟取消)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;取消点必须是系统调用&lt;/p&gt;

&lt;h2 id=&quot;栈清理&quot;&gt;栈清理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_cleanup_push&lt;/li&gt;
  &lt;li&gt;pthread_cleanup_pop&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;类似钩子函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancel-lation clean-up handlers&lt;/p&gt;

&lt;p&gt;必须匹配使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
void pthread_cleanup_push(void (*routine)(void *),
void *arg);
void pthread_cleanup_pop(int execute);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;线程同步&quot;&gt;线程同步&lt;/h2&gt;

&lt;p&gt;互斥量:&lt;/p&gt;

&lt;h2 id=&quot;线程属性&quot;&gt;线程属性&lt;/h2&gt;

&lt;h2 id=&quot;线程与信号&quot;&gt;线程与信号&lt;/h2&gt;

&lt;h2 id=&quot;线程include-&quot;&gt;线程#include &lt;pthread.h&gt;&lt;/pthread.h&gt;&lt;/h2&gt;

&lt;p&gt;void pthread_cleanup_push(void (*routine)(void *),
void *arg);
void pth#include &lt;pthread.h&gt;&lt;/pthread.h&gt;&lt;/p&gt;

&lt;p&gt;void pthread_cleanup_push(void (*routine)(void *),
void *arg);
void pthread_cleanup_pop(int execute);read_cleanup_pop(int execute);与fork&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">KMP算法</title><link href="http://localhost:4000/_posts/2020-05-26-KMP%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html" title="KMP算法" /><published>2020-05-26T00:00:00+08:00</published><updated>2020-05-26T00:00:00+08:00</updated><id>http://localhost:4000/_posts/KMP%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-26-KMP%E7%AE%97%E6%B3%95/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;bf&quot;&gt;BF&lt;/h1&gt;

&lt;p&gt;Brute-Force(BF) 算法又称naive算法，是对字符串子串搜索最简单明了的算法。其主旨就是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不处理模式串&lt;/li&gt;
  &lt;li&gt;模式串从目标串&lt;strong&gt;第一个元素&lt;/strong&gt;起逐一匹配&lt;/li&gt;
  &lt;li&gt;发现无法匹配，模式串匹配右移一位，从下一位目标串元素重新初始逐一元素匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/BF.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然简单易懂，但是同时也导致了复杂度较高，最慢的情形其复杂度可以到达O（模式串长 * 目标串长）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/BF_LOW.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;kmp&quot;&gt;&lt;strong&gt;KMP&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;但是如果仔细观察，可以发现&lt;strong&gt;模式串&lt;/strong&gt;本身是可以自带一些&lt;strong&gt;可被预先计算出&lt;/strong&gt;的&lt;strong&gt;可用于加速匹配的信息&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;当模式串的第K位失配时，前K-1位必然是匹配的，如果直接整体后移一位重新从头开始匹配那之前的那些&lt;strong&gt;已经匹配的信息&lt;/strong&gt;就被浪费了。于是我们可以寻找&lt;strong&gt;最大的必定不需要再匹配的串&lt;/strong&gt;，那这个串是什么呢？&lt;/p&gt;

&lt;p&gt;很显然，这个串就是[1,K-1]位串中&lt;strong&gt;最大且相同&lt;/strong&gt;的&lt;strong&gt;头尾&lt;/strong&gt;串（S）。当失配发生，可以直接&lt;strong&gt;保持目标串中的失配元素不变&lt;/strong&gt;，移动模式串，K-1-S串长个单位重新匹配，这就是KMP算法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/KMP.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么要移动K-1-S串长个单位？失配元素前方一共有K-1个元素，最大相同头尾串长为S。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/KMP2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;若移动小于K-1-S长度(例如K-1-S-1 = K - 1 - (S+1))，则必然无法匹配，因为不存在&lt;strong&gt;更大&lt;/strong&gt;的相同首尾串，如下图中（bab不是相同首尾串，故必然不匹配）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/KMP3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;若移动大于K-1-S长度(例如K-1-S+1 = K - 1 - (S-1))，有可能匹配（当S-1同样是相同子串时），但是可能会因为多移动了位数而遗漏结果。&lt;/p&gt;

&lt;p&gt;KMP算法本身比较好理解，而关于KMP的实现需要引入一个Next数组（由模式串预处理出的数组），Next数组的本身的算法则很难理解&lt;/p&gt;

&lt;h1 id=&quot;next数组&quot;&gt;&lt;strong&gt;Next数组&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Next数组的含义很直观，就是&lt;strong&gt;第几个元素失配时应该右移模式串重新匹配第几个元素&lt;/strong&gt;（不同的教材采用的首元素索引序号不同有的是0有的是1，这也是Next数组算法难以理解的一大原因，所以文中讨论索引序号都直接使用的是&lt;strong&gt;第&lt;/strong&gt;几个元素）。&lt;/p&gt;

&lt;p&gt;Next数组的算法步骤如下图所示，在我们逐步讨论完其算法过程后再会看这张动图或许你会有更深刻地理解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/next.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;逐步讨论&quot;&gt;&lt;strong&gt;逐步讨论&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;对于模式串的首个元素的Next值，约定为&lt;strong&gt;首元素索引值 - 1&lt;/strong&gt;，这么做仅仅是为了&lt;strong&gt;方便实现递归算法&lt;/strong&gt;。这个值&lt;strong&gt;不一定只为首元素的Next值&lt;/strong&gt;，经过优化后可能为其他元素的Next值，这个值（首元素索引 - 1）的含义是：&lt;/p&gt;

&lt;p&gt;将&lt;strong&gt;模式串&lt;/strong&gt;的&lt;strong&gt;首元素&lt;/strong&gt;移动到&lt;strong&gt;失配元素后一位&lt;/strong&gt;并从首元素开始，重新匹配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/next2.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;kmp实现&quot;&gt;KMP实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// T 模式串， S目标串， pos第几个字符之后搜索
// 约定索引起始值为1
void Index_KMP(SString S, SString T, int pos){
   // i 目标串指针，j 模式串指针
    i = pos; j = 1;
    // 只要指针没有溢出对应的串
    while( i &amp;lt;= length(S) &amp;amp;&amp;amp; j &amp;lt;= length(T)){
        // 如果将要和 目标串元素 匹配的元素是模式串首元素前一位的元素
        // 或者
        // 当前目标串元素 和 模式串元素可以匹配
        // if (j == first_indexof(T) - 1 || S[i] == T[j]){
        if(j == 0 || S[i] == T[j]){
           // 指针各自右移一位
            ++i;
            ++j;
        }else{
            // 发生了失配，查Next数组移动模式串指针
            j = next[j];
        }
    }
    if (j &amp;gt; length(T)){
        // 如果模式串指针溢出了（模式串指针匹配完毕了所有模式串中的元素）
       return i - length(T);
    }
    else return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;next&quot;&gt;next&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// T 模式串， next Next数组
// 约定索引起始值为1
void get_next(SString T, int &amp;amp;next[]){
    // i 计算每一个元素Next值的指针，它只可能右移用于计算下一个元素的Next值
    // j 用于指向 无法找到头尾串时 的递归回溯的元素 
    // 初始化第一个元素的Next值
    i = 1; next[1] = 0; j = 0;
    while(i &amp;lt; length(T)){
        // 如果递归回溯到第一个元素，它的next值为0，就无法继续回溯 -&amp;gt; 下一位元素的 Next值 就会等于 第一个元素的索引（1 即 0 + 1）
        // 如果 当前元素 等于 当前元素Next值对应的元素 -&amp;gt; 下一个元素的 Next值 就会等于 当前元素的Next值 + 1
        if (j == 0 || T[i] == T[j]){
            ++i; ++j; next[i] = j;
        }
        else{
            // 否则递归回溯j，将其指向更小的一个同首尾的子串的尾部 + 1
            j = next[j];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;nextval&quot;&gt;&lt;strong&gt;Nextval&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;(以下的讨论假设不需要递归以简化讨论过程)&lt;/p&gt;

&lt;p&gt;优化Next，当第&lt;code&gt;i+1&lt;/code&gt;位失配的时候。通常，我们按照算法会比较 &lt;code&gt;T[i]&lt;/code&gt; 和 &lt;code&gt;T[next[i]]&lt;/code&gt;，若它们相同则将&lt;code&gt;Next[i+1]&lt;/code&gt;设置成&lt;code&gt;Next[i] + 1&lt;/code&gt;。但是，如果 &lt;code&gt;T[Next[i] + 1]&lt;/code&gt;和失配元素（&lt;code&gt;T[i+1]&lt;/code&gt;）相同时，这样设置则是多余的（Next元素的含义就是，某个元素失配时用哪个元素补充匹配，若补充匹配的元素和失配元素相同则这样设置是多余的）。所以，此时应该把&lt;code&gt;Next[i+1]&lt;/code&gt;设置成&lt;code&gt;Next[Next[i] + 1]&lt;/code&gt;，就是当&lt;code&gt;Next[i]+1&lt;/code&gt;失配时应该用哪个元素补充匹配。&lt;/p&gt;

&lt;p&gt;那为什么&lt;code&gt;T[Next[Next[i] + 1]]&lt;/code&gt;不会等于&lt;code&gt;T[i+1]&lt;/code&gt;呢？因为按照这样的算法&lt;strong&gt;递推&lt;/strong&gt;是从第一个元素开始计算，可以确保除了当前失配的元素以外，&lt;strong&gt;之前的任意一个元素（索引为m）&lt;/strong&gt;都不可能等于&lt;code&gt;T[Next[m]+1]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// T 模式串， next Next数组
// 约定索引起始值为1
void get_nextval(SString T, int &amp;amp;nextval[]){
    // i 计算每一个元素Next值的指针，它只可能右移用于计算下一个元素的Next值
    // j 用于指向 无法找到头尾串时 的递归回溯的元素 
    // 初始化第一个元素的Next值
    i = 1; nextval[1] = 0; j = 0;
    while(i &amp;lt; length(T)){
        // 如果递归回溯到第一个元素，它的next值为0，就无法继续回溯 
        // 如果 当前元素 等于 当前元素Next值对应的元素 
        if (j == 0 || T[i] == T[j]){
            ++i; ++j; 
            if(T[i] != T[j]){
                // 如果替补匹配的值不等于当前失配值,则设置它的索引为Next值
               nextval[i] = j;
            }
          else{
                // 否则设置它的Next值为当前失配值的Next值
                nextval[i] = next[j];
            }
        }
        else{
            // 否则递归回溯j，将其指向更小的一个同首尾的子串的尾部 + 1
            j = nextval[j];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/next3.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="算法" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程-进程基础</title><link href="http://localhost:4000/_posts/2020-05-25-linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/" rel="alternate" type="text/html" title="linux编程-进程基础" /><published>2020-05-25T00:00:00+08:00</published><updated>2020-05-25T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-25-linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;进程标示符pid&quot;&gt;进程标示符pid&lt;/h1&gt;

&lt;p&gt;类型:pid_t&lt;/p&gt;

&lt;p&gt;命令:ps&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;getpid&lt;/li&gt;
  &lt;li&gt;getppid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t getpid(void);
pid_t getppid(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;进程产生&quot;&gt;进程产生&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;fork&lt;/li&gt;
  &lt;li&gt;vfork&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t fork(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t vfork(void);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
vfork():
Since glibc 2.12:
(_XOPEN_SOURCE &amp;gt;= 500) &amp;amp;&amp;amp; ! (_POSIX_C_SOURCE &amp;gt;= 200809L)
|| /* Since glibc 2.19: */ _DEFAULT_SOURCE
|| /* Glibc versions &amp;lt;= 2.19: */ _BSD_SOURCE
Before glibc 2.12:
_BSD_SOURCE || _XOPEN_SOURCE &amp;gt;= 500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fork()  creates  a new process by duplicating the calling process.  The
       new process is referred to as the child process.  The  calling  process
       is referred to as the parent process.&lt;/p&gt;

&lt;p&gt;fork后父子进程区别:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;返回值不同&lt;/li&gt;
  &lt;li&gt;pid不同,ppid不同&lt;/li&gt;
  &lt;li&gt;未决信号和文件锁不继承&lt;/li&gt;
  &lt;li&gt;资源利用量清0&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;init进程:1号,是所有的进程的祖先进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;调度器的调度策略决定那个进程先运行&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在fork之前,尽量刷新所有的流:fflush&lt;很重要&gt;&lt;/很重要&gt;&lt;/p&gt;

&lt;h1 id=&quot;进程消亡以及资源释放&quot;&gt;进程消亡以及资源释放&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;wait&lt;/li&gt;
  &lt;li&gt;waitpid&lt;/li&gt;
  &lt;li&gt;waitid&lt;/li&gt;
  &lt;li&gt;wait3&lt;/li&gt;
  &lt;li&gt;wait4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
pid_t wait(int *wstatus);
pid_t waitpid(pid_t pid, int *wstatus, int options);
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
/* This is the glibc and POSIX interface; see
NOTES for information on the raw system call. */
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
waitid():
Since glibc 2.26: _XOPEN_SOURCE &amp;gt;= 500 ||
_POSIX_C_SOURCE &amp;gt;= 200809L
Glibc 2.25 and earlier:
_XOPEN_SOURCE
|| /* Since glibc 2.12: */ _POSIX_C_SOURCE &amp;gt;= 200809L
|| /* Glibc versions &amp;lt;= 2.19: */ _BSD_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;exec函数族&quot;&gt;exec函数族&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
extern char **environ;
int execl(const char *path, const char *arg, ...
/* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
/* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
/*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
char *const envp[]);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
execvpe(): _GNU_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;用户权限以及组权限&quot;&gt;用户权限以及组权限&lt;/h1&gt;

&lt;p&gt;u+s&lt;/p&gt;

&lt;p&gt;g+s&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;getuid&lt;/li&gt;
  &lt;li&gt;geteuid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
uid_t getuid(void);
uid_t geteuid(void);
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
gid_t getgid(void);
gid_t getegid(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;setuid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int setuid(uid_t uid);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;setgid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int setgid(gid_t gid);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;setreuid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int setreuid(uid_t ruid, uid_t euid);
int setregid(gid_t rgid, gid_t egid);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;解释器文件&quot;&gt;解释器文件&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;system&quot;&gt;system&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int system(const char *command);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fork&lt;/code&gt;+&lt;code&gt;exec&lt;/code&gt;+&lt;code&gt;wait&lt;/code&gt;封装&lt;/p&gt;

&lt;h1 id=&quot;进程会计&quot;&gt;进程会计&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;acct&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int acct(const char *filename);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不是标准,了解即可&lt;/p&gt;

&lt;h1 id=&quot;进程时间&quot;&gt;进程时间&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;times&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/times.h&amp;gt;
clock_t times(struct tms *buf);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;守护进程&quot;&gt;守护进程&lt;/h1&gt;

&lt;p&gt;session:sid&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;setsid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t setsid(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;getpgrp&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int setpgid(pid_t pid, pid_t pgid);
pid_t getpgid(pid_t pid);
pid_t getpgrp(void);                 /* POSIX.1 version */
pid_t getpgrp(pid_t pid);            /* BSD version */
int setpgrp(void);                   /* System V version */
int setpgrp(pid_t pid, pid_t pgid);  /* BSD version */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单实例守护进程:锁文件:/var/run/name.pid&lt;/p&gt;

&lt;p&gt;启动脚本文件: /etc/rc*…&lt;/p&gt;

&lt;h1 id=&quot;系统日志&quot;&gt;系统日志&lt;/h1&gt;

&lt;p&gt;syslogd服务&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;openlog&lt;/li&gt;
  &lt;li&gt;syslog&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;syslog.h&amp;gt;
void openlog(const char *ident, int option, int facility);
void syslog(int priority, const char *format, ...);
void closelog(void);
void vsyslog(int priority, const char *format, va_list ap);
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程-文件系统</title><link href="http://localhost:4000/_posts/2020-05-22-linux%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" rel="alternate" type="text/html" title="linux编程-文件系统" /><published>2020-05-22T00:00:00+08:00</published><updated>2020-05-22T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-22-linux%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;文件系统&quot;&gt;文件系统&lt;/h1&gt;

&lt;h2 id=&quot;获取文件属性&quot;&gt;获取文件属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;stat&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;stat, fstat, lstat, fstatat - get file status&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
            int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;stat结构体&quot;&gt;stat结构体&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct stat {
dev_t     st_dev;         /* ID of device containing file */
ino_t     st_ino;         /* Inode number */
mode_t    st_mode;        /* File type and mode */
nlink_t   st_nlink;       /* Number of hard links */
uid_t     st_uid;         /* User ID of owner */
gid_t     st_gid;         /* Group ID of owner */
dev_t     st_rdev;        /* Device ID (if special file) */
off_t     st_size;        /* Total size, in bytes */
blksize_t st_blksize;     /* Block size for filesystem I/O */
blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

/* Since Linux 2.6, the kernel supports nanosecond
precision for the following timestamp fields.
For the details before Linux 2.6, see NOTES. */

struct timespec st_atim;  /* Time of last access */
struct timespec st_mtim;  /* Time of last modification */
struct timespec st_ctim;  /* Time of last status change */

#define st_atime st_atim.tv_sec      /* Backward compatibility */
#define st_mtime st_mtim.tv_sec
#define st_ctime st_ctim.tv_sec
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取文件大小测试程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
//获取文件大小函数
static off_t flen(const char *filename)
{
    //获取文件属性
    struct stat fileinfo;
    if(stat(filename,&amp;amp;fileinfo) &amp;lt; 0)
    {
        perror(&quot;stat()&quot;);
        exit(1);
    }
    return fileinfo.st_size;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在 Linux 系统中，一个文件实际占用了多大的磁盘空间要看 st_blocks 的数量，而不是看 st_size 的大小&lt;/strong&gt;;一般情况下文件系统的一个 block 的大小为 4KB，而每个 st_blocks 是 512B，所以一个有效文件站用磁盘空间最小的大小为 8 个 st_blocks&lt;/p&gt;

&lt;p&gt;空洞文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt; int fd;
    fd = open(argv[1],O_WRONLY|O_CREAT|O_TRUNC,0600);
    if(fd  &amp;lt; 0)
    {
        perror(&quot;open()&quot;);
        exit(0);
    }
    //偏移
//带上LL单位
    lseek(fd,5LL*1024LL*1024LL*1024LL - 1LL,SEEK_SET);
    write(fd,&quot;&quot;,1);
    close(fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mode_t    st_mode&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;权限和文件类型，位图，权限位9位，类型3位，u+s 1位，g+s 1位，粘滞位(T位)1位。位图是用一位或几位数据表示某种状态
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件类型:&lt;code&gt;dcb-lsp&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;d&lt;/th&gt;
      &lt;th&gt;目录&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;c&lt;/td&gt;
      &lt;td&gt;字符快设备文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;b&lt;/td&gt;
      &lt;td&gt;块文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;普通文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;l&lt;/td&gt;
      &lt;td&gt;符号链接文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s&lt;/td&gt;
      &lt;td&gt;套接字文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;p&lt;/td&gt;
      &lt;td&gt;管道文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;文件权限更改&quot;&gt;文件权限更改&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;chmod&lt;/li&gt;
  &lt;li&gt;fchmod&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/stat.h&amp;gt;
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;粘住位&quot;&gt;粘住位&lt;/h2&gt;

&lt;p&gt;t位&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;文件系统:&lt;code&gt;FAT&lt;/code&gt;,&lt;code&gt;UFS&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;硬链接符号链接&quot;&gt;硬链接&amp;amp;符号链接&lt;/h2&gt;

&lt;p&gt;硬链接与目录项是同义词,且建立硬链接有限制,不能给分区建立,不能给目录建立;符号链接优点:可跨分区,可以给目录建立&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;link&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int link(const char *oldpath, const char *newpath);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;unistd.h&amp;gt;
int linkat(int olddirfd, const char *oldpath,
           int newdirfd, const char *newpath, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;unlink&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int unlink(const char *pathname);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;unistd.h&amp;gt;
int unlinkat(int dirfd, const char *pathname, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;remove&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;remove a file or directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int remove(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rename&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int rename(const char *oldpath, const char *newpath);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;stdio.h&amp;gt;
int renameat(int olddirfd, const char *oldpath,
int newdirfd, const char *newpath);
int renameat2(int olddirfd, const char *oldpath,
int newdirfd, const char *newpath, unsigned int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;文件时间&quot;&gt;文件时间&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;utime&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;utime.h&amp;gt;
int utime(const char *filename, const struct utimbuf *times);
#include &amp;lt;sys/time.h&amp;gt;
int utimes(const char *filename, const struct timeval times[2]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;目录创建删除&quot;&gt;目录创建&amp;amp;删除&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
int mkdir(const char *pathname, mode_t mode);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int mkdirat(int dirfd, const char *pathname, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rmdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int rmdir(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;修改工作路径&quot;&gt;修改工作路径&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;chdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int chdir(const char *path);
int fchdir(int fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;突破安全限制,有缺陷&lt;/p&gt;

&lt;h2 id=&quot;获取当前工作路径&quot;&gt;获取当前工作路径&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;getcwd&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
char *getcwd(char *buf, size_t size);
char *getwd(char *buf);
char *get_current_dir_name(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;目录glob函数&quot;&gt;目录glob函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;glob&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;find pathnames &lt;code&gt;matching a pattern&lt;/code&gt;, free memory from
       glob()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;glob.h&amp;gt;
int glob(const char *pattern, int flags,
int (*errfunc) (const char *epath, int eerrno),
glob_t *pglob);
void globfree(glob_t *pglob);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;glob.h&amp;gt;
//匹配的文件
#define PAT &quot;/etc/a*.conf&quot;
//返回错误的函数
int errfunc_(const char *epath,int eerror)
{
    puts(epath);
    fprintf(stderr,&quot;error msg:%s\n&quot;,strerror(eerror));
    return 0;
}
int main(int argc, char const *argv[])
{
    glob_t       globres;
    int err = 0;
    err = glob(PAT,0,NULL,&amp;amp;globres);
    if(err)
    {
        printf(&quot;error code = %d\n&quot;,err);
        exit(1);
    }
    for (size_t i = 0; i &amp;lt; globres.gl_pathc; i++)
    {
        puts(globres.gl_pathv[i]);
    }
    globfree(&amp;amp;globres);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;opendir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
DIR *opendir(const char *name);
DIR *fdopendir(int fd);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
fdopendir():
Since glibc 2.10:
_POSIX_C_SOURCE &amp;gt;= 200809L
Before glibc 2.10:
_GNU_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;closedir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
int closedir(DIR *dirp);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;readdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;dirent.h&amp;gt;
struct dirent *readdir(DIR *dirp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dirent结构体&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct dirent {
               ino_t          d_ino;       /* Inode number */
               off_t          d_off;       /* Not an offset; see below */
               unsigned short d_reclen;    /* Length of this record */
               unsigned char  d_type;      /* Type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* Null-terminated filename */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取文件名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
#define PAT &quot;/etc&quot;
int main(int argc, char const *argv[])
{
    DIR *dp;
    struct dirent *cur;
    dp = opendir(PAT);
    if(dp == NULL)
    {
        perror(&quot;opendir&quot;);
        exit(1);
    }
    while ((cur = readdir(dp)) != NULL)
    {
         puts(cur-&amp;gt;d_name);
    }
    closedir(dp);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rewenddir&lt;/li&gt;
  &lt;li&gt;seekdir&lt;/li&gt;
  &lt;li&gt;telldir&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;系统数据文件和信息&quot;&gt;系统数据文件和信息&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/passwd&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;getpwuid&lt;/li&gt;
      &lt;li&gt;getpwnam&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;pwd.h&amp;gt;
struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);
int getpwnam_r(const char *name, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
int getpwuid_r(uid_t uid, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;passwd结构体&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct passwd {
               char   *pw_name;       /* username */
               char   *pw_passwd;     /* user password */
               uid_t   pw_uid;        /* user ID */
               gid_t   pw_gid;        /* group ID */
               char   *pw_gecos;      /* user information */
               char   *pw_dir;        /* home directory */
               char   *pw_shell;      /* shell program */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;/etc/group
    &lt;ul&gt;
      &lt;li&gt;getgrgid&lt;/li&gt;
      &lt;li&gt;getgrgrnam&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/shadow&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;getspnam&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;shadow.h&amp;gt;
struct spwd *getspnam(const char *name);
struct spwd *getspent(void);
void setspent(void);
void endspent(void);
struct spwd *fgetspent(FILE *stream);
struct spwd *sgetspent(const char *s);
int putspent(const struct spwd *p, FILE *stream);
int lckpwdf(void);
int ulckpwdf(void);
/* GNU extension */
#include &amp;lt;shadow.h&amp;gt;
int getspent_r(struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int getspnam_r(const char *name, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int fgetspent_r(FILE *stream, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int sgetspent_r(const char *s, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;spwd结构体&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct spwd {
               char *sp_namp;     /* Login name */
               char *sp_pwdp;     /* Encrypted password */
               long  sp_lstchg;   /* Date of last change
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               long  sp_min;      /* Min # of days between changes */
               long  sp_max;      /* Max # of days between changes */
               long  sp_warn;     /* # of days before password expires
                                     to warn user to change it */
               long  sp_inact;    /* # of days after password expires
                                     until account is disabled */
               long  sp_expire;   /* Date when account expires
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               unsigned long sp_flag;  /* Reserved */
           };
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;crypt&lt;/p&gt;

        &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define _XOPEN_SOURCE       /* See feature_test_macros(7) */
#include &amp;lt;unistd.h&amp;gt;
char *crypt(const char *key, const char *salt);
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &amp;lt;crypt.h&amp;gt;
char *crypt_r(const char *key, const char *salt,
struct crypt_data *data);
Link with -lcrypt.
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;getpass&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
char *getpass(const char *prompt);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时间戳&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;time&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
time_t time(time_t *tloc);
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;gmtime&lt;/li&gt;
      &lt;li&gt;localtime&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);
char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);
struct tm *gmtime(const time_t *timep);
struct tm *gmtime_r(const time_t *timep, struct tm *result);
struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);
time_t mktime(struct tm *tm);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;tm结构体&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct tm {
               int tm_sec;    /* Seconds (0-60) */
               int tm_min;    /* Minutes (0-59) */
               int tm_hour;   /* Hours (0-23) */
               int tm_mday;   /* Day of the month (1-31) */
               int tm_mon;    /* Month (0-11) */
               int tm_year;   /* Year - 1900 */
               int tm_wday;   /* Day of the week (0-6, Sunday = 0) */
               int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */
               int tm_isdst;  /* Daylight saving time */
           };
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;strftime&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
size_t strftime(char *s, size_t max, const char *format,
const struct tm *tm);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;进程环境&quot;&gt;进程环境&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;main函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main(int argc,char *argv[])
//其实还有第三个参数,环境变量
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;进程的终止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正常终止:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;main函数返回&lt;/li&gt;
  &lt;li&gt;调用exit&lt;/li&gt;
  &lt;li&gt;调用_exit或者_Exit&lt;/li&gt;
  &lt;li&gt;最后一个线程从其启动例程饭后&lt;/li&gt;
  &lt;li&gt;最后一个线程调用pthread_exit&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常终止:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调用abort&lt;/li&gt;
  &lt;li&gt;接到一个信号并终止&lt;/li&gt;
  &lt;li&gt;最后一个线程对其取消请求做出响应&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;钩子函数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;atexit&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int atexit(void (*function)(void));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;命令行参数分析&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;getopt&lt;/li&gt;
      &lt;li&gt;getopt_long&lt;/li&gt;
    &lt;/ol&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int getopt(int argc, char * const argv[],
const char *optstring);
extern char *optarg;
extern int optind, opterr, optopt;
#include &amp;lt;getopt.h&amp;gt;
int getopt_long(int argc, char * const argv[],
const char *optstring,
const struct option *longopts, int *longindex);
int getopt_long_only(int argc, char * const argv[],
const char *optstring,
const struct option *longopts, int *longindex);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;环境变量&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;environ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;extern char **environ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
char *getenv(const char *name);
char *secure_getenv(const char *name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;setenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;putenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int putenv(char *string);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;c程序的存储空间布局&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;pmap&lt;/code&gt;命令查看&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;库&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;动态库&lt;/li&gt;
  &lt;li&gt;静态库&lt;/li&gt;
  &lt;li&gt;手工装载库&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;dlopen&lt;/p&gt;

&lt;p&gt;dlclose&lt;/p&gt;

&lt;p&gt;dlerror&lt;/p&gt;

&lt;p&gt;dlsym&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;dlfcn.h&amp;gt;
void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlmopen (Lmid_t lmid, const char *filename, int flags);
Link with -ldl.   
    #include &amp;lt;dlfcn.h&amp;gt;
    void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlmopen (Lmid_t lmid, const char *filename, int flags);
#include &amp;lt;dlfcn.h&amp;gt;
char *dlerror(void);
void *dlsym(void *handle, const char *symbol);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlvsym(void *handle, char *symbol, char *version);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
       #include &amp;lt;stdlib.h&amp;gt;
       #include &amp;lt;dlfcn.h&amp;gt;
       #include &amp;lt;gnu/lib-names.h&amp;gt;  /* Defines LIBM_SO (which will be a
                                      string such as &quot;libm.so.6&quot;) */
       int
       main(void)
       {
           void *handle;
           double (*cosine)(double);
           char *error;

           handle = dlopen(LIBM_SO, RTLD_LAZY);
           if (!handle) {
               fprintf(stderr, &quot;%s\n&quot;, dlerror());
               exit(EXIT_FAILURE);
           }

           dlerror();    /* Clear any existing error */

           cosine = (double (*)(double)) dlsym(handle, &quot;cos&quot;);

           /* According to the ISO C standard, casting between function
              pointers and 'void *', as done above, produces undefined results.
              POSIX.1-2003 and POSIX.1-2008 accepted this state of affairs and
              proposed the following workaround:

                  *(void **) (&amp;amp;cosine) = dlsym(handle, &quot;cos&quot;);

              This (clumsy) cast conforms with the ISO C standard and will
              avoid any compiler warnings.

              The 2013 Technical Corrigendum to POSIX.1-2008 (a.k.a.
              POSIX.1-2013) improved matters by requiring that conforming
              implementations support casting 'void *' to a function pointer.
              Nevertheless, some compilers (e.g., gcc with the '-pedantic'
              option) may complain about the cast used in this program. */

           error = dlerror();
           if (error != NULL) {
               fprintf(stderr, &quot;%s\n&quot;, error);
               exit(EXIT_FAILURE);
           }

           printf(&quot;%f\n&quot;, (*cosine)(2.0));
           dlclose(handle);
           exit(EXIT_SUCCESS);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;函数跳转&lt;/p&gt;

    &lt;p&gt;setjmp&lt;/p&gt;

    &lt;p&gt;longjmp&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;资源获取及控制&lt;/p&gt;

    &lt;p&gt;getrlimit&lt;/p&gt;

    &lt;p&gt;setrlimit&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;sys/resource.h&amp;gt;
int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);
int prlimit(pid_t pid, int resource, const struct rlimit *new_limit,
struct rlimit *old_limit);
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程</title><link href="http://localhost:4000/_posts/2020-05-20-linux%E7%BC%96%E7%A8%8B-IO/" rel="alternate" type="text/html" title="linux编程" /><published>2020-05-20T00:00:00+08:00</published><updated>2020-05-20T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-IO</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-20-linux%E7%BC%96%E7%A8%8B-IO/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;error&quot;&gt;ERROR&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;vim /usr/include/asm-generic/errno-base.h 
errno.h 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#ifndef _ASM_GENERIC_ERRNO_BASE_H
#define _ASM_GENERIC_ERRNO_BASE_H

#define EPERM            1      /* Operation not permitted */
#define ENOENT           2      /* No such file or directory */
#define ESRCH            3      /* No such process */
#define EINTR            4      /* Interrupted system call */
#define EIO              5      /* I/O error */
#define ENXIO            6      /* No such device or address */
#define E2BIG            7      /* Argument list too long */
#define ENOEXEC          8      /* Exec format error */
#define EBADF            9      /* Bad file number */
#define ECHILD          10      /* No child processes */
#define EAGAIN          11      /* Try again */
#define ENOMEM          12      /* Out of memory */
#define EACCES          13      /* Permission denied */
#define EFAULT          14      /* Bad address */
#define ENOTBLK         15      /* Block device required */
#define EBUSY           16      /* Device or resource busy */
#define EEXIST          17      /* File exists */
#define EXDEV           18      /* Cross-device link */
#define ENODEV          19      /* No such device */
#define ENOTDIR         20      /* Not a directory */
#define EISDIR          21      /* Is a directory */
#define EINVAL          22      /* Invalid argument */
#define ENFILE          23      /* File table overflow */
#define EMFILE          24      /* Too many open files */
#define ENOTTY          25      /* Not a typewriter */
#define ETXTBSY         26      /* Text file busy */
#define EFBIG           27      /* File too large */
#define ENOSPC          28      /* No space left on device */
#define ESPIPE          29      /* Illegal seek */
#define EROFS           30      /* Read-only file system */
#define EMLINK          31      /* Too many links */
#define EPIPE           32      /* Broken pipe */
#define EDOM            33      /* Math argument out of domain of func */
#define ERANGE          34      /* Math result not representable */
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;man手册&quot;&gt;man手册&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;第一章:基本命令&lt;/li&gt;
  &lt;li&gt;第二章:系统调用&lt;/li&gt;
  &lt;li&gt;第三章:标准库函数&lt;/li&gt;
  &lt;li&gt;第七章:体系结构&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;宏和函数&quot;&gt;宏和函数&lt;/h2&gt;

&lt;p&gt;宏占用编译时间,函数占用运行时间,不过更安全&lt;/p&gt;

&lt;h1 id=&quot;io&quot;&gt;IO&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;一切实现的基础&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;input&lt;/code&gt;&amp;amp;&lt;code&gt;output&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;实现:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;stdio&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sysio&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优先考虑stdio,扩展性更好,不同平台底层不一样.&lt;/p&gt;

&lt;h2 id=&quot;errorno-to-error_msg&quot;&gt;errorno to error_msg&lt;/h2&gt;

&lt;p&gt;更直观展示错误内容&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;perror (关联全局变量errorno)&lt;/li&gt;
  &lt;li&gt;strerror&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;file结构体&quot;&gt;FILE结构体&lt;/h2&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;h2 id=&quot;常用函数&quot;&gt;常用函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;fopen&lt;/li&gt;
  &lt;li&gt;fclose&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;NAME
       fopen, fdopen, freopen - stream open functions
SYNOPSIS
       #include &amp;lt;stdio.h&amp;gt;
       FILE *fopen(const char *pathname, const char *mode);
       FILE *fdopen(int fd, const char *mode);
       FILE *freopen(const char *pathname, const char *mode, FILE *stream);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;const&lt;/code&gt;参数,安全性;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mode&lt;/code&gt;:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;r&lt;/th&gt;
      &lt;th&gt;for read&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;r+&lt;/td&gt;
      &lt;td&gt;reading and writing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;truncate fileto zero length or create text  file  for  writing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w+&lt;/td&gt;
      &lt;td&gt;open for reading and writing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;open for appending&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;a+&lt;/td&gt;
      &lt;td&gt;open for reading and appending&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;返回:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;RETURN VALUE
       Upon successful completion fopen(), fdopen()  and  freopen()  return  a
       FILE pointer.  Otherwise, NULL is returned and errno is set to indicate
       the error.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;error 一个&lt;code&gt;全局变量&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;FILE 创建的指针在栈,静态区,或者堆???&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;FILE *fopen(const char *pathname, const char *mode);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在堆上;&lt;/p&gt;

&lt;p&gt;如果一个操作成对出现使用,&lt;code&gt;一般&lt;/code&gt;放在&lt;code&gt;堆&lt;/code&gt;上&lt;/p&gt;

&lt;p&gt;&lt;code&gt;是资源一定有上限&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;fopen打开&lt;code&gt;流&lt;/code&gt;是有上限的,一般体现出来的数量是&lt;code&gt;1021&lt;/code&gt;,其实真实打开的是&lt;code&gt;1024&lt;/code&gt;个,有&lt;code&gt;3&lt;/code&gt;个默认&lt;code&gt;流&lt;/code&gt;:&lt;code&gt;stdout&lt;/code&gt;,&lt;code&gt;stdinput&lt;/code&gt;,&lt;code&gt;stderr&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;具体限制参考:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ulimit -a&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;-t: cpu time (seconds)              unlimited
-f: file size (blocks)              unlimited
-d: data seg size (kbytes)          unlimited
-s: stack size (kbytes)             8192
-c: core file size (blocks)         0
-m: resident set size (kbytes)      unlimited
-u: processes                       31073
-n: file descriptors                1024
-l: locked-in-memory size (kbytes)  16384
-v: address space (kbytes)          unlimited
-x: file locks                      unlimited
-i: pending signals                 31073
-q: bytes in POSIX msg queues       819200
-e: max nice                        0
-r: max rt priority                 0
-N 15:                              unlimited

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建文件后的权限&lt;/p&gt;

&lt;p&gt;具体公式:&lt;code&gt;0666 &amp;amp; ~umask&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;字符操作&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fgetc&lt;/li&gt;
  &lt;li&gt;fputc&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
int ungetc(int c, FILE *stream);
//---------------------
int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
int ungetc(int c, FILE *stream);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return value&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;fgetc(),  getc() and getchar() return the character read as an unsigned
char cast to an int or EOF on end of file or error.
fgets() returns s on success, and NULL on error or  when  end  of  file
occurs while no characters have been read.
ungetc() returns c on success, or EOF on error.

--------------------------

fgetc(),  getc() and getchar() return the character read as an unsigned
char cast to an int or `EOF` on end of file or error.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;fgets&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-CQL&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
int ungetc(int c, FILE *stream);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;fputs&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fputc(int c, FILE *stream);
int fputs(const char *s, FILE *stream);
int putc(int c, FILE *stream);
int putchar(int c);
int puts(const char *s);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;fwrite&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb,
              FILE *stream);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;printf&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int dprintf(int fd, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);
#include &amp;lt;stdarg.h&amp;gt;
int vprintf(const char *format, va_list ap);
int vfprintf(FILE *stream, const char *format, va_list ap);
int vdprintf(int fd, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);=
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;scanf&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int scanf(const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);
int sscanf(const char *str, const char *format, ...);
#include &amp;lt;stdarg.h&amp;gt;
int vscanf(const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;fseek&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, const fpos_t *pos);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;whence&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SEEK_SET&lt;/li&gt;
  &lt;li&gt;SEEK_CUR&lt;/li&gt;
  &lt;li&gt;SEEK_END&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;long offset&lt;/code&gt;注意长度限制,类型为long,有缺陷,&lt;code&gt;fseeko&lt;/code&gt;修改了缺陷,如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fseeko(FILE *stream, off_t offset, int whence);
off_t ftello(FILE *stream);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
fseeko(), ftello():
_FILE_OFFSET_BITS == 64 || _POSIX_C_SOURCE &amp;gt;= 200112L
(defining the obsolete _LARGEFILE_SOURCE macro also works)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;On some architectures, both off_t and long are 32-bit types, but defin‐
       ing  _FILE_OFFSET_BITS  with  the value 64 (before including any header
       files) will turn off_t into a 64-bit type.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;ftell&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, const fpos_t *pos);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;fflush&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fflush(FILE *stream);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;p&gt;If the stream argument is NULL, fflush() flushes all open output streams.For a nonlocking counterpart, see unlocked_stdio(3).&lt;/p&gt;

&lt;p&gt;缓冲区作用:合并系统调用&lt;/p&gt;

&lt;p&gt;分类:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;行缓冲:换行时刷新,stdout&lt;/li&gt;
  &lt;li&gt;全缓冲:满了就刷新,默认&lt;/li&gt;
  &lt;li&gt;无缓冲:stderr&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;修改缓冲:&lt;/p&gt;

&lt;p&gt;setvbuf&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
void setbuf(FILE *stream, char *buf);
void setbuffer(FILE *stream, char *buf, size_t size);
void setlinebuf(FILE *stream);
int setvbuf(FILE *stream, char *buf, int mode, size_t size);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The mode argument must be one of the following three macros:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;_IONBF unbuffered
_IOLBF line buffered
_IOFBF fully buffered
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;getline&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
ssize_t getline(char **lineptr, size_t *n, FILE *stream);
ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
getline(), getdelim():
Since glibc 2.10:
_POSIX_C_SOURCE &amp;gt;= 200809L
    Before glibc 2.10:
_GNU_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于段错误一定要仔细分析,可能是调用的函数引用了其他函数,但是没有初始化,这种容易出错;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;tmpnam&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
char *tmpnam(char *s);
char *tmpnam_r(char *s);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;tmpfile&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
FILE *tmpfile(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匿名文件&lt;/p&gt;

&lt;p&gt;临时问阿金两个问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不冲突&lt;/li&gt;
  &lt;li&gt;及时销毁&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;文件描述符&quot;&gt;文件描述符&lt;/h2&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;h2 id=&quot;系统io&quot;&gt;系统IO&lt;/h2&gt;

&lt;h3 id=&quot;函数&quot;&gt;函数&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;open&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
int creat(const char *pathname, mode_t mode);
int openat(int dirfd, const char *pathname, int flags);
int openat(int dirfd, const char *pathname, int flags, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数名相同,参数不同,在c++和Java里面叫做&lt;code&gt;重载&lt;/code&gt;,但是c里面没有重载,此处是使用&lt;code&gt;变参实现&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以传入多个参数取去编译,如果报错,就是重载实现,如果没有报错,则是变参实现.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;flag&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;O_APPEND&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_ASYNC&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_CLOEXEC&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_CREAT&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_DIRECT&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_DIRECTORY&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_DSYNC&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_EXCL&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_LARGEFILE&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_NOATIME&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_NOCTTY&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_NOFOLLOW&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_NONBLOCK&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_PATH&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_SYNC&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;联系&lt;code&gt;标准io&lt;/code&gt;里面的model,有如下对应关系:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;model&lt;/th&gt;
      &lt;th&gt;flags&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;r-&lt;/td&gt;
      &lt;td&gt;O_RDONLY&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r+&lt;/td&gt;
      &lt;td&gt;O_RDWR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;O_WRONLY|O_CREAT|O_TRUNC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w+&lt;/td&gt;
      &lt;td&gt;O_RDWR|O_TRUNC|O_CREAT&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;close&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int close(int fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;read&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
ssize_t read(int fd, void *buf, size_t count);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;write&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
ssize_t write(int fd, const void *buf, size_t count);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;lseek&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
off_t lseek(int fd, off_t offset, int whence);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;dup&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;复制文件描述符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int dup(int oldfd);
int dup2(int oldfd, int newfd);
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include &amp;lt;fcntl.h&amp;gt;              /* Obtain O_* constant definitions */
#include &amp;lt;unistd.h&amp;gt;
int dup3(int oldfd, int newfd, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;标准IO不要和系统IO混用&lt;/p&gt;

&lt;p&gt;转换&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
void clearerr(FILE *stream);
int feof(FILE *stream);
int ferror(FILE *stream);
int fileno(FILE *stream);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;原子操作&quot;&gt;原子操作&lt;/h2&gt;

&lt;p&gt;不可分割的最小单位,解决竞争和冲突&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;同步&quot;&gt;同步&lt;/h2&gt;

&lt;h3 id=&quot;函数-1&quot;&gt;函数&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;sync&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;sync, syncfs - commit filesystem caches to disk&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
void sync(void);
int syncfs(int fd);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
sync():
_XOPEN_SOURCE &amp;gt;= 500
|| /* Since glibc 2.19: */ _DEFAULT_SOURCE
|| /* Glibc versions &amp;lt;= 2.19: */ _BSD_SOURCE
syncfs():
_GNU_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;fsync&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ynchronize  a  file’s in-core state with storage
       device&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int fsync(int fd);
int fdatasync(int fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;fcntl&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
int fcntl(int fd, int cmd, ... /* arg */ );
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;ioctl&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/ioctl.h&amp;gt;
int ioctl(int fd, unsigned long request, ...);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;devfd目录&quot;&gt;/dev/fd目录&lt;/h2&gt;

&lt;p&gt;虚目录,显示当前进程的文件描述符的信息&lt;/p&gt;

&lt;h1 id=&quot;文件系统&quot;&gt;文件系统&lt;/h1&gt;

&lt;h2 id=&quot;获取文件属性&quot;&gt;获取文件属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;stat&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;stat, fstat, lstat, fstatat - get file status&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
            int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;stat结构体&quot;&gt;stat结构体&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct stat {
dev_t     st_dev;         /* ID of device containing file */
ino_t     st_ino;         /* Inode number */
mode_t    st_mode;        /* File type and mode */
nlink_t   st_nlink;       /* Number of hard links */
uid_t     st_uid;         /* User ID of owner */
gid_t     st_gid;         /* Group ID of owner */
dev_t     st_rdev;        /* Device ID (if special file) */
off_t     st_size;        /* Total size, in bytes */
blksize_t st_blksize;     /* Block size for filesystem I/O */
blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

/* Since Linux 2.6, the kernel supports nanosecond
precision for the following timestamp fields.
For the details before Linux 2.6, see NOTES. */

struct timespec st_atim;  /* Time of last access */
struct timespec st_mtim;  /* Time of last modification */
struct timespec st_ctim;  /* Time of last status change */

#define st_atime st_atim.tv_sec      /* Backward compatibility */
#define st_mtime st_mtim.tv_sec
#define st_ctime st_ctim.tv_sec
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取文件大小测试程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
//获取文件大小函数
static off_t flen(const char *filename)
{
    //获取文件属性
    struct stat fileinfo;
    if(stat(filename,&amp;amp;fileinfo) &amp;lt; 0)
    {
        perror(&quot;stat()&quot;);
        exit(1);
    }
    return fileinfo.st_size;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;空洞文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt; int fd;
    fd = open(argv[1],O_WRONLY|O_CREAT|O_TRUNC,0600);
    if(fd  &amp;lt; 0)
    {
        perror(&quot;open()&quot;);
        exit(0);
    }
    //偏移
//带上LL单位
    lseek(fd,5LL*1024LL*1024LL*1024LL - 1LL,SEEK_SET);
    write(fd,&quot;&quot;,1);
    close(fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mode_t    st_mode&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;权限和文件类型，位图，权限位9位，类型3位，u+s 1位，g+s 1位，粘滞位(T位)1位。位图是用一位或几位数据表示某种状态
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件类型:&lt;code&gt;dcb-lsp&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;d&lt;/th&gt;
      &lt;th&gt;目录&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;c&lt;/td&gt;
      &lt;td&gt;字符快设备文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;b&lt;/td&gt;
      &lt;td&gt;块文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;普通文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;l&lt;/td&gt;
      &lt;td&gt;符号链接文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s&lt;/td&gt;
      &lt;td&gt;套接字文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;p&lt;/td&gt;
      &lt;td&gt;管道文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;文件权限更改&quot;&gt;文件权限更改&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;chmod&lt;/li&gt;
  &lt;li&gt;fchmod&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/stat.h&amp;gt;
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;粘住位&quot;&gt;粘住位&lt;/h2&gt;

&lt;p&gt;t位&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;文件系统:&lt;code&gt;FAT&lt;/code&gt;,&lt;code&gt;UFS&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;硬链接符号链接&quot;&gt;硬链接&amp;amp;符号链接&lt;/h2&gt;

&lt;p&gt;硬链接与目录项是同义词,且建立硬链接有限制,不能给分区建立,不能给目录建立;符号链接优点:可跨分区,可以给目录建立&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;link&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int link(const char *oldpath, const char *newpath);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;unistd.h&amp;gt;
int linkat(int olddirfd, const char *oldpath,
           int newdirfd, const char *newpath, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;unlink&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int unlink(const char *pathname);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;unistd.h&amp;gt;
int unlinkat(int dirfd, const char *pathname, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;remove&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;remove a file or directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int remove(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rename&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int rename(const char *oldpath, const char *newpath);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;stdio.h&amp;gt;
int renameat(int olddirfd, const char *oldpath,
int newdirfd, const char *newpath);
int renameat2(int olddirfd, const char *oldpath,
int newdirfd, const char *newpath, unsigned int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;文件时间&quot;&gt;文件时间&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;utime&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;utime.h&amp;gt;
int utime(const char *filename, const struct utimbuf *times);
#include &amp;lt;sys/time.h&amp;gt;
int utimes(const char *filename, const struct timeval times[2]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;目录创建删除&quot;&gt;目录创建&amp;amp;删除&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
int mkdir(const char *pathname, mode_t mode);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int mkdirat(int dirfd, const char *pathname, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rmdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int rmdir(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;修改工作路径&quot;&gt;修改工作路径&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;chdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int chdir(const char *path);
int fchdir(int fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;突破安全限制,有缺陷&lt;/p&gt;

&lt;h2 id=&quot;获取当前工作路径&quot;&gt;获取当前工作路径&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;getcwd&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
char *getcwd(char *buf, size_t size);
char *getwd(char *buf);
char *get_current_dir_name(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;目录glob函数&quot;&gt;目录glob函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;glob&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;find pathnames &lt;code&gt;matching a pattern&lt;/code&gt;, free memory from
       glob()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;glob.h&amp;gt;
int glob(const char *pattern, int flags,
int (*errfunc) (const char *epath, int eerrno),
glob_t *pglob);
void globfree(glob_t *pglob);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;glob.h&amp;gt;
//匹配的文件
#define PAT &quot;/etc/a*.conf&quot;
//返回错误的函数
int errfunc_(const char *epath,int eerror)
{
    puts(epath);
    fprintf(stderr,&quot;error msg:%s\n&quot;,strerror(eerror));
    return 0;
}
int main(int argc, char const *argv[])
{
    glob_t       globres;
    int err = 0;
    err = glob(PAT,0,NULL,&amp;amp;globres);
    if(err)
    {
        printf(&quot;error code = %d\n&quot;,err);
        exit(1);
    }
    for (size_t i = 0; i &amp;lt; globres.gl_pathc; i++)
    {
        puts(globres.gl_pathv[i]);
    }
    globfree(&amp;amp;globres);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;opendir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
DIR *opendir(const char *name);
DIR *fdopendir(int fd);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
fdopendir():
Since glibc 2.10:
_POSIX_C_SOURCE &amp;gt;= 200809L
Before glibc 2.10:
_GNU_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;closedir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
int closedir(DIR *dirp);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;readdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;dirent.h&amp;gt;
struct dirent *readdir(DIR *dirp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dirent结构体&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct dirent {
               ino_t          d_ino;       /* Inode number */
               off_t          d_off;       /* Not an offset; see below */
               unsigned short d_reclen;    /* Length of this record */
               unsigned char  d_type;      /* Type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* Null-terminated filename */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取文件名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
#define PAT &quot;/etc&quot;
int main(int argc, char const *argv[])
{
    DIR *dp;
    struct dirent *cur;
    dp = opendir(PAT);
    if(dp == NULL)
    {
        perror(&quot;opendir&quot;);
        exit(1);
    }
    while ((cur = readdir(dp)) != NULL)
    {
         puts(cur-&amp;gt;d_name);
    }
    closedir(dp);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rewenddir&lt;/li&gt;
  &lt;li&gt;seekdir&lt;/li&gt;
  &lt;li&gt;telldir&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;系统数据文件和信息&quot;&gt;系统数据文件和信息&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/passwd&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;getpwuid&lt;/li&gt;
      &lt;li&gt;getpwnam&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;pwd.h&amp;gt;
struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);
int getpwnam_r(const char *name, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
int getpwuid_r(uid_t uid, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;passwd结构体&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct passwd {
               char   *pw_name;       /* username */
               char   *pw_passwd;     /* user password */
               uid_t   pw_uid;        /* user ID */
               gid_t   pw_gid;        /* group ID */
               char   *pw_gecos;      /* user information */
               char   *pw_dir;        /* home directory */
               char   *pw_shell;      /* shell program */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;/etc/group
    &lt;ul&gt;
      &lt;li&gt;getgrgid&lt;/li&gt;
      &lt;li&gt;getgrgrnam&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/shadow&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;getspnam&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;shadow.h&amp;gt;
struct spwd *getspnam(const char *name);
struct spwd *getspent(void);
void setspent(void);
void endspent(void);
struct spwd *fgetspent(FILE *stream);
struct spwd *sgetspent(const char *s);
int putspent(const struct spwd *p, FILE *stream);
int lckpwdf(void);
int ulckpwdf(void);
/* GNU extension */
#include &amp;lt;shadow.h&amp;gt;
int getspent_r(struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int getspnam_r(const char *name, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int fgetspent_r(FILE *stream, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int sgetspent_r(const char *s, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;spwd结构体&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct spwd {
               char *sp_namp;     /* Login name */
               char *sp_pwdp;     /* Encrypted password */
               long  sp_lstchg;   /* Date of last change
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               long  sp_min;      /* Min # of days between changes */
               long  sp_max;      /* Max # of days between changes */
               long  sp_warn;     /* # of days before password expires
                                     to warn user to change it */
               long  sp_inact;    /* # of days after password expires
                                     until account is disabled */
               long  sp_expire;   /* Date when account expires
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               unsigned long sp_flag;  /* Reserved */
           };
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;crypt&lt;/p&gt;

        &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define _XOPEN_SOURCE       /* See feature_test_macros(7) */
#include &amp;lt;unistd.h&amp;gt;
char *crypt(const char *key, const char *salt);
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &amp;lt;crypt.h&amp;gt;
char *crypt_r(const char *key, const char *salt,
struct crypt_data *data);
Link with -lcrypt.
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;getpass&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
char *getpass(const char *prompt);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时间戳&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;time&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
time_t time(time_t *tloc);
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;gmtime&lt;/li&gt;
      &lt;li&gt;localtime&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);
char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);
struct tm *gmtime(const time_t *timep);
struct tm *gmtime_r(const time_t *timep, struct tm *result);
struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);
time_t mktime(struct tm *tm);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;tm结构体&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct tm {
               int tm_sec;    /* Seconds (0-60) */
               int tm_min;    /* Minutes (0-59) */
               int tm_hour;   /* Hours (0-23) */
               int tm_mday;   /* Day of the month (1-31) */
               int tm_mon;    /* Month (0-11) */
               int tm_year;   /* Year - 1900 */
               int tm_wday;   /* Day of the week (0-6, Sunday = 0) */
               int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */
               int tm_isdst;  /* Daylight saving time */
           };
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;strftime&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
size_t strftime(char *s, size_t max, const char *format,
const struct tm *tm);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;进程环境&quot;&gt;进程环境&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;main函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main(int argc,char *argv[])
//其实还有第三个参数,环境变量
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;进程的终止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正常终止:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;main函数返回&lt;/li&gt;
  &lt;li&gt;调用exit&lt;/li&gt;
  &lt;li&gt;调用_exit或者_Exit&lt;/li&gt;
  &lt;li&gt;最后一个线程从其启动例程饭后&lt;/li&gt;
  &lt;li&gt;最后一个线程调用pthread_exit&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常终止:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调用abort&lt;/li&gt;
  &lt;li&gt;接到一个信号并终止&lt;/li&gt;
  &lt;li&gt;最后一个线程对其取消请求做出响应&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;钩子函数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;atexit&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int atexit(void (*function)(void));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;命令行参数分析&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;getopt&lt;/li&gt;
      &lt;li&gt;getopt_long&lt;/li&gt;
    &lt;/ol&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int getopt(int argc, char * const argv[],
const char *optstring);
extern char *optarg;
extern int optind, opterr, optopt;
#include &amp;lt;getopt.h&amp;gt;
int getopt_long(int argc, char * const argv[],
const char *optstring,
const struct option *longopts, int *longindex);
int getopt_long_only(int argc, char * const argv[],
const char *optstring,
const struct option *longopts, int *longindex);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;环境变量&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;environ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;extern char **environ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
char *getenv(const char *name);
char *secure_getenv(const char *name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;setenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;putenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int putenv(char *string);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;c程序的存储空间布局&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;pmap&lt;/code&gt;命令查看&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;库&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;动态库&lt;/li&gt;
  &lt;li&gt;静态库&lt;/li&gt;
  &lt;li&gt;手工装载库&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;dlopen&lt;/p&gt;

&lt;p&gt;dlclose&lt;/p&gt;

&lt;p&gt;dlerror&lt;/p&gt;

&lt;p&gt;dlsym&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;dlfcn.h&amp;gt;
void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlmopen (Lmid_t lmid, const char *filename, int flags);
Link with -ldl.   
    #include &amp;lt;dlfcn.h&amp;gt;
    void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlmopen (Lmid_t lmid, const char *filename, int flags);
#include &amp;lt;dlfcn.h&amp;gt;
char *dlerror(void);
void *dlsym(void *handle, const char *symbol);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlvsym(void *handle, char *symbol, char *version);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
       #include &amp;lt;stdlib.h&amp;gt;
       #include &amp;lt;dlfcn.h&amp;gt;
       #include &amp;lt;gnu/lib-names.h&amp;gt;  /* Defines LIBM_SO (which will be a
                                      string such as &quot;libm.so.6&quot;) */
       int
       main(void)
       {
           void *handle;
           double (*cosine)(double);
           char *error;

           handle = dlopen(LIBM_SO, RTLD_LAZY);
           if (!handle) {
               fprintf(stderr, &quot;%s\n&quot;, dlerror());
               exit(EXIT_FAILURE);
           }

           dlerror();    /* Clear any existing error */

           cosine = (double (*)(double)) dlsym(handle, &quot;cos&quot;);

           /* According to the ISO C standard, casting between function
              pointers and 'void *', as done above, produces undefined results.
              POSIX.1-2003 and POSIX.1-2008 accepted this state of affairs and
              proposed the following workaround:

                  *(void **) (&amp;amp;cosine) = dlsym(handle, &quot;cos&quot;);

              This (clumsy) cast conforms with the ISO C standard and will
              avoid any compiler warnings.

              The 2013 Technical Corrigendum to POSIX.1-2008 (a.k.a.
              POSIX.1-2013) improved matters by requiring that conforming
              implementations support casting 'void *' to a function pointer.
              Nevertheless, some compilers (e.g., gcc with the '-pedantic'
              option) may complain about the cast used in this program. */

           error = dlerror();
           if (error != NULL) {
               fprintf(stderr, &quot;%s\n&quot;, error);
               exit(EXIT_FAILURE);
           }

           printf(&quot;%f\n&quot;, (*cosine)(2.0));
           dlclose(handle);
           exit(EXIT_SUCCESS);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;函数跳转&lt;/p&gt;

    &lt;p&gt;setjmp&lt;/p&gt;

    &lt;p&gt;longjmp&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;资源获取及控制&lt;/p&gt;

    &lt;p&gt;getrlimit&lt;/p&gt;

    &lt;p&gt;setrlimit&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;sys/resource.h&amp;gt;
int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);
int prlimit(pid_t pid, int resource, const struct rlimit *new_limit,
struct rlimit *old_limit);
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">Docker笔记</title><link href="http://localhost:4000/_posts/2020-05-15-Docker%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="Docker笔记" /><published>2020-05-15T00:00:00+08:00</published><updated>2020-05-15T00:00:00+08:00</updated><id>http://localhost:4000/_posts/Docker%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-15-Docker%E7%AC%94%E8%AE%B0/">&lt;h2 id=&quot;docker&quot;&gt;Docker&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;官网&quot;&gt;&lt;a href=&quot;https://www.docker.com/&quot;&gt;官网&lt;/a&gt;&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;安装教程&quot;&gt;&lt;a href=&quot;https://hub.docker.com/search?q=&amp;amp;type=edition&amp;amp;offering=community&amp;amp;operating_system=linux&quot;&gt;安装教程&lt;/a&gt;&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;基础命令&quot;&gt;基础命令&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Usage:	docker [OPTIONS] COMMAND

A self-sufficient runtime for containers

Options:
      --config string      Location of client config files (default
                           &quot;/home/yourname/.docker&quot;)
  -c, --context string     Name of the context to use to connect to the
                           daemon (overrides DOCKER_HOST env var and
                           default context set with &quot;docker context use&quot;)
  -D, --debug              Enable debug mode
  -H, --host list          Daemon socket(s) to connect to
  -l, --log-level string   Set the logging level
                           (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;)
                           (default &quot;info&quot;)
      --tls                Use TLS; implied by --tlsverify
      --tlscacert string   Trust certs signed only by this CA (default
                           &quot;/home/yourname/.docker/ca.pem&quot;)
      --tlscert string     Path to TLS certificate file (default
                           &quot;/home/yourname/.docker/cert.pem&quot;)
      --tlskey string      Path to TLS key file (default
                           &quot;/home/yourname/.docker/key.pem&quot;)
      --tlsverify          Use TLS and verify the remote
  -v, --version            Print version information and quit

Management Commands:
  builder     Manage builds
  config      Manage Docker configs
  container   Manage containers
  context     Manage contexts
  engine      Manage the docker engine
  image       Manage images
  network     Manage networks
  node        Manage Swarm nodes
  plugin      Manage plugins
  secret      Manage Docker secrets
  service     Manage services
  stack       Manage Docker stacks
  swarm       Manage Swarm
  system      Manage Docker
  trust       Manage trust on Docker images
  volume      Manage volumes

Commands:
  attach      Attach local standard input, output, and error streams to a running container
  build       Build an image from a Dockerfile
  commit      Create a new image from a container's changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  deploy      Deploy a new stack or update an existing stack
  diff        Inspect changes to files or directories on a container's filesystem
  events      Get real time events from the server
  exec        Run a command in a running container
  export      Export a container's filesystem as a tar archive
  history     Show the history of an image
  images      List images
  import      Import the contents from a tarball to create a filesystem image
  info        Display system-wide information
  inspect     Return low-level information on Docker objects
  kill        Kill one or more running containers
  load        Load an image from a tar archive or STDIN
  login       Log in to a Docker registry
  logout      Log out from a Docker registry
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  ps          List containers
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  run         Run a command in a new container
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  search      Search the Docker Hub for images
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  version     Show the Docker version information
  wait        Block until one or more containers stop, then print their exit codes
Run 'docker COMMAND --help' for more information on a command.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;docker--for-ubuntu-images&quot;&gt;Docker  For Ubuntu Images&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;网站&quot;&gt;&lt;a href=&quot;https://hub.docker.com/_/ubuntu?tab=tags&amp;amp;page=1&quot;&gt;网站&lt;/a&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;拉取最新版的-ubuntu-镜像&quot;&gt;拉取最新版的 Ubuntu 镜像&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker pull ubuntu:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;查看本地镜像&quot;&gt;查看本地镜像&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;删除镜像&quot;&gt;删除镜像&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker rmi &lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;构建镜像&quot;&gt;构建镜像&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker build &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要创建一个 &lt;code&gt;Dockerfile&lt;/code&gt; 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-dockerfile&quot;&gt;FROM    centos:6.7
MAINTAINER      Fisher &quot;fisher@sudops.com&quot;

RUN     /bin/echo 'root:123456' |chpasswd
RUN     useradd runoob
RUN     /bin/echo 'runoob:123456' |chpasswd
RUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &amp;gt;/etc/default/local
EXPOSE  22
EXPOSE  80
CMD     /usr/sbin/sshd -D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。&lt;/p&gt;

&lt;p&gt;第一条FROM，指定使用哪个镜像源&lt;/p&gt;

&lt;p&gt;RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。&lt;/p&gt;

&lt;p&gt;然后，我们使用&lt;code&gt;Dockerfile&lt;/code&gt; 文件，通过 &lt;code&gt;docker build&lt;/code&gt; 命令来构建一个镜像&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; docker build -t runoob/centos:6.7 .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Sending build context to Docker daemon 17.92 kB
Step 1 : FROM centos:6.7
 ---&amp;amp;gt; d95b5ca17cc3
Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;
 ---&amp;amp;gt; Using cache
 ---&amp;amp;gt; 0c92299c6f03
Step 3 : RUN /bin/echo 'root:123456' |chpasswd
 ---&amp;amp;gt; Using cache
 ---&amp;amp;gt; 0397ce2fbd0a
Step 4 : RUN useradd runoob
......
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;-t&lt;/strong&gt; ：指定要创建的目标镜像名&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;.&lt;/strong&gt; ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;查看端口的绑定情况&quot;&gt;查看端口的绑定情况&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker port &lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;运行容器&quot;&gt;运行容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker run -itd --name ubuntu-test ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;exec-命令进入-ubuntu-容器&quot;&gt;exec 命令进入 ubuntu 容器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker exec -it ubuntu-test /bin/bas
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;运行交互式的容器&quot;&gt;运行交互式的容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker run -i -t docker_image /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;-t&lt;/code&gt;在新容器内指定一个伪终端或终端&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-i&lt;/code&gt;允许你对容器内的标准输入 (&lt;code&gt;STDIN&lt;/code&gt;) 进行交互&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;docker-ps&quot;&gt;docker ps&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;CONTAINER ID&lt;/strong&gt;:容器 ID&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IMAGE:&lt;/strong&gt; 使用的镜像&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;COMMAND:&lt;/strong&gt; 启动容器时运行的命令&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CREATED:&lt;/strong&gt; 容器的创建时间&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;STATUS:&lt;/strong&gt; 容器状态
    &lt;ol&gt;
      &lt;li&gt;created（已创建）&lt;/li&gt;
      &lt;li&gt;restarting（重启中）&lt;/li&gt;
      &lt;li&gt;running（运行中）&lt;/li&gt;
      &lt;li&gt;removing（迁移中）&lt;/li&gt;
      &lt;li&gt;paused（暂停）&lt;/li&gt;
      &lt;li&gt;exited（停止）&lt;/li&gt;
      &lt;li&gt;dead（死亡）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PORTS:&lt;/strong&gt; 容器的端口信息和使用的连接类型（tcp\udp）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NAMES:&lt;/strong&gt; 自动分配的容器名称&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;停止容器&quot;&gt;停止容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker stop CONTAINER ID
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;重启容器&quot;&gt;重启容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; docker restart CONTAINER ID
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;进入容器&quot;&gt;进入容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在使用 &lt;strong&gt;-d&lt;/strong&gt; 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker attach  CONTAINER ID
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker exec -it CONTAINER ID /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推荐使用 &lt;code&gt;docker exec&lt;/code&gt; 命令，因为此退出容器终端，不会导致容器的停止。&lt;/p&gt;

&lt;p&gt;更多参数说明请使用 &lt;code&gt;docker exec --help&lt;/code&gt; 命令查看&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;导出容器&quot;&gt;&lt;strong&gt;导出容器&lt;/strong&gt;&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker export  CONTAINER ID &amp;gt; dockername.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;导入容器快照&quot;&gt;&lt;strong&gt;导入容器快照&lt;/strong&gt;&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cat docker/ubuntu.tar | docker import - test/ubuntu:v1
也可以通过指定 URL 或者某个目录来导入
docker import http://example.com/exampleimage.tgz example/imagerepo
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;删除容器&quot;&gt;删除容器&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker rm -f CONTAINER ID
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;运行一个-web-应用flask&quot;&gt;运行一个 web 应用(Flask)&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker pull training/webapp  # 载入镜像
docker run -d -P training/webapp python app.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;-d:&lt;/strong&gt;让容器在后台运行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-P:&lt;/strong&gt;将容器内部使用的网络端口映射到我们使用的主机上&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;查看-web-应用程序日志&quot;&gt;查看 WEB 应用程序日志&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker logs -f  CONTAINER ID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;-f:&lt;/strong&gt; 让 &lt;strong&gt;docker logs&lt;/strong&gt; 像使用 &lt;strong&gt;tail -f&lt;/strong&gt; 一样来输出容器内部的标准输出&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;查看web应用程序容器的进程&quot;&gt;查看WEB应用程序容器的进程&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt; docker top&lt;/code&gt; 来查看容器内部运行的进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker inspect &lt;/code&gt;查看 Docker 的底层信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;停止-web-应用容器&quot;&gt;停止 WEB 应用容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker stop &lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;重启web应用容器&quot;&gt;重启WEB应用容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker start&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;移除web应用容器&quot;&gt;移除WEB应用容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt; docker rm&lt;/code&gt;&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">Docker</summary></entry><entry><title type="html">类加载</title><link href="http://localhost:4000/_posts/2020-05-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD/" rel="alternate" type="text/html" title="类加载" /><published>2020-05-13T00:00:00+08:00</published><updated>2020-05-13T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E7%B1%BB%E5%8A%A0%E8%BD%BD</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;类加载&quot;&gt;类加载&lt;/h1&gt;

&lt;p&gt;在java代码中，&lt;code&gt;类型&lt;/code&gt;的&lt;code&gt;加载&lt;/code&gt;，&lt;code&gt;连接&lt;/code&gt;，&lt;code&gt;初始化&lt;/code&gt;过程都是在程序运行期间完成的&lt;/p&gt;

&lt;h2 id=&quot;java结束生命周期&quot;&gt;java结束生命周期&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;执行System.exit()&lt;/li&gt;
  &lt;li&gt;程序正常结束&lt;/li&gt;
  &lt;li&gt;异常或错误&lt;/li&gt;
  &lt;li&gt;操作系统出错&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;类的加载连接初始化&quot;&gt;类的加载，连接，初始化&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;加载：查找并加载类的二进制数据，将class文件的二进制数据读入内存，将其放到运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象来封装类在方法区内的数据结构&lt;/li&gt;
  &lt;li&gt;连接：
    &lt;ol&gt;
      &lt;li&gt;验证：确保加载类的准确性&lt;/li&gt;
      &lt;li&gt;准备：为类的&lt;code&gt;静态变量&lt;/code&gt;分配内存，并初始胡为&lt;code&gt;默认值&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;解析：把类中的&lt;code&gt;符号引用&lt;/code&gt;转换为&lt;code&gt;直接引用&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;初始化:&lt;code&gt;为静态变量赋初始值&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;类的使用&quot;&gt;类的使用&lt;/h2&gt;

&lt;p&gt;主动使用&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建类的实例&lt;/li&gt;
  &lt;li&gt;访问类或者接口静态变量(getstatice)，或者对静态变量赋值(putstatice)&lt;/li&gt;
  &lt;li&gt;调用静态方法(invokestatic)&lt;/li&gt;
  &lt;li&gt;反射&lt;/li&gt;
  &lt;li&gt;初始化类的子类&lt;/li&gt;
  &lt;li&gt;java虚拟机启动时被标明的启动类&lt;/li&gt;
  &lt;li&gt;动态语言支持&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;被动使用&quot;&gt;被动使用&lt;/h2&gt;</content><author><name></name></author><category term="JVM" /><summary type="html">[toc]</summary></entry><entry><title type="html">置换密码</title><link href="http://localhost:4000/_posts/2020-05-13-%E7%BD%AE%E6%8D%A2%E5%AF%86%E7%A0%81/" rel="alternate" type="text/html" title="置换密码" /><published>2020-05-13T00:00:00+08:00</published><updated>2020-05-13T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E7%BD%AE%E6%8D%A2%E5%AF%86%E7%A0%81</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-13-%E7%BD%AE%E6%8D%A2%E5%AF%86%E7%A0%81/">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;置换密码&quot;&gt;置换密码&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例:设有限集X = {1,2,3,4,5,6,7,8},σ 为X 上的一个置换,满足σ(1)=2,σ(2)=5,σ(3)=3,σ(4)=6,σ(5)=1,σ(6)=8,σ(7)=4,σ(8)=7,其置换可表示为如下:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\sigma =
\left\{
 \begin{matrix}
1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\
2&amp;5&amp;3&amp;6&amp;1&amp;8&amp;4&amp;7
  \end{matrix}
  \right\}
  =(125)(3)(4687)
  =(125)(4687) %]]&gt;&lt;/script&gt;
其逆为：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\sigma^{-1}=
\left\{
 \begin{matrix}
1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\
2&amp;5&amp;3&amp;6&amp;1&amp;8&amp;4&amp;7
  \end{matrix}
  \right\}^{-1}
  =
  \left\{
  \begin{matrix}
  1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\
  5&amp;1&amp;3&amp;7&amp;2&amp;4&amp;8&amp;6
  \end{matrix}
  \right\}
  =
  (125)(3)(4786)=(152)(4786) %]]&gt;&lt;/script&gt;&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">置换密码</summary></entry><entry><title type="html">sql-server常用命令总结</title><link href="http://localhost:4000/_posts/2020-05-12-sql-server%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="sql-server常用命令总结" /><published>2020-05-12T00:00:00+08:00</published><updated>2020-05-12T00:00:00+08:00</updated><id>http://localhost:4000/_posts/sql-server%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-12-sql-server%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/">&lt;ol&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;部分语句模板&quot;&gt;部分语句模板&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建数据库&quot;&gt;创建数据库&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Create a new database called 'DatabaseName'
-- Connect to the 'master' database to run this snippet
USE master
GO
-- Create the new database if it does not exist already
IF NOT EXISTS (
    SELECT name
        FROM sys.databases
        WHERE name = N'DatabaseName'
)
CREATE DATABASE DatabaseName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建表&quot;&gt;创建表&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Create a new table called 'TableName' in schema 'SchemaName'
-- Drop the table if it already exists
IF OBJECT_ID('SchemaName.TableName', 'U') IS NOT NULL
DROP TABLE SchemaName.TableName
GO
-- Create the table in the specified schema
CREATE TABLE SchemaName.TableName
(
    TableNameId INT NOT NULL PRIMARY KEY, -- primary key column
    Column1 [NVARCHAR](50) NOT NULL,
    Column2 [NVARCHAR](50) NOT NULL
    -- specify more columns here
);
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建存储过程&quot;&gt;创建存储过程&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Create a new stored procedure called 'StoredProcedureName' in schema 'SchemaName'
-- Drop the stored procedure if it already exists
IF EXISTS (
SELECT *
    FROM INFORMATION_SCHEMA.ROUTINES
WHERE SPECIFIC_SCHEMA = N'SchemaName'
    AND SPECIFIC_NAME = N'StoredProcedureName'
)
DROP PROCEDURE SchemaName.StoredProcedureName
GO
-- Create the stored procedure in the specified schema
CREATE PROCEDURE SchemaName.StoredProcedureName
    @param1 /*parameter name*/ int /*datatype_for_param1*/ = 0, /*default_value_for_param1*/
    @param2 /*parameter name*/ int /*datatype_for_param1*/ = 0 /*default_value_for_param2*/
-- add more stored procedure parameters here
AS
    -- body of the stored procedure
    SELECT @param1, @param2
GO
-- example to execute the stored procedure we just created
EXECUTE SchemaName.StoredProcedureName 1 /*value_for_param1*/, 2 /*value_for_param2*/
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建视图&quot;&gt;创建视图&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Create a new view called 'ViewName' in schema 'SchemaName'
-- Drop the view if it already exists
IF EXISTS (
SELECT *
    FROM sys.views
    JOIN sys.schemas
    ON sys.views.schema_id = sys.schemas.schema_id
    WHERE sys.schemas.name = N'SchemaName'
    AND sys.views.name = N'ViewName'
)
DROP VIEW SchemaName.ViewName
GO
-- Create the view in the specified schema
CREATE VIEW SchemaName.ViewName
AS
    -- body of the view
    SELECT [Column1],
        [Column2],
        [Column3],
    FROM SchemaName.TableName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;删除数据库&quot;&gt;删除数据库&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Drop the database 'DatabaseName'
-- Connect to the 'master' database to run this snippet
USE master
GO
-- Uncomment the ALTER DATABASE statement below to set the database to SINGLE_USER mode if the drop database command fails because the database is in use.
-- ALTER DATABASE DatabaseName SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
-- Drop the database if it exists
IF EXISTS (
  SELECT name
   FROM sys.databases
   WHERE name = N'DatabaseName'
)
DROP DATABASE DatabaseName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;删除表&quot;&gt;删除表&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Drop the table 'TableName' in schema 'SchemaName'
IF EXISTS (
    SELECT *
        FROM sys.tables
        JOIN sys.schemas
            ON sys.tables.schema_id = sys.schemas.schema_id
    WHERE sys.schemas.name = N'SchemaName'
        AND sys.tables.name = N'TableName'
)
    DROP TABLE SchemaName.TableName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;删除字段&quot;&gt;删除字段&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Drop 'ColumnName' from table 'TableName' in schema 'SchemaName'
ALTER TABLE SchemaName.TableName
    DROP COLUMN ColumnName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;删除存储过程&quot;&gt;删除存储过程&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Drop the stored procedure called 'StoredProcedureName' in schema 'SchemaName'
IF EXISTS (
SELECT *
    FROM INFORMATION_SCHEMA.ROUTINES
WHERE SPECIFIC_SCHEMA = N'SchemaName'
    AND SPECIFIC_NAME = N'StoredProcedureName'
)
DROP PROCEDURE SchemaName.StoredProcedureName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;删除视图&quot;&gt;删除视图&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Drop the view 'ViewName' in schema 'SchemaName'
IF EXISTS (
    SELECT *
        FROM sys.views
        JOIN sys.schemas
            ON sys.views.schema_id = sys.schemas.schema_id
    WHERE sys.schemas.name = N'SchemaName'
        AND sys.views.name = N'ViewName'
)
    DROP VIEW SchemaName.ViewName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;GetHelp&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;/*
mssql getting started:
-----------------------------
1. Change language mode to SQL: Open a .sql file or press Ctrl+K M (Cmd+K M on Mac) and choose 'SQL'.
2. Connect to a database: Press F1 to show the command palette, type 'sqlcon' or 'sql' then click 'Connect'.
3. Use the T-SQL editor: Type T-SQL statements in the editor using T-SQL IntelliSense or type 'sql' to see a list of code snippets you can tweak &amp;amp; reuse.
4. Run T-SQL statements: Press F1 and type 'sqlex' or press Ctrl+Shift+e (Cmd+Shift+e on Mac) to execute all the T-SQL code in the editor.

Tip #1: Put GO on a line by itself to separate T-SQL batches.
Tip #2: Select some T-SQL text in the editor and press `Ctrl+Shift+e` (`Cmd+Shift+e` on Mac) to execute the selection
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;获取空白&quot;&gt;获取空白&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Get the space used by table TableName
SELECT TABL.name AS table_name,
INDX.name AS index_name,
SUM(PART.rows) AS rows_count,
SUM(ALOC.total_pages) AS total_pages,
SUM(ALOC.used_pages) AS used_pages,
SUM(ALOC.data_pages) AS data_pages,
(SUM(ALOC.total_pages)*8/1024) AS total_space_MB,
(SUM(ALOC.used_pages)*8/1024) AS used_space_MB,
(SUM(ALOC.data_pages)*8/1024) AS data_space_MB
FROM sys.tables AS TABL
INNER JOIN sys.indexes AS INDX
ON TABL.object_id = INDX.object_id
INNER JOIN sys.partitions AS PART
ON INDX.object_id = PART.object_id
AND INDX.index_id = PART.index_id
INNER JOIN sys.allocation_units AS ALOC
ON PART.partition_id = ALOC.container_id
WHERE TABL.name LIKE '%TableName%'
AND INDX.object_id &amp;gt; 255
AND INDX.index_id &amp;lt;= 1
GROUP BY TABL.name, 
INDX.object_id,
INDX.index_id,
INDX.name
ORDER BY Object_Name(INDX.object_id),
(SUM(ALOC.total_pages)*8/1024) DESC
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;插入表&quot;&gt;插入表&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Insert rows into table 'TableName'
INSERT INTO TableName
( -- columns to insert data into
 [Column1], [Column2], [Column3]
)
VALUES
( -- first row: values for the columns in the list above
 Column1_Value, Column2_Value, Column3_Value
),
( -- second row: values for the columns in the list above
 Column1_Value, Column2_Value, Column3_Value
)
-- add more rows here
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;查找表&quot;&gt;查找表&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- List columns in all tables whose name is like 'TableName'
SELECT 
    TableName = tbl.TABLE_SCHEMA + '.' + tbl.TABLE_NAME, 
    ColumnName = col.COLUMN_NAME, 
    ColumnDataType = col.DATA_TYPE
FROM INFORMATION_SCHEMA.TABLES tbl
INNER JOIN INFORMATION_SCHEMA.COLUMNS col 
    ON col.TABLE_NAME = tbl.TABLE_NAME
    AND col.TABLE_SCHEMA = tbl.TABLE_SCHEMA

WHERE tbl.TABLE_TYPE = 'BASE TABLE' and tbl.TABLE_NAME like '%TableName%'
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;列举数据库&quot;&gt;列举数据库&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Get a list of databases
SELECT name FROM sys.databases
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;列举当前数据库的表和视图&quot;&gt;列举当前数据库的表和视图&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Get a list of tables and views in the current database
SELECT table_catalog [database], table_schema [schema], table_name name, table_type type
FROM INFORMATION_SCHEMA.TABLES
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;查询&quot;&gt;查询&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Select rows from a Table or View 'TableOrViewName' in schema 'SchemaName'
SELECT * FROM SchemaName.TableOrViewName
WHERE 	/* add search conditions here */
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;更新表里面的数据&quot;&gt;更新表里面的数据&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Update rows in table 'TableName'
UPDATE TableName
SET
    [Colum1] = Colum1_Value,
    [Colum2] = Colum2_Value
    -- add more columns and values here
WHERE 	/* add search conditions here */
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;添加字段&quot;&gt;添加字段&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Add a new column 'NewColumnName' to table 'TableName' in schema 'SchemaName'
ALTER TABLE SchemaName.TableName
    ADD NewColumnName /*new_column_name*/ int /*new_column_datatype*/ NULL /*new_column_nullability*/
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;删除表里面的行数据&quot;&gt;删除表里面的行数据&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Add a new column 'NewColumnName' to table 'TableName' in schema 'SchemaName'
ALTER TABLE SchemaName.TableName
    ADD NewColumnName /*new_column_name*/ int /*new_column_datatype*/ NULL /*new_column_nullability*/
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;详细语句&quot;&gt;详细语句&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;SELECT [ALL|DISTINCT][TOP n[PERCENT]]&amp;lt;目标列表达式&amp;gt;[, … n]    [INTO &amp;lt;新表名&amp;gt;]
FROM &amp;lt;表名&amp;gt;|&amp;lt;视图名&amp;gt;[, … n]
[WHERE &amp;lt;条件表达式&amp;gt;]
[GROUP BY &amp;lt;列名l&amp;gt;
[HAVING &amp;lt;条件表达式&amp;gt;]]
[ORDER BY &amp;lt;列名2&amp;gt;[ASC|DESC]]；  
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;ALL：表示输出所有记录，包括重复记录。DISTINCT表示输出无重
复结果的记录。TOP n [PERCENT]指定返回查询结果的前n行数据，如
果指定PERCENT关键字，则返回查询结果的前n%行数据。&lt;/li&gt;
  &lt;li&gt;
    &lt;目标列表达式&gt;：描述结果集的列，它制定了结果集中要包含的列的名称。
&lt;/目标列表达式&gt;
  &lt;/li&gt;
  &lt;li&gt;INTO &lt;新表名&gt;：指定使用结果集来创建新表，&lt;新表名&gt;指定新表的名称。&lt;/新表名&gt;&lt;/新表名&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FROM &lt;表名&gt;|&lt;视图名&gt;：该子句指定从中查询到结果集数据的源表名或源视图名。&lt;/视图名&gt;&lt;/表名&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;WHERE &lt;条件表达式&gt;：该子句是一个筛选条件，它定义了源表或源视图中的行要满足SELECT语句的要求所必须达到的条件。&lt;/条件表达式&gt;&lt;/li&gt;
  &lt;li&gt;GROUP BY &lt;列名l&gt;：该子句将结果按&lt;列名l&gt;的值进行分组，该属性列值相等的元组为一个组，通常需要在每组上取聚集函数值。&lt;/列名l&gt;&lt;/列名l&gt;&lt;/li&gt;
  &lt;li&gt;HAVING &lt;条件表达式&gt;：该子句是应用于结果集的附加筛选，用来向使用GROUP BY子句的查询中添加数据过滤准则。&lt;/条件表达式&gt;&lt;/li&gt;
  &lt;li&gt;ORDER BY &lt;列名2&gt; [ASC|DESC]：该子句定义了结果集中行的排序顺序，升序使用ASC关键字，降序使用DESC关键字，默认为升序。&lt;/列名2&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;确定范围&quot;&gt;确定范围&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;语句BETWEEN…AND…和NOT BETWEEN…AND…可以用来查找属性值在（或不在）指定范围内的元组，其中BETWEEN后是范围的下限（即低值），AND后是范围的上限（即高值）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;确定集合&quot;&gt;确定集合&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;运算符IN可以用来查找属性值属于指定集合的元组
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;字符匹配&quot;&gt;字符匹配&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;[NOT] LIKE ’&amp;lt;匹配串&amp;gt;’[ESCAPE ’&amp;lt;换码字符&amp;gt;’]
其含义是查找指定的属性列值与&amp;lt;匹配串&amp;gt;相匹配的元组。&amp;lt;匹配串&amp;gt;可以是一个完整的字符串，也可以含有通配符%和_。其中：
 %（百分号）：代表任意长度（长度可以为0）的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。如acb，addgb，ab等都满足该匹配串。
 _（下划线）：代表任意单个字符或汉字。例如a_b表示以a开头，以b结尾的长度为3的任意字符串。如acb，a王b等都满足该匹配串。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;涉及空值的查询例&quot;&gt;涉及空值的查询例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;where **** IS NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;多重条件查询&quot;&gt;多重条件查询&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;可用逻辑运算符AND和OR来联结多个查询条件。AND的优先级高于OR，但可以用括号改变优先级
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;order-by&quot;&gt;ORDER BY&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;  用户可以用ORDER BY子句对查询结果按照一个或多个属性列的升序（ASC）或降序（DESC）排列，缺省值为升序
SELECT *** FROM **
WHERE ***
ORDER BY *** DESC(ASC)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;带having子句的分组查询&quot;&gt;带HAVING子句的分组查询&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;当完成数据结果的查询和统计后，可以使用HAVING关键字来对查询和统计的结果进行进一步的筛选。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;输出前n行&quot;&gt;输出前n行&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;可以利用TOP语句输出查询结果集的前面若干行元组。也可以利用INTO语句将查询结果集输出到一个新建的数据表中
SELECT TOP NUMBER ** FROM ***
WHERE ***
ORDER BY **
TOP后面跟数字表示前几行，后跟PERCENT　表示百分比
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;查询结果集输出到新建表中&quot;&gt;查询结果集输出到新建表中&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;INTO子句用于把查询结果存放到一个新建的表中。新建的表名由&amp;lt;新表名&amp;gt;给出，新表的列由SELECT子句中指定的列构成
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;集合并运算&quot;&gt;集合并运算&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;集合并运算是将来自不同查询的结果集合组合起来，形成一个具有综合信息的查询结果集（并集），UNION操作会自动将重复的元组去除。
SELECT ** FROM **
WHERE ***
UNION
SELECT ** FROM **
WHERE ***
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;集合交运算&quot;&gt;集合交运算&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;集合交运算是将来自不同查询结果集合中共有的元组组合起来，形成一个具有综合信息的查询结果集（交集）
SELECT ** FROM **
WHERE ***
INTERSECT
SELECT ** FROM **
WHERE ***
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;集合差运算&quot;&gt;集合差运算&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;集合差运算是将属于左查询结果集但不属于右查询结果集的元组组合起来，形成一个具有综合信息的查询结果集（差集）。
SELECT ** FROM **
WHERE ***
EXCEPT
SELECT ** FROM **
WHERE ***
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;连接查询-内连接&quot;&gt;连接查询-内连接&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;SELECT &amp;lt;目标列表达式&amp;gt; [, … n]
    FROM &amp;lt;表1&amp;gt; INNER JOIN &amp;lt;表2&amp;gt;
   ON &amp;lt;连接条件表达式&amp;gt;[, … n]
注意：连接条件表达式中的各连接字段类型必须是可比的，但名称不必相同。
 USE JXGL
GO
SELECT S.*,SC.*
FROM S INNER JOIN SC
ON S.SNO=SC.SNO 
GO 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;连接查询-外连接&quot;&gt;连接查询-外连接&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;(1) 左外连接
左外连接是对连接条件左边的表不加限制。当左边表元组与右边表元组不匹配时，与右边表的相应列值取NULL。语句格式如下：
    SELECT &amp;lt;目标列表达式&amp;gt;[, … n]
    FROM &amp;lt;表1&amp;gt;LEFT[OUTER]JOIN &amp;lt;表2&amp;gt;[, … n]
    ON &amp;lt;连接条件表达式&amp;gt;

  (2) 右外连接
右外连接是对连接条件右边的表不加限制。当右边表元组与左边表元组不匹配时，与左边表的相应列值取NULL。语句格式如下：
SELECT &amp;lt;目标列表达式&amp;gt;[, … n]
FROM &amp;lt;表1&amp;gt; RIGHT [OUTER] JOIN &amp;lt;表2&amp;gt;[, … n]
ON &amp;lt;连接条件表达式&amp;gt;

(3) 全外连接
全外连接是对连接条件的两个表都不加限制。当一边表元组与另一边表元组不匹配时，与另一边表的相应列值取NULL。语句格式如下：
SELECT &amp;lt;目标列表达式&amp;gt; [, … n]
FROM &amp;lt;表1&amp;gt; FULL [OUTER] JOIN &amp;lt;表2&amp;gt;[, … n]
ON &amp;lt;连接条件表达式&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;交叉连接&quot;&gt;交叉连接&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;交叉连接（cross join）也称为笛卡尔积，它是在没有连接条件下的两个表的连接，包含了所连接的两个表中所有元组的全部组合。
该连接方式在实际应用中是很少的。语句格式如下：
  SELECT &amp;lt;目标列表达式&amp;gt; [,1 …n]
  FROM &amp;lt;表1&amp;gt; CROSS JOIN &amp;lt;表2&amp;gt;[,1 …n]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;子查询&quot;&gt;子查询&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;子查询（subquery）是指在一个SELECT查询语句中包含另一个SELECT查询语句，即一个SELECT语句嵌入到另一个SELECT语句中。其中，外层的SELECT语句称为父查询或外查询，嵌入内层的SELECT语句称为子查询或内查询。因此，子查询也称为嵌套查询（nested query）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;无关子查询&quot;&gt;无关子查询&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;无关子查询的执行不依赖于父查询。它执行的过程是：首先执行子查询语句，得到的子查询结果集传递给父查询语句使用。无关子查询中对父查询没有任何引用
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;例  查询选修了“C3”号课程的学生的姓名和所在专业。
GO
SELECT SNAME,SDEPT 
FROM S
WHERE SNO IN
     (SELECT SNO
      FROM SC
      WHERE CNO='C3')
GO 
注意：子查询的SELECT语句不能使用ORDER BY子句，ORDER BY子句只能对最终查询结果排序。

例6.41 查询其它系中比计算机科学系（CS）某一学生年龄小的学生姓名和年龄。
    GO
    SELECT SNAME,AGE
    FROM S
    WHERE AGE&amp;lt;ANY(SELECT AGE
                     FROM S
                     WHERE SDEPT='CS')
              AND Sdept&amp;lt;&amp;gt;‘CS’      --注意这是父查询块中的条件
    GO
    SQL Server执行此查询时，首先处理子查询，找出CS系中所有学生的年龄，构成一个查询结果集合，如（21，23，22）。然后处理父查询，查找所有不是CS系且年龄小于21或23或22的学生。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;插入子查询结果&quot;&gt;插入子查询结果&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;子查询不仅可以嵌套在SELECT语句中，也可以嵌套在INSERT语句中，用以生成要插入的批量数据。
    插入子查询结果的INSERT语句的格式为：
     INSERT  INTO &amp;lt;表名&amp;gt;[(&amp;lt;列名&amp;gt;[, … n)]&amp;lt;子查询&amp;gt; 
例  对每一个系，求学生的平均年龄，并把结果存入数据库。首先在数据库中建立一个新表，其中一列存放系名，另一列存放相应的学生平均年龄。
    USE JXGL
    GO
    CREATE TABLE DEPT_AGE( SDEPT CHAR(15), AVG_AGE REAL)
    GO
    然后对S表按系分组求平均年龄，再把系名和平均年龄存入新表中。
    USE JXGL
    GO
    INSERT  INTO DEPT_AGE(SDEPT,AVG_AGE)
    SELECT SDEPT,AVG(AGE)
    FROM S
    GROUP BY SDEPT
    GO
  
     (2) 带子查询的删除语句
子查询也可以嵌套在DELETE语句中，用以构造执行删除操作的条件。
例6.45 删除计算机科学系（CS）所有学生的选课记录。
  USE JXGL
  GO
  DELETE
  FROM SC
  WHERE 'CS'=
      (SELECT SDEPT 
        FROM S
       WHERE S.SNO=SC.SNO)
  GO
                        
    (3) 带子查询的修改语句
子查询也可以嵌套在UPDATE语句中，用以构造修改的条件。
例  将计算机科学系（CS）全体学生的成绩提高5%。 
    USE JXGL
    GO
    UPDATE SC
    SET GRADE=GRADE+GRADE*0.05
    WHERE 'CS'=
       (SELECT SDEPT
        FROM S
        WHERE S.SNO=SC.SNO)
     GO   
注意：对某个基本表中数据的增、删、改操作有可能会破坏参照完整性。 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;游标&quot;&gt;游标&lt;/h2&gt;

&lt;p&gt;声明游标
和使用其它类型变量一样，使用一个游标之前，必须先声明它。
    DECLARE CURSOR&lt;游标名&gt;
    [INSENSITIVE] [SCROLL] CURSOR
    FOR &lt;SELECT-语句&gt;
    [FOR READ ONLY|UPDATE[OF &lt;列名&gt;[, … n]]]
INSENSITIVE：定义的游标所选出来的元组存放在一个临时表中（建立在tempdb数据库中），对该游标的读取操作都有临时表来应答。
 SCROLL：指定游标使用的读取选项，默认时为NEXT，其取值如下表所示。&lt;/列名&gt;&lt;/SELECT-语句&gt;&lt;/游标名&gt;&lt;/p&gt;

&lt;p&gt;SCROLL的取值&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;SCROLL&lt;/strong&gt;选项&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;含 义&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;FIRST&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;读取游标中的第一行数据。&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;LAST&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;读取游标中的最后一行数据。&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;PRIOR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;读取游标当前位置的上一行数据。&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;NEXT&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;读取游标当前位置的下一行数据。&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;RELATIVE n&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;读取游标当前位置之前或之后的第&lt;/strong&gt;n行数据（n为正向前，为负向后）。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;ABSULUTE n&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;读取游标中的第&lt;/strong&gt;n行数据。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;READ ONLY：表示定义的游标为只读游标，表明不允许使用UPDATE、DELETE语句更新游标内的数据。默认状态下游标允许更新。
UPDATE[OF&lt;列名&gt;[, … n]]：指定游标内可以更新的列，如果没有指定要更新的列，则表明所有列都允许更新&lt;/列名&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;例  声明一个名为S_Cursor的游标，用以读取计算机科学系（CS）的所有学生的信息。
USE JXGL
GO
DECLARE S_Cursor CURSOR 
FOR SELECT *
         FROM S
         WHERE SDEPT='CS'
    GO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开游标
声明一个游标后，还必须使用OPEN语句打开游标，才能对其进行访问。语句格式如下：
    OPEN [GLOBAL] &lt;游标名&gt;|&lt;游标变量名&gt;
参数说明如下：
GLOBAL：指定游标为全局游标。&lt;/游标变量名&gt;&lt;/游标名&gt;&lt;/p&gt;
&lt;游标名&gt;：已声明的游标名称。如果一个全局游标与一个局部游标同名，则要使用GLOBAL表明其全局游标。
 &lt;游标变量名&gt;：游标变量的名称，该名称可以引用一个游标

当执行打开游标的语句时，服务器将执行声明游标时使用的SELECT语句。如果声明游标时使用了INSENSITIVE选项，则服务器会在tempdb中建立一个临时表，存放游标将要进行操作的结果集的副本。
利用OPEN语句打开游标后，游标位于查询结果集的第一个行。同时也可以使用全局变量@@cursor_rows获得最后打开的游标中符合条件的行数。

```mssql
例  打开例6.47所声明的游标。
    GO
    OPEN S_Cursor
    GO
```

读取游标
在打开游标后，就可以利用FETCH语句从查询结果集中读取数据。使用FETCH语句一次可以读取一条记录，具体语句格式如下：
FETCH [[NEXT|PRIOR|FIRST|LAST
|ABSOLUTE n|@nvar
|RELATIVE n|@nvar]
FROM]
    [GLOBAL]&lt;游标名&gt;|&lt;游标变量名&gt;
    [INTO @变量名[, … n]]
NEXT：返回结果集中当前行的下一行，并将当前行向后移一行。 
PRIOR：读取紧临当前行的前面一行，并将当前行向前移一行。

FIRST：读取结果集中的第一行并将其设为当前行。
LAST：读取结果集中的最后一行并将其设为当前行。
ABSOLUTE n|@nvar：如果n或@nvar为正数，读取从结果集头部开始的第n行，并将返回的行变为新的当前行；如果n或@nvar为负数，读取从结果集尾部之前的第n行，并将返回的行变为新的当前行；如果n或@nvar为0，则没有行返回。
RELATIVE n | @nvar：如果n或@nvar为正数，则读取当前行之后的第n行，并将返回的行变为新的当前行；如果n或@nvar为负数，则读取当前行之前的第n行，并将返回的行变为新的当前行；如果n或@nvar为0，则读取当前行。
GLOBAL：指定游标为全局游标。
INTO @变量名[, … n]：允许读取的数据存放在多个变量中。在变量行中的每个变量必须与结果集中相应的属性列对应（顺序、数据类型等）

 @@FETCH_STATUS全局变量返回上次执行FETCH命令的状态。返回值如下：
0：表示 FETCH 语句成功。
-1：表示FETCH 语句失败或此行不在结果集中。
-2：表示被读取的行不存在。

```mssql
例 从例6.47所声明的游标中读取数据。
    GO
    FETCH NEXT FROM S_Cursor
    GO

```

关闭游标
在处理完结果集中数据之后，必须关闭游标来释放结果集。可以使用CLOSE语句来关闭游标，但此语句不释放与游标有关的一切资源。语句格式如下：
CLOSE[GLOBAL]&lt;游标名&gt;|&lt;游标变量名&gt;
其中各参数意义与打开命令一致。

```mssql
例  关闭例6.47所声明的游标。
     GO
     CLOSE S_Cursor
     GO
```

释放游标
游标使用不再需要之后，要释放游标，以获取与游标有关的一切资源。语句格式如下：
DEALLOCATE[GLOBAL]&lt;游标名&gt;|&lt;游标变量名&gt;
其中各参数意义与打开命令一致。

```mssql
例  释放例6.47所声明的游标。
     GO
     DEALLOCATE S_Cursor
     GO
```

## 创建视图

```mssql
语句格式为：
     CREATE VIEW &lt;视图名&gt;[(&lt;列名&gt;[, … n ])] 
     AS 
      &lt;SELECT查询子句&gt; 
     [WITH CHECK OPTION] 
```

```mssql
例7.2 建立数学系（MA）学生的视图V_MA，并要求进行修改和插入操作时仍需保证该视图只有数学系的学生。 
USE JXGL
GO
CREATE VIEW V_MA
AS
SELECT SNO,SNAME,AGE
FROM S
WHERE SDEPT='MA'
WITH CHECK OPTION
GO    
由于在定义V_MA视图时加上了WITH CHECK OPTION子句，以后对该视图进行插入、修改和删除操作时，RDBMS会验证条件SDEPT=’MA’。
```

## 修改视图

```mssql
T-SQL提供了ALTER VIEW语句修改视图，语句格式如下：
     ALTER VIEW &lt;视图名&gt;[(&lt;列名&gt;[, … n ])] 
     AS 
     &lt;SELECT查询子句&gt; 
     [WITH CHECK OPTION]
```

```mssql
例7.5 修改例7.2中视图V_MA，并要求该视图只查询数学系（MA）的男学生。 
    USE JXGL
    GO
    ALTER VIEW V_MA
    AS
    SELECT SNO,SNAME,AGE
    FROM S
    WHERE SDEPT='MA' AND SEX='M'
    WITH CHECK OPTION
    GO
```

## 删除视图

DROP VIEW &lt;视图名&gt;
&lt;/视图名&gt;&lt;/SELECT查询子句&gt;&lt;/列名&gt;&lt;/视图名&gt;&lt;/SELECT查询子句&gt;&lt;/列名&gt;&lt;/视图名&gt;&lt;/游标变量名&gt;&lt;/游标名&gt;&lt;/游标变量名&gt;&lt;/游标名&gt;&lt;/游标变量名&gt;&lt;/游标名&gt;&lt;/游标变量名&gt;&lt;/游标名&gt;</content><author><name></name></author><category term="sql" /><summary type="html">部分语句模板</summary></entry><entry><title type="html">删除文件原理</title><link href="http://localhost:4000/_posts/2020-05-12-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86/" rel="alternate" type="text/html" title="删除文件原理" /><published>2020-05-12T00:00:00+08:00</published><updated>2020-05-12T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-12-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86/">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux删除文件原理&quot;&gt;LINUX删除文件原理&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linux是通过link的数量来控制文件删除的，只有当一个文件不存在任何link的时候，这个文件才会被删除。一般来说，每个文件都有2个link计数器:&lt;code&gt;i_count&lt;/code&gt; 和&lt;code&gt;i_link&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;i_count&lt;/code&gt;的意义是当前文件使用者（或被调用）的数量,i_link 的意义是介质连接的数量（硬链接的数量）；可以理解为&lt;code&gt;i_count&lt;/code&gt;是内存引用计数器，i_link是磁盘的引用计数器。&lt;/p&gt;

&lt;p&gt;当一个文件被某一个进程引用时，对应&lt;code&gt;i_count&lt;/code&gt;数就会增加；当创建文件的硬链接的时候，对应&lt;code&gt;i_link&lt;/code&gt;数就会增加&lt;/p&gt;

&lt;p&gt;&lt;code&gt;**对于删除命令rm而言，实际就是减少磁盘引用计数i_link**。&lt;/code&gt;这里就会有一个问题，如果一个文件正在被某个进程调用，而用户却执行rm操作把文件删除了，那么会出现什么结果呢？当用户执行rm操作删除文件后，再执行ls或者其他文件管理命令，无法再找到这个文件了，但是调用这个删除的文件的进程却在继续正常执行，依然能够从文件中正确的读取及写入内容.&lt;/p&gt;

&lt;p&gt;这是因为rm操作只是将文件的i_link减少了，如果没其它的链接i_link就为0了；但由于该文件依然被进程引用，因此，此时文件对应的i_count并不为0，所以即使执行rm操作，但系统并没有真正删除这个文件，当只有i_link及i_count都为0的时候，这个文件才会真正被删除。也就是说，还需要解除该进程的对该文件的调用才行。&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">LINUX删除文件原理</summary></entry></feed>