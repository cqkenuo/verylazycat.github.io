<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-06-19T17:26:42+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lazycat</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
</subtitle><entry><title type="html">ARP安全</title><link href="http://localhost:4000/_posts/2020-06-15-ARP%E5%AE%89%E5%85%A8/" rel="alternate" type="text/html" title="ARP安全" /><published>2020-06-15T00:00:00+08:00</published><updated>2020-06-15T00:00:00+08:00</updated><id>http://localhost:4000/_posts/ARP%E5%AE%89%E5%85%A8</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-15-ARP%E5%AE%89%E5%85%A8/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;arp协议&quot;&gt;ARP协议&lt;/h1&gt;

&lt;p&gt;ARP协议（&lt;code&gt;address resolution protocol&lt;/code&gt;）&lt;code&gt;地址解析协议&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;IP&lt;/code&gt; &lt;code&gt;--&amp;gt;&amp;gt;&lt;/code&gt;　&lt;code&gt;MAC&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ARP协议的基本功能就是通过目标设备的IP地址，来查询目标设备的mac地址。&lt;/p&gt;

&lt;p&gt;在局域网的任意一台主机中，都有一个&lt;code&gt;ARP缓存表&lt;/code&gt;，里面保存本机已知的此局域网中各主机和路由器的IP地址和MAC地址的对照关系。ARP缓存表的&lt;code&gt;生命周期是有时限的&lt;/code&gt;（一般不超过20分钟）&lt;/p&gt;

&lt;h1 id=&quot;apr攻击发现&quot;&gt;APR攻击发现&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;上网明显变慢，或者突然掉线时&lt;/strong&gt;，我们可以用&lt;code&gt;arp -a&lt;/code&gt;命令来检查ARP表&lt;code&gt;arp -d&lt;/code&gt;删除ARP表&lt;/li&gt;
  &lt;li&gt;ARP防火墙类软件&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;攻击方式&quot;&gt;&lt;strong&gt;攻击方式&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;简单的诈骗攻击&quot;&gt;&lt;strong&gt;简单的诈骗攻击&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;这是对比多见的攻击，经过发送伪造的ARP包来诈骗路由和方针主机，让方针主机认为这是一个合法的主机，便完成了诈骗，这种诈骗多发生在同一网段内，因为路由不会把本网段的包向外转发，当然完成不一样网段的攻击也有办法，便要经过ICMP协议来告诉路由器从头挑选路由&lt;/p&gt;

&lt;h2 id=&quot;根据arp的dos&quot;&gt;&lt;strong&gt;根据ARP的DOS&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;D.O.S又称拒绝服务攻击，当大量的衔接请求被发送到一台主机时，因为主机的处理才能有限，不能为正常用户提供服务，便呈现拒绝服务。这个过程中假如运用ARP来躲藏自己，在被攻击主机的日志上就不会呈现真实的IP攻击，也不会影响到本机。&lt;/p&gt;

&lt;h2 id=&quot;mac-flooding&quot;&gt;&lt;strong&gt;MAC Flooding&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;这是一个对比风险的攻击，能够溢出交流机的ARP表，使全部网络不能正常通讯。&lt;/p&gt;

&lt;h1 id=&quot;arp攻击的防护&quot;&gt;&lt;strong&gt;arp攻击的防护&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;arp-高速缓存超时设置&quot;&gt;&lt;strong&gt;ARP 高速缓存超时设置&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在ARP高速缓存中的表项一般都要设置超时值，缩短这个这个超时值能够有用的避免ARP表的溢出。&lt;/p&gt;

&lt;h2 id=&quot;ipmac访问操控--推荐使用&quot;&gt;&lt;strong&gt;IP+MAC访问操控  —–推荐使用&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;单纯依托IP或MAC来树立信赖联系是不安全，抱负的安全联系树立在IP+MAC的根底上，这也是咱们校园网上网有必要绑定IP和MAC的因素之一&lt;/p&gt;

&lt;h2 id=&quot;静态arp缓存表&quot;&gt;&lt;strong&gt;静态ARP缓存表&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;每台主机都有一个暂时寄存IP-MAC的对应表ARP攻击就经过更改这个缓存来到达诈骗的意图，运用静态的ARP来绑定正确的MAC是一个有用的办法，在命令行下运用arp -a能够检查当时的ARP缓存表。&lt;/p&gt;

&lt;h2 id=&quot;自动查询&quot;&gt;&lt;strong&gt;自动查询&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在某个正常的时间，做一个IP和MAC对应的数据库，以后定时检查当时的IP和MAC对应联系是否正常，定时检查交流机的流量列表，检查丢包率。&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">滑动验证码黑产</title><link href="http://localhost:4000/_posts/2020-06-15-%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E9%BB%91%E4%BA%A7/" rel="alternate" type="text/html" title="滑动验证码黑产" /><published>2020-06-15T00:00:00+08:00</published><updated>2020-06-15T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E9%BB%91%E4%BA%A7</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-15-%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%E7%A0%81%E9%BB%91%E4%BA%A7/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;session参数重复校验漏洞&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;思路&quot;&gt;思路&lt;/h1&gt;

&lt;p&gt;由于每次拖动滑块后，会发送一个Request请求数据包到服务器，服务器会验证这个Request请求数据包里携带的位移参数，来判断是否是拖动滑块到了正确的缺口位置。而服务器接收的数据包有很多，除了你发送的，也还会有其他人发送的请求，所以需要一个session参数来作为标识。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先，触发滑动验证机制&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着，滑动滑块到正确缺口位置，然后抓包。分析数据包，寻找session参数。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;每次滑动正确位移后，使用Brupsuite或者其它中间人代理工具，抓包提取数据包里的session参数，保存到本地&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;因为服务器后端默认隐含对我们本地保存的session参数有一个有效时间和有效次数，所以我们不需要再去滑动验证码，直接在session的有效期内发送Request请求数据包到服务器即可验证成功！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后黑产在实际批量注册，薅羊毛或刷赞过程中，遇到触发的滑动验证码机制，只要session在有效期内，只需使用python读取本地的txt内容，调用requests库发送请求数据包，即可绕过滑动验证码&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">TCP&amp;amp;UDP区别</title><link href="http://localhost:4000/_posts/2020-06-13-TCP&UDP%E5%8C%BA%E5%88%AB/" rel="alternate" type="text/html" title="TCP&amp;UDP区别" /><published>2020-06-13T00:00:00+08:00</published><updated>2020-06-13T00:00:00+08:00</updated><id>http://localhost:4000/_posts/TCP&amp;UDP%E5%8C%BA%E5%88%AB</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-13-TCP&amp;UDP%E5%8C%BA%E5%88%AB/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;tcp协议与udp协议的区别&quot;&gt;&lt;strong&gt;TCP协议与UDP协议的区别&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个， 之所以命名为TCP/IP协议，因为TCP、IP协议是两个很重要的协议，就用他两命名了。&lt;/p&gt;

&lt;p&gt;TCP/IP协议集包括应用层,传输层，网络层，网络访问层。&lt;/p&gt;

&lt;h2 id=&quot;应用层包括&quot;&gt;应用层包括&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;超文本传输协议（HTTP）:万维网的基本协议；&lt;/li&gt;
  &lt;li&gt;文件传输（TFTP简单文件传输协议）；&lt;/li&gt;
  &lt;li&gt;远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；&lt;/li&gt;
  &lt;li&gt;网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；&lt;/li&gt;
  &lt;li&gt;域名系统（DNS），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;网络层包括&quot;&gt;网络层包括&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Internet协议（IP）；&lt;/li&gt;
  &lt;li&gt;Internet控制信息协议（ICMP）；&lt;/li&gt;
  &lt;li&gt;地址解析协议（ARP）；&lt;/li&gt;
  &lt;li&gt;反向地址解析协议（RARP)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;网络访问层&quot;&gt;网络访问层&lt;/h2&gt;

&lt;p&gt;网络访问层又称作主机到网络层（host-to-network），网络访问层的功能包括IP地址与物理地址硬件的映射，  以及将IP封装成帧.基于不同硬件类型的网络接口，网络访问层定义了和物理介质的连接.&lt;/p&gt;

&lt;h1 id=&quot;tcp协议和udp协议的区别&quot;&gt;&lt;strong&gt;TCP协议和UDP协议的区别&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;TCP（Transmission Control  Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。  一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂， 只简单的描述下这三次对话的简单过程:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；&lt;/li&gt;
  &lt;li&gt;主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包 ：“可以，你什么时候发？”，这是第二次对话；&lt;/li&gt;
  &lt;li&gt;主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”， 这是第三次对话。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三次“对话”的目的是使数据包的发送和接收同步， 经过三次“对话”之后，主机A才向主机B正式发送数据。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/_posts/2020-06-12-TCP三次握手四次挥手.md&quot;&gt;详细参考&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;名词解释&quot;&gt;名词解释&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。  比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。&lt;/li&gt;
  &lt;li&gt;SYN 同步序列号，TCP建立连接时将这个位置1。&lt;/li&gt;
  &lt;li&gt;FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcp的包头结构&quot;&gt;TCP的包头结构&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;源端口 16位；&lt;/li&gt;
  &lt;li&gt;目标端口 16位；&lt;/li&gt;
  &lt;li&gt;序列号 32位；&lt;/li&gt;
  &lt;li&gt;回应序号 32位；&lt;/li&gt;
  &lt;li&gt;TCP头长度 4位；&lt;/li&gt;
  &lt;li&gt;reserved 6位；&lt;/li&gt;
  &lt;li&gt;控制代码 6位；&lt;/li&gt;
  &lt;li&gt;窗口大小 16位；&lt;/li&gt;
  &lt;li&gt;偏移量 16位；&lt;/li&gt;
  &lt;li&gt;校验和 16位；&lt;/li&gt;
  &lt;li&gt;选项 32位(可选)；&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;这样我们得出了TCP包头的最小长度，为20字节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;udpuser-data-protocol用户数据报协议&quot;&gt;&lt;strong&gt;UDP（User Data Protocol，用户数据报协议）&lt;/strong&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，  当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、  计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。&lt;/li&gt;
  &lt;li&gt;由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。&lt;/li&gt;
  &lt;li&gt;UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。&lt;/li&gt;
  &lt;li&gt;吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。&lt;/li&gt;
  &lt;li&gt;UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。&lt;/li&gt;
  &lt;li&gt;UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常， 其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ping命令&lt;/strong&gt;是用来探测主机到主机之间是否可通信，如果不能&lt;strong&gt;ping&lt;/strong&gt;到某台主机，表明不能和这台主机建立连接。&lt;strong&gt;ping命令&lt;/strong&gt;是使用 IP 和网络控制信息协议 (ICMP)，因而没有涉及到任何传输协议(UDP/TCP) 和应用程序。它发送icmp回送请求消息给目的主机&lt;/p&gt;

&lt;p&gt;ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。&lt;/p&gt;

&lt;h2 id=&quot;udp的包头结构&quot;&gt;&lt;strong&gt;UDP的包头结构&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;源端口 16位&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目的端口 16位&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;长度 16位&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;校验和 16位&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;具体编程时的区别&quot;&gt;具体编程时的区别&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;socket()的参数不同&lt;/li&gt;
  &lt;li&gt;UDP Server不需要调用listen和accept&lt;/li&gt;
  &lt;li&gt;UDP收发数据用sendto/recvfrom函数&lt;/li&gt;
  &lt;li&gt;TCP：地址信息在connect/accept时确定&lt;/li&gt;
  &lt;li&gt;UDP：在sendto/recvfrom函数中每次均 需指定地址信息&lt;/li&gt;
  &lt;li&gt;UDP：shutdown函数无效&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;小结&quot;&gt;小结&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;基于连接与无连接；&lt;/li&gt;
  &lt;li&gt;对系统资源的要求（TCP较多，UDP少）；&lt;/li&gt;
  &lt;li&gt;UDP程序结构较简单；&lt;/li&gt;
  &lt;li&gt;流模式与数据报模式 ；&lt;/li&gt;
  &lt;li&gt;TCP保证数据正确性，UDP可能丢包；&lt;/li&gt;
  &lt;li&gt;TCP保证数据顺序，UDP不保证&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">TCP三次握手四次挥手</title><link href="http://localhost:4000/_posts/2020-06-12-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" rel="alternate" type="text/html" title="TCP三次握手四次挥手" /><published>2020-06-12T00:00:00+08:00</published><updated>2020-06-12T00:00:00+08:00</updated><id>http://localhost:4000/_posts/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-12-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;tcp-三次握手&quot;&gt;&lt;strong&gt;TCP 三次握手&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;TCP 三次握手就好比两个人在街上隔着50米看见了对方，但是因为雾霾等原因不能100%确认，所以要通过招手的方式相互确定对方是否认识自己&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/tcp0.webp&quot; alt=&quot;tcp0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;张三首先向李四招手(&lt;strong&gt;syn&lt;/strong&gt;)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(&lt;strong&gt;ack&lt;/strong&gt;)。张三看到李四微笑后确认了李四成功辨认出了自己(进入&lt;strong&gt;estalished&lt;/strong&gt;状态)。&lt;/p&gt;

&lt;p&gt;但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手(&lt;strong&gt;syn&lt;/strong&gt;)，张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑(&lt;strong&gt;ack&lt;/strong&gt;)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入&lt;strong&gt;established&lt;/strong&gt;状态)。&lt;/p&gt;

&lt;p&gt;于是两人加快步伐，走到了一起，相互拥抱。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/tec1.webp&quot; alt=&quot;tec1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们看到这个过程中一共是四个动作，张三招手–李四点头微笑–李四招手–张三点头微笑。其中李四连续进行了2个动作，先是点头微笑(回复对方)，然后再次招手(寻求确认)，实际上可以将这两个动作合一，招手的同时点头和微笑(&lt;strong&gt;syn+ack&lt;/strong&gt;)。于是四个动作就简化成了三个动作，张三招手–李四点头微笑并招手–张三点头微笑。这就是三次握手的本质，中间的一次动作是两个动作的合并。&lt;/p&gt;

&lt;p&gt;我们看到有两个中间状态，&lt;strong&gt;syn_sent&lt;/strong&gt;和&lt;strong&gt;syn_rcvd&lt;/strong&gt;，这两个状态叫着「半打开」状态，就是向对方招手了，但是还没来得及看到对方的点头微笑。&lt;strong&gt;syn_sent&lt;/strong&gt;是主动打开方的「半打开」状态，&lt;strong&gt;syn_rcvd&lt;/strong&gt;是被动打开方的「半打开」状态。客户端是主动打开方，服务器是被动打开方。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;syn_sent: syn package has been sent&lt;/li&gt;
  &lt;li&gt;syn_rcvd: syn package has been received&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;tcp-数据传输&quot;&gt;&lt;strong&gt;TCP 数据传输&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;TCP 数据传输就是两个人隔空对话，差了一点距离，所以需要对方反复确认听见了自己的话&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/tcp2.webp&quot; alt=&quot;tcp2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;张三喊了一句话(data)，李四听见了之后要向张三回复自己听见了(ack)。&lt;/p&gt;

&lt;p&gt;如果张三喊了一句，半天没听到李四回复，张三就认为自己的话被大风吹走了，李四没听见，所以需要重新喊话，这就是tcp重传。&lt;/p&gt;

&lt;p&gt;也有可能是李四听到了张三的话，但是李四向张三的回复被大风吹走了，以至于张三没听见李四的回复。张三并不能判断究竟是自己的话被大风吹走了还是李四的回复被大风吹走了，张三也不用管，重传一下就是。&lt;/p&gt;

&lt;p&gt;既然会重传，李四就有可能同一句话听见了两次，这就是「去重」。「重传」和「去重」工作操作系统的网络内核模块都已经帮我们处理好了，用户层是不用关心的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/tcp3.webp&quot; alt=&quot;tcp3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;张三可以向李四喊话，同样李四也可以向张三喊话，因为tcp链接是「双工的」，双方都可以主动发起数据传输。不过无论是哪方喊话，都需要收到对方的确认才能认为对方收到了自己的喊话。&lt;/p&gt;

&lt;p&gt;张三可能是个高射炮，一说连说了八句话，这时候李四可以不用一句一句回复，而是连续听了这八句话之后，一起向对方回复说前面你说的八句话我都听见了，这就是批量ack。但是张三也不能一次性说了太多话，李四的脑子短时间可能无法消化太多，两人之间需要有协商好的合适的发送和接受速率，这个就是「TCP窗口大小」。&lt;/p&gt;

&lt;p&gt;网络环境的数据交互同人类之间的对话还要复杂一些，它存在数据包乱序的现象。同一个来源发出来的不同数据包在「网际路由」上可能会走过不同的路径，最终达到同一个地方时，顺序就不一样了。操作系统的网络内核模块会负责对数据包进行排序，到用户层时顺序就已经完全一致了。&lt;/p&gt;

&lt;h2 id=&quot;tcp-四次挥手&quot;&gt;&lt;strong&gt;TCP 四次挥手&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;TCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，张三挥手(fin)——李四伤感地微笑(ack)——李四挥手(fin)——张三伤感地微笑(ack)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/tcp4.webp&quot; alt=&quot;tcp4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之所以中间的两个动作没有合并，是因为tcp存在「半关闭」状态，也就是单向关闭。张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。等待李四累了，也不再说话了，超张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/tcp5.webp&quot; alt=&quot;tcp5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面有一个非常特殊的状态&lt;code&gt;time_wait&lt;/code&gt;，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。&lt;/p&gt;

&lt;p&gt;它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续4分钟的&lt;code&gt;time_wait&lt;/code&gt;状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。&lt;/p&gt;

&lt;p&gt;它的作用是重传最后一个ack报文，确保对方可以收到。因为如果对方没有收到ack的话，会重传fin报文，处于time_wait状态的套接字会立即向对方重发ack报文。&lt;/p&gt;

&lt;p&gt;同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。&lt;/p&gt;

&lt;p&gt;4分钟就是2个MSL，每个MSL是2分钟。MSL就是&lt;code&gt;maximium segment lifetime&lt;/code&gt;——最长报文寿命。这个时间是由官方RFC协议规定的。至于为什么是2个MSL而不是1个MSL，我还没有看到一个非常满意的解释。&lt;/p&gt;

&lt;p&gt;四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从&lt;code&gt;fin_wait_1&lt;/code&gt;状态直接进入到&lt;code&gt;time_wait&lt;/code&gt;状态，跳过了&lt;code&gt;fin_wait_2&lt;/code&gt;状态。&lt;/p&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">大三上计划</title><link href="http://localhost:4000/_posts/2020-06-11-%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AE%A1%E5%88%92/" rel="alternate" type="text/html" title="大三上计划" /><published>2020-06-11T00:00:00+08:00</published><updated>2020-06-11T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AE%A1%E5%88%92</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-11-%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AE%A1%E5%88%92/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;学习&quot;&gt;学习&lt;/h1&gt;

&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;考研英语单词记忆&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;强化口语和听力&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;数学一轮复习&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;四级考试&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;专业&quot;&gt;专业&lt;/h1&gt;

&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; checked=&quot;checked&quot; /&gt;unix环境高级编程&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;自制简易操作系统&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;leetcode&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;c/c++/java深入学习&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category &quot; checked=&quot;checked&quot; /&gt;省或国奖&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;写个c++项目&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;写一个java前后端分离项目&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;其他&quot;&gt;其他&lt;/h1&gt;

&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;深度学习模型分享&lt;/p&gt;</content><author><name></name></author><category term="生活" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程-进程间通信</title><link href="http://localhost:4000/_posts/2020-06-09-linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="alternate" type="text/html" title="linux编程-进程间通信" /><published>2020-06-09T00:00:00+08:00</published><updated>2020-06-09T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-09-linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;管道&quot;&gt;管道&lt;/h1&gt;

&lt;h2 id=&quot;内核提供单工自同步机制&quot;&gt;内核提供,单工,自同步机制&lt;/h2&gt;

&lt;h2 id=&quot;匿名管道&quot;&gt;匿名管道&lt;/h2&gt;

&lt;p&gt;pipe&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;create pipe&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int pipe(int pipefd[2]);
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include &amp;lt;fcntl.h&amp;gt;              /* Obtain O_* constant definitions */
#include &amp;lt;unistd.h&amp;gt;
int pipe2(int pipefd[2], int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;命名管道&quot;&gt;命名管道&lt;/h2&gt;

&lt;h1 id=&quot;xsi&quot;&gt;XSI&lt;/h1&gt;

&lt;p&gt;IPC -&amp;gt; Internet Process Communication&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;ipcs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;key:ftok&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;convert  a pathname and a project identifier to a System V IPC key&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
key_t ftok(const char *pathname, int proj_id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Message Queues&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;msgget&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;get a System V message queue identifier&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/msg.h&amp;gt;
int msgget(key_t key, int msgflg);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;msgop&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;System V message queue operations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/msg.h&amp;gt;
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
int msgflg);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;msgctl&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;System V message control operations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/msg.h&amp;gt;
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Semaphore Arrays&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;semget&lt;/li&gt;
  &lt;li&gt;semop&lt;/li&gt;
  &lt;li&gt;semctl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Shared Memory&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;shmget&lt;/li&gt;
  &lt;li&gt;shmop&lt;/li&gt;
  &lt;li&gt;shmctl&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;网络套接字socket&quot;&gt;网络套接字socket&lt;/h1&gt;

&lt;h2 id=&quot;字节序问题&quot;&gt;字节序问题&lt;/h2&gt;

&lt;p&gt;大端:低地址放高字节&lt;/p&gt;

&lt;p&gt;小端:低地址放低字节&lt;/p&gt;

&lt;h2 id=&quot;报式套接字&quot;&gt;报式套接字&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;socket&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;create an endpoint for communication&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */
#include &amp;lt;sys/socket.h&amp;gt;
int socket(int domain, int type, int protocol);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;bind&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;bind a name to a socket&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */
#include &amp;lt;sys/socket.h&amp;gt;
int bind(int sockfd, const struct sockaddr *addr,
socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;sendto&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;send a message on a socket&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;rcvfrom&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;inet_pton&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;convert IPv4 and IPv6 addresses from text to binary form&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;arpa/inet.h&amp;gt;
int inet_pton(int af, const char *src, void *dst);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;inet_ntop&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;convert IPv4 and IPv6 addresses from binary to text form&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;arpa/inet.h&amp;gt;
const char *inet_ntop(int af, const void *src,
char *dst, socklen_t size);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;getsockopt&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;setsockopt&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;get and set options on sockets&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */
#include &amp;lt;sys/socket.h&amp;gt;
int getsockopt(int sockfd, int level, int optname,
void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname,
const void *optval, socklen_t optlen);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;多点通讯&quot;&gt;多点通讯&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;广播
    &lt;ul&gt;
      &lt;li&gt;全网广播&lt;/li&gt;
      &lt;li&gt;子网广播&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;多播/组播&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;流式套接字&quot;&gt;流式套接字&lt;/h2&gt;

&lt;h1 id=&quot;例子&quot;&gt;例子&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;服务端&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/*
 * @Author: verylazycat 
 * @Date: 2020-06-18 14:57:07 
 * @Last Modified by: verylazycat
 * @Last Modified time: 2020-06-18 21:42:23
 */
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt; 
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include&amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#define PORT  6666
#define MAXDATASIZE 2048

int main(int argc, char const *argv[])
{
    int listenfd;
    listenfd = socket(AF_INET,SOCK_STREAM,0);
    if (listenfd &amp;lt; 0)
    {
        perror(&quot;socket&quot;);
        exit(EXIT_FAILURE);
    }
     struct sockaddr_in serverAddr;
     bzero(&amp;amp;serverAddr,sizeof(serverAddr));
     serverAddr.sin_family = AF_INET;
     serverAddr.sin_port = htons(PORT);
     serverAddr.sin_addr.s_addr = INADDR_ANY;
     bind(listenfd,(struct sockaddr*)&amp;amp;serverAddr,sizeof(serverAddr));
     listen(listenfd,10);
     struct sockaddr_in peerAddr;
    socklen_t peer_len  = sizeof(peerAddr);
    int connfd;
    while (1)
    {
        connfd = accept(listenfd,(struct sockaddr*)&amp;amp;peerAddr,&amp;amp;peer_len);
        if (connfd &amp;lt; 0)
        {
            perror(&quot;accept&quot;);
            exit(EXIT_FAILURE);
        }
        printf(&quot;-----------------连接成功--------------\n&quot;);
        char buf[MAXDATASIZE];
        while (1)
        {
            memset(buf,'\0',MAXDATASIZE/sizeof(char));
            int recv_length = recv(connfd,buf,MAXDATASIZE/sizeof(char),0);
            if(recv_length == 0)
            {
                printf(&quot;client has closed\n&quot;);
                break;
            }
            printf(&quot;client say:&quot;);
            fputs(buf,stdout);
            memset(buf,'\0',MAXDATASIZE/sizeof(char));
            printf(&quot;input:&quot;);
            fgets(buf,sizeof(buf),stdin);
            send(connfd,buf,recv_length,0);
        }
        close(connfd);
        close(listenfd);
        return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;客服端&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#define PORT  6666
#define MAXDATASIZE 2048
int main(int argc, char const *argv[])
{
    if(argc != 2)
    {
        printf(&quot;usage:%s+IP&quot;,argv[0]);
        exit(EXIT_FAILURE);
    }    
    int sockfd;
    sockfd = socket(AF_INET,SOCK_STREAM,0);
    const char *server_ip = argv[1];
    struct sockaddr_in serverAddr;
    bzero(&amp;amp;serverAddr,sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(PORT);
    inet_pton(AF_INET,server_ip,&amp;amp;serverAddr.sin_addr);
    connect(sockfd,(struct sockaddr*)&amp;amp;serverAddr,sizeof(serverAddr));
    printf(&quot;--------------服务器连接成功-------------\n&quot;);
    char buf[MAXDATASIZE];
    printf(&quot;input:&quot;);
    while (fgets(buf,sizeof(buf),stdin)!=NULL &amp;amp;&amp;amp; (strcmp(buf,&quot;quit&quot;)))
    {
        send(sockfd,buf,sizeof(buf),0);
        memset(buf,0,sizeof(buf));
        recv(sockfd,buf,sizeof(buf),0);
        printf(&quot;server say:&quot;);
        fputs(buf,stdout);
        memset(buf,0,sizeof(buf));
        printf(&quot;input:&quot;);
    }
    printf(&quot;client will be closed, see you next time.\n&quot;);
    close(sockfd);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">虚拟内存</title><link href="http://localhost:4000/_posts/2020-06-08-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" rel="alternate" type="text/html" title="虚拟内存" /><published>2020-06-08T00:00:00+08:00</published><updated>2020-06-08T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-08-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;概念&quot;&gt;概念&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;现代所有用于一般应用的操作系统都对普通的应用程序使用虚拟内存技术，老一些的操作系统，如DOS和1980年代的Windows，或者那些1960年代的大型机，一般都没有虚拟内存的功能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在很久以前,程序指令所访问的内存地址就是物理内存地址,也就是不得不把程序的全部装进内存当中，然后运行。&lt;/p&gt;

&lt;p&gt;物理内存其实就是插在计算机主板内存槽上的实际物理内存，CPU可以直接进行寻址。物理内存的容量是固定的，但是寻址空间却取决于cpu地址线条数，如32位机，则寻址空间为2^32 = 4G，所以最大支只持4G的寻址空间，即使插了8G的内存条也只能使用4G内存;&lt;/p&gt;

&lt;h1 id=&quot;直接使用物理内存产生的问题&quot;&gt;直接使用物理内存产生的问题&lt;/h1&gt;

&lt;p&gt;在这种直接使用物理内存的状态下就会产生一些问题:&lt;/p&gt;

&lt;h2 id=&quot;内存空间利用率的问题&quot;&gt;内存空间利用率的问题&lt;/h2&gt;

&lt;p&gt;各个进程对内存的使用会导致内存碎片化，当要用malloc分配一块很大的内存空间时，可能会出现虽然有足够多的空闲物理内存，却没有足够大的连续空闲内存这种情况，东一块西一块的内存碎片就被浪费掉了&lt;/p&gt;

&lt;h2 id=&quot;读写内存的安全性问题&quot;&gt;读写内存的安全性问题&lt;/h2&gt;

&lt;p&gt;物理内存本身是不限制访问的，任何地址都可以读写，而现代操作系统需要实现不同的页面具有不同的访问权限，例如只读的数据等等&lt;/p&gt;

&lt;h2 id=&quot;进程间的安全问题&quot;&gt;进程间的安全问题&lt;/h2&gt;

&lt;p&gt;各个进程之间没有独立的地址空间，一个进程由于执行错误指令或是恶意代码都可以直接修改其它进程的数据，甚至修改内核地址空间的数据，这是操作系统所不愿看到的&lt;/p&gt;

&lt;h2 id=&quot;内存读写的效率问题&quot;&gt;内存读写的效率问题&lt;/h2&gt;

&lt;p&gt;当多个进程同时运行，需要分配给进程的内存总和大于实际可用的物理内存时，需要将其他程序暂时拷贝到硬盘当中，然后将新的程序装入内存运行。由于大量的数据频繁装入装出，内存的使用效率会非常低&lt;/p&gt;

&lt;h1 id=&quot;什么是虚拟内存&quot;&gt;什么是虚拟内存&lt;/h1&gt;

&lt;p&gt;每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，虚拟的意思就是，其实这个地址空间时不存在的，仅仅是每个进程“认为”自己拥有4G的内存，而实际上，它用了多少空间，操作系统就在磁盘上划出多少空间给它，等到进程真正运行的时候，需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行数据拷贝&lt;/p&gt;

&lt;p&gt;更准确一点的说，系统将虚拟内存分割为称为虚拟页(Virtual Page,VP)的大小固定的块，每个虚拟页的大小为P =  2^p字节，类似地，物理内存被分割为物理页(Physical Page,PP)，大小也为P字节（物理页也称为页帧(page frame)）&lt;/p&gt;

&lt;p&gt;在任意时刻，虚拟页面都分为互不相交的三种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;未分配的：系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间&lt;/li&gt;
  &lt;li&gt;未缓存的：没有缓存在物理存储器中的已分配页&lt;/li&gt;
  &lt;li&gt;缓存的：当前缓存在物理存储器中的已分配页&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图是一个示例：&lt;img src=&quot;/img/虚拟存储器.jpg&quot; alt=&quot;虚拟存储器&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个示例展示了一个有8个虚拟页的小虚拟存储器，虚拟页0和3还没有被分配，因此在磁盘上还不存在。虚拟页1、4和6被缓存在物理存储器中。页2、5和7已经被分配了，但是当前并未缓存在主存中&lt;/p&gt;

&lt;p&gt;操作系统向进程描述了一个完整的连续的虚拟地址空间供进程使用，但是在物理内存中进程数据的存储采用离散式存储(提高内存利用率)，但是其实虚拟内存和物理内存之间的关系并不像上图中那样直接，其中还需要使用页表映射虚拟地址与物理地址的映射关系，并且通过页表实现内存访问控制。&lt;/p&gt;

&lt;h1 id=&quot;页表&quot;&gt;页表&lt;/h1&gt;

&lt;p&gt;页表是一种特殊的数据结构，存放着各个虚拟页的状态，是否映射，是否缓存.。进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，这就需要用页表来记录。页表的每一个表项分为两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址(如果在的话)。当进程访问某个虚拟地址，就会先去看页表，如果发现对应的数据不在物理内存中，则发生缺页异常。&lt;/p&gt;

&lt;p&gt;缺页异常的事等下再说，先体会一下虚拟内存究竟是如何通过页表与物理内存联系起来的，再看一个示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/页表.jpg&quot; alt=&quot;页表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中展示了一个页表的基本组织结构，页表就是一个页表条目(Page Table  Entry,PTE)的数组，每个PTE由一个有效位(valid  bit)和一个地址组成，有效位表明了该虚拟页当前是否存在于物理内存中，如果有效位是1，该PTE中就会存储物理内存中相应的物理页的起始地址。如果有效位是0，且PTE中的地址为null，这表示这个虚拟页还未被分配，而如果有效位是0且PTE中有地址，那么这个地址指向该虚拟页在磁盘上的起始位置&lt;/p&gt;

&lt;p&gt;上图的示例展示了一个有8个虚拟页和4个物理页的系统的页表，四个虚拟页（VP1、VP2、VP4和VP7）当前存储于物理内存中，两个页（VP0和VP5）还未被分配（也就是什么都没存的虚拟内存，在磁盘和物理内存中都不存在这个空间），而剩下的页（VP3和VP6）已经被分配了，但是还未缓存进物理内存（也就是存在于磁盘上）&lt;/p&gt;

&lt;p&gt;在上面的过程中，CPU读包含在VP1中的一个数据时，地址翻译硬件将虚拟地址作为一个索引找到页表中的PTE 2，然后再从PTE 2中保存的物理地址从真正的物理内存中读到这个数据，在有效位为1的PTE中成功找到对应的物理页就称之为页命中&lt;/p&gt;

&lt;p&gt;而当试图访问一个有效位为0，但PTE中又保存了地址的虚拟内存中的数据时（也就是VP3和VP6的情况，数据保存在磁盘中），就是DRAM缓存不命中，一般将这种状况称为缺页异常(page  fault)。触发缺页异常后，系统会调用内核中的缺页异常处理程序，该程序会选择一个牺牲页(牺牲页的选择有具体的算法，在这里不做讨论)，在此例中就是存放在PP3中的VP4，内核将修改后的VP4重新拷贝回磁盘，并且修改VP4中的页表条目，将有效位改成0，反映出VP4不再存在于物理内存中这一事实。接下来，内核从磁盘拷贝VP3到存储器中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，再次从试图访问该虚拟地址开始，这时有效位是1，于是正常页命中，从物理地址中读取内存&lt;/p&gt;

&lt;h1 id=&quot;虚拟内存的工作原理&quot;&gt;虚拟内存的工作原理&lt;/h1&gt;

&lt;p&gt;当一个进程试图访问虚拟地址空间中的某个数据时，会经历下面两种情况的过程:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CPU想访问某个虚拟内存地址，找到进程对应的页表中的条目，判断有效位， 如果有效位为1，说明在页表条目中的物理内存地址不为空，根据物理内存地址，访问物理内存中的内容，返回&lt;/li&gt;
  &lt;li&gt;CPU想访问某个虚拟内存地址，找到进程对应的页表中的条目，判断有效位，如果有效位为0，但页表条目中还有地址，这个地址是磁盘空间的地址，这时触发缺页异常，系统把物理内存中的一些数据拷贝到磁盘上，腾出所需的空间，并且更新页表。此时重新执行访问之前虚拟内存的指令，就会发现变成了情况1.&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="操作系统" /><summary type="html">[toc]</summary></entry><entry><title type="html">进程虚拟地址空间区域划分</title><link href="http://localhost:4000/_posts/2020-06-08-%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/" rel="alternate" type="text/html" title="进程虚拟地址空间区域划分" /><published>2020-06-08T00:00:00+08:00</published><updated>2020-06-08T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-08-%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;首先要知道一点，程序由磁盘加载到内存时是不可能直接加载到物理内存当中的，这里的原因以及物理内存和虚拟内存的区别与联系在本篇先不做讨论&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;本篇接下来所讨论的范围在x86体系32位Linux环境下&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux系统会给当前每一个进程分配一个2^32位大小(4G)的一块空间，这块空间就叫做进程的虚拟地址空间&lt;/p&gt;

&lt;p&gt;这里附上IBM公司关于&lt;strong&gt;虚拟&lt;/strong&gt;的解释:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;它存在，你看得见，它是物理的&lt;/li&gt;
  &lt;li&gt;它存在，你看不见，它是透明的&lt;/li&gt;
  &lt;li&gt;它不存在，你看得见，它是虚拟的&lt;/li&gt;
  &lt;li&gt;它不存在，你看不见，它被删除&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这块空间的内容如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/内存空间.png&quot; alt=&quot;内存空间&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来分别阐述每块空间的作用:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从0x00000000到0x08048000的这段空间是预留的，是不能访问的，例如对空指针进行访问程序就会崩溃&lt;/li&gt;
  &lt;li&gt;程序运行时产生的指令就放在.text段（代码段）。这一段同时也保存了只读数据（read only data），例如char* p = “hello world”中的”hello world”，在这里，当想进行*p = ‘a’操作时可以通过编译但运行会崩溃（在比较新的c++编译器中不允许用普通指针指向常量字符串），因为该段是只能读但不能写的。&lt;/li&gt;
  &lt;li&gt;.data存放了初始化了的且初始化的值不为0的数据&lt;/li&gt;
  &lt;li&gt;.bss存放未初始化及初始化为0的数据,打印未初始化的全局变量会看到值为0，因为存放于.bss段，操作系统会将.bss段的数据全部赋值为0&lt;/li&gt;
  &lt;li&gt;堆（heap），在《深入理解计算机系统》中的名称是运行时堆（由malloc创建），也就是说这里的堆空间是暂时没有的，当程序运行，new或malloc之后才会分配堆内存，由低地址向高地址增长&lt;/li&gt;
  &lt;li&gt;加载共享库，也就是动态链接库，Windows下是&lt;em&gt;.dll,Linux下是&lt;/em&gt;so&lt;/li&gt;
  &lt;li&gt;stack 函数运行或产生线程时，每一个函数/线程独有的栈空间，由高地址向低地址增长的&lt;/li&gt;
  &lt;li&gt;命令行参数和环境变量，命令行参数如main函数传参，环境变量如搜索头文件、库文件时默认的路径&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过分析具体代码的方式体会虚拟地址空间的划分:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int g_data1 = 10;
int g_data2 = 0;
int g_data3;

static int g_data4 = 11;
static int g_data5 = 0;
static int g_data6;

int main(){
    int a = 12;
    int b = 0;
    int c;

    static int e = 13;
    static int f = 0;
    static int g;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的程序中，所有的全局变量（g_data），不管是普通的还是静态（static）的，每一个在编译后的符号表中都会产生符号，他们叫做数据。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;g_data1和g_data4都是初始化了的且初始化的值不为0的，所以它们放在.data段&lt;/li&gt;
  &lt;li&gt;g_data3和g_data6都是未初始化的，g_data2和g_data5虽然已经初始化但初始化值为0，所以它们都放在.bss段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而在main函数中，a、b、c三个局部变量并不会在符号表中产生符号，它们生成的是指令，例如int a = 12;在x86架构的汇编中产生的是mov dword ptr[a],0Ch指令，也就是将0Ch(12)移入a的内存，所以它们三个其实是放在指令段（.text）的
main函数中的e、f、g三个静态局部变量也是放在数据段的，但是程序启动时不会初始化，当程序运行到该条语句时才会初始化，它们的存储位置与全局变量相同&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;e是初始化且不为0的，放在.data段&lt;/li&gt;
  &lt;li&gt;f虽然初始化但初始化值为0，g未初始化，所以都放在.bss段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这里，如果打印c，c的值不会为0，而打印g的值为0，原因就是g存放在.bss段，操作系统自动赋初值为0了.&lt;/p&gt;

&lt;p&gt;同时这里理解时可能会产生一个问题，通常我们说局部变量是在栈上，为什么这里说是指令保存在指令段呢？事实上，int a = 12这句代码在编译时产生的是一条指令，这个指令保存在.text段，而在运行时，系统会在当前进程的栈上给函数开辟一个栈帧，该指令运行时会在栈上开辟一段4个字节的空间存放“12”这个整数&lt;/p&gt;

&lt;p&gt;同时对于这一部分也要注意，每一个进程的用户空间是私有的，但是内核空间是共享的。这也就是进程间通信比较困难的原因，而进程间通信方式的一种，匿名管道通信其实就是在内核空间中划分出一片内存，每个进程就都可以在这片空间写入数据给其他进程看，由此实现通信的目的&lt;/p&gt;</content><author><name></name></author><category term="操作系统" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程-高级IO</title><link href="http://localhost:4000/_posts/2020-06-06-linux%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO/" rel="alternate" type="text/html" title="linux编程-高级IO" /><published>2020-06-06T00:00:00+08:00</published><updated>2020-06-06T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-06-linux%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;非阻塞io&quot;&gt;非阻塞IO&lt;/h1&gt;

&lt;h2 id=&quot;非阻塞io概念&quot;&gt;非阻塞IO概念&lt;/h2&gt;

&lt;p&gt;简单流程:自然流程是结构化的&lt;/p&gt;

&lt;p&gt;复杂流程:自然流程不是结构化的&lt;/p&gt;

&lt;h2 id=&quot;io多路转接&quot;&gt;IO多路转接&lt;/h2&gt;

&lt;p&gt;IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。&lt;/li&gt;
  &lt;li&gt;当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。&lt;/li&gt;
  &lt;li&gt;如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。&lt;/li&gt;
  &lt;li&gt;如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。&lt;/li&gt;
  &lt;li&gt;如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;select&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;synchronous I/O  multiplexing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* According to POSIX.1-2001, POSIX.1-2008 */
#include &amp;lt;sys/select.h&amp;gt;
/* According to earlier standards */
#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int select(int nfds, fd_set *readfds, fd_set *writefds,
fd_set *exceptfds, struct timeval *timeout);
void FD_CLR(int fd, fd_set *set);
int  FD_ISSET(int fd, fd_set *set);
void FD_SET(int fd, fd_set *set);
void FD_ZERO(fd_set *set);
#include &amp;lt;sys/select.h&amp;gt;
int pselect(int nfds, fd_set *readfds, fd_set *writefds,
fd_set *exceptfds, const struct timespec *timeout,
const sigset_t *sigmask);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/sellect.png&quot; alt=&quot;sellect&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;poll&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;wait for some event on a file descriptor&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;poll.h&amp;gt;
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;
int ppoll(struct pollfd *fds, nfds_t nfds,
const struct timespec *tmo_p, const sigset_t *sigmask);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;epoll&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;I/O event notification facility&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查看机制&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;man 7 epoll
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;其他读写函数&quot;&gt;其他读写函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;readv&lt;/li&gt;
  &lt;li&gt;writev&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;read or write data into multiple buffers&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/uio.h&amp;gt;
ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
ssize_t preadv(int fd, const struct iovec *iov, int iovcnt,
off_t offset);
ssize_t pwritev(int fd, const struct iovec *iov, int iovcnt,
off_t offset);
ssize_t preadv2(int fd, const struct iovec *iov, int iovcnt,
off_t offset, int flags);
ssize_t pwritev2(int fd, const struct iovec *iov, int iovcnt,
off_t offset, int flags);
struct iovec {
               void  *iov_base;    /* Starting address */
               size_t iov_len;     /* Number of bytes to transfer */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;存储映射io&quot;&gt;存储映射IO&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;mmap&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;map or unmap files or devices into memory&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/mman.h&amp;gt;
void *mmap(void *addr, size_t length, int prot, int flags,
int fd, off_t offset);
int munmap(void *addr, size_t length);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;文件锁&quot;&gt;文件锁&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;lockf&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;test or remove a POSIX lock on an open file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int lockf(int fd, int cmd, off_t len);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;flock&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;apply or remove an advisory lock on an open file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/file.h&amp;gt;
int flock(int fd, int operation);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;有限状态机编程&quot;&gt;有限状态机编程&lt;/h1&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">排序算法</title><link href="http://localhost:4000/_posts/2020-06-06-%E6%8E%92%E5%BA%8F/" rel="alternate" type="text/html" title="排序算法" /><published>2020-06-06T00:00:00+08:00</published><updated>2020-06-06T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E6%8E%92%E5%BA%8F</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-06-%E6%8E%92%E5%BA%8F/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/冒泡排序.webp&quot; alt=&quot;冒泡排序&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void BubbleSort(int *array,int length)
{
    if (array == NULL)
    {
        fprintf(stderr,&quot;empty\n&quot;);
        exit(1);
    }
    int temp = 0;
    for (size_t i = 0; i &amp;lt; length; i++)
    {
        for (size_t j = i+1; j &amp;lt; length; j++)
        {
            if (array[i] &amp;gt; array[j])
            {
                temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            } 
        }          
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;选择排序&quot;&gt;选择排序&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;在一个长度为 N 的无序数组中，第一次遍历 n-1 个数找到最小的和第一个数交换。&lt;/li&gt;
  &lt;li&gt;第二次从下一个数开始遍历 n-2 个数，找到最小的数和第二个数交换。&lt;/li&gt;
  &lt;li&gt;重复以上操作直到第 n-1 次遍历最小的数和第 n-1 个数交换，排序完成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/选择排序.gif&quot; alt=&quot;选择排序&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void SelectSort(int *array,int length)
{
    if (array == NULL || length == 0)
    {
        fprintf(stderr,&quot;empty\n&quot;);
        exit(1);
    }
    for (size_t i = 0; i &amp;lt; length; i++)
    {
        int MinKey = array[i];
        for (size_t j = i; j &amp;lt; length; j++)
        {
            if (MinKey &amp;gt; array[j])
            {
                int temp = array[j];
                array[j] = MinKey;
                MinKey = temp;
            } 
        }
           array[i] = MinKey;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;快速排序&quot;&gt;快速排序&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先设定一个分界值，通过该分界值将数组分成左右两部分。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/快速排序.gif&quot; alt=&quot;快速排序&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="算法" /><summary type="html">[toc]</summary></entry></feed>