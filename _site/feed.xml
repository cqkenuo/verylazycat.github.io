<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-06-12T15:58:23+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lazycat</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
</subtitle><entry><title type="html">TCP三次握手四次挥手</title><link href="http://localhost:4000/_posts/2020-06-12-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" rel="alternate" type="text/html" title="TCP三次握手四次挥手" /><published>2020-06-12T00:00:00+08:00</published><updated>2020-06-12T00:00:00+08:00</updated><id>http://localhost:4000/_posts/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-12-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;tcp-三次握手&quot;&gt;&lt;strong&gt;TCP 三次握手&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;TCP 三次握手就好比两个人在街上隔着50米看见了对方，但是因为雾霾等原因不能100%确认，所以要通过招手的方式相互确定对方是否认识自己&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/tcp0.webp&quot; alt=&quot;tcp0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;张三首先向李四招手(&lt;strong&gt;syn&lt;/strong&gt;)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(&lt;strong&gt;ack&lt;/strong&gt;)。张三看到李四微笑后确认了李四成功辨认出了自己(进入&lt;strong&gt;estalished&lt;/strong&gt;状态)。&lt;/p&gt;

&lt;p&gt;但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手(&lt;strong&gt;syn&lt;/strong&gt;)，张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑(&lt;strong&gt;ack&lt;/strong&gt;)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入&lt;strong&gt;established&lt;/strong&gt;状态)。&lt;/p&gt;

&lt;p&gt;于是两人加快步伐，走到了一起，相互拥抱。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/tec1.webp&quot; alt=&quot;tec1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们看到这个过程中一共是四个动作，张三招手–李四点头微笑–李四招手–张三点头微笑。其中李四连续进行了2个动作，先是点头微笑(回复对方)，然后再次招手(寻求确认)，实际上可以将这两个动作合一，招手的同时点头和微笑(&lt;strong&gt;syn+ack&lt;/strong&gt;)。于是四个动作就简化成了三个动作，张三招手–李四点头微笑并招手–张三点头微笑。这就是三次握手的本质，中间的一次动作是两个动作的合并。&lt;/p&gt;

&lt;p&gt;我们看到有两个中间状态，&lt;strong&gt;syn_sent&lt;/strong&gt;和&lt;strong&gt;syn_rcvd&lt;/strong&gt;，这两个状态叫着「半打开」状态，就是向对方招手了，但是还没来得及看到对方的点头微笑。&lt;strong&gt;syn_sent&lt;/strong&gt;是主动打开方的「半打开」状态，&lt;strong&gt;syn_rcvd&lt;/strong&gt;是被动打开方的「半打开」状态。客户端是主动打开方，服务器是被动打开方。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;syn_sent: syn package has been sent&lt;/li&gt;
  &lt;li&gt;syn_rcvd: syn package has been received&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;tcp-数据传输&quot;&gt;&lt;strong&gt;TCP 数据传输&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;TCP 数据传输就是两个人隔空对话，差了一点距离，所以需要对方反复确认听见了自己的话&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/tcp2.webp&quot; alt=&quot;tcp2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;张三喊了一句话(data)，李四听见了之后要向张三回复自己听见了(ack)。&lt;/p&gt;

&lt;p&gt;如果张三喊了一句，半天没听到李四回复，张三就认为自己的话被大风吹走了，李四没听见，所以需要重新喊话，这就是tcp重传。&lt;/p&gt;

&lt;p&gt;也有可能是李四听到了张三的话，但是李四向张三的回复被大风吹走了，以至于张三没听见李四的回复。张三并不能判断究竟是自己的话被大风吹走了还是李四的回复被大风吹走了，张三也不用管，重传一下就是。&lt;/p&gt;

&lt;p&gt;既然会重传，李四就有可能同一句话听见了两次，这就是「去重」。「重传」和「去重」工作操作系统的网络内核模块都已经帮我们处理好了，用户层是不用关心的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/tcp3.webp&quot; alt=&quot;tcp3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;张三可以向李四喊话，同样李四也可以向张三喊话，因为tcp链接是「双工的」，双方都可以主动发起数据传输。不过无论是哪方喊话，都需要收到对方的确认才能认为对方收到了自己的喊话。&lt;/p&gt;

&lt;p&gt;张三可能是个高射炮，一说连说了八句话，这时候李四可以不用一句一句回复，而是连续听了这八句话之后，一起向对方回复说前面你说的八句话我都听见了，这就是批量ack。但是张三也不能一次性说了太多话，李四的脑子短时间可能无法消化太多，两人之间需要有协商好的合适的发送和接受速率，这个就是「TCP窗口大小」。&lt;/p&gt;

&lt;p&gt;网络环境的数据交互同人类之间的对话还要复杂一些，它存在数据包乱序的现象。同一个来源发出来的不同数据包在「网际路由」上可能会走过不同的路径，最终达到同一个地方时，顺序就不一样了。操作系统的网络内核模块会负责对数据包进行排序，到用户层时顺序就已经完全一致了。&lt;/p&gt;

&lt;h2 id=&quot;tcp-四次挥手&quot;&gt;&lt;strong&gt;TCP 四次挥手&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;TCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，张三挥手(fin)——李四伤感地微笑(ack)——李四挥手(fin)——张三伤感地微笑(ack)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/tcp4.webp&quot; alt=&quot;tcp4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之所以中间的两个动作没有合并，是因为tcp存在「半关闭」状态，也就是单向关闭。张三已经挥了手，可是人还没有走，只是不再说话，但是耳朵还是可以继续听，李四呢继续喊话。等待李四累了，也不再说话了，超张三挥了挥手，张三伤感地微笑了一下，才彻底结束了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/tcp5.webp&quot; alt=&quot;tcp5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面有一个非常特殊的状态&lt;code&gt;time_wait&lt;/code&gt;，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是4分钟，4分钟后才会进入到closed状态，释放套接字资源。不过在具体实现上这个时间是可以调整的。&lt;/p&gt;

&lt;p&gt;它就好比主动分手方要承担的责任，是你提出的要分手，你得付出代价。这个后果就是持续4分钟的&lt;code&gt;time_wait&lt;/code&gt;状态，不能释放套接字资源(端口)，就好比守寡期，这段时间内套接字资源(端口)不得回收利用。&lt;/p&gt;

&lt;p&gt;它的作用是重传最后一个ack报文，确保对方可以收到。因为如果对方没有收到ack的话，会重传fin报文，处于time_wait状态的套接字会立即向对方重发ack报文。&lt;/p&gt;

&lt;p&gt;同时在这段时间内，该链接在对话期间于网际路由上产生的残留报文(因为路径过于崎岖，数据报文走的时间太长，重传的报文都收到了，原始报文还在路上)传过来时，都会被立即丢弃掉。4分钟的时间足以使得这些残留报文彻底消逝。不然当新的端口被重复利用时，这些残留报文可能会干扰新的链接。&lt;/p&gt;

&lt;p&gt;4分钟就是2个MSL，每个MSL是2分钟。MSL就是&lt;code&gt;maximium segment lifetime&lt;/code&gt;——最长报文寿命。这个时间是由官方RFC协议规定的。至于为什么是2个MSL而不是1个MSL，我还没有看到一个非常满意的解释。&lt;/p&gt;

&lt;p&gt;四次挥手也并不总是四次挥手，中间的两个动作有时候是可以合并一起进行的，这个时候就成了三次挥手，主动关闭方就会从&lt;code&gt;fin_wait_1&lt;/code&gt;状态直接进入到&lt;code&gt;time_wait&lt;/code&gt;状态，跳过了&lt;code&gt;fin_wait_2&lt;/code&gt;状态。&lt;/p&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">大三上计划</title><link href="http://localhost:4000/_posts/2020-06-11-%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AE%A1%E5%88%92/" rel="alternate" type="text/html" title="大三上计划" /><published>2020-06-11T00:00:00+08:00</published><updated>2020-06-11T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AE%A1%E5%88%92</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-11-%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AE%A1%E5%88%92/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;学习&quot;&gt;学习&lt;/h1&gt;

&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;考研英语单词记忆&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;强化口语和听力&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;数学一轮复习&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;四级考试&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;专业&quot;&gt;专业&lt;/h1&gt;

&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;unix环境高级编程&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;自制简易操作系统&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;leetcode&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;c/c++/java深入学习&lt;/p&gt;
&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;省或国奖&lt;/p&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;其他&quot;&gt;其他&lt;/h1&gt;

&lt;p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;category&quot; /&gt;深度学习模型分享&lt;/p&gt;</content><author><name></name></author><category term="生活" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程-进程间通信</title><link href="http://localhost:4000/_posts/2020-06-09-linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" rel="alternate" type="text/html" title="linux编程-进程间通信" /><published>2020-06-09T00:00:00+08:00</published><updated>2020-06-09T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-09-linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;管道&quot;&gt;管道&lt;/h1&gt;

&lt;h2 id=&quot;内核提供单工自同步机制&quot;&gt;内核提供,单工,自同步机制&lt;/h2&gt;

&lt;h2 id=&quot;匿名管道&quot;&gt;匿名管道&lt;/h2&gt;

&lt;p&gt;pipe&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;create pipe&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int pipe(int pipefd[2]);
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include &amp;lt;fcntl.h&amp;gt;              /* Obtain O_* constant definitions */
#include &amp;lt;unistd.h&amp;gt;
int pipe2(int pipefd[2], int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;命名管道&quot;&gt;命名管道&lt;/h2&gt;

&lt;h1 id=&quot;xsi&quot;&gt;XSI&lt;/h1&gt;

&lt;p&gt;IPC -&amp;gt; Internet Process Communication&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;ipcs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;key:ftok&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;convert  a pathname and a project identifier to a System V IPC key&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
key_t ftok(const char *pathname, int proj_id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Message Queues&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;msgget&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;get a System V message queue identifier&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/msg.h&amp;gt;
int msgget(key_t key, int msgflg);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;msgop&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;System V message queue operations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/msg.h&amp;gt;
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
int msgflg);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;msgctl&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;System V message control operations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/msg.h&amp;gt;
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Semaphore Arrays&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;semget&lt;/li&gt;
  &lt;li&gt;semop&lt;/li&gt;
  &lt;li&gt;semctl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Shared Memory&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;shmget&lt;/li&gt;
  &lt;li&gt;shmop&lt;/li&gt;
  &lt;li&gt;shmctl&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;网络套接字socket&quot;&gt;网络套接字socket&lt;/h1&gt;

&lt;h2 id=&quot;字节序问题&quot;&gt;字节序问题&lt;/h2&gt;

&lt;p&gt;大端:低地址放高字节&lt;/p&gt;

&lt;p&gt;小端:低地址放低字节&lt;/p&gt;

&lt;h2 id=&quot;报式套接字&quot;&gt;报式套接字&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;socket&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;create an endpoint for communication&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */
#include &amp;lt;sys/socket.h&amp;gt;
int socket(int domain, int type, int protocol);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;bind&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;bind a name to a socket&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */
#include &amp;lt;sys/socket.h&amp;gt;
int bind(int sockfd, const struct sockaddr *addr,
socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;sendto&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;send a message on a socket&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;rcvfrom&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;inet_pton&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;convert IPv4 and IPv6 addresses from text to binary form&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;arpa/inet.h&amp;gt;
int inet_pton(int af, const char *src, void *dst);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;inet_ntop&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;convert IPv4 and IPv6 addresses from binary to text form&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;arpa/inet.h&amp;gt;
const char *inet_ntop(int af, const void *src,
char *dst, socklen_t size);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;getsockopt&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;setsockopt&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;get and set options on sockets&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;          /* See NOTES */
#include &amp;lt;sys/socket.h&amp;gt;
int getsockopt(int sockfd, int level, int optname,
void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname,
const void *optval, socklen_t optlen);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;多点通讯&quot;&gt;多点通讯&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;广播
    &lt;ul&gt;
      &lt;li&gt;全网广播&lt;/li&gt;
      &lt;li&gt;子网广播&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;多播/组播&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;流式套接字&quot;&gt;流式套接字&lt;/h2&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">虚拟内存</title><link href="http://localhost:4000/_posts/2020-06-08-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" rel="alternate" type="text/html" title="虚拟内存" /><published>2020-06-08T00:00:00+08:00</published><updated>2020-06-08T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-08-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;概念&quot;&gt;概念&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;现代所有用于一般应用的操作系统都对普通的应用程序使用虚拟内存技术，老一些的操作系统，如DOS和1980年代的Windows，或者那些1960年代的大型机，一般都没有虚拟内存的功能&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在很久以前,程序指令所访问的内存地址就是物理内存地址,也就是不得不把程序的全部装进内存当中，然后运行。&lt;/p&gt;

&lt;p&gt;物理内存其实就是插在计算机主板内存槽上的实际物理内存，CPU可以直接进行寻址。物理内存的容量是固定的，但是寻址空间却取决于cpu地址线条数，如32位机，则寻址空间为2^32 = 4G，所以最大支只持4G的寻址空间，即使插了8G的内存条也只能使用4G内存;&lt;/p&gt;

&lt;h1 id=&quot;直接使用物理内存产生的问题&quot;&gt;直接使用物理内存产生的问题&lt;/h1&gt;

&lt;p&gt;在这种直接使用物理内存的状态下就会产生一些问题:&lt;/p&gt;

&lt;h2 id=&quot;内存空间利用率的问题&quot;&gt;内存空间利用率的问题&lt;/h2&gt;

&lt;p&gt;各个进程对内存的使用会导致内存碎片化，当要用malloc分配一块很大的内存空间时，可能会出现虽然有足够多的空闲物理内存，却没有足够大的连续空闲内存这种情况，东一块西一块的内存碎片就被浪费掉了&lt;/p&gt;

&lt;h2 id=&quot;读写内存的安全性问题&quot;&gt;读写内存的安全性问题&lt;/h2&gt;

&lt;p&gt;物理内存本身是不限制访问的，任何地址都可以读写，而现代操作系统需要实现不同的页面具有不同的访问权限，例如只读的数据等等&lt;/p&gt;

&lt;h2 id=&quot;进程间的安全问题&quot;&gt;进程间的安全问题&lt;/h2&gt;

&lt;p&gt;各个进程之间没有独立的地址空间，一个进程由于执行错误指令或是恶意代码都可以直接修改其它进程的数据，甚至修改内核地址空间的数据，这是操作系统所不愿看到的&lt;/p&gt;

&lt;h2 id=&quot;内存读写的效率问题&quot;&gt;内存读写的效率问题&lt;/h2&gt;

&lt;p&gt;当多个进程同时运行，需要分配给进程的内存总和大于实际可用的物理内存时，需要将其他程序暂时拷贝到硬盘当中，然后将新的程序装入内存运行。由于大量的数据频繁装入装出，内存的使用效率会非常低&lt;/p&gt;

&lt;h1 id=&quot;什么是虚拟内存&quot;&gt;什么是虚拟内存&lt;/h1&gt;

&lt;p&gt;每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，虚拟的意思就是，其实这个地址空间时不存在的，仅仅是每个进程“认为”自己拥有4G的内存，而实际上，它用了多少空间，操作系统就在磁盘上划出多少空间给它，等到进程真正运行的时候，需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行数据拷贝&lt;/p&gt;

&lt;p&gt;更准确一点的说，系统将虚拟内存分割为称为虚拟页(Virtual Page,VP)的大小固定的块，每个虚拟页的大小为P =  2^p字节，类似地，物理内存被分割为物理页(Physical Page,PP)，大小也为P字节（物理页也称为页帧(page frame)）&lt;/p&gt;

&lt;p&gt;在任意时刻，虚拟页面都分为互不相交的三种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;未分配的：系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间&lt;/li&gt;
  &lt;li&gt;未缓存的：没有缓存在物理存储器中的已分配页&lt;/li&gt;
  &lt;li&gt;缓存的：当前缓存在物理存储器中的已分配页&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图是一个示例：&lt;img src=&quot;/img/虚拟存储器.jpg&quot; alt=&quot;虚拟存储器&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个示例展示了一个有8个虚拟页的小虚拟存储器，虚拟页0和3还没有被分配，因此在磁盘上还不存在。虚拟页1、4和6被缓存在物理存储器中。页2、5和7已经被分配了，但是当前并未缓存在主存中&lt;/p&gt;

&lt;p&gt;操作系统向进程描述了一个完整的连续的虚拟地址空间供进程使用，但是在物理内存中进程数据的存储采用离散式存储(提高内存利用率)，但是其实虚拟内存和物理内存之间的关系并不像上图中那样直接，其中还需要使用页表映射虚拟地址与物理地址的映射关系，并且通过页表实现内存访问控制。&lt;/p&gt;

&lt;h1 id=&quot;页表&quot;&gt;页表&lt;/h1&gt;

&lt;p&gt;页表是一种特殊的数据结构，存放着各个虚拟页的状态，是否映射，是否缓存.。进程要知道哪些内存地址上的数据在物理内存上，哪些不在，还有在物理内存上的哪里，这就需要用页表来记录。页表的每一个表项分为两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址(如果在的话)。当进程访问某个虚拟地址，就会先去看页表，如果发现对应的数据不在物理内存中，则发生缺页异常。&lt;/p&gt;

&lt;p&gt;缺页异常的事等下再说，先体会一下虚拟内存究竟是如何通过页表与物理内存联系起来的，再看一个示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/页表.jpg&quot; alt=&quot;页表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中展示了一个页表的基本组织结构，页表就是一个页表条目(Page Table  Entry,PTE)的数组，每个PTE由一个有效位(valid  bit)和一个地址组成，有效位表明了该虚拟页当前是否存在于物理内存中，如果有效位是1，该PTE中就会存储物理内存中相应的物理页的起始地址。如果有效位是0，且PTE中的地址为null，这表示这个虚拟页还未被分配，而如果有效位是0且PTE中有地址，那么这个地址指向该虚拟页在磁盘上的起始位置&lt;/p&gt;

&lt;p&gt;上图的示例展示了一个有8个虚拟页和4个物理页的系统的页表，四个虚拟页（VP1、VP2、VP4和VP7）当前存储于物理内存中，两个页（VP0和VP5）还未被分配（也就是什么都没存的虚拟内存，在磁盘和物理内存中都不存在这个空间），而剩下的页（VP3和VP6）已经被分配了，但是还未缓存进物理内存（也就是存在于磁盘上）&lt;/p&gt;

&lt;p&gt;在上面的过程中，CPU读包含在VP1中的一个数据时，地址翻译硬件将虚拟地址作为一个索引找到页表中的PTE 2，然后再从PTE 2中保存的物理地址从真正的物理内存中读到这个数据，在有效位为1的PTE中成功找到对应的物理页就称之为页命中&lt;/p&gt;

&lt;p&gt;而当试图访问一个有效位为0，但PTE中又保存了地址的虚拟内存中的数据时（也就是VP3和VP6的情况，数据保存在磁盘中），就是DRAM缓存不命中，一般将这种状况称为缺页异常(page  fault)。触发缺页异常后，系统会调用内核中的缺页异常处理程序，该程序会选择一个牺牲页(牺牲页的选择有具体的算法，在这里不做讨论)，在此例中就是存放在PP3中的VP4，内核将修改后的VP4重新拷贝回磁盘，并且修改VP4中的页表条目，将有效位改成0，反映出VP4不再存在于物理内存中这一事实。接下来，内核从磁盘拷贝VP3到存储器中的PP3，更新PTE3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，再次从试图访问该虚拟地址开始，这时有效位是1，于是正常页命中，从物理地址中读取内存&lt;/p&gt;

&lt;h1 id=&quot;虚拟内存的工作原理&quot;&gt;虚拟内存的工作原理&lt;/h1&gt;

&lt;p&gt;当一个进程试图访问虚拟地址空间中的某个数据时，会经历下面两种情况的过程:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CPU想访问某个虚拟内存地址，找到进程对应的页表中的条目，判断有效位， 如果有效位为1，说明在页表条目中的物理内存地址不为空，根据物理内存地址，访问物理内存中的内容，返回&lt;/li&gt;
  &lt;li&gt;CPU想访问某个虚拟内存地址，找到进程对应的页表中的条目，判断有效位，如果有效位为0，但页表条目中还有地址，这个地址是磁盘空间的地址，这时触发缺页异常，系统把物理内存中的一些数据拷贝到磁盘上，腾出所需的空间，并且更新页表。此时重新执行访问之前虚拟内存的指令，就会发现变成了情况1.&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="操作系统" /><summary type="html">[toc]</summary></entry><entry><title type="html">进程虚拟地址空间区域划分</title><link href="http://localhost:4000/_posts/2020-06-08-%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/" rel="alternate" type="text/html" title="进程虚拟地址空间区域划分" /><published>2020-06-08T00:00:00+08:00</published><updated>2020-06-08T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-08-%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;首先要知道一点，程序由磁盘加载到内存时是不可能直接加载到物理内存当中的，这里的原因以及物理内存和虚拟内存的区别与联系在本篇先不做讨论&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;本篇接下来所讨论的范围在x86体系32位Linux环境下&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Linux系统会给当前每一个进程分配一个2^32位大小(4G)的一块空间，这块空间就叫做进程的虚拟地址空间&lt;/p&gt;

&lt;p&gt;这里附上IBM公司关于&lt;strong&gt;虚拟&lt;/strong&gt;的解释:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;它存在，你看得见，它是物理的&lt;/li&gt;
  &lt;li&gt;它存在，你看不见，它是透明的&lt;/li&gt;
  &lt;li&gt;它不存在，你看得见，它是虚拟的&lt;/li&gt;
  &lt;li&gt;它不存在，你看不见，它被删除&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这块空间的内容如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/内存空间.png&quot; alt=&quot;内存空间&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来分别阐述每块空间的作用:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从0x00000000到0x08048000的这段空间是预留的，是不能访问的，例如对空指针进行访问程序就会崩溃&lt;/li&gt;
  &lt;li&gt;程序运行时产生的指令就放在.text段（代码段）。这一段同时也保存了只读数据（read only data），例如char* p = “hello world”中的”hello world”，在这里，当想进行*p = ‘a’操作时可以通过编译但运行会崩溃（在比较新的c++编译器中不允许用普通指针指向常量字符串），因为该段是只能读但不能写的。&lt;/li&gt;
  &lt;li&gt;.data存放了初始化了的且初始化的值不为0的数据&lt;/li&gt;
  &lt;li&gt;.bss存放未初始化及初始化为0的数据,打印未初始化的全局变量会看到值为0，因为存放于.bss段，操作系统会将.bss段的数据全部赋值为0&lt;/li&gt;
  &lt;li&gt;堆（heap），在《深入理解计算机系统》中的名称是运行时堆（由malloc创建），也就是说这里的堆空间是暂时没有的，当程序运行，new或malloc之后才会分配堆内存，由低地址向高地址增长&lt;/li&gt;
  &lt;li&gt;加载共享库，也就是动态链接库，Windows下是&lt;em&gt;.dll,Linux下是&lt;/em&gt;so&lt;/li&gt;
  &lt;li&gt;stack 函数运行或产生线程时，每一个函数/线程独有的栈空间，由高地址向低地址增长的&lt;/li&gt;
  &lt;li&gt;命令行参数和环境变量，命令行参数如main函数传参，环境变量如搜索头文件、库文件时默认的路径&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过分析具体代码的方式体会虚拟地址空间的划分:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int g_data1 = 10;
int g_data2 = 0;
int g_data3;

static int g_data4 = 11;
static int g_data5 = 0;
static int g_data6;

int main(){
    int a = 12;
    int b = 0;
    int c;

    static int e = 13;
    static int f = 0;
    static int g;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的程序中，所有的全局变量（g_data），不管是普通的还是静态（static）的，每一个在编译后的符号表中都会产生符号，他们叫做数据。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;g_data1和g_data4都是初始化了的且初始化的值不为0的，所以它们放在.data段&lt;/li&gt;
  &lt;li&gt;g_data3和g_data6都是未初始化的，g_data2和g_data5虽然已经初始化但初始化值为0，所以它们都放在.bss段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而在main函数中，a、b、c三个局部变量并不会在符号表中产生符号，它们生成的是指令，例如int a = 12;在x86架构的汇编中产生的是mov dword ptr[a],0Ch指令，也就是将0Ch(12)移入a的内存，所以它们三个其实是放在指令段（.text）的
main函数中的e、f、g三个静态局部变量也是放在数据段的，但是程序启动时不会初始化，当程序运行到该条语句时才会初始化，它们的存储位置与全局变量相同&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;e是初始化且不为0的，放在.data段&lt;/li&gt;
  &lt;li&gt;f虽然初始化但初始化值为0，g未初始化，所以都放在.bss段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这里，如果打印c，c的值不会为0，而打印g的值为0，原因就是g存放在.bss段，操作系统自动赋初值为0了.&lt;/p&gt;

&lt;p&gt;同时这里理解时可能会产生一个问题，通常我们说局部变量是在栈上，为什么这里说是指令保存在指令段呢？事实上，int a = 12这句代码在编译时产生的是一条指令，这个指令保存在.text段，而在运行时，系统会在当前进程的栈上给函数开辟一个栈帧，该指令运行时会在栈上开辟一段4个字节的空间存放“12”这个整数&lt;/p&gt;

&lt;p&gt;同时对于这一部分也要注意，每一个进程的用户空间是私有的，但是内核空间是共享的。这也就是进程间通信比较困难的原因，而进程间通信方式的一种，匿名管道通信其实就是在内核空间中划分出一片内存，每个进程就都可以在这片空间写入数据给其他进程看，由此实现通信的目的&lt;/p&gt;</content><author><name></name></author><category term="操作系统" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程-高级IO</title><link href="http://localhost:4000/_posts/2020-06-06-linux%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO/" rel="alternate" type="text/html" title="linux编程-高级IO" /><published>2020-06-06T00:00:00+08:00</published><updated>2020-06-06T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-06-linux%E7%BC%96%E7%A8%8B-%E9%AB%98%E7%BA%A7IO/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;非阻塞io&quot;&gt;非阻塞IO&lt;/h1&gt;

&lt;h2 id=&quot;非阻塞io概念&quot;&gt;非阻塞IO概念&lt;/h2&gt;

&lt;p&gt;简单流程:自然流程是结构化的&lt;/p&gt;

&lt;p&gt;复杂流程:自然流程不是结构化的&lt;/p&gt;

&lt;h2 id=&quot;io多路转接&quot;&gt;IO多路转接&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;select&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;synchronous I/O  multiplexing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;/* According to POSIX.1-2001, POSIX.1-2008 */
#include &amp;lt;sys/select.h&amp;gt;
/* According to earlier standards */
#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int select(int nfds, fd_set *readfds, fd_set *writefds,
fd_set *exceptfds, struct timeval *timeout);
void FD_CLR(int fd, fd_set *set);
int  FD_ISSET(int fd, fd_set *set);
void FD_SET(int fd, fd_set *set);
void FD_ZERO(fd_set *set);
#include &amp;lt;sys/select.h&amp;gt;
int pselect(int nfds, fd_set *readfds, fd_set *writefds,
fd_set *exceptfds, const struct timespec *timeout,
const sigset_t *sigmask);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;poll&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;wait for some event on a file descriptor&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;poll.h&amp;gt;
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &amp;lt;signal.h&amp;gt;
#include &amp;lt;poll.h&amp;gt;
int ppoll(struct pollfd *fds, nfds_t nfds,
const struct timespec *tmo_p, const sigset_t *sigmask);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;epoll&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;I/O event notification facility&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查看机制&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;man 7 epoll
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;其他读写函数&quot;&gt;其他读写函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;readv&lt;/li&gt;
  &lt;li&gt;writev&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;read or write data into multiple buffers&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/uio.h&amp;gt;
ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
ssize_t preadv(int fd, const struct iovec *iov, int iovcnt,
off_t offset);
ssize_t pwritev(int fd, const struct iovec *iov, int iovcnt,
off_t offset);
ssize_t preadv2(int fd, const struct iovec *iov, int iovcnt,
off_t offset, int flags);
ssize_t pwritev2(int fd, const struct iovec *iov, int iovcnt,
off_t offset, int flags);
struct iovec {
               void  *iov_base;    /* Starting address */
               size_t iov_len;     /* Number of bytes to transfer */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;存储映射io&quot;&gt;存储映射IO&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;mmap&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;map or unmap files or devices into memory&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/mman.h&amp;gt;
void *mmap(void *addr, size_t length, int prot, int flags,
int fd, off_t offset);
int munmap(void *addr, size_t length);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;文件锁&quot;&gt;文件锁&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;lockf&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;test or remove a POSIX lock on an open file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int lockf(int fd, int cmd, off_t len);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;flock&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;apply or remove an advisory lock on an open file&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/file.h&amp;gt;
int flock(int fd, int operation);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;有限状态机编程&quot;&gt;有限状态机编程&lt;/h1&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">排序算法</title><link href="http://localhost:4000/_posts/2020-06-06-%E6%8E%92%E5%BA%8F/" rel="alternate" type="text/html" title="排序算法" /><published>2020-06-06T00:00:00+08:00</published><updated>2020-06-06T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E6%8E%92%E5%BA%8F</id><content type="html" xml:base="http://localhost:4000/_posts/2020-06-06-%E6%8E%92%E5%BA%8F/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/冒泡排序.webp&quot; alt=&quot;冒泡排序&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void BubbleSort(int *array,int length)
{
    if (array == NULL)
    {
        fprintf(stderr,&quot;empty\n&quot;);
        exit(1);
    }
    int temp = 0;
    for (size_t i = 0; i &amp;lt; length; i++)
    {
        for (size_t j = i+1; j &amp;lt; length; j++)
        {
            if (array[i] &amp;gt; array[j])
            {
                temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            } 
        }          
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;选择排序&quot;&gt;选择排序&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;在一个长度为 N 的无序数组中，第一次遍历 n-1 个数找到最小的和第一个数交换。&lt;/li&gt;
  &lt;li&gt;第二次从下一个数开始遍历 n-2 个数，找到最小的数和第二个数交换。&lt;/li&gt;
  &lt;li&gt;重复以上操作直到第 n-1 次遍历最小的数和第 n-1 个数交换，排序完成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/选择排序.gif&quot; alt=&quot;选择排序&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void SelectSort(int *array,int length)
{
    if (array == NULL || length == 0)
    {
        fprintf(stderr,&quot;empty\n&quot;);
        exit(1);
    }
    for (size_t i = 0; i &amp;lt; length; i++)
    {
        int MinKey = array[i];
        for (size_t j = i; j &amp;lt; length; j++)
        {
            if (MinKey &amp;gt; array[j])
            {
                int temp = array[j];
                array[j] = MinKey;
                MinKey = temp;
            } 
        }
           array[i] = MinKey;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;快速排序&quot;&gt;快速排序&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先设定一个分界值，通过该分界值将数组分成左右两部分。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/快速排序.gif&quot; alt=&quot;快速排序&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="算法" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程-并发</title><link href="http://localhost:4000/_posts/2020-05-30-linux%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91/" rel="alternate" type="text/html" title="linux编程-并发" /><published>2020-05-30T00:00:00+08:00</published><updated>2020-05-30T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-30-linux%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;信号&quot;&gt;信号&lt;/h1&gt;

&lt;h2 id=&quot;信号概念&quot;&gt;信号概念&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;同步:&lt;/p&gt;

  &lt;p&gt;异步:&lt;/p&gt;

  &lt;p&gt;异步事件的处理:查询法,通知法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;信号是软件的&lt;code&gt;中断&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;signal&quot;&gt;signal&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;void(&lt;em&gt;signal(intosignum,void (&lt;/em&gt;func)(int)))(int)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;信号会打断阻塞的系统调用&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;信号不可靠&quot;&gt;信号不可靠&lt;/h2&gt;

&lt;h2 id=&quot;可重入函数&quot;&gt;可重入函数&lt;/h2&gt;

&lt;p&gt;所有的系统调用都是可重入的,一部分库函数也可以重入,如memcpy&lt;/p&gt;

&lt;h2 id=&quot;信号响应过程&quot;&gt;信号响应过程&lt;/h2&gt;

&lt;h2 id=&quot;常用函数&quot;&gt;常用函数&lt;/h2&gt;

&lt;h3 id=&quot;kill&quot;&gt;kill&lt;/h3&gt;

&lt;p&gt;send signal to a process&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;signal.h&amp;gt;
int kill(pid_t pid, int sig);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;raise&quot;&gt;raise&lt;/h3&gt;

&lt;p&gt;send a signal to the caller&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int raise(int sig);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;alarm&quot;&gt;alarm&lt;/h3&gt;

&lt;p&gt;set an alarm clock for delivery of a signal&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
unsigned int alarm(unsigned int seconds);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;pause&quot;&gt;pause&lt;/h3&gt;

&lt;p&gt;wait for signal&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int pause(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;setitimer&quot;&gt;setitimer&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/time.h&amp;gt;
int getitimer(int which, struct itimerval *curr_value);
int setitimer(int which, const struct itimerval *new_value,
struct itimerval *old_value);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽量用setitimer不要alarm&lt;/p&gt;

&lt;h3 id=&quot;abort&quot;&gt;abort&lt;/h3&gt;

&lt;p&gt;cause abnormal process termination&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
void abort(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;system&quot;&gt;system&lt;/h3&gt;

&lt;p&gt;execute a shell command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int system(const char *command);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;During  execution  of  the command, SIGCHLD will be blocked, and SIGINT
       and SIGQUIT will be ignored, in the process that calls system()  (these
       signals  will  be  handled according to their defaults inside the child
       process that executes command)&lt;/p&gt;

&lt;h3 id=&quot;sleep&quot;&gt;sleep&lt;/h3&gt;

&lt;p&gt;sleep for a specified number of seconds&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
unsigned int sleep(unsigned int seconds);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;信号集&quot;&gt;信号集&lt;/h2&gt;

&lt;p&gt;sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX sig‐nal set operations&lt;/p&gt;

&lt;p&gt;类型:sigset_t&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
int sigismember(const sigset_t *set, int signum);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;sigpending&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigpending(sigset_t *set);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;信号屏蔽字pending集的处理&quot;&gt;信号屏蔽字/pending集的处理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;sigprocmask&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;sigprocmask, rt_sigprocmask - examine and change blocked signals&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
/* Prototype for the glibc wrapper function */
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
/* Prototype for the underlying system call */
int rt_sigprocmask(int how, const kernel_sigset_t *set,
kernel_sigset_t *oldset, size_t sigsetsize);
/* Prototype for the legacy system call (deprecated) */
int sigprocmask(int how, const old_kernel_sigset_t *set,
old_kernel_sigset_t *oldset);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;联系mask和pending的位图,理解原理&lt;/p&gt;

&lt;h2 id=&quot;扩展函数&quot;&gt;扩展函数&lt;/h2&gt;

&lt;h3 id=&quot;sigsuspend&quot;&gt;sigsuspend&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigsuspend(const sigset_t *mask);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sigaction&quot;&gt;sigaction&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigaction(int signum, const struct sigaction *act,
struct sigaction *oldact);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;实时信号&quot;&gt;实时信号&lt;/h2&gt;

&lt;h1 id=&quot;线程&quot;&gt;线程&lt;/h1&gt;

&lt;h2 id=&quot;线程概念&quot;&gt;线程概念&lt;/h2&gt;

&lt;p&gt;posix标准&lt;/p&gt;

&lt;p&gt;openmp线程&lt;/p&gt;

&lt;p&gt;线程标识:pthread_t&lt;/p&gt;

&lt;p&gt;pthread_equal&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;compare thread IDs&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_equal(pthread_t t1, pthread_t t2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pthread_self&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;obtain ID of the calling thread&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
pthread_t pthread_self(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;线程创建&quot;&gt;线程创建&lt;/h2&gt;

&lt;p&gt;pthread_create&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;create a new thread&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
void *(*start_routine) (void *), void *arg);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程的调度取决于调度器策略&lt;/p&gt;

&lt;h2 id=&quot;线程终止&quot;&gt;线程终止&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;线程从启动例程返回,返回值就是线程的退出码&lt;/li&gt;
  &lt;li&gt;线程可以被同一进程中的其他线程取消&lt;/li&gt;
  &lt;li&gt;线程调用&lt;code&gt;pthread_exi&lt;/code&gt;t函数&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
void pthread_exit(void *retval);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pthread_join&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_join(pthread_t thread, void **retval);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;线程的取消选项&quot;&gt;线程的取消选项&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_cancel&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;send a cancellation request to a thread&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_cancel(pthread_t thread);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;可取消状态&lt;/li&gt;
  &lt;li&gt;取消类型(推迟取消)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;取消点必须是系统调用&lt;/p&gt;

&lt;h2 id=&quot;栈清理&quot;&gt;栈清理&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_cleanup_push&lt;/li&gt;
  &lt;li&gt;pthread_cleanup_pop&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;类似钩子函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancel-lation clean-up handlers&lt;/p&gt;

&lt;p&gt;必须匹配使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
void pthread_cleanup_push(void (*routine)(void *),
void *arg);
void pthread_cleanup_pop(int execute);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;线程同步&quot;&gt;线程同步&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ubuntu 环境需要安装:sudo apt-get install glibc-doc&lt;/p&gt;

  &lt;p&gt;sudo apt-get install manpages-posix-dev&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;互斥量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
pthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;
int  pthread_mutex_init(pthread_mutex_t  *mutex,  const  pthread_mutex‐
attr_t *mutexattr);
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
int pthread_mutex_destroy(pthread_mutex_t *mutex);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件变量&lt;/p&gt;

&lt;p&gt;类型:pthread_conf_t&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_cond_init&lt;/li&gt;
  &lt;li&gt;pthread_cond_signal&lt;/li&gt;
  &lt;li&gt;pthread_cond_broadcast&lt;/li&gt;
  &lt;li&gt;pthread_cond_wait&lt;/li&gt;
  &lt;li&gt;pthread_cond_timedwait&lt;/li&gt;
  &lt;li&gt;pthread_cond_destroy&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int    pthread_cond_init(pthread_cond_t    *cond,    pthread_condattr_t
*cond_attr);
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int   pthread_cond_timedwait(pthread_cond_t   *cond,    pthread_mutex_t
*mutex, const struct timespec *abstime);
int pthread_cond_destroy(pthread_cond_t *cond);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;信号量&lt;/p&gt;

&lt;p&gt;读写锁&lt;/p&gt;

&lt;p&gt;读锁-&amp;gt;共享锁;&lt;/p&gt;

&lt;p&gt;写锁-&amp;gt;互斥锁&lt;/p&gt;

&lt;h2 id=&quot;线程属性&quot;&gt;线程属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_attr_init&lt;/li&gt;
  &lt;li&gt;pthread_attr_destroy&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_attr_init(pthread_attr_t *attr);
int pthread_attr_destroy(pthread_attr_t *attr);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;pthread_attr_init, pthread_attr_destroy - initialize and destroy thread attributes object&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;详细参考 SEE ALSO&lt;/p&gt;

&lt;h2 id=&quot;线程同步属性&quot;&gt;线程同步属性&lt;/h2&gt;

&lt;p&gt;互斥量属性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_mutexattr_init&lt;/li&gt;
  &lt;li&gt;pthread_mutexattr_destroy&lt;/li&gt;
  &lt;li&gt;pthread_mutexattr_settype&lt;/li&gt;
  &lt;li&gt;pthread_mutexattr_gettype&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
int pthread_mutexattr_init(pthread_mutexattr_t *attr);
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind);
int  pthread_mutexattr_gettype(const  pthread_mutexattr_t  *attr,   int
*kind);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;clone&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;create a child process&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define _GNU_SOURCE
#include &amp;lt;sched.h&amp;gt;
int clone(int (*fn)(void *), void *child_stack,
int flags, void *arg, ...
/* pid_t *ptid, void *newtls, pid_t *ctid */ );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件变量属性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;pthread.h&amp;gt;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int    pthread_cond_init(pthread_cond_t    *cond,    pthread_condattr_t
*cond_attr);
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int   pthread_cond_timedwait(pthread_cond_t   *cond,    pthread_mutex_t
*mutex, const struct timespec *abstime);
int pthread_cond_destroy(pthread_cond_t *cond);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;更多参考SEE ALSO&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;重入&quot;&gt;重入&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;POSIX标准规定发布的库要支持并发,如果不支持,函数名称要体现出来&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;多线程中的io&quot;&gt;多线程中的IO&lt;/h3&gt;

&lt;h3 id=&quot;线程与信号&quot;&gt;线程与信号&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_sigmask&lt;/li&gt;
  &lt;li&gt;sigwait&lt;/li&gt;
  &lt;li&gt;pthread_kill&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int sigwait(const sigset_t *set, int *sig);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;signal.h&amp;gt;
int pthread_kill(pthread_t thread, int sig);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;线程与fork&quot;&gt;线程与fork&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;openmp标准&quot;&gt;openmp标准&lt;/h2&gt;

&lt;p&gt;www.OpenMP.org&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
int main(int argc, char const *argv[])
{
#pragma omp parallel
{
        puts(&quot;hello&quot;);
        puts(&quot;world&quot;);
}
         exit(0);
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">KMP算法</title><link href="http://localhost:4000/_posts/2020-05-26-KMP%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html" title="KMP算法" /><published>2020-05-26T00:00:00+08:00</published><updated>2020-05-26T00:00:00+08:00</updated><id>http://localhost:4000/_posts/KMP%E7%AE%97%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-26-KMP%E7%AE%97%E6%B3%95/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;bf&quot;&gt;BF&lt;/h1&gt;

&lt;p&gt;Brute-Force(BF) 算法又称naive算法，是对字符串子串搜索最简单明了的算法。其主旨就是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不处理模式串&lt;/li&gt;
  &lt;li&gt;模式串从目标串&lt;strong&gt;第一个元素&lt;/strong&gt;起逐一匹配&lt;/li&gt;
  &lt;li&gt;发现无法匹配，模式串匹配右移一位，从下一位目标串元素重新初始逐一元素匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/BF.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然简单易懂，但是同时也导致了复杂度较高，最慢的情形其复杂度可以到达O（模式串长 * 目标串长）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/BF_LOW.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;kmp&quot;&gt;&lt;strong&gt;KMP&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;但是如果仔细观察，可以发现&lt;strong&gt;模式串&lt;/strong&gt;本身是可以自带一些&lt;strong&gt;可被预先计算出&lt;/strong&gt;的&lt;strong&gt;可用于加速匹配的信息&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;当模式串的第K位失配时，前K-1位必然是匹配的，如果直接整体后移一位重新从头开始匹配那之前的那些&lt;strong&gt;已经匹配的信息&lt;/strong&gt;就被浪费了。于是我们可以寻找&lt;strong&gt;最大的必定不需要再匹配的串&lt;/strong&gt;，那这个串是什么呢？&lt;/p&gt;

&lt;p&gt;很显然，这个串就是[1,K-1]位串中&lt;strong&gt;最大且相同&lt;/strong&gt;的&lt;strong&gt;头尾&lt;/strong&gt;串（S）。当失配发生，可以直接&lt;strong&gt;保持目标串中的失配元素不变&lt;/strong&gt;，移动模式串，K-1-S串长个单位重新匹配，这就是KMP算法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/KMP.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么要移动K-1-S串长个单位？失配元素前方一共有K-1个元素，最大相同头尾串长为S。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/KMP2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;若移动小于K-1-S长度(例如K-1-S-1 = K - 1 - (S+1))，则必然无法匹配，因为不存在&lt;strong&gt;更大&lt;/strong&gt;的相同首尾串，如下图中（bab不是相同首尾串，故必然不匹配）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/KMP3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;若移动大于K-1-S长度(例如K-1-S+1 = K - 1 - (S-1))，有可能匹配（当S-1同样是相同子串时），但是可能会因为多移动了位数而遗漏结果。&lt;/p&gt;

&lt;p&gt;KMP算法本身比较好理解，而关于KMP的实现需要引入一个Next数组（由模式串预处理出的数组），Next数组的本身的算法则很难理解&lt;/p&gt;

&lt;h1 id=&quot;next数组&quot;&gt;&lt;strong&gt;Next数组&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Next数组的含义很直观，就是&lt;strong&gt;第几个元素失配时应该右移模式串重新匹配第几个元素&lt;/strong&gt;（不同的教材采用的首元素索引序号不同有的是0有的是1，这也是Next数组算法难以理解的一大原因，所以文中讨论索引序号都直接使用的是&lt;strong&gt;第&lt;/strong&gt;几个元素）。&lt;/p&gt;

&lt;p&gt;Next数组的算法步骤如下图所示，在我们逐步讨论完其算法过程后再会看这张动图或许你会有更深刻地理解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/next.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;逐步讨论&quot;&gt;&lt;strong&gt;逐步讨论&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;对于模式串的首个元素的Next值，约定为&lt;strong&gt;首元素索引值 - 1&lt;/strong&gt;，这么做仅仅是为了&lt;strong&gt;方便实现递归算法&lt;/strong&gt;。这个值&lt;strong&gt;不一定只为首元素的Next值&lt;/strong&gt;，经过优化后可能为其他元素的Next值，这个值（首元素索引 - 1）的含义是：&lt;/p&gt;

&lt;p&gt;将&lt;strong&gt;模式串&lt;/strong&gt;的&lt;strong&gt;首元素&lt;/strong&gt;移动到&lt;strong&gt;失配元素后一位&lt;/strong&gt;并从首元素开始，重新匹配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/next2.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;kmp实现&quot;&gt;KMP实现&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// T 模式串， S目标串， pos第几个字符之后搜索
// 约定索引起始值为1
void Index_KMP(SString S, SString T, int pos){
   // i 目标串指针，j 模式串指针
    i = pos; j = 1;
    // 只要指针没有溢出对应的串
    while( i &amp;lt;= length(S) &amp;amp;&amp;amp; j &amp;lt;= length(T)){
        // 如果将要和 目标串元素 匹配的元素是模式串首元素前一位的元素
        // 或者
        // 当前目标串元素 和 模式串元素可以匹配
        // if (j == first_indexof(T) - 1 || S[i] == T[j]){
        if(j == 0 || S[i] == T[j]){
           // 指针各自右移一位
            ++i;
            ++j;
        }else{
            // 发生了失配，查Next数组移动模式串指针
            j = next[j];
        }
    }
    if (j &amp;gt; length(T)){
        // 如果模式串指针溢出了（模式串指针匹配完毕了所有模式串中的元素）
       return i - length(T);
    }
    else return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;next&quot;&gt;next&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// T 模式串， next Next数组
// 约定索引起始值为1
void get_next(SString T, int &amp;amp;next[]){
    // i 计算每一个元素Next值的指针，它只可能右移用于计算下一个元素的Next值
    // j 用于指向 无法找到头尾串时 的递归回溯的元素 
    // 初始化第一个元素的Next值
    i = 1; next[1] = 0; j = 0;
    while(i &amp;lt; length(T)){
        // 如果递归回溯到第一个元素，它的next值为0，就无法继续回溯 -&amp;gt; 下一位元素的 Next值 就会等于 第一个元素的索引（1 即 0 + 1）
        // 如果 当前元素 等于 当前元素Next值对应的元素 -&amp;gt; 下一个元素的 Next值 就会等于 当前元素的Next值 + 1
        if (j == 0 || T[i] == T[j]){
            ++i; ++j; next[i] = j;
        }
        else{
            // 否则递归回溯j，将其指向更小的一个同首尾的子串的尾部 + 1
            j = next[j];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;nextval&quot;&gt;&lt;strong&gt;Nextval&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;(以下的讨论假设不需要递归以简化讨论过程)&lt;/p&gt;

&lt;p&gt;优化Next，当第&lt;code&gt;i+1&lt;/code&gt;位失配的时候。通常，我们按照算法会比较 &lt;code&gt;T[i]&lt;/code&gt; 和 &lt;code&gt;T[next[i]]&lt;/code&gt;，若它们相同则将&lt;code&gt;Next[i+1]&lt;/code&gt;设置成&lt;code&gt;Next[i] + 1&lt;/code&gt;。但是，如果 &lt;code&gt;T[Next[i] + 1]&lt;/code&gt;和失配元素（&lt;code&gt;T[i+1]&lt;/code&gt;）相同时，这样设置则是多余的（Next元素的含义就是，某个元素失配时用哪个元素补充匹配，若补充匹配的元素和失配元素相同则这样设置是多余的）。所以，此时应该把&lt;code&gt;Next[i+1]&lt;/code&gt;设置成&lt;code&gt;Next[Next[i] + 1]&lt;/code&gt;，就是当&lt;code&gt;Next[i]+1&lt;/code&gt;失配时应该用哪个元素补充匹配。&lt;/p&gt;

&lt;p&gt;那为什么&lt;code&gt;T[Next[Next[i] + 1]]&lt;/code&gt;不会等于&lt;code&gt;T[i+1]&lt;/code&gt;呢？因为按照这样的算法&lt;strong&gt;递推&lt;/strong&gt;是从第一个元素开始计算，可以确保除了当前失配的元素以外，&lt;strong&gt;之前的任意一个元素（索引为m）&lt;/strong&gt;都不可能等于&lt;code&gt;T[Next[m]+1]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;// T 模式串， next Next数组
// 约定索引起始值为1
void get_nextval(SString T, int &amp;amp;nextval[]){
    // i 计算每一个元素Next值的指针，它只可能右移用于计算下一个元素的Next值
    // j 用于指向 无法找到头尾串时 的递归回溯的元素 
    // 初始化第一个元素的Next值
    i = 1; nextval[1] = 0; j = 0;
    while(i &amp;lt; length(T)){
        // 如果递归回溯到第一个元素，它的next值为0，就无法继续回溯 
        // 如果 当前元素 等于 当前元素Next值对应的元素 
        if (j == 0 || T[i] == T[j]){
            ++i; ++j; 
            if(T[i] != T[j]){
                // 如果替补匹配的值不等于当前失配值,则设置它的索引为Next值
               nextval[i] = j;
            }
          else{
                // 否则设置它的Next值为当前失配值的Next值
                nextval[i] = next[j];
            }
        }
        else{
            // 否则递归回溯j，将其指向更小的一个同首尾的子串的尾部 + 1
            j = nextval[j];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/next3.webp&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="算法" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程-进程基础</title><link href="http://localhost:4000/_posts/2020-05-25-linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/" rel="alternate" type="text/html" title="linux编程-进程基础" /><published>2020-05-25T00:00:00+08:00</published><updated>2020-05-25T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-25-linux%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;进程标示符pid&quot;&gt;进程标示符pid&lt;/h1&gt;

&lt;p&gt;类型:pid_t&lt;/p&gt;

&lt;p&gt;命令:ps&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;getpid&lt;/li&gt;
  &lt;li&gt;getppid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t getpid(void);
pid_t getppid(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;进程产生&quot;&gt;进程产生&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;fork&lt;/li&gt;
  &lt;li&gt;vfork&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t fork(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t vfork(void);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
vfork():
Since glibc 2.12:
(_XOPEN_SOURCE &amp;gt;= 500) &amp;amp;&amp;amp; ! (_POSIX_C_SOURCE &amp;gt;= 200809L)
|| /* Since glibc 2.19: */ _DEFAULT_SOURCE
|| /* Glibc versions &amp;lt;= 2.19: */ _BSD_SOURCE
Before glibc 2.12:
_BSD_SOURCE || _XOPEN_SOURCE &amp;gt;= 500
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fork()  creates  a new process by duplicating the calling process.  The
       new process is referred to as the child process.  The  calling  process
       is referred to as the parent process.&lt;/p&gt;

&lt;p&gt;fork后父子进程区别:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;返回值不同&lt;/li&gt;
  &lt;li&gt;pid不同,ppid不同&lt;/li&gt;
  &lt;li&gt;未决信号和文件锁不继承&lt;/li&gt;
  &lt;li&gt;资源利用量清0&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;init进程:1号,是所有的进程的祖先进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;调度器的调度策略决定那个进程先运行&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在fork之前,尽量刷新所有的流:fflush&lt;很重要&gt;&lt;/很重要&gt;&lt;/p&gt;

&lt;h1 id=&quot;进程消亡以及资源释放&quot;&gt;进程消亡以及资源释放&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;wait&lt;/li&gt;
  &lt;li&gt;waitpid&lt;/li&gt;
  &lt;li&gt;waitid&lt;/li&gt;
  &lt;li&gt;wait3&lt;/li&gt;
  &lt;li&gt;wait4&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
pid_t wait(int *wstatus);
pid_t waitpid(pid_t pid, int *wstatus, int options);
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
/* This is the glibc and POSIX interface; see
NOTES for information on the raw system call. */
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
waitid():
Since glibc 2.26: _XOPEN_SOURCE &amp;gt;= 500 ||
_POSIX_C_SOURCE &amp;gt;= 200809L
Glibc 2.25 and earlier:
_XOPEN_SOURCE
|| /* Since glibc 2.12: */ _POSIX_C_SOURCE &amp;gt;= 200809L
|| /* Glibc versions &amp;lt;= 2.19: */ _BSD_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;exec函数族&quot;&gt;exec函数族&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
extern char **environ;
int execl(const char *path, const char *arg, ...
/* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
/* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
/*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
char *const envp[]);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
execvpe(): _GNU_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;用户权限以及组权限&quot;&gt;用户权限以及组权限&lt;/h1&gt;

&lt;p&gt;u+s&lt;/p&gt;

&lt;p&gt;g+s&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;getuid&lt;/li&gt;
  &lt;li&gt;geteuid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
uid_t getuid(void);
uid_t geteuid(void);
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
gid_t getgid(void);
gid_t getegid(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;setuid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int setuid(uid_t uid);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;setgid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int setgid(gid_t gid);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;setreuid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int setreuid(uid_t ruid, uid_t euid);
int setregid(gid_t rgid, gid_t egid);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;解释器文件&quot;&gt;解释器文件&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;system&quot;&gt;system&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int system(const char *command);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;fork&lt;/code&gt;+&lt;code&gt;exec&lt;/code&gt;+&lt;code&gt;wait&lt;/code&gt;封装&lt;/p&gt;

&lt;h1 id=&quot;进程会计&quot;&gt;进程会计&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;acct&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int acct(const char *filename);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不是标准,了解即可&lt;/p&gt;

&lt;h1 id=&quot;进程时间&quot;&gt;进程时间&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;times&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/times.h&amp;gt;
clock_t times(struct tms *buf);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;守护进程&quot;&gt;守护进程&lt;/h1&gt;

&lt;p&gt;session:sid&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;setsid&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
pid_t setsid(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;getpgrp&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int setpgid(pid_t pid, pid_t pgid);
pid_t getpgid(pid_t pid);
pid_t getpgrp(void);                 /* POSIX.1 version */
pid_t getpgrp(pid_t pid);            /* BSD version */
int setpgrp(void);                   /* System V version */
int setpgrp(pid_t pid, pid_t pgid);  /* BSD version */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;单实例守护进程:锁文件:/var/run/name.pid&lt;/p&gt;

&lt;p&gt;启动脚本文件: /etc/rc*…&lt;/p&gt;

&lt;h1 id=&quot;系统日志&quot;&gt;系统日志&lt;/h1&gt;

&lt;p&gt;syslogd服务&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;openlog&lt;/li&gt;
  &lt;li&gt;syslog&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;syslog.h&amp;gt;
void openlog(const char *ident, int option, int facility);
void syslog(int priority, const char *format, ...);
void closelog(void);
void vsyslog(int priority, const char *format, va_list ap);
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry></feed>