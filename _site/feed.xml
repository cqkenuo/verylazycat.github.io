<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-08T13:31:37+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">imod</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;iframe
  src=&quot;&quot;
  width=100%
  height=52
  frameborder=&quot;no&quot;
  border=&quot;0&quot;
  marginwidth=&quot;0&quot;
  marginheight=&quot;0&quot;
&gt;&lt;/iframe&gt;
</subtitle><entry><title type="html">git常用命令</title><link href="http://localhost:4000/_posts/2020-05-08-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="alternate" type="text/html" title="git常用命令" /><published>2020-05-08T00:00:00+08:00</published><updated>2020-05-08T00:00:00+08:00</updated><id>http://localhost:4000/_posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-08-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">&lt;p&gt;&lt;img src=&quot;/home/admin233/博客/verylazycat.github.io/img/git.png&quot; alt=&quot;git&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;workspace&lt;/code&gt;：工作区&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;index/stage&lt;/code&gt;：暂存区&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;repository&lt;/code&gt;:厂库区&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;remoter&lt;/code&gt;远程厂库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Git的设置文件为&lt;code&gt;.gitconfig&lt;/code&gt;，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;#查看配置
git config --list

#编辑配置
git config -e [--global]

#设置提交代码用户配置
git config --global user.name  &quot;[name]&quot;
git config --global user.email &quot;[email address]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建代码库&quot;&gt;创建代码库&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;git init
git clone  url
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;增加删除&quot;&gt;增加/删除&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;#添加到暂存区
git add file  

#添加指定目录到暂存区
git add  dir

#添加当前目录所有文件到暂存区
git add . 

#对于同一个文件的多处变化，可以实现分次提交
git add -p

# 删除工作区文件，并且将这次删除放入暂存区
git rm [file1] [file2]

# 停止追踪指定文件，但该文件会保留在工作区
git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
git mv [file-original] [file-renamed]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;代码提交&quot;&gt;代码提交&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# 提交暂存区到仓库区
git commit -m [message]

# 提交暂存区的指定文件到仓库区
git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
git commit -a

# 提交时显示所有diff信息
git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
git commit --amend [file1] [file2] 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;分支&quot;&gt;分支&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;
# 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]

# 本地存在一个分支，名称叫：develop_chen，但远程没有怎么办？

git push origin develop_chen

这样就在远程建立一个和本地一样的分支 

git branch --set-upstream-to=origin/develop  develop  本地分支和远程分支简历跟踪关系
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;标签&quot;&gt;标签&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;查看信息&quot;&gt;查看信息&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的代码差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog

# 从本地master拉取代码更新当前分支：branch 一般为master
$ git rebase [branch]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;远程同步&quot;&gt;远程同步&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ git remote update  --更新远程仓储
# 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;撤销&quot;&gt;撤销&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;合并&quot;&gt;合并&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;git checkout dev           #切换到dev开发分支
git pull
git checkout master
git merge dev              #合并dev分支到master上
git push origin master     #将代码推到master上
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="git" /><summary type="html"></summary></entry><entry><title type="html">JAVA一些问题三</title><link href="http://localhost:4000/_posts/2020-05-07-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%89/" rel="alternate" type="text/html" title="JAVA一些问题三" /><published>2020-05-07T00:00:00+08:00</published><updated>2020-05-07T00:00:00+08:00</updated><id>http://localhost:4000/_posts/JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%89</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-07-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%89/">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;并行和并发有什么区别&quot;&gt;&lt;strong&gt;并行和并发有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。&lt;/li&gt;
  &lt;li&gt;并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。&lt;/li&gt;
  &lt;li&gt;在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程和进程的区别&quot;&gt;&lt;strong&gt;线程和进程的区别？&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;守护线程是什么&quot;&gt;&lt;strong&gt;守护线程是什么？&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建线程有哪几种方式&quot;&gt;&lt;strong&gt;创建线程有哪几种方式&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①. 继承Thread类创建线程类&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。&lt;/li&gt;
  &lt;li&gt;创建Thread子类的实例，即创建了线程对象。&lt;/li&gt;
  &lt;li&gt;调用线程对象的start()方法来启动该线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;②. 通过Runnable接口创建线程类&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。&lt;/li&gt;
  &lt;li&gt;创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。&lt;/li&gt;
  &lt;li&gt;调用线程对象的start()方法来启动该线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;③. 通过Callable和Future创建线程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。&lt;/li&gt;
  &lt;li&gt;创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。&lt;/li&gt;
  &lt;li&gt;使用FutureTask对象作为Thread对象的target创建并启动新线程。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;runnable-和-callable-区别&quot;&gt;runnable 和 callable 区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有点深的问题了，也看出一个Java程序员学习知识的广度。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程有哪些状态&quot;&gt;&lt;strong&gt;线程有哪些状态&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。&lt;/p&gt;

&lt;p&gt;就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。&lt;/p&gt;

&lt;p&gt;运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。&lt;/p&gt;

&lt;p&gt;阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。&lt;/p&gt;

&lt;p&gt;死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;sleep-和-wait-区别&quot;&gt;&lt;strong&gt;sleep() 和 wait() 区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep()  方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。&lt;/p&gt;

&lt;p&gt;wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;notify和-notifyall有什么区别&quot;&gt;&lt;strong&gt;notify()和 notifyAll()有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。&lt;/p&gt;

&lt;p&gt;当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait  线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。&lt;/p&gt;

&lt;p&gt;优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized  代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程的-run和-start有什么区别&quot;&gt;&lt;strong&gt;线程的 run()和 start()有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。&lt;/p&gt;

&lt;p&gt;start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态，  这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。&lt;/p&gt;

&lt;p&gt;run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建线程池有哪几种方式&quot;&gt;&lt;strong&gt;创建线程池有哪几种方式&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①. newFixedThreadPool(int nThreads)&lt;/p&gt;

&lt;p&gt;创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。&lt;/p&gt;

&lt;p&gt;②. newCachedThreadPool()&lt;/p&gt;

&lt;p&gt;创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。&lt;/p&gt;

&lt;p&gt;③. newSingleThreadExecutor()&lt;/p&gt;

&lt;p&gt;这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。&lt;/p&gt;

&lt;p&gt;④. newScheduledThreadPool(int corePoolSize)&lt;/p&gt;

&lt;p&gt;创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程池都有哪些状态&quot;&gt;&lt;strong&gt;线程池都有哪些状态&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。&lt;/p&gt;

&lt;p&gt;线程池各个状态切换框架图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/线程池.png&quot; alt=&quot;线程池&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程池中-submit和-execute方法有什么区别&quot;&gt;&lt;strong&gt;线程池中 submit()和 execute()方法有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;接收的参数不一样&lt;/li&gt;
  &lt;li&gt;submit有返回值，而execute没有&lt;/li&gt;
  &lt;li&gt;submit方便Exception处理&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;在-java-程序中怎么保证多线程的运行安全&quot;&gt;&lt;strong&gt;在 java 程序中怎么保证多线程的运行安全&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程安全在三个方面体现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；&lt;/li&gt;
  &lt;li&gt;可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；&lt;/li&gt;
  &lt;li&gt;有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;多线程锁的升级原理是什么&quot;&gt;&lt;strong&gt;多线程锁的升级原理是什么&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。&lt;/p&gt;

&lt;p&gt;锁升级的图示过程:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/锁升级.png&quot; alt=&quot;锁升级&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;什么是死锁&quot;&gt;&lt;strong&gt;什么是死锁&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;怎么防止死锁&quot;&gt;&lt;strong&gt;怎么防止死锁&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;死锁的四个必要条件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源&lt;/li&gt;
  &lt;li&gt;请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放&lt;/li&gt;
  &lt;li&gt;不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放&lt;/li&gt;
  &lt;li&gt;环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。&lt;/p&gt;

&lt;p&gt;理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。&lt;/p&gt;

&lt;p&gt;所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。&lt;/p&gt;

&lt;p&gt;此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;threadlocal-是什么有哪些使用场景&quot;&gt;&lt;strong&gt;ThreadLocal 是什么？有哪些使用场景&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web  服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;说一下-synchronized-底层实现原理&quot;&gt;&lt;strong&gt;说一下 synchronized 底层实现原理&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。&lt;/p&gt;

&lt;p&gt;Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;普通同步方法，锁是当前实例对象&lt;/li&gt;
  &lt;li&gt;静态同步方法，锁是当前类的class对象&lt;/li&gt;
  &lt;li&gt;同步方法块，锁是括号里面的对象&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;synchronized-和-volatile-的区别是什么&quot;&gt;&lt;strong&gt;synchronized 和 volatile 的区别是什么&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。&lt;/li&gt;
  &lt;li&gt;volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。&lt;/li&gt;
  &lt;li&gt;volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。&lt;/li&gt;
  &lt;li&gt;volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。&lt;/li&gt;
  &lt;li&gt;volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;synchronized-和-lock-有什么区别&quot;&gt;&lt;strong&gt;synchronized 和 Lock 有什么区别&lt;/strong&gt;&lt;/h2&gt;

    &lt;ol&gt;
      &lt;li&gt;首先synchronized是java内置关键字，在jvm层面，Lock是个java类；&lt;/li&gt;
      &lt;li&gt;synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；&lt;/li&gt;
      &lt;li&gt;synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；&lt;/li&gt;
      &lt;li&gt;用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；&lt;/li&gt;
      &lt;li&gt;synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；&lt;/li&gt;
      &lt;li&gt;Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;synchronized-和-reentrantlock-区别是什么&quot;&gt;&lt;strong&gt;synchronized 和 ReentrantLock 区别是什么&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁&lt;/li&gt;
  &lt;li&gt;ReentrantLock可以获取各种锁的信息&lt;/li&gt;
  &lt;li&gt;ReentrantLock可以灵活地实现多路通知&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;atomic-的原理&quot;&gt;&lt;strong&gt;atomic 的原理&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。&lt;/p&gt;

&lt;p&gt;Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题&lt;/p&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">并行和并发有什么区别</summary></entry><entry><title type="html">JAVA一些问题二</title><link href="http://localhost:4000/_posts/2020-05-06-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%BA%8C/" rel="alternate" type="text/html" title="JAVA一些问题二" /><published>2020-05-06T00:00:00+08:00</published><updated>2020-05-06T00:00:00+08:00</updated><id>http://localhost:4000/_posts/JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%BA%8C</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-06-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%BA%8C/">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;java-容器都有哪些&quot;&gt;&lt;strong&gt;java 容器都有哪些&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2&gt;&lt;img src=&quot;/img/容器.png&quot; alt=&quot;容器&quot; /&gt;&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;collection-和-collections-有什么区别&quot;&gt;&lt;strong&gt;Collection 和 Collections 有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;java.util.Collection &lt;/code&gt;是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java  类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set&lt;/li&gt;
  &lt;li&gt;Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;listsetmap-之间的区别是什么&quot;&gt;&lt;strong&gt;List、Set、Map 之间的区别是什么&lt;img src=&quot;/img/区别.png&quot; alt=&quot;区别&quot; /&gt;&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;hashmap-和-hashtable-有什么区别&quot;&gt;&lt;strong&gt;HashMap 和 Hashtable 有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法&lt;/li&gt;
  &lt;li&gt;hashTable同步的，而HashMap是非同步的，效率上比hashTable要高&lt;/li&gt;
  &lt;li&gt;hashMap允许空键值，而hashTable不允许。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;如何决定使用-hashmap-还是-treemap&quot;&gt;&lt;strong&gt;如何决定使用 HashMap 还是 TreeMap&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;hashmap-的实现原理&quot;&gt;&lt;strong&gt;HashMap 的实现原理&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&lt;/p&gt;

&lt;p&gt;HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。&lt;/p&gt;

&lt;p&gt;当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。&lt;/p&gt;

&lt;p&gt;需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;hashset-的实现原理&quot;&gt;&lt;strong&gt;HashSet 的实现原理&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;HashSet底层由HashMap实现&lt;/li&gt;
  &lt;li&gt;HashSet的值存放于HashMap的key上&lt;/li&gt;
  &lt;li&gt;HashMap的value统一为PRESENT&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;arraylist-和-linkedlist-的区别&quot;&gt;**ArrayList 和 LinkedList 的区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;数组和-list-之间的转换&quot;&gt;&lt;strong&gt;数组和 List 之间的转换&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;List转换成为数组：调用ArrayList的toArray方法。&lt;/li&gt;
  &lt;li&gt;数组转换成为List：调用Arrays的asList方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;arraylist-和-vector-的区别&quot;&gt;**ArrayList 和 Vector 的区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。&lt;/li&gt;
  &lt;li&gt;ArrayList比Vector快，它因为有同步，不会过载。&lt;/li&gt;
  &lt;li&gt;ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;array-和-arraylist-区别&quot;&gt;&lt;strong&gt;Array 和 ArrayList 区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Array可以容纳基本类型和对象，而ArrayList只能容纳对象。&lt;/li&gt;
  &lt;li&gt;Array是指定大小的，而ArrayList大小是固定的。&lt;/li&gt;
  &lt;li&gt;Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;-queue-中-poll和-remove区别&quot;&gt;** Queue 中 poll()和 remove()区别**&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;哪些集合类是线程安全的&quot;&gt;&lt;strong&gt;哪些集合类是线程安全的&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。&lt;/li&gt;
  &lt;li&gt;statck：堆栈类，先进后出。&lt;/li&gt;
  &lt;li&gt;hashtable：就比hashmap多了个线程安全。&lt;/li&gt;
  &lt;li&gt;enumeration：枚举，相当于迭代器&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;迭代器-iterator-是什么&quot;&gt;&lt;strong&gt;迭代器 Iterator 是什么&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;iterator-怎么使用有什么特点&quot;&gt;&lt;strong&gt;Iterator 怎么使用？有什么特点&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java中的Iterator功能比较简单，并且只能单向移动：&lt;/p&gt;

&lt;p&gt;(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。&lt;/p&gt;

&lt;p&gt;(2) 使用next()获得序列中的下一个元素。&lt;/p&gt;

&lt;p&gt;(3) 使用hasNext()检查序列中是否还有元素。&lt;/p&gt;

&lt;p&gt;(4) 使用remove()将迭代器新返回的元素删除。&lt;/p&gt;

&lt;p&gt;Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;iterator-和-listiterator-有什么区别&quot;&gt;&lt;strong&gt;Iterator 和 ListIterator 有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。&lt;/li&gt;
  &lt;li&gt;Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。&lt;/li&gt;
  &lt;li&gt;ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">java 容器都有哪些</summary></entry><entry><title type="html">新型冠状肺炎数据可视化</title><link href="http://localhost:4000/_posts/2020-05-06-%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E8%82%BA%E7%82%8E%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="alternate" type="text/html" title="新型冠状肺炎数据可视化" /><published>2020-05-06T00:00:00+08:00</published><updated>2020-05-06T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E8%82%BA%E7%82%8E%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-06-%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E8%82%BA%E7%82%8E%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">&lt;h4 id=&quot;时间20200110--20200412&quot;&gt;时间:2020.01.10 ~ 2020.04.12&lt;/h4&gt;

&lt;h4 id=&quot;国内数据&quot;&gt;国内数据&lt;/h4&gt;

&lt;h4 id=&quot;主要数据来源&quot;&gt;主要数据来源：&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-http&quot;&gt;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5
https://view.inews.qq.com/g2/getOnsInfo?name=disease_other
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后续网站可能没有维护，在此保存了&lt;code&gt;sql&lt;/code&gt;文件:&lt;code&gt;cov.sql&lt;/code&gt;,您只需导入即可&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用前请修改相应的&lt;code&gt;sql&lt;/code&gt;连接配置&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;spider.py &lt;/code&gt;&amp;amp; &lt;code&gt;utils.py&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt; conn = pymysql.connect(host=&quot;######&quot;, user=&quot;#####&quot;, password=&quot;#######&quot;, db=&quot;cov&quot;, charset=&quot;utf8&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/img/cov.jpg&quot; alt=&quot;cov&quot; /&gt;&lt;/p&gt;

&lt;p&gt;项目地址:https://github.com/verylazycat/COV_2020&lt;/p&gt;</content><author><name></name></author><category term="数据可视化" /><summary type="html">时间:2020.01.10 ~ 2020.04.12</summary></entry><entry><title type="html">JAVA一些问题一</title><link href="http://localhost:4000/_posts/2020-05-05-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%80/" rel="alternate" type="text/html" title="JAVA一些问题一" /><published>2020-05-05T00:00:00+08:00</published><updated>2020-05-05T00:00:00+08:00</updated><id>http://localhost:4000/_posts/JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%80</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-05-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%80/">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;jdk--jre区别&quot;&gt;&lt;code&gt;JDK&lt;/code&gt; &amp;amp; &lt;code&gt;JRE&lt;/code&gt;区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;JRE&lt;/code&gt;:Java RunTime Environment&lt;/p&gt;

&lt;p&gt;&lt;code&gt;JDK&lt;/code&gt;:Java Development Kit&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器&lt;code&gt;javac&lt;/code&gt;，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/jdk&amp;amp;jre.png&quot; alt=&quot;jdk&amp;amp;jre&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;-和equals区别&quot;&gt;&lt;code&gt;==&lt;/code&gt; 和&lt;code&gt;equals&lt;/code&gt;区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;==&lt;/code&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;基本类型:&lt;code&gt;==&lt;/code&gt;比较值是否相同&lt;/li&gt;
      &lt;li&gt;引用类型:&lt;code&gt;==&lt;/code&gt;比较引用是否相同&lt;/li&gt;
    &lt;/ol&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String x = &quot;string&quot;;
String y = &quot;string&quot;;
String z = new String(&quot;string&quot;);
System.out.println(x==y);  //true
System.out.println(x==z);  //false
System.out.println(x.equals(y));  //true
System.out.println(x.equals(z));  //true
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;equals&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;String&lt;/code&gt;和&lt;code&gt;Integer&lt;/code&gt;重写了equals方法,默认&lt;code&gt;equals&lt;/code&gt;比较有相同值的对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;static class  Cat{
        private  String name;
        public Cat(String name){
            this.name = name;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
    public static void main(String[] args) {
        Cat cat1  = new Cat(&quot;one&quot;);
        Cat cat2 = new Cat(&quot;one&quot;);
        System.out.println(cat1.equals(cat2)); // false
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;equals源码 (本质就是&lt;code&gt;==&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public boolean equals(Object var1) {
    return this == var1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;String 重写了&lt;code&gt;equals&lt;/code&gt;，源码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public boolean equals(Object var1) {
    if (this == var1) {
        return true;
    } else {
        if (var1 instanceof String) {
            String var2 = (String)var1;
            int var3 = this.value.length;
            if (var3 == var2.value.length) {
                char[] var4 = this.value;
                char[] var5 = var2.value;
                for(int var6 = 0; var3-- != 0; ++var6) {
                    if (var4[var6] != var5[var6]) {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：&lt;code&gt;==&lt;/code&gt;用于值的比较,&lt;code&gt;equals&lt;/code&gt;用于引用的比较，不过String ,Integer等重写了&lt;code&gt;equals&lt;/code&gt;，所以一般情况下，&lt;code&gt;equals&lt;/code&gt;比较值是否相同&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;hashcode相同equals一定为true吗&quot;&gt;&lt;code&gt;hashcode&lt;/code&gt;相同,&lt;code&gt;equals&lt;/code&gt;一定为&lt;code&gt;true&lt;/code&gt;吗?&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不一定，反例如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String str1 = &quot;通话&quot;;
String str2 = &quot;重地&quot;;
//        str:1179395 | str2:1179395
System.out.println(String.format(&quot;str:%d | str2:%d&quot;,str1.hashCode(),str2.hashCode()));
//        false
System.out.println(str1.equals(str2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在散列表中，&lt;code&gt;hashcode&lt;/code&gt;相等则两个键值对的哈希值相等，然而哈希值相等，并不能得出键值对相等&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;final&quot;&gt;&lt;code&gt;final&lt;/code&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;final&lt;/code&gt;修饰的类叫最终类，，不能被继承&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;final&lt;/code&gt;修饰的方法不能被重写&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;final&lt;/code&gt;修饰的变量叫常量，必须被初始化，之后不能被修改&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;mathround-15值&quot;&gt;Math.round(-1.5)值&lt;/h2&gt;

    &lt;p&gt;-1&lt;/p&gt;

    &lt;p&gt;中间值0.5向右取&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;java基础数据类型&quot;&gt;Java基础数据类型&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;byte&lt;/li&gt;
  &lt;li&gt;boolean&lt;/li&gt;
  &lt;li&gt;char&lt;/li&gt;
  &lt;li&gt;short&lt;/li&gt;
  &lt;li&gt;int&lt;/li&gt;
  &lt;li&gt;float&lt;/li&gt;
  &lt;li&gt;long&lt;/li&gt;
  &lt;li&gt;double&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;字符串操作类&quot;&gt;字符串操作类&lt;/h2&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;StringBuffer&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;StringBuilder&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;code&gt;String&lt;/code&gt;声明的是不可变的对象，每次操作都会产生新的&lt;code&gt;String&lt;/code&gt;对象，然后指针指向新的对象，&lt;code&gt;StringBuffer&lt;/code&gt;和&lt;code&gt;StringBuilder&lt;/code&gt;可以在原有的对象上操作．&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt;和&lt;code&gt;StringBuilder&lt;/code&gt;区别：&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt;是线程安全的，而&lt;code&gt;StringBuilder&lt;/code&gt;是非线程安全的，但是&lt;code&gt;StringBuilder&lt;/code&gt;性能高于&lt;code&gt;SringBuffer&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;string-stri与-string-strnew-stringi一样吗&quot;&gt;String str=”i”与 String str=new String(“i”)一样吗？&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不一样，内存分配方式不一样．String str=”i”的方式，java 虚拟机会将其分配到&lt;code&gt;常量池&lt;/code&gt;中；而 String str=new String(“i”) 则会被分到&lt;code&gt;堆内存&lt;/code&gt;中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;如何将字符串反转&quot;&gt;如何将字符串反转？&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用&lt;code&gt;StringBuilder&lt;/code&gt;或者&lt;code&gt;StringBuffer&lt;/code&gt;的&lt;code&gt;reverse()&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
		StringBuilder str = new StringBuilder(&quot;hello&quot;);
		System.out.println(str.reverse());    //olleh
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;string-类的常用方法都有那些&quot;&gt;&lt;strong&gt;String 类的常用方法都有那些&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;indexOf()：返回指定字符的索引&lt;/li&gt;
  &lt;li&gt;charAt()：返回指定索引处的字符&lt;/li&gt;
  &lt;li&gt;replace()：字符串替换&lt;/li&gt;
  &lt;li&gt;trim()：去除字符串两端空白&lt;/li&gt;
  &lt;li&gt;split()：分割字符串，返回一个分割后的字符串数组&lt;/li&gt;
  &lt;li&gt;getBytes()：返回字符串的 byte 类型数组&lt;/li&gt;
  &lt;li&gt;length()：返回字符串长度&lt;/li&gt;
  &lt;li&gt;toLowerCase()：将字符串转成小写字母&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;toUpperCase()：将字符串转成大写字符&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;substring()：截取字符串&lt;/li&gt;
  &lt;li&gt;equals()：字符串比较&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String str = new String(&quot; Hello &quot;);
		System.out.println(str.indexOf('o'));
		System.out.println(str.charAt(1));
		System.out.println(str.replace('o', 'O'));
		System.out.println(str.trim());
		System.out.println(str.getBytes());
		System.out.println(str.length());
		System.out.println(str.toLowerCase());
		System.out.println(str.toUpperCase());
		System.out.println(str.substring(1, 3));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;抽象类必须要有抽象方法吗&quot;&gt;&lt;strong&gt;抽象类必须要有抽象方法吗&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;abstract class Cat {
    public static void sayHi() {
        System.out.println(&quot;hi~&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;普通类和抽象类有哪些区别&quot;&gt;&lt;strong&gt;普通类和抽象类有哪些区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;普通类不能包含抽象方法，抽象类可以包含抽象方法&lt;/li&gt;
  &lt;li&gt;抽象类不能直接实例化，普通类可以直接实例化&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;抽象类能使用-final-修饰吗&quot;&gt;&lt;strong&gt;抽象类能使用 final 修饰吗&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;接口和抽象类有什么区别&quot;&gt;&lt;strong&gt;接口和抽象类有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口&lt;/li&gt;
  &lt;li&gt;构造函数：抽象类可以有构造函数；接口不能有&lt;/li&gt;
  &lt;li&gt;main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法&lt;/li&gt;
  &lt;li&gt;实现数量：类可以实现很多个接口；但是只能继承一个抽象类&lt;/li&gt;
  &lt;li&gt;访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;java-中-io-流分为几种&quot;&gt;&lt;strong&gt;java 中 IO 流分为几种&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按功能来分：输入流（input）、输出流（output）。&lt;/p&gt;

&lt;p&gt;按类型来分：字节流和字符流。&lt;/p&gt;

&lt;p&gt;字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;bionioaio-有什么区别&quot;&gt;&lt;strong&gt;&lt;code&gt;BIO&lt;/code&gt;、&lt;code&gt;NIO&lt;/code&gt;、&lt;code&gt;AIO&lt;/code&gt; 有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低&lt;/li&gt;
  &lt;li&gt;NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用&lt;/li&gt;
  &lt;li&gt;AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;files的常用方法都有哪些&quot;&gt;&lt;strong&gt;Files的常用方法都有哪些&lt;/strong&gt;&lt;/h2&gt;

    &lt;ol&gt;
      &lt;li&gt;Files.exists()：检测文件路径是否存在&lt;/li&gt;
      &lt;li&gt;Files.createFile()：创建文件&lt;/li&gt;
      &lt;li&gt;Files.createDirectory()：创建文件夹&lt;/li&gt;
      &lt;li&gt;Files.delete()：删除一个文件或目录&lt;/li&gt;
      &lt;li&gt;Files.copy()：复制文件&lt;/li&gt;
      &lt;li&gt;Files.move()：移动文件&lt;/li&gt;
      &lt;li&gt;Files.size()：查看文件个数&lt;/li&gt;
      &lt;li&gt;Files.read()：读取文件&lt;/li&gt;
      &lt;li&gt;Files.write()：写入文件&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">JDK &amp;amp; JRE区别</summary></entry><entry><title type="html">数据结构－线性表</title><link href="http://localhost:4000/_posts/2020-05-04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="alternate" type="text/html" title="数据结构－线性表" /><published>2020-05-04T00:00:00+08:00</published><updated>2020-05-04T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/">&lt;h4 id=&quot;创建线性表和链表实现表之间的链接并去掉重复&quot;&gt;创建线性表和链表，实现表之间的链接，并去掉重复&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;error.h&amp;gt;

//数据类型声明
typedef int DataType;

//顺序表实现
//顺序表结构定义
typedef struct orderList
{
    DataType *value;//数据
    size_t size;//当前数据大小
    size_t max;//最大存储容量
}orderList;

//创建orderList
orderList *CreateOrderList(void)
{
    orderList *list = NULL;
    list = malloc(sizeof(orderList *));
    if (list == NULL)
    {
        perror(&quot;malloc:&quot;);
        exit(EXIT_FAILURE);
    }
    else
    {
        printf(&quot;顺序表创建成功!,adress:%p\n&quot;,list);
        printf(&quot;---------------------------------------\n&quot;);
        return list;
    }
}

//orderList 初始化
//max : 最大长度
int OrderListInit(orderList *list,size_t max)
{
    list-&amp;gt;value = malloc(sizeof(DataType) * max);
    if (list-&amp;gt;value == NULL)
    {
        perror(&quot;malloc&quot;);
        // exit(EXIT_FAILURE);
        return -1;
    }
    list-&amp;gt;size = 0;
    list-&amp;gt;max = max;
    return 1;
}

//顺序表插入值，当插入-1退出
//有缺陷，不能插入-1
void InsertOrderList(orderList *list)
{
    if (list == NULL)
    {
        printf(&quot;list is not create or init \n&quot;);
        exit(EXIT_FAILURE);
    }
    printf(&quot;Enter the value you want,while enter -1 exit:\n&quot;);
    //计数，是否达到上限
    DataType temp = 0;
    for ( int i = 0; i &amp;lt; list-&amp;gt;max; i++)
    {
        scanf(&quot;%d&quot;,&amp;amp;temp);
        if (temp == -1)
        {
            printf(&quot;exit\n&quot;);
            printf(&quot;---------------------------------------\n&quot;);
            break;            
        }
        list-&amp;gt;value[i] =  temp;
        list-&amp;gt;size++;
    }
}

//打印
void DisplayOrderList(orderList *list)
{
    if (list == NULL)
    {
        printf(&quot;list is not create or init \n&quot;);
        exit(EXIT_FAILURE);
    }
    for (int  i = 0; i &amp;lt; list-&amp;gt;size; i++)
    {
        printf(&quot;value:%d\tsize:%ld,max:%ld\taddress:%p\n&quot;,list-&amp;gt;value[i], list-&amp;gt;size,list-&amp;gt;max,&amp;amp;list-&amp;gt;value[i]);
    }
    printf(&quot;---------------------------------------\n&quot;);
}

//链接两个线性表

orderList *linkTwoOrderList(orderList *listDes,orderList *listFrom)
{
    //先判断输入是否合法
    if (listDes == NULL)
    {
        printf(&quot;listDes is not create or init \n&quot;);
        exit(EXIT_FAILURE);
    }
    if (listFrom == NULL)
    {
        printf(&quot;listFrom is not create or init \n&quot;);
        exit(EXIT_FAILURE);
    }
    orderList *list = NULL;
    list = malloc(sizeof(orderList *));
    if (list == NULL)
    {
        printf(&quot;listFrom is not create or init \n&quot;);
        exit(EXIT_FAILURE);
    }
    list-&amp;gt;max = listDes-&amp;gt;max + listFrom-&amp;gt;max;
    list-&amp;gt;value = malloc(sizeof(DataType)*list-&amp;gt;max);
    list-&amp;gt;size = 0;
    if (list == NULL)
    {
        perror(&quot;malloc:&quot;);
        exit(EXIT_FAILURE);
    }
    //两次循环，填充list
    //注意顺序，from ---&amp;gt;&amp;gt; des
    int temp = 0;
    for (int  i = 0; i &amp;lt; listDes-&amp;gt;size; i++,temp ++)
    {
        list-&amp;gt;value[i] = listDes-&amp;gt;value[i];
        list-&amp;gt;size ++;
    }
    for (int  i = 0; i &amp;lt; listFrom-&amp;gt;size; i++,temp++)
    {
        list-&amp;gt;value[temp] = listFrom-&amp;gt;value[i];
        list-&amp;gt;size ++;
    }
    printf(&quot;链接成功\n&quot;);
    return list;
}
//删除array某值
//不越界情况下
void DelArrayIndex(orderList *array,int size)
{
int i,j,k=0;
    for(i=0;i&amp;lt;size;++i)
    {
        for(j=i+1;j&amp;lt;size &amp;amp;&amp;amp; array-&amp;gt;value[i]-array-&amp;gt;value[j];++j);
        if(!(j-size))
            array-&amp;gt;value[k++]=array-&amp;gt;value[i];
    }
    //调整array size
    array-&amp;gt;size = k;
}
//去重
orderList *RemoveRepeatValue(orderList *list)
{
    if (list == NULL)
    {
        printf(&quot;Invalid list\n&quot;);
        exit(EXIT_FAILURE);
    }
    DelArrayIndex(list,list-&amp;gt;size);
    return list;
}
// -------------------------------------------------

//单链表实现
//node定义
typedef struct listNode
{
    DataType value;
    struct  listNode *next;
}listNode;

//list定义
typedef struct List
{
    listNode *head;
    listNode *tail;
    size_t len;
}List;

//list创建
List *CreateList(void )
{
    List *list  = NULL;
    list = malloc(sizeof(List *));
    if(list == NULL)
    {
        perror(&quot;malloc:&quot;);
        exit(EXIT_FAILURE);
    }
    list-&amp;gt;head = NULL;
    list-&amp;gt;tail = NULL;
    list-&amp;gt;len = 0;
    return list;
}
//尾插
//.....
//在表头插入节点
int InserNode(List *dlist,DataType data)
{
    listNode *pNode = NULL;
    pNode = malloc(sizeof(listNode *));
    if (pNode == NULL)
    {
        perror(&quot;malloc&quot;);
        return -1;
    }
    pNode-&amp;gt;value = data;
    pNode-&amp;gt;next = NULL;
    // pNode-&amp;gt;prev = NULL;

    if (dlist-&amp;gt;len == 0)//表示当前链表无节点
    {
        dlist-&amp;gt;head = pNode;
        dlist-&amp;gt;tail = pNode;
    }
    else//已有节点
    {
        pNode-&amp;gt;next = dlist-&amp;gt;head;
        // dlist-&amp;gt;head-&amp;gt;prev = pNode;
        dlist-&amp;gt;head = pNode;
    }
    dlist-&amp;gt;len ++;
    return 0;
}


//print list
void DisplayList(List *list)
{
    if(list == NULL)
    {
        perror(&quot;malloc:&quot;);
        exit(EXIT_FAILURE);
    }
    if(list-&amp;gt;len == 0)
    {
        printf(&quot;list is Empty\n&quot;);
        exit(EXIT_SUCCESS);
    }
    listNode *temp = list-&amp;gt;head;//一定不要直接操作list,要间接操作!!!!!!
    for (int i = 0; i &amp;lt; list-&amp;gt;len; i++)
    {
        printf(&quot;value=%d\tadress=%p\tnextAdress=%p\n&quot;,temp-&amp;gt;value,temp,temp-&amp;gt;next);
        //交换
        temp = temp-&amp;gt;next;
    }
}
//链接
List  *linkTwoList(List *desList,List *fromList)
{
    if(desList == NULL || fromList == NULL)
    {
        printf(&quot;Invalid List\n&quot;);
        exit(EXIT_FAILURE);
    }
    List *list = NULL;
    list = malloc(sizeof(List *));
    if(list == NULL)
    {
        perror(&quot;malloc:&quot;);
        exit(EXIT_FAILURE);
    }
    list-&amp;gt;len = desList-&amp;gt;len + fromList-&amp;gt;len;
    list-&amp;gt;head = desList-&amp;gt;head;
    desList-&amp;gt;tail-&amp;gt;next = fromList-&amp;gt;head;
    list-&amp;gt;tail = fromList-&amp;gt;tail;
    return list;
}

void pur_LinkList(List *L){
	listNode *p,*s,*q;
	p=L-&amp;gt;head-&amp;gt;next;
	if(!p)	
        return;
	while(p)
	{
        //固定p所指结点，向后遍历，寻找与之数据域相同的结点
		q=p;
		while(q-&amp;gt;next)				
		{
            //在这里将q-&amp;gt;next所指的结点存放数据与p作比较
			if(q-&amp;gt;next-&amp;gt;value==p-&amp;gt;value)	
			{
				s=q-&amp;gt;next;
				q-&amp;gt;next=s-&amp;gt;next;
				free(s);
                L-&amp;gt;len --;
			}
			else q=q-&amp;gt;next;
		}
		p=p-&amp;gt;next;
	}
}

// #define __BUILD_OderList__
#define __BUILD_List_
int main(int argc, char const *argv[])
{
    #ifdef __BUILD_OderList__
    //创建
    orderList *listOne = CreateOrderList();
    orderList *listTwo = CreateOrderList();
    orderList *listTree = CreateOrderList();
    //init
    printf(&quot;orderOne:&quot;);
    OrderListInit(listOne,5);
    //插入
    InsertOrderList(listOne);
    printf(&quot;orderTwo:&quot;);
    OrderListInit(listTwo,5);
    InsertOrderList(listTwo);
    //printf
    DisplayOrderList(listOne);
    DisplayOrderList(listTwo);
    //链接
    listTree = linkTwoOrderList(listOne,listTwo);
    printf(&quot;listOne 链接 listTwo:\n&quot;);
    DisplayOrderList(listTree);
    //去重
    listTree = RemoveRepeatValue(listTree);
    printf(&quot;去掉重复元素:\n&quot;);
    DisplayOrderList(listTree);
    #endif    
    //--------------------------------
    #ifdef  __BUILD_List_
    List *listOne = CreateList();
    List *listTwo = CreateList();
    List *listThres = CreateList();
    //插值
    InserNode(listOne,1);
    InserNode(listOne,1);
    InserNode(listOne,0);
    //插值
    InserNode(listTwo,4);
    InserNode(listTwo,3);
    InserNode(listTwo,2);
    printf(&quot;初始化完成\n&quot;);
    printf(&quot;listOne:\n&quot;);
    DisplayList(listOne);
    printf(&quot;-----------------------------------\n&quot;);
    printf(&quot;listTwo:\n&quot;);
    DisplayList(listTwo);
    printf(&quot;-----------------------------------\n&quot;);
    listThres = linkTwoList(listOne,listTwo);
    printf(&quot;链接成功:\n&quot;);
    DisplayList(listThres);
    printf(&quot;-----------------------------------\n&quot;);
    pur_LinkList(listThres);
    printf(&quot;去重成功:\n&quot;);
    DisplayList(listThres);
    #endif
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="数据结构" /><summary type="html">创建线性表和链表，实现表之间的链接，并去掉重复</summary></entry><entry><title type="html">jdbc笔记</title><link href="http://localhost:4000/_posts/2020-05-02-jdbc%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="jdbc笔记" /><published>2020-05-02T00:00:00+08:00</published><updated>2020-05-02T00:00:00+08:00</updated><id>http://localhost:4000/_posts/jdbc%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-02-jdbc%E7%AC%94%E8%AE%B0/">&lt;h2 id=&quot;jdbc笔记&quot;&gt;jdbc笔记&lt;/h2&gt;

&lt;h4 id=&quot;jdbc双层架构&quot;&gt;jdbc双层架构&lt;/h4&gt;

&lt;h4&gt;&lt;img src=&quot;/img/jdbc1.png&quot; alt=&quot;jdbc1&quot; /&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;作用：此架构中，Java Applet 或应用直接访问数据源。&lt;/li&gt;
  &lt;li&gt;条件:要求 Driver 能与访问的数据库交互&lt;/li&gt;
  &lt;li&gt;机制:用户命令传给数据库或其他数据源，随之结果被返回。&lt;/li&gt;
  &lt;li&gt;部署:数据源可以在另一台机器上，用户通过网络连接，称为 C/S配置（可以是内联网或互联网）&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;jdbc三层架构&lt;img src=&quot;/img/jdbc2.png&quot; alt=&quot;jdbc2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;侧架构特殊之处在于，引入中间层服务.&lt;/p&gt;

&lt;p&gt;流程：命令和结构都会经过该层。&lt;/p&gt;

&lt;p&gt;吸引：可以增加企业数据的访问控制，以及多种类型的更新；另外，也可简化应用的部署，并在多数情况下有性能优势。&lt;/p&gt;

&lt;p&gt;历史趋势： 以往，因性能问题，中间层都用 C 或 C++ 编写，随着优化编译器（将 Java 字节码 转为 高效的  特定机器码）和技术的发展，如EJB，Java 开始用于中间层的开发这也让 Java 的优势突显出现出来，使用 Java  作为服务器代码语言，JDBC随之被重视。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;步骤&quot;&gt;步骤&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;加载驱动&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;建立连接&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Connection  conn = DriverManager.getConnection(URL,USER,PASSWORD);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;执行sql&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String sql = &quot;select * from details&quot;;
注意没有分号
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;结果&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;while(rs.next()){
                    System.out.println(rs.getString(&quot;字段&quot;));
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;rs.close();
conn.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.sql.*;

public class mysqltest {
    public static final String URL = &quot;jdbc:mysql://localhost:3306/cov&quot;;
    public static  final  String USER = &quot;admin&quot;;
    public static final String PASSWORD = &quot;admin&quot;;
    public static void main(String[] args) {
       //加载驱动
        try {
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
            Connection conn = null;
            try {
                conn = DriverManager.getConnection(URL,USER,PASSWORD);
                System.out.println(&quot;连接成功&quot;);
                Statement statement = conn.createStatement();
                String sql = &quot;select * from details&quot;;
                ResultSet rs;
                rs = statement.executeQuery(sql);
                while(rs.next()){
                    System.out.println(rs.getString(&quot;city&quot;));
                }
                rs.close();
                conn.close();
            } catch (SQLException throwables) {
                System.out.println(&quot;连接失败&quot;);
                throwables.printStackTrace();
            }
        } catch (ClassNotFoundException e) {
            System.out.println(&quot;驱动加载失败&quot;);
            e.printStackTrace();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;外部配置信息建立连接&quot;&gt;外部配置信息建立连接&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;在resource下新建文件mysqlproperties&quot;&gt;在resource下新建文件&lt;code&gt;mysql.properties&lt;/code&gt;&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/cov
user=admin
password=admin
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;配置文件读取&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Properties properties = new Properties();
        FileInputStream inputStream = new FileInputStream(&quot;resource/mysql.properties&quot;);  //注意路径
        properties.load(inputStream);

        String driver = properties.getProperty(&quot;driver&quot;);
        String url = properties.getProperty(&quot;url&quot;);
        String user = properties.getProperty(&quot;user&quot;);
        String pwd=properties.getProperty(&quot;password&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取配置信息更好方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//通过反射
InputStream inputStream = this(当前类的Class对象).getResourceAsStream(&quot;/mysql.properties&quot;); 
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">jdbc笔记</summary></entry><entry><title type="html">sql-server复习</title><link href="http://localhost:4000/_posts/2020-05-02-sql-server%E5%A4%8D%E4%B9%A0%E4%B8%80/" rel="alternate" type="text/html" title="sql-server复习" /><published>2020-05-02T00:00:00+08:00</published><updated>2020-05-02T00:00:00+08:00</updated><id>http://localhost:4000/_posts/sql-server%E5%A4%8D%E4%B9%A0%E4%B8%80</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-02-sql-server%E5%A4%8D%E4%B9%A0%E4%B8%80/">&lt;h2 id=&quot;sql-server复习一&quot;&gt;sql-server复习一&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;基础概念&quot;&gt;基础概念&lt;/h4&gt;

    &lt;ol&gt;
      &lt;li&gt;数据库(Data)&lt;/li&gt;
      &lt;li&gt;数据库(Database)&lt;/li&gt;
      &lt;li&gt;数据库管理系统(DBMS)&lt;/li&gt;
      &lt;li&gt;数据库系统(DBS)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库系统组成&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;数据库&lt;/li&gt;
      &lt;li&gt;数据库管理系统&lt;/li&gt;
      &lt;li&gt;应用程序&lt;/li&gt;
      &lt;li&gt;数据库管理员&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DBMS主要功能&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;数据库的定义功能:定义语言DDL来定义数据库的三级结构、两级映象，定义数据的完整性约束、保密限制等约束&lt;/li&gt;
      &lt;li&gt;数据库的操纵功能：操纵语言DML实现对数据的基本操作，数据查询和数据更新&lt;/li&gt;
      &lt;li&gt;数据库的保护功能：数据库恢复、数据库的并发控制、数据完整性控制、数据安全性控制&lt;/li&gt;
      &lt;li&gt;数据库的维护功能：数据库的数据载入、转换、转储、数据库的改组以及性能监控工能&lt;/li&gt;
      &lt;li&gt;数据字典（DD）：对数据库的操作都要通过DD才能实现，DD还存放数据库运行时的统计信息&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库管理员(DBA)职责&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;决定数据库中的信息内容和结构：数据库中要存放哪些信息，DBA要参与决策&lt;/li&gt;
      &lt;li&gt;决定数据库的存储结构和存取策略：DBA要综合各用户的应用要求，和数据库设计人员共同决定数据的存储结构和存取策略，以求获得较高的存取效率和存储空间利用率&lt;/li&gt;
      &lt;li&gt;定义数据的安全性要求和完整性约束条件：DBA的重要职责是保证数据库的安全性和完整性&lt;/li&gt;
      &lt;li&gt;监控数据库的使用和运行：DBA还有一个重要职责就是监视数据库系统的运行情况，及时处理运行过程中出现的问题。比如系统发生各种故障时，数据库会因此遭到不同程度的破坏，DBA必须在最短时间内将数据库恢复到正确状态，并尽可能不影响或少影响计算机系统其他部分的正常运行&lt;/li&gt;
      &lt;li&gt;数据库的改进、重组或重构：DBA还负责在系统运行期间监视系统的空间利用率、处理效率等性能指标，对运行情况进行记录、统计分析，依靠工作实践并根据实际应用环境，不断改进数据库设计&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;三级模式体系结构&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;外部级（External）&lt;/li&gt;
      &lt;li&gt;概念级（Conceptual）&lt;/li&gt;
      &lt;li&gt;内部级（Internal）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模式/内模式映像
由于这两级的数据结构可能不一致，即记录类型、字段类型的命名和组成可能不一样，因此需要这个映像说明概念记录和内部记录之间的对应性。模式/内模式映像一般是放在内模式中描述的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;外模式/模式映像
 外模式/模式映像一般是放在外模式中描述的。三级模式结构中，模式即全局逻辑结构是数据库的中心与关键，它独立于其他层次。因此设计数据库模式结构时应首先确定数据库的逻辑模式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据独立性（Data Independence）&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;物理数据独立性
如果数据库的内模式要修改，即数据库的物理结构有所变化，那么只要对模式/内模式映像做相应的修改即可。&lt;/li&gt;
      &lt;li&gt;逻辑数据独立性  &lt;br /&gt;
   如果数据库的概念模式要修改，譬如增加记录类型或增加数据项，那么只要对外模式/模式映像做相应的修改，可以使外模式和应用程序尽可能保持不变。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据处理的三个阶段&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;概念数据模型：&lt;/p&gt;

        &lt;p&gt;独立于计算机系统的数据模型，完全不涉及信息在计算机中的表示，只是用来描述某个特定组织所关心的信息结构&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;逻辑数据模型：&lt;/p&gt;

        &lt;p&gt;是直接面向数据库的逻辑结构，它是对现实世界的第二层抽象。这类模型直接与DBMS有关，简称“逻辑模型”。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;ER&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ER（实体─联系方法）图提供了表示实体型、属性和联系的方法：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;实体型：用矩形表示，矩形框内写明实体名。&lt;/li&gt;
      &lt;li&gt;属性：用椭圆形表示，并用无向边将其与相应的实体型连接起来。&lt;img src=&quot;/img/er.png&quot; alt=&quot;er&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1:1，1:N或M:N）&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;img src=&quot;/img/联系.png&quot; alt=&quot;联系&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;二元联系主&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;一对一联系（1:1）：如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为l:1&lt;/li&gt;
      &lt;li&gt;一对多联系（1:N）：如果对于实体集A中的每一个实体，实体集B中有N（N≥0）个实体与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1:N&lt;/li&gt;
      &lt;li&gt;多对多联系（M:N）：如果对于实体集A中的每一个实体，实体集B中有N（N≥0）个实体与之联系，反之，对于实体集B中的每一个实体，实体集A中也有M（M≥0）个实体与之联系，则称实体集A与实体集B具有多对多联系，记为M:N&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;三元联系和一元联系&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;三元联系是三个实体之间的联系，这些实体之间也存在着一对一、一对多或多对多的联系。例如，对于课程、教师与参考书3个实体，如果一门课程可以有多个教师讲授，使用若干本参考书，而每一个教师只讲授一门课程，每一本参考书只供一门课程使用，则课程与教师、参考书之间的联系是一对多的&lt;/li&gt;
  &lt;li&gt;同一个实体集内的各实体之间也可以存在一对一、一对多、多对多的联系，称为一元联系。例如，一个公司的所有员工组成的实体集内部具有领导与被领导的联系，即某一员工（经理）领导若干名员工，而一个员工仅被另外一个员工（经理）直接领导，因此这是一对多的联&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;逻辑模型&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;在数据库系统中，传统的逻辑模型有层次模型、网状模型和关系模型三种，非传统的逻辑模型有面向对象模型（Object-Oriented model，OO）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;逻辑模型中的数据描述&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;字段（field）：标记实体属性的命名单位称为字段或数据项。字段的命名往往和属性名相同。例如学生有学号、姓名、性别、年龄等字段。&lt;/li&gt;
      &lt;li&gt;记录（record）：字段的有序集合称为记录。一般用一个记录描述一个实体，所以记录又可以定义为能完整地描述一个实体的字段集。&lt;/li&gt;
      &lt;li&gt;文件（file）： 同一类记录的集合称为文件。文件是用来描述实体集的。
关键码（key）： 能惟一标识文件中每个记录的字段或字段集，称为记录的关键码（简称为键）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;层次数据模型的数据结构&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;在数据库中定义满足下面两个条件的基本层次联系的集合为层次模型。有且只有一个结点没有双亲结点，这个结点称为根结点；&lt;/li&gt;
      &lt;li&gt;根以外的其他结点有且只有一个双亲结点&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;层次模型的优点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;层次模型的数据结构比较简单清晰。&lt;/li&gt;
      &lt;li&gt;层次数据库的查询效率高。因为层次模型中记录之间的联系用有向边表示，这种联系在DBMS中常常用指针来实现。因此这种联系也就是记录之间的存取路径。当要存取某个结点的记录值，DBMS就沿着这一条路径很快找到该记录值，所以，层次数据库的查询性能优于关系数据库，不低于网状数据库。&lt;/li&gt;
      &lt;li&gt;层次数据模型提供了良好的完整性支持。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;层次模型的缺点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;现实世界中很多联系是非层次型的，如结点之间具有多对多联系。&lt;/li&gt;
      &lt;li&gt;一个结点具有多个双亲等，层次模型表示这类联系的方法很笨拙，只能通过引入冗余数据（易产生不一致性）或创建非自然的数据结构（引入虚拟结点）来解决。对插入和删除操作的限制比较多，因此应用程序的编写比较复杂。&lt;/li&gt;
      &lt;li&gt;查询子女结点必须通过双亲结点。&lt;/li&gt;
      &lt;li&gt;由于结构严密，层次命令趋于程序化&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网状数据模型的数据结构&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型：允许一个以上的结点无双亲；一个结点可以有多于一个的双亲。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网状数据模型的优点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;能够更为直接地描述现实世界，如一个结点可以有多个双亲。结点之间可以有多种联系。&lt;/li&gt;
      &lt;li&gt;具有良好的性能，存取效率较高&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网状数据模型的缺点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握。&lt;/li&gt;
      &lt;li&gt;网状模型的DDL、DML复杂，并且要嵌入某一种高级语言（如COBOL、C）中。因此用户不易掌握和使用。&lt;/li&gt;
      &lt;li&gt;由于记录之间的联系是通过存取路径实现的，应用程序在访问数据时必须选择适当的存取路径，因此，用户必须了解系统结构的细节。这样就加重了编写应用程序的负担&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系数据模型的数据结构&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;关系（Relation）： 一个关系对应通常说的一张表，如表2.2中的这张学生登记表。元组（Tuple） 表中的一行即为一个元组。&lt;/li&gt;
      &lt;li&gt;属性（Attribute）： 表中的一列即为一个属性，给每一个属性起一个名称即属性名。如这张表有6列，对应6个属性：学号，姓名，年龄，性别，系名和年级。&lt;/li&gt;
      &lt;li&gt;码（Key）： 也称为码键。表中的某个属性组，它可以惟一确定一个元组，如表2.2中的学号，可以惟一确定一个学生，也就成为本关系的码。&lt;/li&gt;
      &lt;li&gt;域（Domain）： 属性的取值范围，如人的年龄一般在1～150岁之间，大学生年龄属性的域是（14～38），性别的域是（男，女），系名的域是一个学校所有系名的集合。分量 元组中的一个属性值。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系模式&lt;/p&gt;

    &lt;p&gt;关系名（属性l，属性2，…，属性n）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系数据模型优点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;关系模型与非关系模型不同，它是建立在严格的数学概念的基础上的。&lt;/li&gt;
      &lt;li&gt;关系模型的概念单一。无论实体还是实体之间的联系都用关系来表示。对数据的检索和更新结果也是关系（即表）。所以其数据结构简单、清晰，用户易懂易用。&lt;/li&gt;
      &lt;li&gt;关系模型的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系数据模型缺点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;由于存取路径对用户透明，查询效率往往不如非关系数据模型。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;面向对象模型&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;对象（Object）： 对象是现实世界中实体的模型化，与记录概念相仿，但远比记录复杂。每个对象有一个惟一的标识符，把状态（State）和行为（Behavior）封装（Encapsulate）在一起。其中，对象的状态是该对象属性值的集合，对象的行为是在对象状态上操作的方法集。&lt;/li&gt;
      &lt;li&gt;类（Class）： 将属性集和方法集相同的所有对象组合在一起，构成了一个类。类的属性值域可以是基本数据类型（整型、实型、字符串型），也可以是记录类型和集合类型。也就是类可以有嵌套结构。系统中所有的类组成了一个有根的有向无环图，叫类层次&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;面向对象数据库系统的优点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;能有效地表达客观世界和有效地查询信息：面向对象方法综合了在关系数据库中发展的全部工程原理、系统分析、软件工程和专家系统领域的内容。&lt;/li&gt;
      &lt;li&gt;可维护性好：在耦合性和内聚性方面，面向对象数据模型的性能尤为突出。&lt;/li&gt;
      &lt;li&gt;能很好地解决“阻抗不匹配”（impedance mismatch）问题：应用程序语言与数据库管理系统对数据类型支持的不一致问题，这一问题通常称之为阻抗不匹配问题&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;面向对象数据库系统的缺点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;技术还不成熟：面向对象模型还存在着标准化问题，是否修改SQL以适应面向对象的程序，还是用新的对象查询语言来代替它，目前还没有解决。&lt;/li&gt;
      &lt;li&gt;面向对象系统开发的有关原理才刚开始，只是具有雏形，还需要一段时间的研究。但在可靠性、成本等方面还是令人可以接受的。&lt;/li&gt;
      &lt;li&gt;理论还需完善：到现在为止没有关于面向对象分析的一套清晰的概念模型，怎样设计独立于物理存储的信息还不明确&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="sql-server复习" /><summary type="html">sql-server复习一</summary></entry></feed>