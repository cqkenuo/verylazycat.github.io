<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-26T14:57:09+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">imod</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
</subtitle><entry><title type="html">linux编程-文件系统</title><link href="http://localhost:4000/_posts/2020-05-22-linux%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" rel="alternate" type="text/html" title="linux编程-文件系统" /><published>2020-05-22T00:00:00+08:00</published><updated>2020-05-22T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-22-linux%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;文件系统&quot;&gt;文件系统&lt;/h1&gt;

&lt;h2 id=&quot;获取文件属性&quot;&gt;获取文件属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;stat&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;stat, fstat, lstat, fstatat - get file status&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
            int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;stat结构体&quot;&gt;stat结构体&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct stat {
dev_t     st_dev;         /* ID of device containing file */
ino_t     st_ino;         /* Inode number */
mode_t    st_mode;        /* File type and mode */
nlink_t   st_nlink;       /* Number of hard links */
uid_t     st_uid;         /* User ID of owner */
gid_t     st_gid;         /* Group ID of owner */
dev_t     st_rdev;        /* Device ID (if special file) */
off_t     st_size;        /* Total size, in bytes */
blksize_t st_blksize;     /* Block size for filesystem I/O */
blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

/* Since Linux 2.6, the kernel supports nanosecond
precision for the following timestamp fields.
For the details before Linux 2.6, see NOTES. */

struct timespec st_atim;  /* Time of last access */
struct timespec st_mtim;  /* Time of last modification */
struct timespec st_ctim;  /* Time of last status change */

#define st_atime st_atim.tv_sec      /* Backward compatibility */
#define st_mtime st_mtim.tv_sec
#define st_ctime st_ctim.tv_sec
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取文件大小测试程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
//获取文件大小函数
static off_t flen(const char *filename)
{
    //获取文件属性
    struct stat fileinfo;
    if(stat(filename,&amp;amp;fileinfo) &amp;lt; 0)
    {
        perror(&quot;stat()&quot;);
        exit(1);
    }
    return fileinfo.st_size;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;空洞文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt; int fd;
    fd = open(argv[1],O_WRONLY|O_CREAT|O_TRUNC,0600);
    if(fd  &amp;lt; 0)
    {
        perror(&quot;open()&quot;);
        exit(0);
    }
    //偏移
//带上LL单位
    lseek(fd,5LL*1024LL*1024LL*1024LL - 1LL,SEEK_SET);
    write(fd,&quot;&quot;,1);
    close(fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mode_t    st_mode&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;权限和文件类型，位图，权限位9位，类型3位，u+s 1位，g+s 1位，粘滞位(T位)1位。位图是用一位或几位数据表示某种状态
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件类型:&lt;code&gt;dcb-lsp&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;d&lt;/th&gt;
      &lt;th&gt;目录&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;c&lt;/td&gt;
      &lt;td&gt;字符快设备文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;b&lt;/td&gt;
      &lt;td&gt;块文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;普通文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;l&lt;/td&gt;
      &lt;td&gt;符号链接文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s&lt;/td&gt;
      &lt;td&gt;套接字文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;p&lt;/td&gt;
      &lt;td&gt;管道文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;文件权限更改&quot;&gt;文件权限更改&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;chmod&lt;/li&gt;
  &lt;li&gt;fchmod&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/stat.h&amp;gt;
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;粘住位&quot;&gt;粘住位&lt;/h2&gt;

&lt;p&gt;t位&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;文件系统:&lt;code&gt;FAT&lt;/code&gt;,&lt;code&gt;UFS&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;硬链接符号链接&quot;&gt;硬链接&amp;amp;符号链接&lt;/h2&gt;

&lt;p&gt;硬链接与目录项是同义词,且建立硬链接有限制,不能给分区建立,不能给目录建立;符号链接优点:可跨分区,可以给目录建立&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;link&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int link(const char *oldpath, const char *newpath);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;unistd.h&amp;gt;
int linkat(int olddirfd, const char *oldpath,
           int newdirfd, const char *newpath, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;unlink&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int unlink(const char *pathname);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;unistd.h&amp;gt;
int unlinkat(int dirfd, const char *pathname, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;remove&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;remove a file or directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int remove(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rename&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int rename(const char *oldpath, const char *newpath);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;stdio.h&amp;gt;
int renameat(int olddirfd, const char *oldpath,
int newdirfd, const char *newpath);
int renameat2(int olddirfd, const char *oldpath,
int newdirfd, const char *newpath, unsigned int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;文件时间&quot;&gt;文件时间&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;utime&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;utime.h&amp;gt;
int utime(const char *filename, const struct utimbuf *times);
#include &amp;lt;sys/time.h&amp;gt;
int utimes(const char *filename, const struct timeval times[2]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;目录创建删除&quot;&gt;目录创建&amp;amp;删除&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
int mkdir(const char *pathname, mode_t mode);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int mkdirat(int dirfd, const char *pathname, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rmdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int rmdir(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;修改工作路径&quot;&gt;修改工作路径&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;chdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int chdir(const char *path);
int fchdir(int fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;突破安全限制,有缺陷&lt;/p&gt;

&lt;h2 id=&quot;获取当前工作路径&quot;&gt;获取当前工作路径&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;getcwd&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
char *getcwd(char *buf, size_t size);
char *getwd(char *buf);
char *get_current_dir_name(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;目录glob函数&quot;&gt;目录glob函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;glob&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;find pathnames &lt;code&gt;matching a pattern&lt;/code&gt;, free memory from
       glob()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;glob.h&amp;gt;
int glob(const char *pattern, int flags,
int (*errfunc) (const char *epath, int eerrno),
glob_t *pglob);
void globfree(glob_t *pglob);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;glob.h&amp;gt;
//匹配的文件
#define PAT &quot;/etc/a*.conf&quot;
//返回错误的函数
int errfunc_(const char *epath,int eerror)
{
    puts(epath);
    fprintf(stderr,&quot;error msg:%s\n&quot;,strerror(eerror));
    return 0;
}
int main(int argc, char const *argv[])
{
    glob_t       globres;
    int err = 0;
    err = glob(PAT,0,NULL,&amp;amp;globres);
    if(err)
    {
        printf(&quot;error code = %d\n&quot;,err);
        exit(1);
    }
    for (size_t i = 0; i &amp;lt; globres.gl_pathc; i++)
    {
        puts(globres.gl_pathv[i]);
    }
    globfree(&amp;amp;globres);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;opendir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
DIR *opendir(const char *name);
DIR *fdopendir(int fd);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
fdopendir():
Since glibc 2.10:
_POSIX_C_SOURCE &amp;gt;= 200809L
Before glibc 2.10:
_GNU_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;closedir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
int closedir(DIR *dirp);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;readdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;dirent.h&amp;gt;
struct dirent *readdir(DIR *dirp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dirent结构体&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct dirent {
               ino_t          d_ino;       /* Inode number */
               off_t          d_off;       /* Not an offset; see below */
               unsigned short d_reclen;    /* Length of this record */
               unsigned char  d_type;      /* Type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* Null-terminated filename */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取文件名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
#define PAT &quot;/etc&quot;
int main(int argc, char const *argv[])
{
    DIR *dp;
    struct dirent *cur;
    dp = opendir(PAT);
    if(dp == NULL)
    {
        perror(&quot;opendir&quot;);
        exit(1);
    }
    while ((cur = readdir(dp)) != NULL)
    {
         puts(cur-&amp;gt;d_name);
    }
    closedir(dp);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rewenddir&lt;/li&gt;
  &lt;li&gt;seekdir&lt;/li&gt;
  &lt;li&gt;telldir&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;系统数据文件和信息&quot;&gt;系统数据文件和信息&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/passwd&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;getpwuid&lt;/li&gt;
      &lt;li&gt;getpwnam&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;pwd.h&amp;gt;
struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);
int getpwnam_r(const char *name, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
int getpwuid_r(uid_t uid, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;passwd结构体&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct passwd {
               char   *pw_name;       /* username */
               char   *pw_passwd;     /* user password */
               uid_t   pw_uid;        /* user ID */
               gid_t   pw_gid;        /* group ID */
               char   *pw_gecos;      /* user information */
               char   *pw_dir;        /* home directory */
               char   *pw_shell;      /* shell program */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;/etc/group
    &lt;ul&gt;
      &lt;li&gt;getgrgid&lt;/li&gt;
      &lt;li&gt;getgrgrnam&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/shadow&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;getspnam&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;shadow.h&amp;gt;
struct spwd *getspnam(const char *name);
struct spwd *getspent(void);
void setspent(void);
void endspent(void);
struct spwd *fgetspent(FILE *stream);
struct spwd *sgetspent(const char *s);
int putspent(const struct spwd *p, FILE *stream);
int lckpwdf(void);
int ulckpwdf(void);
/* GNU extension */
#include &amp;lt;shadow.h&amp;gt;
int getspent_r(struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int getspnam_r(const char *name, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int fgetspent_r(FILE *stream, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int sgetspent_r(const char *s, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;spwd结构体&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct spwd {
               char *sp_namp;     /* Login name */
               char *sp_pwdp;     /* Encrypted password */
               long  sp_lstchg;   /* Date of last change
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               long  sp_min;      /* Min # of days between changes */
               long  sp_max;      /* Max # of days between changes */
               long  sp_warn;     /* # of days before password expires
                                     to warn user to change it */
               long  sp_inact;    /* # of days after password expires
                                     until account is disabled */
               long  sp_expire;   /* Date when account expires
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               unsigned long sp_flag;  /* Reserved */
           };
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;crypt&lt;/p&gt;

        &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define _XOPEN_SOURCE       /* See feature_test_macros(7) */
#include &amp;lt;unistd.h&amp;gt;
char *crypt(const char *key, const char *salt);
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &amp;lt;crypt.h&amp;gt;
char *crypt_r(const char *key, const char *salt,
struct crypt_data *data);
Link with -lcrypt.
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;getpass&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
char *getpass(const char *prompt);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时间戳&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;time&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
time_t time(time_t *tloc);
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;gmtime&lt;/li&gt;
      &lt;li&gt;localtime&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);
char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);
struct tm *gmtime(const time_t *timep);
struct tm *gmtime_r(const time_t *timep, struct tm *result);
struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);
time_t mktime(struct tm *tm);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;tm结构体&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct tm {
               int tm_sec;    /* Seconds (0-60) */
               int tm_min;    /* Minutes (0-59) */
               int tm_hour;   /* Hours (0-23) */
               int tm_mday;   /* Day of the month (1-31) */
               int tm_mon;    /* Month (0-11) */
               int tm_year;   /* Year - 1900 */
               int tm_wday;   /* Day of the week (0-6, Sunday = 0) */
               int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */
               int tm_isdst;  /* Daylight saving time */
           };
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;strftime&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
size_t strftime(char *s, size_t max, const char *format,
const struct tm *tm);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;进程环境&quot;&gt;进程环境&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;main函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main(int argc,char *argv[])
//其实还有第三个参数,环境变量
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;进程的终止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正常终止:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;main函数返回&lt;/li&gt;
  &lt;li&gt;调用exit&lt;/li&gt;
  &lt;li&gt;调用_exit或者_Exit&lt;/li&gt;
  &lt;li&gt;最后一个线程从其启动例程饭后&lt;/li&gt;
  &lt;li&gt;最后一个线程调用pthread_exit&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常终止:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调用abort&lt;/li&gt;
  &lt;li&gt;接到一个信号并终止&lt;/li&gt;
  &lt;li&gt;最后一个线程对其取消请求做出响应&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;钩子函数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;atexit&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int atexit(void (*function)(void));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;命令行参数分析&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;getopt&lt;/li&gt;
      &lt;li&gt;getopt_long&lt;/li&gt;
    &lt;/ol&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int getopt(int argc, char * const argv[],
const char *optstring);
extern char *optarg;
extern int optind, opterr, optopt;
#include &amp;lt;getopt.h&amp;gt;
int getopt_long(int argc, char * const argv[],
const char *optstring,
const struct option *longopts, int *longindex);
int getopt_long_only(int argc, char * const argv[],
const char *optstring,
const struct option *longopts, int *longindex);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;环境变量&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;environ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;extern char **environ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
char *getenv(const char *name);
char *secure_getenv(const char *name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;setenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;putenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int putenv(char *string);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;c程序的存储空间布局&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;pmap&lt;/code&gt;命令查看&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;库&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;动态库&lt;/li&gt;
  &lt;li&gt;静态库&lt;/li&gt;
  &lt;li&gt;手工装载库&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;dlopen&lt;/p&gt;

&lt;p&gt;dlclose&lt;/p&gt;

&lt;p&gt;dlerror&lt;/p&gt;

&lt;p&gt;dlsym&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;dlfcn.h&amp;gt;
void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlmopen (Lmid_t lmid, const char *filename, int flags);
Link with -ldl.   
    #include &amp;lt;dlfcn.h&amp;gt;
    void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlmopen (Lmid_t lmid, const char *filename, int flags);
#include &amp;lt;dlfcn.h&amp;gt;
char *dlerror(void);
void *dlsym(void *handle, const char *symbol);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlvsym(void *handle, char *symbol, char *version);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
       #include &amp;lt;stdlib.h&amp;gt;
       #include &amp;lt;dlfcn.h&amp;gt;
       #include &amp;lt;gnu/lib-names.h&amp;gt;  /* Defines LIBM_SO (which will be a
                                      string such as &quot;libm.so.6&quot;) */
       int
       main(void)
       {
           void *handle;
           double (*cosine)(double);
           char *error;

           handle = dlopen(LIBM_SO, RTLD_LAZY);
           if (!handle) {
               fprintf(stderr, &quot;%s\n&quot;, dlerror());
               exit(EXIT_FAILURE);
           }

           dlerror();    /* Clear any existing error */

           cosine = (double (*)(double)) dlsym(handle, &quot;cos&quot;);

           /* According to the ISO C standard, casting between function
              pointers and 'void *', as done above, produces undefined results.
              POSIX.1-2003 and POSIX.1-2008 accepted this state of affairs and
              proposed the following workaround:

                  *(void **) (&amp;amp;cosine) = dlsym(handle, &quot;cos&quot;);

              This (clumsy) cast conforms with the ISO C standard and will
              avoid any compiler warnings.

              The 2013 Technical Corrigendum to POSIX.1-2008 (a.k.a.
              POSIX.1-2013) improved matters by requiring that conforming
              implementations support casting 'void *' to a function pointer.
              Nevertheless, some compilers (e.g., gcc with the '-pedantic'
              option) may complain about the cast used in this program. */

           error = dlerror();
           if (error != NULL) {
               fprintf(stderr, &quot;%s\n&quot;, error);
               exit(EXIT_FAILURE);
           }

           printf(&quot;%f\n&quot;, (*cosine)(2.0));
           dlclose(handle);
           exit(EXIT_SUCCESS);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;函数跳转&lt;/p&gt;

    &lt;p&gt;setjmp&lt;/p&gt;

    &lt;p&gt;longjmp&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;资源获取及控制&lt;/p&gt;

    &lt;p&gt;getrlimit&lt;/p&gt;

    &lt;p&gt;setrlimit&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;sys/resource.h&amp;gt;
int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);
int prlimit(pid_t pid, int resource, const struct rlimit *new_limit,
struct rlimit *old_limit);
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux编程</title><link href="http://localhost:4000/_posts/2020-05-20-linux%E7%BC%96%E7%A8%8B-IO/" rel="alternate" type="text/html" title="linux编程" /><published>2020-05-20T00:00:00+08:00</published><updated>2020-05-20T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%BC%96%E7%A8%8B-IO</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-20-linux%E7%BC%96%E7%A8%8B-IO/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;error&quot;&gt;ERROR&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;vim /usr/include/asm-generic/errno-base.h 
errno.h 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#ifndef _ASM_GENERIC_ERRNO_BASE_H
#define _ASM_GENERIC_ERRNO_BASE_H

#define EPERM            1      /* Operation not permitted */
#define ENOENT           2      /* No such file or directory */
#define ESRCH            3      /* No such process */
#define EINTR            4      /* Interrupted system call */
#define EIO              5      /* I/O error */
#define ENXIO            6      /* No such device or address */
#define E2BIG            7      /* Argument list too long */
#define ENOEXEC          8      /* Exec format error */
#define EBADF            9      /* Bad file number */
#define ECHILD          10      /* No child processes */
#define EAGAIN          11      /* Try again */
#define ENOMEM          12      /* Out of memory */
#define EACCES          13      /* Permission denied */
#define EFAULT          14      /* Bad address */
#define ENOTBLK         15      /* Block device required */
#define EBUSY           16      /* Device or resource busy */
#define EEXIST          17      /* File exists */
#define EXDEV           18      /* Cross-device link */
#define ENODEV          19      /* No such device */
#define ENOTDIR         20      /* Not a directory */
#define EISDIR          21      /* Is a directory */
#define EINVAL          22      /* Invalid argument */
#define ENFILE          23      /* File table overflow */
#define EMFILE          24      /* Too many open files */
#define ENOTTY          25      /* Not a typewriter */
#define ETXTBSY         26      /* Text file busy */
#define EFBIG           27      /* File too large */
#define ENOSPC          28      /* No space left on device */
#define ESPIPE          29      /* Illegal seek */
#define EROFS           30      /* Read-only file system */
#define EMLINK          31      /* Too many links */
#define EPIPE           32      /* Broken pipe */
#define EDOM            33      /* Math argument out of domain of func */
#define ERANGE          34      /* Math result not representable */
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;man手册&quot;&gt;man手册&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;第一章:基本命令&lt;/li&gt;
  &lt;li&gt;第二章:系统调用&lt;/li&gt;
  &lt;li&gt;第三章:标准库函数&lt;/li&gt;
  &lt;li&gt;第七章:体系结构&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;宏和函数&quot;&gt;宏和函数&lt;/h2&gt;

&lt;p&gt;宏占用编译时间,函数占用运行时间,不过更安全&lt;/p&gt;

&lt;h1 id=&quot;io&quot;&gt;IO&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;一切实现的基础&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;input&lt;/code&gt;&amp;amp;&lt;code&gt;output&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;实现:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;stdio&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sysio&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;优先考虑stdio,扩展性更好,不同平台底层不一样.&lt;/p&gt;

&lt;h2 id=&quot;errorno-to-error_msg&quot;&gt;errorno to error_msg&lt;/h2&gt;

&lt;p&gt;更直观展示错误内容&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;perror (关联全局变量errorno)&lt;/li&gt;
  &lt;li&gt;strerror&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;file结构体&quot;&gt;FILE结构体&lt;/h2&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;h2 id=&quot;常用函数&quot;&gt;常用函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;fopen&lt;/li&gt;
  &lt;li&gt;fclose&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;NAME
       fopen, fdopen, freopen - stream open functions
SYNOPSIS
       #include &amp;lt;stdio.h&amp;gt;
       FILE *fopen(const char *pathname, const char *mode);
       FILE *fdopen(int fd, const char *mode);
       FILE *freopen(const char *pathname, const char *mode, FILE *stream);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;const&lt;/code&gt;参数,安全性;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mode&lt;/code&gt;:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;r&lt;/th&gt;
      &lt;th&gt;for read&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;r+&lt;/td&gt;
      &lt;td&gt;reading and writing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;truncate fileto zero length or create text  file  for  writing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w+&lt;/td&gt;
      &lt;td&gt;open for reading and writing&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;open for appending&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;a+&lt;/td&gt;
      &lt;td&gt;open for reading and appending&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;返回:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;RETURN VALUE
       Upon successful completion fopen(), fdopen()  and  freopen()  return  a
       FILE pointer.  Otherwise, NULL is returned and errno is set to indicate
       the error.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;error 一个&lt;code&gt;全局变量&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;FILE 创建的指针在栈,静态区,或者堆???&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;FILE *fopen(const char *pathname, const char *mode);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在堆上;&lt;/p&gt;

&lt;p&gt;如果一个操作成对出现使用,&lt;code&gt;一般&lt;/code&gt;放在&lt;code&gt;堆&lt;/code&gt;上&lt;/p&gt;

&lt;p&gt;&lt;code&gt;是资源一定有上限&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;fopen打开&lt;code&gt;流&lt;/code&gt;是有上限的,一般体现出来的数量是&lt;code&gt;1021&lt;/code&gt;,其实真实打开的是&lt;code&gt;1024&lt;/code&gt;个,有&lt;code&gt;3&lt;/code&gt;个默认&lt;code&gt;流&lt;/code&gt;:&lt;code&gt;stdout&lt;/code&gt;,&lt;code&gt;stdinput&lt;/code&gt;,&lt;code&gt;stderr&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;具体限制参考:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ulimit -a&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;-t: cpu time (seconds)              unlimited
-f: file size (blocks)              unlimited
-d: data seg size (kbytes)          unlimited
-s: stack size (kbytes)             8192
-c: core file size (blocks)         0
-m: resident set size (kbytes)      unlimited
-u: processes                       31073
-n: file descriptors                1024
-l: locked-in-memory size (kbytes)  16384
-v: address space (kbytes)          unlimited
-x: file locks                      unlimited
-i: pending signals                 31073
-q: bytes in POSIX msg queues       819200
-e: max nice                        0
-r: max rt priority                 0
-N 15:                              unlimited

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建文件后的权限&lt;/p&gt;

&lt;p&gt;具体公式:&lt;code&gt;0666 &amp;amp; ~umask&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;字符操作&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fgetc&lt;/li&gt;
  &lt;li&gt;fputc&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
int ungetc(int c, FILE *stream);
//---------------------
int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
int ungetc(int c, FILE *stream);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return value&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;fgetc(),  getc() and getchar() return the character read as an unsigned
char cast to an int or EOF on end of file or error.
fgets() returns s on success, and NULL on error or  when  end  of  file
occurs while no characters have been read.
ungetc() returns c on success, or EOF on error.

--------------------------

fgetc(),  getc() and getchar() return the character read as an unsigned
char cast to an int or `EOF` on end of file or error.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;fgets&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-CQL&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
int ungetc(int c, FILE *stream);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;fputs&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fputc(int c, FILE *stream);
int fputs(const char *s, FILE *stream);
int putc(int c, FILE *stream);
int putchar(int c);
int puts(const char *s);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;fwrite&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb,
              FILE *stream);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;printf&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int dprintf(int fd, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);
#include &amp;lt;stdarg.h&amp;gt;
int vprintf(const char *format, va_list ap);
int vfprintf(FILE *stream, const char *format, va_list ap);
int vdprintf(int fd, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);=
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;scanf&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int scanf(const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);
int sscanf(const char *str, const char *format, ...);
#include &amp;lt;stdarg.h&amp;gt;
int vscanf(const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;fseek&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, const fpos_t *pos);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;whence&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SEEK_SET&lt;/li&gt;
  &lt;li&gt;SEEK_CUR&lt;/li&gt;
  &lt;li&gt;SEEK_END&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;long offset&lt;/code&gt;注意长度限制,类型为long,有缺陷,&lt;code&gt;fseeko&lt;/code&gt;修改了缺陷,如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fseeko(FILE *stream, off_t offset, int whence);
off_t ftello(FILE *stream);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
fseeko(), ftello():
_FILE_OFFSET_BITS == 64 || _POSIX_C_SOURCE &amp;gt;= 200112L
(defining the obsolete _LARGEFILE_SOURCE macro also works)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;On some architectures, both off_t and long are 32-bit types, but defin‐
       ing  _FILE_OFFSET_BITS  with  the value 64 (before including any header
       files) will turn off_t into a 64-bit type.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;ftell&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, const fpos_t *pos);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;fflush&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int fflush(FILE *stream);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:&lt;/p&gt;

&lt;p&gt;If the stream argument is NULL, fflush() flushes all open output streams.For a nonlocking counterpart, see unlocked_stdio(3).&lt;/p&gt;

&lt;p&gt;缓冲区作用:合并系统调用&lt;/p&gt;

&lt;p&gt;分类:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;行缓冲:换行时刷新,stdout&lt;/li&gt;
  &lt;li&gt;全缓冲:满了就刷新,默认&lt;/li&gt;
  &lt;li&gt;无缓冲:stderr&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;修改缓冲:&lt;/p&gt;

&lt;p&gt;setvbuf&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
void setbuf(FILE *stream, char *buf);
void setbuffer(FILE *stream, char *buf, size_t size);
void setlinebuf(FILE *stream);
int setvbuf(FILE *stream, char *buf, int mode, size_t size);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The mode argument must be one of the following three macros:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;_IONBF unbuffered
_IOLBF line buffered
_IOFBF fully buffered
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;getline&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
ssize_t getline(char **lineptr, size_t *n, FILE *stream);
ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
getline(), getdelim():
Since glibc 2.10:
_POSIX_C_SOURCE &amp;gt;= 200809L
    Before glibc 2.10:
_GNU_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于段错误一定要仔细分析,可能是调用的函数引用了其他函数,但是没有初始化,这种容易出错;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;tmpnam&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
char *tmpnam(char *s);
char *tmpnam_r(char *s);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;tmpfile&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
FILE *tmpfile(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匿名文件&lt;/p&gt;

&lt;p&gt;临时问阿金两个问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不冲突&lt;/li&gt;
  &lt;li&gt;及时销毁&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;文件描述符&quot;&gt;文件描述符&lt;/h2&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;h2 id=&quot;系统io&quot;&gt;系统IO&lt;/h2&gt;

&lt;h3 id=&quot;函数&quot;&gt;函数&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;open&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
int creat(const char *pathname, mode_t mode);
int openat(int dirfd, const char *pathname, int flags);
int openat(int dirfd, const char *pathname, int flags, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数名相同,参数不同,在c++和Java里面叫做&lt;code&gt;重载&lt;/code&gt;,但是c里面没有重载,此处是使用&lt;code&gt;变参实现&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以传入多个参数取去编译,如果报错,就是重载实现,如果没有报错,则是变参实现.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;flag&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;O_APPEND&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_ASYNC&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_CLOEXEC&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_CREAT&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_DIRECT&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_DIRECTORY&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_DSYNC&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_EXCL&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_LARGEFILE&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_NOATIME&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_NOCTTY&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_NOFOLLOW&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_NONBLOCK&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_PATH&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O_SYNC&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;联系&lt;code&gt;标准io&lt;/code&gt;里面的model,有如下对应关系:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;model&lt;/th&gt;
      &lt;th&gt;flags&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;r-&lt;/td&gt;
      &lt;td&gt;O_RDONLY&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r+&lt;/td&gt;
      &lt;td&gt;O_RDWR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;O_WRONLY|O_CREAT|O_TRUNC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w+&lt;/td&gt;
      &lt;td&gt;O_RDWR|O_TRUNC|O_CREAT&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;close&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int close(int fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;read&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
ssize_t read(int fd, void *buf, size_t count);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;write&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
ssize_t write(int fd, const void *buf, size_t count);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;lseek&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
off_t lseek(int fd, off_t offset, int whence);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;dup&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;复制文件描述符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int dup(int oldfd);
int dup2(int oldfd, int newfd);
#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include &amp;lt;fcntl.h&amp;gt;              /* Obtain O_* constant definitions */
#include &amp;lt;unistd.h&amp;gt;
int dup3(int oldfd, int newfd, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;标准IO不要和系统IO混用&lt;/p&gt;

&lt;p&gt;转换&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
void clearerr(FILE *stream);
int feof(FILE *stream);
int ferror(FILE *stream);
int fileno(FILE *stream);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;原子操作&quot;&gt;原子操作&lt;/h2&gt;

&lt;p&gt;不可分割的最小单位,解决竞争和冲突&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;同步&quot;&gt;同步&lt;/h2&gt;

&lt;h3 id=&quot;函数-1&quot;&gt;函数&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;sync&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;sync, syncfs - commit filesystem caches to disk&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
void sync(void);
int syncfs(int fd);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
sync():
_XOPEN_SOURCE &amp;gt;= 500
|| /* Since glibc 2.19: */ _DEFAULT_SOURCE
|| /* Glibc versions &amp;lt;= 2.19: */ _BSD_SOURCE
syncfs():
_GNU_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;fsync&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ynchronize  a  file’s in-core state with storage
       device&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int fsync(int fd);
int fdatasync(int fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;fcntl&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
int fcntl(int fd, int cmd, ... /* arg */ );
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;ioctl&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/ioctl.h&amp;gt;
int ioctl(int fd, unsigned long request, ...);
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;devfd目录&quot;&gt;/dev/fd目录&lt;/h2&gt;

&lt;p&gt;虚目录,显示当前进程的文件描述符的信息&lt;/p&gt;

&lt;h1 id=&quot;文件系统&quot;&gt;文件系统&lt;/h1&gt;

&lt;h2 id=&quot;获取文件属性&quot;&gt;获取文件属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;stat&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;stat, fstat, lstat, fstatat - get file status&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
            int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;stat结构体&quot;&gt;stat结构体&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct stat {
dev_t     st_dev;         /* ID of device containing file */
ino_t     st_ino;         /* Inode number */
mode_t    st_mode;        /* File type and mode */
nlink_t   st_nlink;       /* Number of hard links */
uid_t     st_uid;         /* User ID of owner */
gid_t     st_gid;         /* Group ID of owner */
dev_t     st_rdev;        /* Device ID (if special file) */
off_t     st_size;        /* Total size, in bytes */
blksize_t st_blksize;     /* Block size for filesystem I/O */
blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

/* Since Linux 2.6, the kernel supports nanosecond
precision for the following timestamp fields.
For the details before Linux 2.6, see NOTES. */

struct timespec st_atim;  /* Time of last access */
struct timespec st_mtim;  /* Time of last modification */
struct timespec st_ctim;  /* Time of last status change */

#define st_atime st_atim.tv_sec      /* Backward compatibility */
#define st_mtime st_mtim.tv_sec
#define st_ctime st_ctim.tv_sec
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取文件大小测试程序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
//获取文件大小函数
static off_t flen(const char *filename)
{
    //获取文件属性
    struct stat fileinfo;
    if(stat(filename,&amp;amp;fileinfo) &amp;lt; 0)
    {
        perror(&quot;stat()&quot;);
        exit(1);
    }
    return fileinfo.st_size;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;空洞文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt; int fd;
    fd = open(argv[1],O_WRONLY|O_CREAT|O_TRUNC,0600);
    if(fd  &amp;lt; 0)
    {
        perror(&quot;open()&quot;);
        exit(0);
    }
    //偏移
//带上LL单位
    lseek(fd,5LL*1024LL*1024LL*1024LL - 1LL,SEEK_SET);
    write(fd,&quot;&quot;,1);
    close(fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mode_t    st_mode&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;权限和文件类型，位图，权限位9位，类型3位，u+s 1位，g+s 1位，粘滞位(T位)1位。位图是用一位或几位数据表示某种状态
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件类型:&lt;code&gt;dcb-lsp&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;d&lt;/th&gt;
      &lt;th&gt;目录&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;c&lt;/td&gt;
      &lt;td&gt;字符快设备文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;b&lt;/td&gt;
      &lt;td&gt;块文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;普通文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;l&lt;/td&gt;
      &lt;td&gt;符号链接文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;s&lt;/td&gt;
      &lt;td&gt;套接字文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;p&lt;/td&gt;
      &lt;td&gt;管道文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;文件权限更改&quot;&gt;文件权限更改&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;chmod&lt;/li&gt;
  &lt;li&gt;fchmod&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/stat.h&amp;gt;
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;粘住位&quot;&gt;粘住位&lt;/h2&gt;

&lt;p&gt;t位&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;文件系统:&lt;code&gt;FAT&lt;/code&gt;,&lt;code&gt;UFS&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;硬链接符号链接&quot;&gt;硬链接&amp;amp;符号链接&lt;/h2&gt;

&lt;p&gt;硬链接与目录项是同义词,且建立硬链接有限制,不能给分区建立,不能给目录建立;符号链接优点:可跨分区,可以给目录建立&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;link&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int link(const char *oldpath, const char *newpath);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;unistd.h&amp;gt;
int linkat(int olddirfd, const char *oldpath,
           int newdirfd, const char *newpath, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;unlink&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int unlink(const char *pathname);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;unistd.h&amp;gt;
int unlinkat(int dirfd, const char *pathname, int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;remove&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;remove a file or directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int remove(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rename&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
int rename(const char *oldpath, const char *newpath);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;stdio.h&amp;gt;
int renameat(int olddirfd, const char *oldpath,
int newdirfd, const char *newpath);
int renameat2(int olddirfd, const char *oldpath,
int newdirfd, const char *newpath, unsigned int flags);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;文件时间&quot;&gt;文件时间&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;utime&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;utime.h&amp;gt;
int utime(const char *filename, const struct utimbuf *times);
#include &amp;lt;sys/time.h&amp;gt;
int utimes(const char *filename, const struct timeval times[2]);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;目录创建删除&quot;&gt;目录创建&amp;amp;删除&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;mkdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
int mkdir(const char *pathname, mode_t mode);
#include &amp;lt;fcntl.h&amp;gt;           /* Definition of AT_* constants */
#include &amp;lt;sys/stat.h&amp;gt;
int mkdirat(int dirfd, const char *pathname, mode_t mode);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rmdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int rmdir(const char *pathname);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;修改工作路径&quot;&gt;修改工作路径&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;chdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int chdir(const char *path);
int fchdir(int fd);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;突破安全限制,有缺陷&lt;/p&gt;

&lt;h2 id=&quot;获取当前工作路径&quot;&gt;获取当前工作路径&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;getcwd&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
char *getcwd(char *buf, size_t size);
char *getwd(char *buf);
char *get_current_dir_name(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;目录glob函数&quot;&gt;目录glob函数&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;glob&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;find pathnames &lt;code&gt;matching a pattern&lt;/code&gt;, free memory from
       glob()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;glob.h&amp;gt;
int glob(const char *pattern, int flags,
int (*errfunc) (const char *epath, int eerrno),
glob_t *pglob);
void globfree(glob_t *pglob);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;glob.h&amp;gt;
//匹配的文件
#define PAT &quot;/etc/a*.conf&quot;
//返回错误的函数
int errfunc_(const char *epath,int eerror)
{
    puts(epath);
    fprintf(stderr,&quot;error msg:%s\n&quot;,strerror(eerror));
    return 0;
}
int main(int argc, char const *argv[])
{
    glob_t       globres;
    int err = 0;
    err = glob(PAT,0,NULL,&amp;amp;globres);
    if(err)
    {
        printf(&quot;error code = %d\n&quot;,err);
        exit(1);
    }
    for (size_t i = 0; i &amp;lt; globres.gl_pathc; i++)
    {
        puts(globres.gl_pathv[i]);
    }
    globfree(&amp;amp;globres);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;opendir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
DIR *opendir(const char *name);
DIR *fdopendir(int fd);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
fdopendir():
Since glibc 2.10:
_POSIX_C_SOURCE &amp;gt;= 200809L
Before glibc 2.10:
_GNU_SOURCE
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;closedir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
int closedir(DIR *dirp);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;readdir&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;dirent.h&amp;gt;
struct dirent *readdir(DIR *dirp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dirent结构体&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct dirent {
               ino_t          d_ino;       /* Inode number */
               off_t          d_off;       /* Not an offset; see below */
               unsigned short d_reclen;    /* Length of this record */
               unsigned char  d_type;      /* Type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* Null-terminated filename */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取文件名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt;
#define PAT &quot;/etc&quot;
int main(int argc, char const *argv[])
{
    DIR *dp;
    struct dirent *cur;
    dp = opendir(PAT);
    if(dp == NULL)
    {
        perror(&quot;opendir&quot;);
        exit(1);
    }
    while ((cur = readdir(dp)) != NULL)
    {
         puts(cur-&amp;gt;d_name);
    }
    closedir(dp);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;rewenddir&lt;/li&gt;
  &lt;li&gt;seekdir&lt;/li&gt;
  &lt;li&gt;telldir&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;系统数据文件和信息&quot;&gt;系统数据文件和信息&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/passwd&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;getpwuid&lt;/li&gt;
      &lt;li&gt;getpwnam&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;pwd.h&amp;gt;
struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);
int getpwnam_r(const char *name, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
int getpwuid_r(uid_t uid, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;passwd结构体&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct passwd {
               char   *pw_name;       /* username */
               char   *pw_passwd;     /* user password */
               uid_t   pw_uid;        /* user ID */
               gid_t   pw_gid;        /* group ID */
               char   *pw_gecos;      /* user information */
               char   *pw_dir;        /* home directory */
               char   *pw_shell;      /* shell program */
           };
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;/etc/group
    &lt;ul&gt;
      &lt;li&gt;getgrgid&lt;/li&gt;
      &lt;li&gt;getgrgrnam&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;/etc/shadow&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;getspnam&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;shadow.h&amp;gt;
struct spwd *getspnam(const char *name);
struct spwd *getspent(void);
void setspent(void);
void endspent(void);
struct spwd *fgetspent(FILE *stream);
struct spwd *sgetspent(const char *s);
int putspent(const struct spwd *p, FILE *stream);
int lckpwdf(void);
int ulckpwdf(void);
/* GNU extension */
#include &amp;lt;shadow.h&amp;gt;
int getspent_r(struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int getspnam_r(const char *name, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int fgetspent_r(FILE *stream, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int sgetspent_r(const char *s, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;spwd结构体&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct spwd {
               char *sp_namp;     /* Login name */
               char *sp_pwdp;     /* Encrypted password */
               long  sp_lstchg;   /* Date of last change
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               long  sp_min;      /* Min # of days between changes */
               long  sp_max;      /* Max # of days between changes */
               long  sp_warn;     /* # of days before password expires
                                     to warn user to change it */
               long  sp_inact;    /* # of days after password expires
                                     until account is disabled */
               long  sp_expire;   /* Date when account expires
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               unsigned long sp_flag;  /* Reserved */
           };
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;crypt&lt;/p&gt;

        &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define _XOPEN_SOURCE       /* See feature_test_macros(7) */
#include &amp;lt;unistd.h&amp;gt;
char *crypt(const char *key, const char *salt);
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &amp;lt;crypt.h&amp;gt;
char *crypt_r(const char *key, const char *salt,
struct crypt_data *data);
Link with -lcrypt.
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;getpass&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
char *getpass(const char *prompt);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时间戳&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;time&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
time_t time(time_t *tloc);
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;gmtime&lt;/li&gt;
      &lt;li&gt;localtime&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);
char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);
struct tm *gmtime(const time_t *timep);
struct tm *gmtime_r(const time_t *timep, struct tm *result);
struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);
time_t mktime(struct tm *tm);
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;tm结构体&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct tm {
               int tm_sec;    /* Seconds (0-60) */
               int tm_min;    /* Minutes (0-59) */
               int tm_hour;   /* Hours (0-23) */
               int tm_mday;   /* Day of the month (1-31) */
               int tm_mon;    /* Month (0-11) */
               int tm_year;   /* Year - 1900 */
               int tm_wday;   /* Day of the week (0-6, Sunday = 0) */
               int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */
               int tm_isdst;  /* Daylight saving time */
           };
&lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;strftime&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;time.h&amp;gt;
size_t strftime(char *s, size_t max, const char *format,
const struct tm *tm);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;进程环境&quot;&gt;进程环境&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;main函数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int main(int argc,char *argv[])
//其实还有第三个参数,环境变量
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;进程的终止&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正常终止:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;main函数返回&lt;/li&gt;
  &lt;li&gt;调用exit&lt;/li&gt;
  &lt;li&gt;调用_exit或者_Exit&lt;/li&gt;
  &lt;li&gt;最后一个线程从其启动例程饭后&lt;/li&gt;
  &lt;li&gt;最后一个线程调用pthread_exit&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常终止:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调用abort&lt;/li&gt;
  &lt;li&gt;接到一个信号并终止&lt;/li&gt;
  &lt;li&gt;最后一个线程对其取消请求做出响应&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;钩子函数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;atexit&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int atexit(void (*function)(void));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;命令行参数分析&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;getopt&lt;/li&gt;
      &lt;li&gt;getopt_long&lt;/li&gt;
    &lt;/ol&gt;

    &lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
int getopt(int argc, char * const argv[],
const char *optstring);
extern char *optarg;
extern int optind, opterr, optopt;
#include &amp;lt;getopt.h&amp;gt;
int getopt_long(int argc, char * const argv[],
const char *optstring,
const struct option *longopts, int *longindex);
int getopt_long_only(int argc, char * const argv[],
const char *optstring,
const struct option *longopts, int *longindex);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;环境变量&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;environ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;extern char **environ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
char *getenv(const char *name);
char *secure_getenv(const char *name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;setenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;putenv&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
int putenv(char *string);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;c程序的存储空间布局&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;pmap&lt;/code&gt;命令查看&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;库&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;动态库&lt;/li&gt;
  &lt;li&gt;静态库&lt;/li&gt;
  &lt;li&gt;手工装载库&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;dlopen&lt;/p&gt;

&lt;p&gt;dlclose&lt;/p&gt;

&lt;p&gt;dlerror&lt;/p&gt;

&lt;p&gt;dlsym&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;dlfcn.h&amp;gt;
void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlmopen (Lmid_t lmid, const char *filename, int flags);
Link with -ldl.   
    #include &amp;lt;dlfcn.h&amp;gt;
    void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlmopen (Lmid_t lmid, const char *filename, int flags);
#include &amp;lt;dlfcn.h&amp;gt;
char *dlerror(void);
void *dlsym(void *handle, const char *symbol);
#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;
void *dlvsym(void *handle, char *symbol, char *version);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
       #include &amp;lt;stdlib.h&amp;gt;
       #include &amp;lt;dlfcn.h&amp;gt;
       #include &amp;lt;gnu/lib-names.h&amp;gt;  /* Defines LIBM_SO (which will be a
                                      string such as &quot;libm.so.6&quot;) */
       int
       main(void)
       {
           void *handle;
           double (*cosine)(double);
           char *error;

           handle = dlopen(LIBM_SO, RTLD_LAZY);
           if (!handle) {
               fprintf(stderr, &quot;%s\n&quot;, dlerror());
               exit(EXIT_FAILURE);
           }

           dlerror();    /* Clear any existing error */

           cosine = (double (*)(double)) dlsym(handle, &quot;cos&quot;);

           /* According to the ISO C standard, casting between function
              pointers and 'void *', as done above, produces undefined results.
              POSIX.1-2003 and POSIX.1-2008 accepted this state of affairs and
              proposed the following workaround:

                  *(void **) (&amp;amp;cosine) = dlsym(handle, &quot;cos&quot;);

              This (clumsy) cast conforms with the ISO C standard and will
              avoid any compiler warnings.

              The 2013 Technical Corrigendum to POSIX.1-2008 (a.k.a.
              POSIX.1-2013) improved matters by requiring that conforming
              implementations support casting 'void *' to a function pointer.
              Nevertheless, some compilers (e.g., gcc with the '-pedantic'
              option) may complain about the cast used in this program. */

           error = dlerror();
           if (error != NULL) {
               fprintf(stderr, &quot;%s\n&quot;, error);
               exit(EXIT_FAILURE);
           }

           printf(&quot;%f\n&quot;, (*cosine)(2.0));
           dlclose(handle);
           exit(EXIT_SUCCESS);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;函数跳转&lt;/p&gt;

    &lt;p&gt;setjmp&lt;/p&gt;

    &lt;p&gt;longjmp&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;资源获取及控制&lt;/p&gt;

    &lt;p&gt;getrlimit&lt;/p&gt;

    &lt;p&gt;setrlimit&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;sys/resource.h&amp;gt;
int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);
int prlimit(pid_t pid, int resource, const struct rlimit *new_limit,
struct rlimit *old_limit);
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry><entry><title type="html">Docker笔记</title><link href="http://localhost:4000/_posts/2020-05-15-Docker%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="Docker笔记" /><published>2020-05-15T00:00:00+08:00</published><updated>2020-05-15T00:00:00+08:00</updated><id>http://localhost:4000/_posts/Docker%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-15-Docker%E7%AC%94%E8%AE%B0/">&lt;h2 id=&quot;docker&quot;&gt;Docker&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;官网&quot;&gt;&lt;a href=&quot;https://www.docker.com/&quot;&gt;官网&lt;/a&gt;&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;安装教程&quot;&gt;&lt;a href=&quot;https://hub.docker.com/search?q=&amp;amp;type=edition&amp;amp;offering=community&amp;amp;operating_system=linux&quot;&gt;安装教程&lt;/a&gt;&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;基础命令&quot;&gt;基础命令&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Usage:	docker [OPTIONS] COMMAND

A self-sufficient runtime for containers

Options:
      --config string      Location of client config files (default
                           &quot;/home/yourname/.docker&quot;)
  -c, --context string     Name of the context to use to connect to the
                           daemon (overrides DOCKER_HOST env var and
                           default context set with &quot;docker context use&quot;)
  -D, --debug              Enable debug mode
  -H, --host list          Daemon socket(s) to connect to
  -l, --log-level string   Set the logging level
                           (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;)
                           (default &quot;info&quot;)
      --tls                Use TLS; implied by --tlsverify
      --tlscacert string   Trust certs signed only by this CA (default
                           &quot;/home/yourname/.docker/ca.pem&quot;)
      --tlscert string     Path to TLS certificate file (default
                           &quot;/home/yourname/.docker/cert.pem&quot;)
      --tlskey string      Path to TLS key file (default
                           &quot;/home/yourname/.docker/key.pem&quot;)
      --tlsverify          Use TLS and verify the remote
  -v, --version            Print version information and quit

Management Commands:
  builder     Manage builds
  config      Manage Docker configs
  container   Manage containers
  context     Manage contexts
  engine      Manage the docker engine
  image       Manage images
  network     Manage networks
  node        Manage Swarm nodes
  plugin      Manage plugins
  secret      Manage Docker secrets
  service     Manage services
  stack       Manage Docker stacks
  swarm       Manage Swarm
  system      Manage Docker
  trust       Manage trust on Docker images
  volume      Manage volumes

Commands:
  attach      Attach local standard input, output, and error streams to a running container
  build       Build an image from a Dockerfile
  commit      Create a new image from a container's changes
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container
  deploy      Deploy a new stack or update an existing stack
  diff        Inspect changes to files or directories on a container's filesystem
  events      Get real time events from the server
  exec        Run a command in a running container
  export      Export a container's filesystem as a tar archive
  history     Show the history of an image
  images      List images
  import      Import the contents from a tarball to create a filesystem image
  info        Display system-wide information
  inspect     Return low-level information on Docker objects
  kill        Kill one or more running containers
  load        Load an image from a tar archive or STDIN
  login       Log in to a Docker registry
  logout      Log out from a Docker registry
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  ps          List containers
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  run         Run a command in a new container
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  search      Search the Docker Hub for images
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  version     Show the Docker version information
  wait        Block until one or more containers stop, then print their exit codes
Run 'docker COMMAND --help' for more information on a command.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;docker--for-ubuntu-images&quot;&gt;Docker  For Ubuntu Images&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;网站&quot;&gt;&lt;a href=&quot;https://hub.docker.com/_/ubuntu?tab=tags&amp;amp;page=1&quot;&gt;网站&lt;/a&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;拉取最新版的-ubuntu-镜像&quot;&gt;拉取最新版的 Ubuntu 镜像&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker pull ubuntu:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;查看本地镜像&quot;&gt;查看本地镜像&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;删除镜像&quot;&gt;删除镜像&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker rmi &lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;构建镜像&quot;&gt;构建镜像&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker build &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要创建一个 &lt;code&gt;Dockerfile&lt;/code&gt; 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-dockerfile&quot;&gt;FROM    centos:6.7
MAINTAINER      Fisher &quot;fisher@sudops.com&quot;

RUN     /bin/echo 'root:123456' |chpasswd
RUN     useradd runoob
RUN     /bin/echo 'runoob:123456' |chpasswd
RUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &amp;gt;/etc/default/local
EXPOSE  22
EXPOSE  80
CMD     /usr/sbin/sshd -D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。&lt;/p&gt;

&lt;p&gt;第一条FROM，指定使用哪个镜像源&lt;/p&gt;

&lt;p&gt;RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。&lt;/p&gt;

&lt;p&gt;然后，我们使用&lt;code&gt;Dockerfile&lt;/code&gt; 文件，通过 &lt;code&gt;docker build&lt;/code&gt; 命令来构建一个镜像&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; docker build -t runoob/centos:6.7 .
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Sending build context to Docker daemon 17.92 kB
Step 1 : FROM centos:6.7
 ---&amp;amp;gt; d95b5ca17cc3
Step 2 : MAINTAINER Fisher &quot;fisher@sudops.com&quot;
 ---&amp;amp;gt; Using cache
 ---&amp;amp;gt; 0c92299c6f03
Step 3 : RUN /bin/echo 'root:123456' |chpasswd
 ---&amp;amp;gt; Using cache
 ---&amp;amp;gt; 0397ce2fbd0a
Step 4 : RUN useradd runoob
......
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;-t&lt;/strong&gt; ：指定要创建的目标镜像名&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;.&lt;/strong&gt; ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;查看端口的绑定情况&quot;&gt;查看端口的绑定情况&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker port &lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;运行容器&quot;&gt;运行容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker run -itd --name ubuntu-test ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;exec-命令进入-ubuntu-容器&quot;&gt;exec 命令进入 ubuntu 容器&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker exec -it ubuntu-test /bin/bas
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;运行交互式的容器&quot;&gt;运行交互式的容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker run -i -t docker_image /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;-t&lt;/code&gt;在新容器内指定一个伪终端或终端&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;-i&lt;/code&gt;允许你对容器内的标准输入 (&lt;code&gt;STDIN&lt;/code&gt;) 进行交互&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;docker-ps&quot;&gt;docker ps&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;CONTAINER ID&lt;/strong&gt;:容器 ID&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IMAGE:&lt;/strong&gt; 使用的镜像&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;COMMAND:&lt;/strong&gt; 启动容器时运行的命令&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CREATED:&lt;/strong&gt; 容器的创建时间&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;STATUS:&lt;/strong&gt; 容器状态
    &lt;ol&gt;
      &lt;li&gt;created（已创建）&lt;/li&gt;
      &lt;li&gt;restarting（重启中）&lt;/li&gt;
      &lt;li&gt;running（运行中）&lt;/li&gt;
      &lt;li&gt;removing（迁移中）&lt;/li&gt;
      &lt;li&gt;paused（暂停）&lt;/li&gt;
      &lt;li&gt;exited（停止）&lt;/li&gt;
      &lt;li&gt;dead（死亡）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PORTS:&lt;/strong&gt; 容器的端口信息和使用的连接类型（tcp\udp）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NAMES:&lt;/strong&gt; 自动分配的容器名称&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;停止容器&quot;&gt;停止容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker stop CONTAINER ID
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;重启容器&quot;&gt;重启容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; docker restart CONTAINER ID
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;进入容器&quot;&gt;进入容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在使用 &lt;strong&gt;-d&lt;/strong&gt; 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker attach  CONTAINER ID
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker exec -it CONTAINER ID /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推荐使用 &lt;code&gt;docker exec&lt;/code&gt; 命令，因为此退出容器终端，不会导致容器的停止。&lt;/p&gt;

&lt;p&gt;更多参数说明请使用 &lt;code&gt;docker exec --help&lt;/code&gt; 命令查看&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;导出容器&quot;&gt;&lt;strong&gt;导出容器&lt;/strong&gt;&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker export  CONTAINER ID &amp;gt; dockername.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;导入容器快照&quot;&gt;&lt;strong&gt;导入容器快照&lt;/strong&gt;&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cat docker/ubuntu.tar | docker import - test/ubuntu:v1
也可以通过指定 URL 或者某个目录来导入
docker import http://example.com/exampleimage.tgz example/imagerepo
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;删除容器&quot;&gt;删除容器&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker rm -f CONTAINER ID
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;运行一个-web-应用flask&quot;&gt;运行一个 web 应用(Flask)&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker pull training/webapp  # 载入镜像
docker run -d -P training/webapp python app.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;-d:&lt;/strong&gt;让容器在后台运行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-P:&lt;/strong&gt;将容器内部使用的网络端口映射到我们使用的主机上&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;查看-web-应用程序日志&quot;&gt;查看 WEB 应用程序日志&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker logs -f  CONTAINER ID
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;-f:&lt;/strong&gt; 让 &lt;strong&gt;docker logs&lt;/strong&gt; 像使用 &lt;strong&gt;tail -f&lt;/strong&gt; 一样来输出容器内部的标准输出&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;查看web应用程序容器的进程&quot;&gt;查看WEB应用程序容器的进程&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt; docker top&lt;/code&gt; 来查看容器内部运行的进程&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker inspect &lt;/code&gt;查看 Docker 的底层信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;停止-web-应用容器&quot;&gt;停止 WEB 应用容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker stop &lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;重启web应用容器&quot;&gt;重启WEB应用容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;docker start&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;移除web应用容器&quot;&gt;移除WEB应用容器&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt; docker rm&lt;/code&gt;&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">Docker</summary></entry><entry><title type="html">类加载</title><link href="http://localhost:4000/_posts/2020-05-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD/" rel="alternate" type="text/html" title="类加载" /><published>2020-05-13T00:00:00+08:00</published><updated>2020-05-13T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E7%B1%BB%E5%8A%A0%E8%BD%BD</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;类加载&quot;&gt;类加载&lt;/h1&gt;

&lt;p&gt;在java代码中，&lt;code&gt;类型&lt;/code&gt;的&lt;code&gt;加载&lt;/code&gt;，&lt;code&gt;连接&lt;/code&gt;，&lt;code&gt;初始化&lt;/code&gt;过程都是在程序运行期间完成的&lt;/p&gt;

&lt;h2 id=&quot;java结束生命周期&quot;&gt;java结束生命周期&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;执行System.exit()&lt;/li&gt;
  &lt;li&gt;程序正常结束&lt;/li&gt;
  &lt;li&gt;异常或错误&lt;/li&gt;
  &lt;li&gt;操作系统出错&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;类的加载连接初始化&quot;&gt;类的加载，连接，初始化&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;加载：查找并加载类的二进制数据，将class文件的二进制数据读入内存，将其放到运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象来封装类在方法区内的数据结构&lt;/li&gt;
  &lt;li&gt;连接：
    &lt;ol&gt;
      &lt;li&gt;验证：确保加载类的准确性&lt;/li&gt;
      &lt;li&gt;准备：为类的&lt;code&gt;静态变量&lt;/code&gt;分配内存，并初始胡为&lt;code&gt;默认值&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;解析：把类中的&lt;code&gt;符号引用&lt;/code&gt;转换为&lt;code&gt;直接引用&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;初始化:&lt;code&gt;为静态变量赋初始值&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;类的使用&quot;&gt;类的使用&lt;/h2&gt;

&lt;p&gt;主动使用&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建类的实例&lt;/li&gt;
  &lt;li&gt;访问类或者接口静态变量(getstatice)，或者对静态变量赋值(putstatice)&lt;/li&gt;
  &lt;li&gt;调用静态方法(invokestatic)&lt;/li&gt;
  &lt;li&gt;反射&lt;/li&gt;
  &lt;li&gt;初始化类的子类&lt;/li&gt;
  &lt;li&gt;java虚拟机启动时被标明的启动类&lt;/li&gt;
  &lt;li&gt;动态语言支持&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;被动使用&quot;&gt;被动使用&lt;/h2&gt;</content><author><name></name></author><category term="JVM" /><summary type="html">[toc]</summary></entry><entry><title type="html">置换密码</title><link href="http://localhost:4000/_posts/2020-05-13-%E7%BD%AE%E6%8D%A2%E5%AF%86%E7%A0%81/" rel="alternate" type="text/html" title="置换密码" /><published>2020-05-13T00:00:00+08:00</published><updated>2020-05-13T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E7%BD%AE%E6%8D%A2%E5%AF%86%E7%A0%81</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-13-%E7%BD%AE%E6%8D%A2%E5%AF%86%E7%A0%81/">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;置换密码&quot;&gt;置换密码&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例:设有限集X = {1,2,3,4,5,6,7,8},σ 为X 上的一个置换,满足σ(1)=2,σ(2)=5,σ(3)=3,σ(4)=6,σ(5)=1,σ(6)=8,σ(7)=4,σ(8)=7,其置换可表示为如下:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\sigma =
\left\{
 \begin{matrix}
1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\
2&amp;5&amp;3&amp;6&amp;1&amp;8&amp;4&amp;7
  \end{matrix}
  \right\}
  =(125)(3)(4687)
  =(125)(4687) %]]&gt;&lt;/script&gt;
其逆为：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\sigma^{-1}=
\left\{
 \begin{matrix}
1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\
2&amp;5&amp;3&amp;6&amp;1&amp;8&amp;4&amp;7
  \end{matrix}
  \right\}^{-1}
  =
  \left\{
  \begin{matrix}
  1&amp;2&amp;3&amp;4&amp;5&amp;6&amp;7&amp;8\\
  5&amp;1&amp;3&amp;7&amp;2&amp;4&amp;8&amp;6
  \end{matrix}
  \right\}
  =
  (125)(3)(4786)=(152)(4786) %]]&gt;&lt;/script&gt;&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">置换密码</summary></entry><entry><title type="html">sql-server常用命令总结</title><link href="http://localhost:4000/_posts/2020-05-12-sql-server%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="sql-server常用命令总结" /><published>2020-05-12T00:00:00+08:00</published><updated>2020-05-12T00:00:00+08:00</updated><id>http://localhost:4000/_posts/sql-server%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-12-sql-server%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/">&lt;ol&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;部分语句模板&quot;&gt;部分语句模板&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建数据库&quot;&gt;创建数据库&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Create a new database called 'DatabaseName'
-- Connect to the 'master' database to run this snippet
USE master
GO
-- Create the new database if it does not exist already
IF NOT EXISTS (
    SELECT name
        FROM sys.databases
        WHERE name = N'DatabaseName'
)
CREATE DATABASE DatabaseName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建表&quot;&gt;创建表&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Create a new table called 'TableName' in schema 'SchemaName'
-- Drop the table if it already exists
IF OBJECT_ID('SchemaName.TableName', 'U') IS NOT NULL
DROP TABLE SchemaName.TableName
GO
-- Create the table in the specified schema
CREATE TABLE SchemaName.TableName
(
    TableNameId INT NOT NULL PRIMARY KEY, -- primary key column
    Column1 [NVARCHAR](50) NOT NULL,
    Column2 [NVARCHAR](50) NOT NULL
    -- specify more columns here
);
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建存储过程&quot;&gt;创建存储过程&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Create a new stored procedure called 'StoredProcedureName' in schema 'SchemaName'
-- Drop the stored procedure if it already exists
IF EXISTS (
SELECT *
    FROM INFORMATION_SCHEMA.ROUTINES
WHERE SPECIFIC_SCHEMA = N'SchemaName'
    AND SPECIFIC_NAME = N'StoredProcedureName'
)
DROP PROCEDURE SchemaName.StoredProcedureName
GO
-- Create the stored procedure in the specified schema
CREATE PROCEDURE SchemaName.StoredProcedureName
    @param1 /*parameter name*/ int /*datatype_for_param1*/ = 0, /*default_value_for_param1*/
    @param2 /*parameter name*/ int /*datatype_for_param1*/ = 0 /*default_value_for_param2*/
-- add more stored procedure parameters here
AS
    -- body of the stored procedure
    SELECT @param1, @param2
GO
-- example to execute the stored procedure we just created
EXECUTE SchemaName.StoredProcedureName 1 /*value_for_param1*/, 2 /*value_for_param2*/
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建视图&quot;&gt;创建视图&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Create a new view called 'ViewName' in schema 'SchemaName'
-- Drop the view if it already exists
IF EXISTS (
SELECT *
    FROM sys.views
    JOIN sys.schemas
    ON sys.views.schema_id = sys.schemas.schema_id
    WHERE sys.schemas.name = N'SchemaName'
    AND sys.views.name = N'ViewName'
)
DROP VIEW SchemaName.ViewName
GO
-- Create the view in the specified schema
CREATE VIEW SchemaName.ViewName
AS
    -- body of the view
    SELECT [Column1],
        [Column2],
        [Column3],
    FROM SchemaName.TableName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;删除数据库&quot;&gt;删除数据库&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Drop the database 'DatabaseName'
-- Connect to the 'master' database to run this snippet
USE master
GO
-- Uncomment the ALTER DATABASE statement below to set the database to SINGLE_USER mode if the drop database command fails because the database is in use.
-- ALTER DATABASE DatabaseName SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
-- Drop the database if it exists
IF EXISTS (
  SELECT name
   FROM sys.databases
   WHERE name = N'DatabaseName'
)
DROP DATABASE DatabaseName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;删除表&quot;&gt;删除表&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Drop the table 'TableName' in schema 'SchemaName'
IF EXISTS (
    SELECT *
        FROM sys.tables
        JOIN sys.schemas
            ON sys.tables.schema_id = sys.schemas.schema_id
    WHERE sys.schemas.name = N'SchemaName'
        AND sys.tables.name = N'TableName'
)
    DROP TABLE SchemaName.TableName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;删除字段&quot;&gt;删除字段&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Drop 'ColumnName' from table 'TableName' in schema 'SchemaName'
ALTER TABLE SchemaName.TableName
    DROP COLUMN ColumnName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;删除存储过程&quot;&gt;删除存储过程&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Drop the stored procedure called 'StoredProcedureName' in schema 'SchemaName'
IF EXISTS (
SELECT *
    FROM INFORMATION_SCHEMA.ROUTINES
WHERE SPECIFIC_SCHEMA = N'SchemaName'
    AND SPECIFIC_NAME = N'StoredProcedureName'
)
DROP PROCEDURE SchemaName.StoredProcedureName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;删除视图&quot;&gt;删除视图&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Drop the view 'ViewName' in schema 'SchemaName'
IF EXISTS (
    SELECT *
        FROM sys.views
        JOIN sys.schemas
            ON sys.views.schema_id = sys.schemas.schema_id
    WHERE sys.schemas.name = N'SchemaName'
        AND sys.views.name = N'ViewName'
)
    DROP VIEW SchemaName.ViewName
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;GetHelp&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;/*
mssql getting started:
-----------------------------
1. Change language mode to SQL: Open a .sql file or press Ctrl+K M (Cmd+K M on Mac) and choose 'SQL'.
2. Connect to a database: Press F1 to show the command palette, type 'sqlcon' or 'sql' then click 'Connect'.
3. Use the T-SQL editor: Type T-SQL statements in the editor using T-SQL IntelliSense or type 'sql' to see a list of code snippets you can tweak &amp;amp; reuse.
4. Run T-SQL statements: Press F1 and type 'sqlex' or press Ctrl+Shift+e (Cmd+Shift+e on Mac) to execute all the T-SQL code in the editor.

Tip #1: Put GO on a line by itself to separate T-SQL batches.
Tip #2: Select some T-SQL text in the editor and press `Ctrl+Shift+e` (`Cmd+Shift+e` on Mac) to execute the selection
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;获取空白&quot;&gt;获取空白&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Get the space used by table TableName
SELECT TABL.name AS table_name,
INDX.name AS index_name,
SUM(PART.rows) AS rows_count,
SUM(ALOC.total_pages) AS total_pages,
SUM(ALOC.used_pages) AS used_pages,
SUM(ALOC.data_pages) AS data_pages,
(SUM(ALOC.total_pages)*8/1024) AS total_space_MB,
(SUM(ALOC.used_pages)*8/1024) AS used_space_MB,
(SUM(ALOC.data_pages)*8/1024) AS data_space_MB
FROM sys.tables AS TABL
INNER JOIN sys.indexes AS INDX
ON TABL.object_id = INDX.object_id
INNER JOIN sys.partitions AS PART
ON INDX.object_id = PART.object_id
AND INDX.index_id = PART.index_id
INNER JOIN sys.allocation_units AS ALOC
ON PART.partition_id = ALOC.container_id
WHERE TABL.name LIKE '%TableName%'
AND INDX.object_id &amp;gt; 255
AND INDX.index_id &amp;lt;= 1
GROUP BY TABL.name, 
INDX.object_id,
INDX.index_id,
INDX.name
ORDER BY Object_Name(INDX.object_id),
(SUM(ALOC.total_pages)*8/1024) DESC
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;插入表&quot;&gt;插入表&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Insert rows into table 'TableName'
INSERT INTO TableName
( -- columns to insert data into
 [Column1], [Column2], [Column3]
)
VALUES
( -- first row: values for the columns in the list above
 Column1_Value, Column2_Value, Column3_Value
),
( -- second row: values for the columns in the list above
 Column1_Value, Column2_Value, Column3_Value
)
-- add more rows here
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;查找表&quot;&gt;查找表&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- List columns in all tables whose name is like 'TableName'
SELECT 
    TableName = tbl.TABLE_SCHEMA + '.' + tbl.TABLE_NAME, 
    ColumnName = col.COLUMN_NAME, 
    ColumnDataType = col.DATA_TYPE
FROM INFORMATION_SCHEMA.TABLES tbl
INNER JOIN INFORMATION_SCHEMA.COLUMNS col 
    ON col.TABLE_NAME = tbl.TABLE_NAME
    AND col.TABLE_SCHEMA = tbl.TABLE_SCHEMA

WHERE tbl.TABLE_TYPE = 'BASE TABLE' and tbl.TABLE_NAME like '%TableName%'
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;列举数据库&quot;&gt;列举数据库&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Get a list of databases
SELECT name FROM sys.databases
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;列举当前数据库的表和视图&quot;&gt;列举当前数据库的表和视图&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Get a list of tables and views in the current database
SELECT table_catalog [database], table_schema [schema], table_name name, table_type type
FROM INFORMATION_SCHEMA.TABLES
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;查询&quot;&gt;查询&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Select rows from a Table or View 'TableOrViewName' in schema 'SchemaName'
SELECT * FROM SchemaName.TableOrViewName
WHERE 	/* add search conditions here */
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;更新表里面的数据&quot;&gt;更新表里面的数据&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Update rows in table 'TableName'
UPDATE TableName
SET
    [Colum1] = Colum1_Value,
    [Colum2] = Colum2_Value
    -- add more columns and values here
WHERE 	/* add search conditions here */
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;添加字段&quot;&gt;添加字段&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Add a new column 'NewColumnName' to table 'TableName' in schema 'SchemaName'
ALTER TABLE SchemaName.TableName
    ADD NewColumnName /*new_column_name*/ int /*new_column_datatype*/ NULL /*new_column_nullability*/
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;删除表里面的行数据&quot;&gt;删除表里面的行数据&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;-- Add a new column 'NewColumnName' to table 'TableName' in schema 'SchemaName'
ALTER TABLE SchemaName.TableName
    ADD NewColumnName /*new_column_name*/ int /*new_column_datatype*/ NULL /*new_column_nullability*/
GO
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h1 id=&quot;详细语句&quot;&gt;详细语句&lt;/h1&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;SELECT [ALL|DISTINCT][TOP n[PERCENT]]&amp;lt;目标列表达式&amp;gt;[, … n]    [INTO &amp;lt;新表名&amp;gt;]
FROM &amp;lt;表名&amp;gt;|&amp;lt;视图名&amp;gt;[, … n]
[WHERE &amp;lt;条件表达式&amp;gt;]
[GROUP BY &amp;lt;列名l&amp;gt;
[HAVING &amp;lt;条件表达式&amp;gt;]]
[ORDER BY &amp;lt;列名2&amp;gt;[ASC|DESC]]；  
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;ALL：表示输出所有记录，包括重复记录。DISTINCT表示输出无重
复结果的记录。TOP n [PERCENT]指定返回查询结果的前n行数据，如
果指定PERCENT关键字，则返回查询结果的前n%行数据。&lt;/li&gt;
  &lt;li&gt;
    &lt;目标列表达式&gt;：描述结果集的列，它制定了结果集中要包含的列的名称。
&lt;/目标列表达式&gt;
  &lt;/li&gt;
  &lt;li&gt;INTO &lt;新表名&gt;：指定使用结果集来创建新表，&lt;新表名&gt;指定新表的名称。&lt;/新表名&gt;&lt;/新表名&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FROM &lt;表名&gt;|&lt;视图名&gt;：该子句指定从中查询到结果集数据的源表名或源视图名。&lt;/视图名&gt;&lt;/表名&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;WHERE &lt;条件表达式&gt;：该子句是一个筛选条件，它定义了源表或源视图中的行要满足SELECT语句的要求所必须达到的条件。&lt;/条件表达式&gt;&lt;/li&gt;
  &lt;li&gt;GROUP BY &lt;列名l&gt;：该子句将结果按&lt;列名l&gt;的值进行分组，该属性列值相等的元组为一个组，通常需要在每组上取聚集函数值。&lt;/列名l&gt;&lt;/列名l&gt;&lt;/li&gt;
  &lt;li&gt;HAVING &lt;条件表达式&gt;：该子句是应用于结果集的附加筛选，用来向使用GROUP BY子句的查询中添加数据过滤准则。&lt;/条件表达式&gt;&lt;/li&gt;
  &lt;li&gt;ORDER BY &lt;列名2&gt; [ASC|DESC]：该子句定义了结果集中行的排序顺序，升序使用ASC关键字，降序使用DESC关键字，默认为升序。&lt;/列名2&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;确定范围&quot;&gt;确定范围&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;语句BETWEEN…AND…和NOT BETWEEN…AND…可以用来查找属性值在（或不在）指定范围内的元组，其中BETWEEN后是范围的下限（即低值），AND后是范围的上限（即高值）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;确定集合&quot;&gt;确定集合&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;运算符IN可以用来查找属性值属于指定集合的元组
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;字符匹配&quot;&gt;字符匹配&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;[NOT] LIKE ’&amp;lt;匹配串&amp;gt;’[ESCAPE ’&amp;lt;换码字符&amp;gt;’]
其含义是查找指定的属性列值与&amp;lt;匹配串&amp;gt;相匹配的元组。&amp;lt;匹配串&amp;gt;可以是一个完整的字符串，也可以含有通配符%和_。其中：
 %（百分号）：代表任意长度（长度可以为0）的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。如acb，addgb，ab等都满足该匹配串。
 _（下划线）：代表任意单个字符或汉字。例如a_b表示以a开头，以b结尾的长度为3的任意字符串。如acb，a王b等都满足该匹配串。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;涉及空值的查询例&quot;&gt;涉及空值的查询例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;where **** IS NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;多重条件查询&quot;&gt;多重条件查询&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;可用逻辑运算符AND和OR来联结多个查询条件。AND的优先级高于OR，但可以用括号改变优先级
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;order-by&quot;&gt;ORDER BY&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;  用户可以用ORDER BY子句对查询结果按照一个或多个属性列的升序（ASC）或降序（DESC）排列，缺省值为升序
SELECT *** FROM **
WHERE ***
ORDER BY *** DESC(ASC)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;带having子句的分组查询&quot;&gt;带HAVING子句的分组查询&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;当完成数据结果的查询和统计后，可以使用HAVING关键字来对查询和统计的结果进行进一步的筛选。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;输出前n行&quot;&gt;输出前n行&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;可以利用TOP语句输出查询结果集的前面若干行元组。也可以利用INTO语句将查询结果集输出到一个新建的数据表中
SELECT TOP NUMBER ** FROM ***
WHERE ***
ORDER BY **
TOP后面跟数字表示前几行，后跟PERCENT　表示百分比
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;查询结果集输出到新建表中&quot;&gt;查询结果集输出到新建表中&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;INTO子句用于把查询结果存放到一个新建的表中。新建的表名由&amp;lt;新表名&amp;gt;给出，新表的列由SELECT子句中指定的列构成
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;集合并运算&quot;&gt;集合并运算&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;集合并运算是将来自不同查询的结果集合组合起来，形成一个具有综合信息的查询结果集（并集），UNION操作会自动将重复的元组去除。
SELECT ** FROM **
WHERE ***
UNION
SELECT ** FROM **
WHERE ***
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;集合交运算&quot;&gt;集合交运算&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;集合交运算是将来自不同查询结果集合中共有的元组组合起来，形成一个具有综合信息的查询结果集（交集）
SELECT ** FROM **
WHERE ***
INTERSECT
SELECT ** FROM **
WHERE ***
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;集合差运算&quot;&gt;集合差运算&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;集合差运算是将属于左查询结果集但不属于右查询结果集的元组组合起来，形成一个具有综合信息的查询结果集（差集）。
SELECT ** FROM **
WHERE ***
EXCEPT
SELECT ** FROM **
WHERE ***
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;连接查询-内连接&quot;&gt;连接查询-内连接&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;SELECT &amp;lt;目标列表达式&amp;gt; [, … n]
    FROM &amp;lt;表1&amp;gt; INNER JOIN &amp;lt;表2&amp;gt;
   ON &amp;lt;连接条件表达式&amp;gt;[, … n]
注意：连接条件表达式中的各连接字段类型必须是可比的，但名称不必相同。
 USE JXGL
GO
SELECT S.*,SC.*
FROM S INNER JOIN SC
ON S.SNO=SC.SNO 
GO 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;连接查询-外连接&quot;&gt;连接查询-外连接&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;(1) 左外连接
左外连接是对连接条件左边的表不加限制。当左边表元组与右边表元组不匹配时，与右边表的相应列值取NULL。语句格式如下：
    SELECT &amp;lt;目标列表达式&amp;gt;[, … n]
    FROM &amp;lt;表1&amp;gt;LEFT[OUTER]JOIN &amp;lt;表2&amp;gt;[, … n]
    ON &amp;lt;连接条件表达式&amp;gt;

  (2) 右外连接
右外连接是对连接条件右边的表不加限制。当右边表元组与左边表元组不匹配时，与左边表的相应列值取NULL。语句格式如下：
SELECT &amp;lt;目标列表达式&amp;gt;[, … n]
FROM &amp;lt;表1&amp;gt; RIGHT [OUTER] JOIN &amp;lt;表2&amp;gt;[, … n]
ON &amp;lt;连接条件表达式&amp;gt;

(3) 全外连接
全外连接是对连接条件的两个表都不加限制。当一边表元组与另一边表元组不匹配时，与另一边表的相应列值取NULL。语句格式如下：
SELECT &amp;lt;目标列表达式&amp;gt; [, … n]
FROM &amp;lt;表1&amp;gt; FULL [OUTER] JOIN &amp;lt;表2&amp;gt;[, … n]
ON &amp;lt;连接条件表达式&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;交叉连接&quot;&gt;交叉连接&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;交叉连接（cross join）也称为笛卡尔积，它是在没有连接条件下的两个表的连接，包含了所连接的两个表中所有元组的全部组合。
该连接方式在实际应用中是很少的。语句格式如下：
  SELECT &amp;lt;目标列表达式&amp;gt; [,1 …n]
  FROM &amp;lt;表1&amp;gt; CROSS JOIN &amp;lt;表2&amp;gt;[,1 …n]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;子查询&quot;&gt;子查询&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;子查询（subquery）是指在一个SELECT查询语句中包含另一个SELECT查询语句，即一个SELECT语句嵌入到另一个SELECT语句中。其中，外层的SELECT语句称为父查询或外查询，嵌入内层的SELECT语句称为子查询或内查询。因此，子查询也称为嵌套查询（nested query）
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;无关子查询&quot;&gt;无关子查询&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;无关子查询的执行不依赖于父查询。它执行的过程是：首先执行子查询语句，得到的子查询结果集传递给父查询语句使用。无关子查询中对父查询没有任何引用
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;例  查询选修了“C3”号课程的学生的姓名和所在专业。
GO
SELECT SNAME,SDEPT 
FROM S
WHERE SNO IN
     (SELECT SNO
      FROM SC
      WHERE CNO='C3')
GO 
注意：子查询的SELECT语句不能使用ORDER BY子句，ORDER BY子句只能对最终查询结果排序。

例6.41 查询其它系中比计算机科学系（CS）某一学生年龄小的学生姓名和年龄。
    GO
    SELECT SNAME,AGE
    FROM S
    WHERE AGE&amp;lt;ANY(SELECT AGE
                     FROM S
                     WHERE SDEPT='CS')
              AND Sdept&amp;lt;&amp;gt;‘CS’      --注意这是父查询块中的条件
    GO
    SQL Server执行此查询时，首先处理子查询，找出CS系中所有学生的年龄，构成一个查询结果集合，如（21，23，22）。然后处理父查询，查找所有不是CS系且年龄小于21或23或22的学生。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;插入子查询结果&quot;&gt;插入子查询结果&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;子查询不仅可以嵌套在SELECT语句中，也可以嵌套在INSERT语句中，用以生成要插入的批量数据。
    插入子查询结果的INSERT语句的格式为：
     INSERT  INTO &amp;lt;表名&amp;gt;[(&amp;lt;列名&amp;gt;[, … n)]&amp;lt;子查询&amp;gt; 
例  对每一个系，求学生的平均年龄，并把结果存入数据库。首先在数据库中建立一个新表，其中一列存放系名，另一列存放相应的学生平均年龄。
    USE JXGL
    GO
    CREATE TABLE DEPT_AGE( SDEPT CHAR(15), AVG_AGE REAL)
    GO
    然后对S表按系分组求平均年龄，再把系名和平均年龄存入新表中。
    USE JXGL
    GO
    INSERT  INTO DEPT_AGE(SDEPT,AVG_AGE)
    SELECT SDEPT,AVG(AGE)
    FROM S
    GROUP BY SDEPT
    GO
  
     (2) 带子查询的删除语句
子查询也可以嵌套在DELETE语句中，用以构造执行删除操作的条件。
例6.45 删除计算机科学系（CS）所有学生的选课记录。
  USE JXGL
  GO
  DELETE
  FROM SC
  WHERE 'CS'=
      (SELECT SDEPT 
        FROM S
       WHERE S.SNO=SC.SNO)
  GO
                        
    (3) 带子查询的修改语句
子查询也可以嵌套在UPDATE语句中，用以构造修改的条件。
例  将计算机科学系（CS）全体学生的成绩提高5%。 
    USE JXGL
    GO
    UPDATE SC
    SET GRADE=GRADE+GRADE*0.05
    WHERE 'CS'=
       (SELECT SDEPT
        FROM S
        WHERE S.SNO=SC.SNO)
     GO   
注意：对某个基本表中数据的增、删、改操作有可能会破坏参照完整性。 

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;游标&quot;&gt;游标&lt;/h2&gt;

&lt;p&gt;声明游标
和使用其它类型变量一样，使用一个游标之前，必须先声明它。
    DECLARE CURSOR&lt;游标名&gt;
    [INSENSITIVE] [SCROLL] CURSOR
    FOR &lt;SELECT-语句&gt;
    [FOR READ ONLY|UPDATE[OF &lt;列名&gt;[, … n]]]
INSENSITIVE：定义的游标所选出来的元组存放在一个临时表中（建立在tempdb数据库中），对该游标的读取操作都有临时表来应答。
 SCROLL：指定游标使用的读取选项，默认时为NEXT，其取值如下表所示。&lt;/列名&gt;&lt;/SELECT-语句&gt;&lt;/游标名&gt;&lt;/p&gt;

&lt;p&gt;SCROLL的取值&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;SCROLL&lt;/strong&gt;选项&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;含 义&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;FIRST&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;读取游标中的第一行数据。&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;LAST&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;读取游标中的最后一行数据。&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;PRIOR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;读取游标当前位置的上一行数据。&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;NEXT&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;读取游标当前位置的下一行数据。&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;RELATIVE n&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;读取游标当前位置之前或之后的第&lt;/strong&gt;n行数据（n为正向前，为负向后）。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;ABSULUTE n&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;读取游标中的第&lt;/strong&gt;n行数据。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;READ ONLY：表示定义的游标为只读游标，表明不允许使用UPDATE、DELETE语句更新游标内的数据。默认状态下游标允许更新。
UPDATE[OF&lt;列名&gt;[, … n]]：指定游标内可以更新的列，如果没有指定要更新的列，则表明所有列都允许更新&lt;/列名&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mssql&quot;&gt;例  声明一个名为S_Cursor的游标，用以读取计算机科学系（CS）的所有学生的信息。
USE JXGL
GO
DECLARE S_Cursor CURSOR 
FOR SELECT *
         FROM S
         WHERE SDEPT='CS'
    GO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开游标
声明一个游标后，还必须使用OPEN语句打开游标，才能对其进行访问。语句格式如下：
    OPEN [GLOBAL] &lt;游标名&gt;|&lt;游标变量名&gt;
参数说明如下：
GLOBAL：指定游标为全局游标。&lt;/游标变量名&gt;&lt;/游标名&gt;&lt;/p&gt;
&lt;游标名&gt;：已声明的游标名称。如果一个全局游标与一个局部游标同名，则要使用GLOBAL表明其全局游标。
 &lt;游标变量名&gt;：游标变量的名称，该名称可以引用一个游标

当执行打开游标的语句时，服务器将执行声明游标时使用的SELECT语句。如果声明游标时使用了INSENSITIVE选项，则服务器会在tempdb中建立一个临时表，存放游标将要进行操作的结果集的副本。
利用OPEN语句打开游标后，游标位于查询结果集的第一个行。同时也可以使用全局变量@@cursor_rows获得最后打开的游标中符合条件的行数。

```mssql
例  打开例6.47所声明的游标。
    GO
    OPEN S_Cursor
    GO
```

读取游标
在打开游标后，就可以利用FETCH语句从查询结果集中读取数据。使用FETCH语句一次可以读取一条记录，具体语句格式如下：
FETCH [[NEXT|PRIOR|FIRST|LAST
|ABSOLUTE n|@nvar
|RELATIVE n|@nvar]
FROM]
    [GLOBAL]&lt;游标名&gt;|&lt;游标变量名&gt;
    [INTO @变量名[, … n]]
NEXT：返回结果集中当前行的下一行，并将当前行向后移一行。 
PRIOR：读取紧临当前行的前面一行，并将当前行向前移一行。

FIRST：读取结果集中的第一行并将其设为当前行。
LAST：读取结果集中的最后一行并将其设为当前行。
ABSOLUTE n|@nvar：如果n或@nvar为正数，读取从结果集头部开始的第n行，并将返回的行变为新的当前行；如果n或@nvar为负数，读取从结果集尾部之前的第n行，并将返回的行变为新的当前行；如果n或@nvar为0，则没有行返回。
RELATIVE n | @nvar：如果n或@nvar为正数，则读取当前行之后的第n行，并将返回的行变为新的当前行；如果n或@nvar为负数，则读取当前行之前的第n行，并将返回的行变为新的当前行；如果n或@nvar为0，则读取当前行。
GLOBAL：指定游标为全局游标。
INTO @变量名[, … n]：允许读取的数据存放在多个变量中。在变量行中的每个变量必须与结果集中相应的属性列对应（顺序、数据类型等）

 @@FETCH_STATUS全局变量返回上次执行FETCH命令的状态。返回值如下：
0：表示 FETCH 语句成功。
-1：表示FETCH 语句失败或此行不在结果集中。
-2：表示被读取的行不存在。

```mssql
例 从例6.47所声明的游标中读取数据。
    GO
    FETCH NEXT FROM S_Cursor
    GO

```

关闭游标
在处理完结果集中数据之后，必须关闭游标来释放结果集。可以使用CLOSE语句来关闭游标，但此语句不释放与游标有关的一切资源。语句格式如下：
CLOSE[GLOBAL]&lt;游标名&gt;|&lt;游标变量名&gt;
其中各参数意义与打开命令一致。

```mssql
例  关闭例6.47所声明的游标。
     GO
     CLOSE S_Cursor
     GO
```

释放游标
游标使用不再需要之后，要释放游标，以获取与游标有关的一切资源。语句格式如下：
DEALLOCATE[GLOBAL]&lt;游标名&gt;|&lt;游标变量名&gt;
其中各参数意义与打开命令一致。

```mssql
例  释放例6.47所声明的游标。
     GO
     DEALLOCATE S_Cursor
     GO
```

## 创建视图

```mssql
语句格式为：
     CREATE VIEW &lt;视图名&gt;[(&lt;列名&gt;[, … n ])] 
     AS 
      &lt;SELECT查询子句&gt; 
     [WITH CHECK OPTION] 
```

```mssql
例7.2 建立数学系（MA）学生的视图V_MA，并要求进行修改和插入操作时仍需保证该视图只有数学系的学生。 
USE JXGL
GO
CREATE VIEW V_MA
AS
SELECT SNO,SNAME,AGE
FROM S
WHERE SDEPT='MA'
WITH CHECK OPTION
GO    
由于在定义V_MA视图时加上了WITH CHECK OPTION子句，以后对该视图进行插入、修改和删除操作时，RDBMS会验证条件SDEPT=’MA’。
```

## 修改视图

```mssql
T-SQL提供了ALTER VIEW语句修改视图，语句格式如下：
     ALTER VIEW &lt;视图名&gt;[(&lt;列名&gt;[, … n ])] 
     AS 
     &lt;SELECT查询子句&gt; 
     [WITH CHECK OPTION]
```

```mssql
例7.5 修改例7.2中视图V_MA，并要求该视图只查询数学系（MA）的男学生。 
    USE JXGL
    GO
    ALTER VIEW V_MA
    AS
    SELECT SNO,SNAME,AGE
    FROM S
    WHERE SDEPT='MA' AND SEX='M'
    WITH CHECK OPTION
    GO
```

## 删除视图

DROP VIEW &lt;视图名&gt;
&lt;/视图名&gt;&lt;/SELECT查询子句&gt;&lt;/列名&gt;&lt;/视图名&gt;&lt;/SELECT查询子句&gt;&lt;/列名&gt;&lt;/视图名&gt;&lt;/游标变量名&gt;&lt;/游标名&gt;&lt;/游标变量名&gt;&lt;/游标名&gt;&lt;/游标变量名&gt;&lt;/游标名&gt;&lt;/游标变量名&gt;&lt;/游标名&gt;</content><author><name></name></author><category term="sql" /><summary type="html">部分语句模板</summary></entry><entry><title type="html">删除文件原理</title><link href="http://localhost:4000/_posts/2020-05-12-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86/" rel="alternate" type="text/html" title="删除文件原理" /><published>2020-05-12T00:00:00+08:00</published><updated>2020-05-12T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-12-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%8E%9F%E7%90%86/">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux删除文件原理&quot;&gt;LINUX删除文件原理&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linux是通过link的数量来控制文件删除的，只有当一个文件不存在任何link的时候，这个文件才会被删除。一般来说，每个文件都有2个link计数器:&lt;code&gt;i_count&lt;/code&gt; 和&lt;code&gt;i_link&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;i_count&lt;/code&gt;的意义是当前文件使用者（或被调用）的数量,i_link 的意义是介质连接的数量（硬链接的数量）；可以理解为&lt;code&gt;i_count&lt;/code&gt;是内存引用计数器，i_link是磁盘的引用计数器。&lt;/p&gt;

&lt;p&gt;当一个文件被某一个进程引用时，对应&lt;code&gt;i_count&lt;/code&gt;数就会增加；当创建文件的硬链接的时候，对应&lt;code&gt;i_link&lt;/code&gt;数就会增加&lt;/p&gt;

&lt;p&gt;&lt;code&gt;**对于删除命令rm而言，实际就是减少磁盘引用计数i_link**。&lt;/code&gt;这里就会有一个问题，如果一个文件正在被某个进程调用，而用户却执行rm操作把文件删除了，那么会出现什么结果呢？当用户执行rm操作删除文件后，再执行ls或者其他文件管理命令，无法再找到这个文件了，但是调用这个删除的文件的进程却在继续正常执行，依然能够从文件中正确的读取及写入内容.&lt;/p&gt;

&lt;p&gt;这是因为rm操作只是将文件的i_link减少了，如果没其它的链接i_link就为0了；但由于该文件依然被进程引用，因此，此时文件对应的i_count并不为0，所以即使执行rm操作，但系统并没有真正删除这个文件，当只有i_link及i_count都为0的时候，这个文件才会真正被删除。也就是说，还需要解除该进程的对该文件的调用才行。&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">LINUX删除文件原理</summary></entry><entry><title type="html">JAVA一些问题二</title><link href="http://localhost:4000/_posts/2020-05-11-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%89/" rel="alternate" type="text/html" title="JAVA一些问题二" /><published>2020-05-11T00:00:00+08:00</published><updated>2020-05-11T00:00:00+08:00</updated><id>http://localhost:4000/_posts/JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%89</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-11-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%89/">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;并行和并发区别&quot;&gt;&lt;strong&gt;并行和并发区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。&lt;/li&gt;
  &lt;li&gt;并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。&lt;/li&gt;
  &lt;li&gt;在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程和进程的区别&quot;&gt;&lt;strong&gt;线程和进程的区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;守护线程&quot;&gt;&lt;strong&gt;守护线程&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建线程方式&quot;&gt;&lt;strong&gt;创建线程&lt;/strong&gt;方式&lt;em&gt;**&lt;/em&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①. 继承Thread类创建线程类&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。&lt;/li&gt;
  &lt;li&gt;创建Thread子类的实例，即创建了线程对象。&lt;/li&gt;
  &lt;li&gt;调用线程对象的start()方法来启动该线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;②. 通过Runnable接口创建线程类&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。&lt;/li&gt;
  &lt;li&gt;创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。&lt;/li&gt;
  &lt;li&gt;调用线程对象的start()方法来启动该线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;③. 通过Callable和Future创建线程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。&lt;/li&gt;
  &lt;li&gt;创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。&lt;/li&gt;
  &lt;li&gt;使用FutureTask对象作为Thread对象的target创建并启动新线程。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用FutureTask对象的get()方法来获得子线程执行结束后的返回值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;runnable-和-callable-区别&quot;&gt;&lt;strong&gt;runnable 和 callable 区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程状态&quot;&gt;&lt;strong&gt;线程状态&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。&lt;/li&gt;
  &lt;li&gt;就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。&lt;/li&gt;
  &lt;li&gt;运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。&lt;/li&gt;
  &lt;li&gt;阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 　　&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;sleep-和-wait-区别&quot;&gt;&lt;strong&gt;sleep() 和 wait()&lt;/strong&gt; 区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep()  方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。&lt;/p&gt;

&lt;p&gt;wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;notify和-notifyall区别&quot;&gt;&lt;strong&gt;notify()和 notifyAll()&lt;/strong&gt;区别&lt;em&gt;**&lt;/em&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。&lt;/p&gt;

&lt;p&gt;当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait  线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。&lt;/p&gt;

&lt;p&gt;优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized  代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程的-run和-start区别&quot;&gt;&lt;strong&gt;线程的 run()和 start()&lt;/strong&gt;区别&lt;em&gt;**&lt;/em&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。&lt;/p&gt;

&lt;p&gt;start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态，  这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。&lt;/p&gt;

&lt;p&gt;run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建线程池方式&quot;&gt;&lt;strong&gt;创建线程池方式&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①. newFixedThreadPool(int nThreads)&lt;/p&gt;

&lt;p&gt;创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。&lt;/p&gt;

&lt;p&gt;②. newCachedThreadPool()&lt;/p&gt;

&lt;p&gt;创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。&lt;/p&gt;

&lt;p&gt;③. newSingleThreadExecutor()&lt;/p&gt;

&lt;p&gt;这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。&lt;/p&gt;

&lt;p&gt;④. newScheduledThreadPool(int corePoolSize)&lt;/p&gt;

&lt;p&gt;创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程池状态&quot;&gt;&lt;strong&gt;线程池&lt;/strong&gt;状态&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated&lt;/p&gt;

&lt;p&gt;线程池各个状态切换框架图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/博客/verylazycat.github.io/img/线程池.png&quot; alt=&quot;线程池&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程池中-submit和-execute方法区别&quot;&gt;&lt;strong&gt;线程池中 submit()和 execute()方法&lt;/strong&gt;区别&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;接收的参数不一样&lt;/li&gt;
  &lt;li&gt;submit有返回值，而execute没有&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;submit方便Exception处理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;在-java-程序中怎么保证多线程的运行安全&quot;&gt;&lt;strong&gt;在 java 程序中怎么保证多线程的运行安全&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程安全在三个方面体现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；&lt;/li&gt;
  &lt;li&gt;可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;多线程锁的升级原理&quot;&gt;&lt;strong&gt;多线程锁的升级原理&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/博客/verylazycat.github.io/img/锁升级.png&quot; alt=&quot;锁升级&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;死锁&quot;&gt;&lt;strong&gt;死锁&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;防止死锁&quot;&gt;&lt;strong&gt;防止死锁&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;死锁的四个必要条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源&lt;/li&gt;
  &lt;li&gt;请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放&lt;/li&gt;
  &lt;li&gt;不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放&lt;/li&gt;
  &lt;li&gt;环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。&lt;/p&gt;

&lt;p&gt;此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;threadlocal&quot;&gt;&lt;strong&gt;ThreadLocal&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web  服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;synchronized-底层实现原理&quot;&gt;&lt;strong&gt;synchronized 底层实现原理&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。&lt;/p&gt;

&lt;p&gt;Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;普通同步方法，锁是当前实例对象&lt;/li&gt;
  &lt;li&gt;静态同步方法，锁是当前类的class对象&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同步方法块，锁是括号里面的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;synchronized-和-volatile-的区别&quot;&gt;&lt;strong&gt;synchronized 和 volatile 的区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。&lt;/li&gt;
  &lt;li&gt;volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。&lt;/li&gt;
  &lt;li&gt;volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。&lt;/li&gt;
  &lt;li&gt;volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;synchronized-和-lock-区别&quot;&gt;&lt;strong&gt;synchronized 和 Lock 区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;首先synchronized是java内置关键字，在jvm层面，Lock是个java类；&lt;/li&gt;
  &lt;li&gt;synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；&lt;/li&gt;
  &lt;li&gt;synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；&lt;/li&gt;
  &lt;li&gt;用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；&lt;/li&gt;
  &lt;li&gt;synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；&lt;/li&gt;
  &lt;li&gt;Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;synchronized-和-reentrantlock-区别&quot;&gt;&lt;strong&gt;synchronized 和 ReentrantLock 区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁&lt;/li&gt;
  &lt;li&gt;ReentrantLock可以获取各种锁的信息&lt;/li&gt;
  &lt;li&gt;ReentrantLock可以灵活地实现多路通知&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;atomic-的原理&quot;&gt;&lt;strong&gt;atomic 的原理&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。&lt;/p&gt;

&lt;p&gt;Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。&lt;/p&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">并行和并发区别</summary></entry><entry><title type="html">sql-server复习二</title><link href="http://localhost:4000/_posts/2020-05-10-sql-server%E5%A4%8D%E4%B9%A0%E4%BA%8C/" rel="alternate" type="text/html" title="sql-server复习二" /><published>2020-05-10T00:00:00+08:00</published><updated>2020-05-10T00:00:00+08:00</updated><id>http://localhost:4000/_posts/sql-server%E5%A4%8D%E4%B9%A0%E4%BA%8C</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-10-sql-server%E5%A4%8D%E4%B9%A0%E4%BA%8C/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;关系模式&quot;&gt;关系模式&lt;/h1&gt;

&lt;p&gt;每个关系都有一个模式，称为关系模式(relation schema)，由一个关系名及它的所有属性名构成。一般表示为：关系名（属性1,属性2,…,属性n）&lt;/p&gt;

&lt;p&gt;关系是一种规范化了的二维表格，具有如下性质：
属性值是原子的，不可分解。
没有重复元组。
没有行序。
理论上没有列序，但一般使用时都有列序&lt;/p&gt;

&lt;h1 id=&quot;关键码和表之间的联系&quot;&gt;关键码和表之间的联系&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;超键：在一个关系中，能惟一标识元组的属性或属性集称为关系的超键&lt;/li&gt;
  &lt;li&gt;候选键：如果一个属性集能惟一标识元组，且又不含有多余的属性，那么这个属性集称为关系的候选键。&lt;/li&gt;
  &lt;li&gt;主键：若一个关系中有多个候选键，则选其中的一个为关系的主键。&lt;/li&gt;
  &lt;li&gt;外键：若一个关系R中包含有另一个关系S的主键所对应的属性组F，则称F为R的外键。并称关系S为参照关系，关系R为依赖关系。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;基本的关系操作&quot;&gt;基本的关系操作&lt;/h1&gt;

&lt;p&gt;关系模型中常用的关系操作包括&lt;code&gt;查询（Query）&lt;/code&gt;操作和&lt;code&gt;插入（Insert）&lt;/code&gt;、&lt;code&gt;删除（Delete）&lt;/code&gt;、&lt;code&gt;修改（Update）&lt;/code&gt;操作。
查询操作又可以分为：&lt;code&gt;选择（Select）&lt;/code&gt;、&lt;code&gt;投影（Project）&lt;/code&gt;、&lt;code&gt;连接（Join）&lt;/code&gt;、&lt;code&gt;除（Divide）&lt;/code&gt;、&lt;code&gt;并（Union）&lt;/code&gt;、&lt;code&gt;差（Except）&lt;/code&gt;、&lt;code&gt;交（Intersection）&lt;/code&gt;、&lt;code&gt;笛卡尔积等&lt;/code&gt;。其中选择、投影、并、差、笛卡尔积是5种基本操作&lt;/p&gt;

&lt;h1 id=&quot;实体完整性entity-integrity约束&quot;&gt;实体完整性（Entity Integrity）约束&lt;/h1&gt;

&lt;p&gt;若属性（指一个或一组属性）A是基本关系R的主属性。则A不能取空值。&lt;/p&gt;

&lt;h1 id=&quot;参照完整性约束&quot;&gt;参照完整性约束&lt;/h1&gt;

&lt;p&gt;如果属性集K是关系模式R1的主键，K也是关系模式R2的外键，那么在R2的关系中，K的取值只允许两种可能，或者为空值，或者等于R1关系中某个主键值。
 这条规则的实质是“不允许引用不存在的实体”。
 在上述形式定义中，关系模式R1的关系称为“参照关系”，关系模式R2的关系称为“依赖关系”。&lt;/p&gt;

&lt;h1 id=&quot;用户定义的完整性规则&quot;&gt;用户定义的完整性规则&lt;/h1&gt;

&lt;p&gt;用户定义完整性约束（user defined integrity constraint）就是针对用户的具体应用环境，给出的具体数据的约束条件。 
用户可以针对具体的数据要求特征，设置完整性约束，由系统来检验实施，以使用统一的方法处理它们，不再由应用程序承担这项工作&lt;/p&gt;

&lt;h1 id=&quot;传统的集合运算&quot;&gt;传统的集合运算&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;并（Union）
      设关系R和S具有相同的关系模式，R和S的并是由属于R或属
  于S的元组构成的集合，记为R∪S。形式定义如下：
  R∪S≡{t | t∈R ∨ t∈S}，t是元组变量，R和S的元数相同。&lt;/li&gt;
  &lt;li&gt;差（Difference）
      设关系R和S具有相同的关系模式，R和S的差是由属于R但不
  属于S的元组构成的集合，记为R－S。形式定义如下：
  R－S≡{ t | t∈R ∧ t∈S}，R和S的元数相同。&lt;/li&gt;
  &lt;li&gt;交（intersection）
      关系R和S的交是由属于R又属于S的元组构成的集合，记为
R∩S，这里要求R和S定义在相同的关系模式上。形式定义如
下：
       R∩S≡{t︱t∈R ∧ t∈S}，R和S的元数相同。
由于R∩S = R-(R-S)，或R∩S = S-(S-R)，因此交操作不是一个独立的操作。&lt;/li&gt;
  &lt;li&gt;笛卡儿积(Cartesian Product)
    设关系R和S的元数分别为r和s,定义R和S的一个(r+s)元的元
组集合，每个元组的前r个分量来自R的一个元组，后s个分量来自S的一个元组，记为R×S。
       R×S ≡{t|t=&amp;lt;tr,ts&amp;gt;∧tr∈R∧ts∈S}&lt;/li&gt;
  &lt;li&gt;选择（Selection）
选择是在关系R中选择满足给定条件的所有元组构成的新关系。形式定义为：
σF(R)={t|t∈R∧F(t)=true}其中，F表示选择条件，它是一个逻辑表达式，取逻辑值“true”或“false”。在选择条件表达式F中，有时属性也用其排列序号来表示，常量值用单引号括起来。
例如，σ2＞ˊ3ˊ（R）表示从R中挑选第2个分量值大于3的元组所构成的关系。
书写时，为了与属性序号区别起见，常量用引号括起来，而属性序号或属性名不要用引号括起来。&lt;/li&gt;
  &lt;li&gt;投影
关系R上的投影是从R中选择出若干属性列组成新的关系。形式定义为：
 πA(R)={t[A] | t∈R}
其中A为R中的属性列集合，其中A也可以用属性序号表示。 
投影操作是从列角度进行的运算。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;连接（join）
连接（join）运算是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;实例&quot;&gt;实例&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例2.11 设教学数据库中有三个关系：
      学生关系   S(S#,SNAME,AGE,SEX)
      选课关系   SC(S#,C#,GRADE)&lt;br /&gt;
      课程关系    C(C#,CNAME,TEACHER)
   用关系代数表达式表示查询语句。
  (1) 检索学习课程号为C2的学生学号与成绩。
        πS#,GRADE(σC#=‘C2’ (SC))
 (2) 检索学习课程号为C2的学生的学号与姓名。
         πS#,SNAME(σC#=‘C2’ (S ⋈ SC))
 (3) 检索选修课程名为MATHS的学生学号与姓名。
           πS#,SNAME(σCNAME=‘MATHS’ (S ⋈ SC ⋈ C))&lt;/p&gt;

&lt;p&gt;(4) 检索选修课程号为C2或C4的学生学号。
           πS#(σC#=‘C2’ ∨C#=‘C4’(SC))
  (5) 检索至少选修课程号为C2和C4的学生学号。
           π1(σ1=4∧2=‘C2’ ∧5=‘C4’ (SC×SC))&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;一般地有下列规律：
(1) 对于只涉及到选择、投影、连接的查询可用下列表达式表示：                &lt;br /&gt;
             π(σ(R×S)) 	或者π(σ(R       S))
(2) 对于否定的操作，一般要用差操作表示，例如“检索不学C2课的学生姓名”。用下列表达式表示：
          πSNAME(S)-πSNAME(σCNO=’C2’(S       SC))但不能用下式表示：    		πSNAME(σCNO≠’C2’(S       SC))  &lt;br /&gt;
⑶ 对于检索具有“全部”特征的操作，一般要用除法操作表示，例如“检索学习全部课程的学生学号”。用下列表达式表示：    &lt;br /&gt;
         要用πSNO,CNO(SC)÷πCNO(C)表示&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;规范化原则&quot;&gt;规范化原则&lt;/h1&gt;

&lt;p&gt;关系模式有操作异常或冗余问题，就分解它&lt;/p&gt;

&lt;h1 id=&quot;函数依赖的定义&quot;&gt;函数依赖的定义&lt;/h1&gt;

&lt;p&gt;设有关系模式R(U)，X和Y是属性集U的子集，若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖（Functional Depend-
ency，简记为FD）于X，记作X→Y&lt;/p&gt;

&lt;h1 id=&quot;完全函数依赖和部分函数依赖&quot;&gt;完全函数依赖和部分函数依赖&lt;/h1&gt;

&lt;p&gt;假设在关系模式R(U)中，X和Y是属性集U的子集，且有X→Y，如果对于X的任一个真子集W，都有W→Y不成立，则称Y完全函数依赖于X，否则，称Y部分函数依赖于X。
 完全函数依赖说明了在依赖关系的决定项中没有多余的属性。
如函数依赖(SNO,CNO)→GRADE，TNAME→TAGE是完全函数依赖。 (SNO,CNO)→SNAME，(SNO,CNO)→CNAME，(SNO,CNO)→TNAME，(SNO,CNO)→TAGE都是部分函数依赖。&lt;/p&gt;

&lt;h1 id=&quot;fd和关键码的联系&quot;&gt;FD和关键码的联系&lt;/h1&gt;

&lt;p&gt;利用完全函数依赖和部分函数依赖可以说明函数依赖和键的关系：假设关系
模式R的属性集是U，X是U的一个子集。如果U部分函数依赖于X，则X是R的一个
超键。如果U完全函数依赖于X，则X是R的一个候选键。&lt;/p&gt;

&lt;h1 id=&quot;传递函数依赖&quot;&gt;传递函数依赖&lt;/h1&gt;

&lt;p&gt;假设在关系模式R(U)中，X 、Y和Z是属性集U的不同子集，如果X→Y（并且Y→X不成立），Y→Z，则称Z传递函数依赖X，或称X传递函数确定Z。
如函数依赖CNO→TNAME和TNAME→TAGE，所以R的函数依赖CNO→TAGE是传递函数依赖。&lt;/p&gt;

&lt;h1 id=&quot;armstrong推理&quot;&gt;Armstrong推理&lt;/h1&gt;

&lt;p&gt;从已知的一些函数依赖，可以推导出另外一些函数依赖，这就需要一系列的推理规则。称为Armstrong公理。&lt;/p&gt;

&lt;p&gt;设U是关系模式R的属性集，F是R上成立的只涉及到U中属性的函数依赖集。FD的推理规则有以下三条：
 A1（自反性，Reflexivity）：若YXU，则X→Y在R上成立。
 A2（增广性，Augmentation）：若X→Y在R上成立，且ZU，则XZ→YZ在R上成立。
 A3（传递性，Transitivity）：若X→Y和Y→Z在R上成立，则X→Z在R上成立。&lt;/p&gt;

&lt;p&gt;FD的其他五条推理规则:
(1) A4（合并性，Union）：｛ X→Y，X→Z ｝⊨X→YZ。
(2) A5（分解性，Decomposition）：  ｛ X→Y，ZY ｝ ⊨ X→Z 。
(3) A6（伪传递性）：｛ X→Y，WY→Z ｝⊨ WX→Z。
(4) A7（复合性，Composition）：  ｛ X→Y，W→Z ｝ ⊨ XW→YZ。&lt;/p&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;例2.14  设关系R(ABCDE)上函数依赖集为F，并且F={A→BC，CD→E，B→D，E→A}。求出R的候选键。
解：已知A→BC，由分解性得A→B，A→C；又已知B→D，由传递性得 A→D；又由合并性得 A→CD，又已知CD→E，再由传递性得 A→E，因此，A是R的一个候选键。
同理可得R的另外三个候选键E、CD和BC。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;关系的范式及规范化&quot;&gt;关系的范式及规范化&lt;/h1&gt;

&lt;p&gt;关系模式的好与坏，用什么标准衡量？这个标准就是模式的范式
（Normal Forms，简记为NF）。范式的种类与数据依赖有着直接的联系，基于FD的范式有1NF、2NF、3NF、BCNF等多种。
在不提及FD时，关系中是不可能有冗余的问题，但是当存在FD时，关系中就有可能存在数据冗余问题。
1NF是关系模式的基础；2NF已成为历史，一般不再提及；在数据库设计中最常用的是3NF和BCNF。&lt;/p&gt;

&lt;p&gt;对于各种范式之间的联系有：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;BCNF | 3NF | 2NF | 1NF
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;范式&quot;&gt;范式&lt;/h1&gt;

&lt;h2 id=&quot;第一范式&quot;&gt;第一范式&lt;/h2&gt;

&lt;p&gt;定义 如果关系模式R的每个关系r的属性值都是不可分的原子值，那么称R是第一范式（first normal form，简记为1NF）的模式。
满足1NF的关系称为规范化的关系，否则称为非规范化的关系。关系数据库研究的关系都是规范化的关系。例如关系模式R（NAME，
ADDRESS，PHONE），如果一个人有两个电话号码（PHONE），那么在关系中至少要出现两个元组，以便存储这两个号码。
1NF是关系模式应具备的最起码的条件。&lt;/p&gt;

&lt;p&gt;非规范模式变为1NF：
   (1)  把不含单纯值的属性分解为多个原子值。
   (2)  把关系模式分解。&lt;/p&gt;

&lt;h2 id=&quot;第二范式&quot;&gt;第二范式&lt;/h2&gt;

&lt;p&gt;定义 如果关系模式R是1NF，且每个非主属性完全函数依赖于候选键，那么称R是第二范式（2NF）的模式。如果数据库模式中每个关系模式都是2NF，则称数据库模式为2NF的数据库模式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;例2.15 设关系模式R(SNO,CNO,GRADE,TNAME,TADDR) 。  
（SNO,CNO）是R的候选键。R上有两个函数依赖：
  (SNO,CNO)→(TNAME,TADDR)
   CNO→(TNAME,TADDR)
 前一个函数依赖是局部依赖，R不属于2NF模式。此时R的关系就会出现数据冗余和操作异常现象。
如果把R分解成R1(CNO,TNAME,TADDR)和R2(SNO,CNO,GRADE)后，局部依赖(SNO,CNO)→(TNAME,TADDR)就消失了。R1和R2都属于2NF模式。  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;第三范式&quot;&gt;第三范式&lt;/h2&gt;

&lt;p&gt;定义  如果关系模式R是1NF，且每个非主属性都不传递依赖于R的候选键，那么称R是第三范式（3NF）的模式。如果数据库模式中每个关系模式都是3NF，则称其为3NF的数据库模式 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;例  在例2.15中，R2是2NF模式，而且也已是3NF模式。
R1(CNO,TNAME,TADDR)是2NF模式，却不是3NF模式。这是因为R1中存在函数依赖CNO→TNAME和TNAME→TADDR，则CNO→TADDR是一个传递依赖。
如果把R2分解成R21(TNAME,TADDR)和R22(CNO,TNAME)后，CNO→TADDR就不会出现在R21和R22中。这样R21和R22都是3NF模式。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bc范式&quot;&gt;BC范式&lt;/h2&gt;

&lt;p&gt;定义 如果关系模式R是1NF，且每个属性都不传递依赖于R的候选键，那么称R是BCNF的模式。如果数据库模式中每个关系模式都是BCNF，则称为BCNF的数据库模式。
如果R是BCNF模式，那么R也是3NF模式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;例2.16 设关系模式C(CNO,CNAME,PCNO)的属性分别表示课程号、课程名和先修课程号。
CNO是主键，这里没有任何非主属性对CNO部分依赖或传递依赖，所以C属于3NF。
同时C中CNO是唯一的决定因素，所以C∈BCNF。 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;例2.17 关系模式STJ(S，T，J)中，S表示学生，T表示教师，J表示课程。每一教师只教一门课。每门课有若干教师，某一学生选定某门课，就对应一个固定的教师。由语义可得到如下的函数依赖。
(S，J)→T；(S，T)→J；T→J。
这里(S，J)、(S，T)都是候诜键。
STJ是3NF，因为没有任何非主属性对键函数传递依赖或部分函数依赖。但STJ不是BCNF模式，是因为T是决定因素，而T不包含键。
3NF和BC范式是在函数依赖的条件下对模式分解所能达到的分离程度的测度。一个数据库中的关系模式如果都是BC范式，那么在函数依赖范畴内，它已经实现彻底的分离，已消除了插入和删除异常。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;无损分解&quot;&gt;无损分解&lt;/h1&gt;

&lt;p&gt;定义 当对关系模式R进行分解时，R的元组将分别在相应属性集进行投影而产生新的关系。如果对新的关系进行自然连接得到的元组集合与原关系完全一致，则称该分解为无损分解（lossless decompose）。否则称为有损分解。&lt;/p&gt;

&lt;h1 id=&quot;heath定理&quot;&gt;Heath定理&lt;/h1&gt;

&lt;p&gt;假设关系模式R分解为两个子关系模式R1和R2，如果R1∩R2至少包含其中一个子关系模式的主键，则此分解是无损分解。
      在例2.18中，R(SNO,CNAME,TNAME,GRADE)分解成两个子关系模式R1(SNO,CNAME,GRADE)和R2(CNAME,TNAME)，由于R1∩R2={CNAME}，而CNAME是关系模式R2的主键，由Heath定理，该分解为无损分解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;例：设有关系模式R（{SNO，Sname,CNO,Grade},                                 
        的一个分解为：
      R1(SNO,Sname),R2(SNO,CNO,Grade)
     因为R1∩R2=SNO, 由于SNO是R1的主键，则分解具有无损性连接。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;保持函数依赖分解&quot;&gt;保持函数依赖分解&lt;/h1&gt;

&lt;p&gt;模式分解的过程还必须保证数据的语义完整性。在做任何数据输入和修改时，只要每个关系模式本身的函数依赖被满足，就可以确保整个数据库中数据的语义完整性不受破坏。
定义：设ρ={R1(U1),R2(U2),…,Rn(Un)}是关系模式R(U)的一个分解，R的函数依赖集F在Ui上的投影为Fi，如果满足              ，则称ρ具有函数依赖保持性，也称该分解为保持依赖分解（preserve depend-ency decompose）&lt;/p&gt;

&lt;h1 id=&quot;3nf分解&quot;&gt;3NF分解&lt;/h1&gt;

&lt;p&gt;前在信息系统的设计中，广泛被采用的是“基于3NF的系统设计”方法 。
将R分解成多个3NF关系模式的步骤如下：
(1) 如果R不属于1NF，对其进行分解，使其满足1NF。
分解为1NF的方法可以直接将其多值属性进行分解，用分解后的多个单值属性集取代原来的属性。如关系模式R(NAME,ADDRESS,PHONE)中，假设每条记录至多有3个电话号码。此时可将多值属性分解为R1(NAME,ADDRESS,PHONE1,PHONE2,PHONE3)。有时，当多值属性取值较多时，为了防止出现大量的空值，一般将多值属性单独定义为一个实体。&lt;/p&gt;

&lt;p&gt;(2) 如果R属于1NF但R不属于2NF，分解R使其满足2NF。
将关系模式分解为符合2NF条件的方法如下：
设关系模式R(U)，主键是W，R上还存在函数依赖X→Z，并且Z是非主属性和XW，那么W→Z就是一个局部依赖。此时应把R分解成两个模式R1(XZ)，主键是X和R2(Y)，其中Y=U-Z，主键仍是W，外键是X。&lt;/p&gt;

&lt;p&gt;(3) 如果R属于2NF但R不属于3NF，分解R使其满足3NF。
将关系模式分解为符合3NF条件的方法如下：设关系模式R(U)，主键是W，R上还存在函数依赖X→Z。Z不含于X并且是非主属性，X不是候选键，那么W→Z就是一个传递函数依赖。
此时应把R分解成两个模式R1(XZ)，主键是X和R2(Y)，其中Y=U-Z，主键仍是W，外键是X。如在例2.15的关系模式R1(CNO,TNAME,TADDR)，取W={CNO}，X={TNAME}，Z={TADDR}，利用该方法就可以得到符合3NF的关系模式R11(TNAME,TADDR)和R12(CNO,TNAME)。&lt;/p&gt;

&lt;h1 id=&quot;事务四大特性及隔离级别&quot;&gt;事务四大特性及隔离级别&lt;/h1&gt;

&lt;h2 id=&quot;特性&quot;&gt;特性:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;原子性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一致性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;隔离性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;隔离性是当多个用户&lt;code&gt;并发&lt;/code&gt;访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;持久性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。&lt;/p&gt;

&lt;h2 id=&quot;隔离级别&quot;&gt;隔离级别&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;脏读&lt;/p&gt;

    &lt;p&gt;脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不可重复读&lt;/p&gt;

    &lt;p&gt;不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚读&lt;/p&gt;

    &lt;p&gt;幻读是事务非独立执行时发生的一种现象&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="sql" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux笔记</title><link href="http://localhost:4000/_posts/2020-05-09-linux%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="linux笔记" /><published>2020-05-09T00:00:00+08:00</published><updated>2020-05-09T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-09-linux%E7%AC%94%E8%AE%B0/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;unix和linux区别&quot;&gt;Unix和Linux区别&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;开源性
Linux是一款开源操作系统，不需要付费，即可使用；Unix是一款对源码实行知识产权保护的传统商业软件，使用需要付费授权使用。&lt;/li&gt;
  &lt;li&gt;跨平台性
Linux操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix操作系统跨平台性能较弱，大多需与硬件配套使用。&lt;/li&gt;
  &lt;li&gt;可视化界面
Linux除了进行命令行操作，还有窗体管理系统；Unix只是命令行下的系统。&lt;/li&gt;
  &lt;li&gt;硬件环境
Linux操作系统对硬件的要求较低，安装方法更易掌握；Unix对硬件要求比较苛刻，按照难度较大。&lt;/li&gt;
  &lt;li&gt;用户群体
Linux的用户群体很广泛，个人和企业均可使用；Unix的用户群体比较窄，多是安全性要求高的大型企业使用，如银行、电信部门等，或者Unix硬件厂商使用，如Sun等。相比于Unix操作系统，Linux操作系统更受广大计算机爱好者的喜爱，主要原因是Linux操作系统具有Unix操作系统的全部功能，并且能够在普通PC计算机上实现全部的Unix特性，开源免费的特性，更容易普及使用&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;linux-内核&quot;&gt;Linux 内核&lt;/h1&gt;

&lt;p&gt;Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;系统内存管理&lt;/li&gt;
  &lt;li&gt;应用程序管理&lt;/li&gt;
  &lt;li&gt;硬件设备管理&lt;/li&gt;
  &lt;li&gt;文件系统管理&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;linux的基本组件&quot;&gt;Linux的基本组件&lt;/h1&gt;

&lt;p&gt;Linux内核、Shell、GUI,文件系统、应用程序&lt;/p&gt;

&lt;h1 id=&quot;linux-的体系结构&quot;&gt;Linux 的体系结构&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/linux.png&quot; alt=&quot;linux&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。
内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code)&lt;/p&gt;

&lt;p&gt;Linux 体系结构要分为用户空间和内核空间的原因&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1、现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问的寄存器不同。&lt;/li&gt;
  &lt;li&gt;2、Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用户空间和内核空间是程序执行的&lt;strong&gt;两种不同的状态&lt;/strong&gt;，我们可以通过两种方式完成用户空间到内核空间的转移：1）系统调用；2）硬件中断&lt;/p&gt;

&lt;h1 id=&quot;bash和dos之间的区别&quot;&gt;BASH和DOS之间的区别&lt;/h1&gt;

&lt;p&gt;BASH和DOS控制台之间的主要区别在于3个方面：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BASH命令区分大小写，而DOS命令则不区分;&lt;/li&gt;
  &lt;li&gt;在BASH下，/ character是目录分隔符，\作为转义字符。在DOS下，/用作命令参数分隔符，\是目录分隔符&lt;/li&gt;
  &lt;li&gt;DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，扩展名为3个字符。BASH没有遵循这样的惯例&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;linux-开机启动过程&quot;&gt;Linux 开机启动过程&lt;/h1&gt;

&lt;p&gt;1、主机加电自检，加载 BIOS 硬件信息。&lt;/p&gt;

&lt;p&gt;BIOS(Basic Input/Output System)，基本输入输出系统，该系统存储于主板的ROM芯片上，计算机在开机时，会最先读取该系统，然后会有一个加电自检过程，这个过程其实就是检查CPU和内存，计算机最基本的组成单元(控制器、运算器和存储器)，还会检查其他硬件，若没有异常就开始加载BIOS程序到内存当中。详细的BIOS功能，这边就不说了，BIOS主要的一个功能就是存储了磁盘的启动顺序，BIOS会按照启动顺序去查找第一个磁盘头的MBR信息，并加载和执行MBR中的Bootloader程序，若第一个磁盘不存在MBR，则会继续查找第二个磁盘(PS：启动顺序可以在BIOS的界面中进行设置)，一旦BootLoader程序被检测并加载内存中，BIOS就将控制权交接给了BootLoader程序。&lt;/p&gt;

&lt;p&gt;2、读取 MBR 的引导文件(GRUB、LILO)。&lt;/p&gt;

&lt;p&gt;MBR(Master Boot Record)，主引导记录，MBR存储于磁盘的头部，大小为512bytes，其中，446bytes用于存储BootLoader程序，64bytes用于存储分区表信息，最后2bytes用于MBR的有效性检查。&lt;/p&gt;

&lt;h1 id=&quot;mbr结构&quot;&gt;&lt;code&gt;MBR&lt;/code&gt;结构&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;主引导程序代码，占446字节&lt;/li&gt;
  &lt;li&gt;磁盘签名&lt;/li&gt;
  &lt;li&gt;硬盘分区表&lt;code&gt;DPT&lt;/code&gt;，占64字节&lt;/li&gt;
  &lt;li&gt;主引导扇区结束标志&lt;code&gt;55AAH&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;查看&lt;code&gt;MBR&lt;/code&gt;记录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;sudo dd if=/dev/sda of=mbr.bin bs=1 count=512
hexdump -C mbr.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/img/MBR.png&quot; alt=&quot;MBR&quot; /&gt;&lt;/p&gt;

&lt;p&gt;GRUB(Grand Unified Bootloader)，多系统启动程序，其执行过程可分为三个步骤：&lt;/p&gt;

&lt;p&gt;　　　　Stage1：这个其实就是MBR，它的主要工作就是查找并加载第二段Bootloader程序(stage2)，但系统在没启动时，MBR根本找不到文件系统，也就找不到stage2所存放的位置，因此，就有了stage1_5&lt;/p&gt;

&lt;p&gt;　　　　Stage1_5：该步骤就是为了识别文件系统&lt;/p&gt;

&lt;p&gt;　　　　Stage2：GRUB程序会根据/boot/grub/grub.conf文件查找Kernel的信息，然后开始加载Kernel程序，当Kernel程序被检测并在加载到内存中，GRUB就将控制权交接给了Kernel程序。&lt;/p&gt;

&lt;p&gt;　　　　PS：实际上这个步骤/boot还没被挂载，GRUB直接识别grub所在磁盘的文件系统，所以实际上应该是/grub/grub.conf文件，该配置文件的信息如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-markdown&quot;&gt;grub.conf：　

#boot=/dev/sda

default=0        #设定默认启动的title的编号，从0开始

timeout=5       #等待用户选择的超时时间

splashimage=(hd0,0)/boot/grub/splash.xpm.gz    #GRUB的背景图片

hiddenmenu     #隐藏菜单

title CentOS (2.6.18-194.el5PAE)      #内核标题

root (hd0,0)         #内核文件所在的设备

kernel /vmlinuz-2.6.18-194.el5PAE ro root=LABEL=/     #内核文件路径以及传递给内核的参数

initrd /initrd-2.6.18-194.el5PAE.img                            #ramdisk文件路径
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、引导 Linux 内核。&lt;/p&gt;

&lt;p&gt;Kernel，内核，Kernel是Linux系统最主要的程序，实际上，Kernel的文件很小，只保留了最基本的模块，并以压缩的文件形式存储在硬盘中，当GRUB将Kernel读进内存，内存开始解压缩内核文件。讲内核启动，应该先讲下initrd这个文件，&lt;/p&gt;

&lt;p&gt;　　initrd(Initial RAM  Disk)，它在stage2这个步骤就被拷贝到了内存中，这个文件是在安装系统时产生的，是一个临时的根文件系统(rootfs)。因为Kernel为了精简，只保留了最基本的模块，因此，Kernel上并没有各种硬件的驱动程序，也就无法识rootfs所在的设备，故产生了initrd这个文件，该文件装载了必要的驱动模块，当Kernel启动时，可以从initrd文件中装载驱动模块，直到挂载真正的rootfs，然后将initrd从内存中移除。&lt;/p&gt;

&lt;p&gt;　　Kernel会以只读方式挂载根文件系统，当根文件系统被挂载后，开始装载第一个进程(用户空间的进程)，执行/sbin/init，之后就将控制权交接给了init程序&lt;/p&gt;

&lt;p&gt;4、运行第一个进程 init (进程号永远为 1 )。&lt;/p&gt;

&lt;p&gt;init，初始化，顾名思义，该程序就是进行OS初始化操作，实际上是根据/etc/inittab(定义了系统默认运行级别)设定的动作进行脚本的执行，第一个被执行的脚本为/etc/rc.d/rc.sysinit，这个是真正的OS初始化脚本，简单讲下这个脚本的任务(可以去看看实际脚本，看看都做了什么)：&lt;/p&gt;

&lt;p&gt;　　1、激活udev和selinux；2、根据/etc/sysctl.conf文件，来设定内核参数；3、设定系统时钟；4、装载硬盘映射；5、启用交换分区；6、设置主机名；7、根文件系统检测，并以读写方式重新挂载根文件系统；8、激活RAID和LVM设备；9、启用磁盘配额；10、根据/etc/fstab，检查并挂载其他文件系统；11、清理过期的锁和PID文件&lt;/p&gt;

&lt;p&gt;　　执行完后，根据配置的启动级别，执行对应目录底下的脚本，最后执行/etc/rc.d/rc.local这个脚本，至此，系统启动完成&lt;/p&gt;

&lt;p&gt;5、进入相应的运行级别。&lt;/p&gt;

&lt;p&gt;runlevel，运行级别，不同的级别会启动的服务不一样，init会根据定义的级别去执行相应目录下的脚本，Linux的启动级别分为以下几种&lt;/p&gt;

&lt;p&gt;　　0：关机模式&lt;/p&gt;

&lt;p&gt;　　1：单一用户模式(直接以管理员身份进入)&lt;/p&gt;

&lt;p&gt;　　2：多用户模式（无网络）&lt;/p&gt;

&lt;p&gt;　　3：多用户模式（命令行）&lt;/p&gt;

&lt;p&gt;　　4：保留&lt;/p&gt;

&lt;p&gt;　　5：多用户模式（图形界面）&lt;/p&gt;

&lt;p&gt;　　6：重启&lt;/p&gt;

&lt;p&gt;在不同的运行级别下，/etc/rc.d/rc这个脚本会分别执行不同目录下的脚本&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Run level 0 – /etc/rc.d/rc0.d/&lt;/li&gt;
  &lt;li&gt;Run level 1 – /etc/rc.d/rc1.d/&lt;/li&gt;
  &lt;li&gt;Run level 2 – /etc/rc.d/rc2.d/&lt;/li&gt;
  &lt;li&gt;Run level 3 – /etc/rc.d/rc3.d/&lt;/li&gt;
  &lt;li&gt;Run level 4 – /etc/rc.d/rc4.d/&lt;/li&gt;
  &lt;li&gt;Run level 5 – /etc/rc.d/rc5.d/&lt;/li&gt;
  &lt;li&gt;Run level 6 – /etc/rc.d/rc6.d/&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　这些目录下的脚本只有K&lt;em&gt;和S&lt;/em&gt;开头的文件，K开头的文件为开机需要执行关闭的服务，S开头的文件为开机需要执行开启的服务&lt;/p&gt;

&lt;p&gt;6、运行终端，输入用户名和密码&lt;/p&gt;

&lt;h1 id=&quot;linux系统缺省的运行级别&quot;&gt;Linux系统缺省的运行级别&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;关机。&lt;/li&gt;
  &lt;li&gt;单机用户模式。&lt;/li&gt;
  &lt;li&gt;字符界面的多用户模式(不支持网络)。&lt;/li&gt;
  &lt;li&gt;字符界面的多用户模式。&lt;/li&gt;
  &lt;li&gt;未分配使用。&lt;/li&gt;
  &lt;li&gt;图形界面的多用户模式。&lt;/li&gt;
  &lt;li&gt;重启&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;linux-使用的进程间通信方式&quot;&gt;Linux 使用的进程间通信方式&lt;/h1&gt;

&lt;p&gt;1、管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。&lt;/p&gt;

&lt;p&gt;2、信号(signal) 。&lt;/p&gt;

&lt;p&gt;3、消息队列。&lt;/p&gt;

&lt;p&gt;4、共享内存。&lt;/p&gt;

&lt;p&gt;5、信号量。&lt;/p&gt;

&lt;p&gt;6、套接字(socket)&lt;/p&gt;

&lt;h1 id=&quot;linux-有哪些系统日志文件&quot;&gt;Linux 有哪些系统日志文件&lt;/h1&gt;

&lt;p&gt;重要的是 &lt;code&gt;/var/log/messages&lt;/code&gt; 日志文件&lt;/p&gt;

&lt;h1 id=&quot;linux系统桌面环境&quot;&gt;Linux系统桌面环境&lt;/h1&gt;

&lt;p&gt;KDE或Gnome&lt;/p&gt;

&lt;h1 id=&quot;交换空间&quot;&gt;交换空间&lt;/h1&gt;

&lt;p&gt;交换空间是Linux使用的一定空间，用于临时保存一些并发运行的程序。当RAM没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。&lt;/p&gt;

&lt;h1 id=&quot;root帐户&quot;&gt;root帐户&lt;/h1&gt;

&lt;p&gt;root帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装Linux时都是默认帐户&lt;/p&gt;

&lt;h1 id=&quot;lilo&quot;&gt;LILO&lt;/h1&gt;

&lt;p&gt;LILO是Linux的引导加载程序。它主要用于将Linux操作系统加载到主内存中，以便它可以开始运行&lt;/p&gt;

&lt;h1 id=&quot;bash&quot;&gt;BASH&lt;/h1&gt;

&lt;p&gt;BASH是Bourne Again SHell的缩写。它由Steve Bourne编写，作为原始Bourne Shell（由/ bin / sh表示）的替代品。它结合了原始版本的Bourne Shell的所有功能，以及其他功能，使其更容易使用。从那以后，它已被改编为运行Linux的大多数系统的默认shell；推荐&lt;code&gt;zsh&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;cli&quot;&gt;CLI&lt;/h1&gt;

&lt;p&gt;命令行界面（英语&lt;strong&gt;：command-line interface&lt;/strong&gt;，缩写]：CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（CUI）。&lt;/p&gt;

&lt;p&gt;通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。因为，命令行界面的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。&lt;/p&gt;

&lt;h1 id=&quot;gui&quot;&gt;GUI&lt;/h1&gt;

&lt;p&gt;图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。&lt;/p&gt;

&lt;p&gt;图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点&lt;/p&gt;

&lt;h1 id=&quot;开源优势&quot;&gt;开源优势&lt;/h1&gt;

&lt;p&gt;开源允许你将软件（包括源代码）免费分发给任何感兴趣的人。然后，人们可以添加功能，甚至可以调试和更正源代码中的错误。它们甚至可以让它运行得更好，然后再次自由地重新分配这些增强的源代码。这最终使社区中的每个人受益&lt;/p&gt;

&lt;h1 id=&quot;linux-文件系统&quot;&gt;Linux 文件系统&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;也就是说在 Linux 系统中有一个重要的概念&lt;strong&gt;：一切都是文件&lt;/strong&gt;。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。&lt;/p&gt;

&lt;p&gt;Linux 支持 5 种文件类型，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/LINUX_FILE.png&quot; alt=&quot;LINUX_FILE&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;linux-的目录结构&quot;&gt;Linux 的目录结构&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/LINUX_THREE.png&quot; alt=&quot;LINUX_THREE&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;/bin： 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；&lt;/li&gt;
  &lt;li&gt;/etc： 存放系统管理和配置文件；&lt;/li&gt;
  &lt;li&gt;/home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；&lt;/li&gt;
  &lt;li&gt;/usr &lt;strong&gt;： 用于存放系统应用程序；&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;**/opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；&lt;/li&gt;
  &lt;li&gt;/proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；&lt;/li&gt;
  &lt;li&gt;/root： 超级用户（系统管理员）的主目录（特权阶级o）；&lt;/li&gt;
  &lt;li&gt;/sbin: 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；&lt;/li&gt;
  &lt;li&gt;/dev： 用于存放设备文件；&lt;/li&gt;
  &lt;li&gt;/mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；&lt;/li&gt;
  &lt;li&gt;/boot： 存放用于系统引导时使用的各种文件；&lt;/li&gt;
  &lt;li&gt;**/lib **： 存放着和系统运行相关的库文件 ；&lt;/li&gt;
  &lt;li&gt;/tmp： 用于存放各种临时文件，是公用的临时文件存储点；&lt;/li&gt;
  &lt;li&gt;/var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；&lt;/li&gt;
  &lt;li&gt;/lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;inode&quot;&gt;inode&lt;/h1&gt;

&lt;p&gt;文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。&lt;/p&gt;

&lt;p&gt;操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。&lt;/p&gt;

&lt;p&gt;文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。&lt;/p&gt;

&lt;p&gt;每一个文件都有对应的inode，里面包含了与该文件有关的一些信息&lt;/p&gt;

&lt;h1 id=&quot;linux-文件系统通过-i-节点把文件的逻辑结构和物理结构转换的工作过程&quot;&gt;Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程&lt;/h1&gt;

&lt;p&gt;inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。
Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构&lt;/p&gt;

&lt;h1 id=&quot;硬链接和软链接&quot;&gt;硬链接和软链接&lt;/h1&gt;

&lt;p&gt;1）硬链接&lt;/p&gt;

&lt;p&gt;由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）软链接&lt;/p&gt;

&lt;p&gt;软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际场景下，基本是使用软链接。总结区别如下：&lt;/p&gt;

&lt;h1 id=&quot;raid&quot;&gt;RAID&lt;/h1&gt;

&lt;p&gt;RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当做一个硬盘。&lt;/p&gt;

&lt;p&gt;RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据自己的实际需求选择不同的 RAID 方案&lt;/p&gt;

&lt;p&gt;Linux 性能调优都有哪几种方法？&lt;/p&gt;

&lt;p&gt;1、Disabling daemons (关闭 daemons)。
2、Shutting down the GUI (关闭 GUI)。
3、Changing kernel parameters (改变内核参数)。
4、Kernel parameters (内核参数)。
5、Tuning the processor subsystem (处理器子系统调优)。
6、Tuning the memory subsystem (内存子系统调优)。
7、Tuning the file system (文件系统子系统调优)。
8、Tuning the network subsystem（网络子系统调优)&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">[toc]</summary></entry></feed>