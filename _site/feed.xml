<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-08-01T05:53:50-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lazycat</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
</subtitle><entry><title type="html">JAVA多线程常见问题</title><link href="http://localhost:4000/_posts/2020-07-31-JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" rel="alternate" type="text/html" title="JAVA多线程常见问题" /><published>2020-07-31T00:00:00-04:00</published><updated>2020-07-31T00:00:00-04:00</updated><id>http://localhost:4000/_posts/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-31-JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;java上下文切换&quot;&gt;JAVA上下文切换&lt;/h1&gt;

&lt;p&gt;多线程并不一定是要在多核处理器才支持的，就算是单核也是可以支持多线程的。 CPU 通过给每个线程分配一定的时间片，由于时间非常短通常是几十毫秒，所以 CPU 可以不停的切换线程执行任务从而达到了多线程的效果。&lt;/p&gt;

&lt;p&gt;但是由于在线程切换的时候需要保存本次执行的信息(&lt;a href=&quot;https://github.com/crossoverJie/Java-Interview/blob/master/MD/MemoryAllocation.md#程序计数器&quot;&gt;详见&lt;/a&gt;)，在该线程被 CPU 剥夺时间片后又再次运行恢复上次所保存的信息的过程就称为上下文切换。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;上下文切换是非常耗效率的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常有以下解决方案:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;采用无锁编程，比如将数据按照 &lt;code&gt;Hash(id)&lt;/code&gt; 进行取模分段，每个线程处理各自分段的数据，从而避免使用锁。&lt;/li&gt;
  &lt;li&gt;采用 CAS(compare and swap) 算法，如 &lt;code&gt;Atomic&lt;/code&gt; 包就是采用 CAS 算法(&lt;a href=&quot;https://github.com/crossoverJie/JCSprout/blob/master/MD/Threadcore.md#原子性&quot;&gt;详见&lt;/a&gt;)。&lt;/li&gt;
  &lt;li&gt;合理的创建线程，避免创建了一些线程但其中大部分都是处于 &lt;code&gt;waiting&lt;/code&gt; 状态，因为每当从 &lt;code&gt;waiting&lt;/code&gt; 状态切换到 &lt;code&gt;running&lt;/code&gt; 状态都是一次上下文切换。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;死锁&quot;&gt;死锁&lt;/h1&gt;

&lt;p&gt;死锁的场景一般是：线程 A 和线程 B 都在互相等待对方释放锁，或者是其中某个线程在释放锁的时候出现异常如死循环之类的。这时就会导致系统不可用。&lt;/p&gt;

&lt;p&gt;常用的解决方案如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;尽量一个线程只获取一个锁。&lt;/li&gt;
  &lt;li&gt;一个线程只占用一个资源。&lt;/li&gt;
  &lt;li&gt;尝试使用定时锁，至少能保证锁最终会被释放。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;资源限制&quot;&gt;资源限制&lt;/h1&gt;

&lt;p&gt;当在带宽有限的情况下一个线程下载某个资源需要 &lt;code&gt;1M/S&lt;/code&gt;,当开 10 个线程时速度并不会乘 10 倍，反而还会增加时间，毕竟上下文切换比较耗时。&lt;/p&gt;

&lt;p&gt;如果是受限于资源的话可以采用集群来处理任务，不同的机器来处理不同的数据，就类似于开始提到的无锁编程。&lt;/p&gt;

&lt;h1 id=&quot;synchronized原理&quot;&gt;synchronized原理&lt;/h1&gt;

&lt;p&gt;众所周知 &lt;code&gt;synchronized&lt;/code&gt; 关键字是解决并发问题常用解决方案，有以下三种使用方式:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同步普通方法，锁的是当前对象。&lt;/li&gt;
  &lt;li&gt;同步静态方法，锁的是当前 &lt;code&gt;Class&lt;/code&gt; 对象。&lt;/li&gt;
  &lt;li&gt;同步块，锁的是 &lt;code&gt;()&lt;/code&gt; 中的对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现原理： &lt;code&gt;JVM&lt;/code&gt; 是通过进入、退出对象监视器( &lt;code&gt;Monitor&lt;/code&gt; )来实现对方法、同步块的同步的。&lt;/p&gt;

&lt;p&gt;具体实现是在编译之后在同步方法调用前加入一个 &lt;code&gt;monitor.enter&lt;/code&gt; 指令，在退出方法和异常处插入 &lt;code&gt;monitor.exit&lt;/code&gt; 的指令。&lt;/p&gt;

&lt;p&gt;其本质就是对一个对象监视器( &lt;code&gt;Monitor&lt;/code&gt; )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。&lt;/p&gt;

&lt;p&gt;而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 &lt;code&gt;monitor.exit&lt;/code&gt; 之后才能尝试继续获取锁。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/synchronized.webp&quot; alt=&quot;synchronized&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过一段代码来演示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) {
        synchronized (Synchronize.class){
            System.out.println(&quot;Synchronize&quot;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;javap -c Synchronize&lt;/code&gt; 可以查看编译之后的具体信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class com.crossoverjie.synchronize.Synchronize {
  public com.crossoverjie.synchronize.Synchronize();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // class com/crossoverjie/synchronize/Synchronize
       2: dup
       3: astore_1
       **4: monitorenter**
       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
       8: ldc           #4                  // String Synchronize
      10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      13: aload_1
      **14: monitorexit**
      15: goto          23
      18: astore_2
      19: aload_1
      20: monitorexit
      21: aload_2
      22: athrow
      23: return
    Exception table:
       from    to  target type
           5    15    18   any
          18    21    18   any
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到在同步块的入口和出口分别有 &lt;code&gt;monitorenter,monitorexit&lt;/code&gt; 指令。&lt;/p&gt;

&lt;h1 id=&quot;锁优化&quot;&gt;锁优化&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;  很多都称之为重量锁，&lt;code&gt;JDK1.6&lt;/code&gt; 中对 &lt;code&gt;synchronized&lt;/code&gt; 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了&lt;code&gt;偏向锁&lt;/code&gt;和&lt;code&gt;轻量锁&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;轻量锁&quot;&gt;轻量锁&lt;/h1&gt;

&lt;p&gt;当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(&lt;code&gt;Lock Record&lt;/code&gt;)区域，同时将锁对象的对象头中 &lt;code&gt;Mark Word&lt;/code&gt; 拷贝到锁记录中，再尝试使用 &lt;code&gt;CAS&lt;/code&gt; 将 &lt;code&gt;Mark Word&lt;/code&gt; 更新为指向锁记录的指针。&lt;/p&gt;

&lt;p&gt;如果更新&lt;strong&gt;成功&lt;/strong&gt;，当前线程就获得了锁。&lt;/p&gt;

&lt;p&gt;如果更新&lt;strong&gt;失败&lt;/strong&gt; &lt;code&gt;JVM&lt;/code&gt; 会先检查锁对象的 &lt;code&gt;Mark Word&lt;/code&gt; 是否指向当前线程的锁记录。&lt;/p&gt;

&lt;p&gt;如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。&lt;/p&gt;

&lt;p&gt;不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，&lt;strong&gt;轻量锁就会膨胀为重量锁&lt;/strong&gt;。&lt;/p&gt;

&lt;h1 id=&quot;解锁&quot;&gt;解锁&lt;/h1&gt;

&lt;p&gt;轻量锁的解锁过程也是利用 &lt;code&gt;CAS&lt;/code&gt; 来实现的，会尝试锁记录替换回锁对象的 &lt;code&gt;Mark Word&lt;/code&gt; 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为&lt;code&gt;重量锁&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;轻量锁能提升性能的原因是：&lt;/p&gt;

&lt;p&gt;认为大多数锁在整个同步周期都不存在竞争，所以使用 &lt;code&gt;CAS&lt;/code&gt; 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 &lt;code&gt;CAS&lt;/code&gt; 的开销，甚至比重量锁更慢。&lt;/p&gt;

&lt;h1 id=&quot;偏向锁&quot;&gt;偏向锁&lt;/h1&gt;

&lt;p&gt;为了进一步的降低获取锁的代价，&lt;code&gt;JDK1.6&lt;/code&gt; 之后还引入了偏向锁。&lt;/p&gt;

&lt;p&gt;偏向锁的特征是:锁不存在多线程竞争，并且应由一个线程多次获得锁。&lt;/p&gt;

&lt;p&gt;当线程访问同步块时，会使用 &lt;code&gt;CAS&lt;/code&gt; 将线程 ID 更新到锁对象的 &lt;code&gt;Mark Word&lt;/code&gt; 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。&lt;/p&gt;

&lt;h1 id=&quot;释放锁&quot;&gt;释放锁&lt;/h1&gt;

&lt;p&gt;当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 &lt;code&gt;Mark Word&lt;/code&gt; 设置为无锁或者是轻量锁状态。&lt;/p&gt;

&lt;p&gt;偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 &lt;code&gt;-XX:-UseBiasedLocking&lt;/code&gt; 来关闭偏向锁，并默认进入轻量锁。&lt;/p&gt;

&lt;h1 id=&quot;其他优化&quot;&gt;其他优化&lt;/h1&gt;

&lt;h2 id=&quot;适应性自旋&quot;&gt;适应性自旋&lt;/h2&gt;

&lt;p&gt;在使用 &lt;code&gt;CAS&lt;/code&gt; 时，如果操作失败，&lt;code&gt;CAS&lt;/code&gt; 会自旋再次尝试。由于自旋是需要消耗 &lt;code&gt;CPU&lt;/code&gt; 资源的，所以如果长期自旋就白白浪费了 &lt;code&gt;CPU&lt;/code&gt;。&lt;code&gt;JDK1.6&lt;/code&gt;加入了适应性自旋:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果某个锁自旋很少成功获得，那么下一次就会减少自旋。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;java多线程三大核心&quot;&gt;JAVA多线程三大核心&lt;/h1&gt;

&lt;h2 id=&quot;原子性&quot;&gt;原子性&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 的原子性就和数据库事务的原子性差不多，一个操作中要么全部执行成功或者失败。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;JMM&lt;/code&gt; 只是保证了基本的原子性，但类似于 &lt;code&gt;i++&lt;/code&gt; 之类的操作，看似是原子操作，其实里面涉及到:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获取 i 的值。&lt;/li&gt;
  &lt;li&gt;自增。&lt;/li&gt;
  &lt;li&gt;再赋值给 i。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这三步操作，所以想要实现 &lt;code&gt;i++&lt;/code&gt; 这样的原子操作就需要用到 &lt;code&gt;synchronized&lt;/code&gt; 或者是 &lt;code&gt;lock&lt;/code&gt; 进行加锁处理。&lt;/p&gt;

&lt;p&gt;如果是基础类的自增操作可以使用 &lt;code&gt;AtomicInteger&lt;/code&gt; 这样的原子类来实现(其本质是利用了 &lt;code&gt;CPU&lt;/code&gt; 级别的 的 &lt;code&gt;CAS&lt;/code&gt; 指令来完成的)。&lt;/p&gt;

&lt;p&gt;其中用的最多的方法就是: &lt;code&gt;incrementAndGet()&lt;/code&gt; 以原子的方式自增。 源码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public final long incrementAndGet() {
        for (;;) {
            long current = get();
            long next = current + 1;
            if (compareAndSet(current, next))
                return next;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是获得当前的值，然后自增 +1。接着则是最核心的 &lt;code&gt;compareAndSet()&lt;/code&gt; 来进行原子更新。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public final boolean compareAndSet(long expect, long update) {
        return unsafe.compareAndSwapLong(this, valueOffset, expect, update);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其逻辑就是判断当前的值是否被更新过，是否等于 &lt;code&gt;current&lt;/code&gt;，如果等于就说明没有更新过然后将当前的值更新为 &lt;code&gt;next&lt;/code&gt;，如果不等于则返回&lt;code&gt;false&lt;/code&gt; 进入循环，直到更新成功为止。&lt;/p&gt;

&lt;p&gt;还有其中的 &lt;code&gt;get()&lt;/code&gt; 方法也很关键，返回的是当前的值，当前值用了 &lt;code&gt;volatile&lt;/code&gt; 关键词修饰，保证了内存可见性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt; private volatile int value;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;可见性&quot;&gt;可见性&lt;/h2&gt;

&lt;p&gt;现代计算机中，由于 &lt;code&gt;CPU&lt;/code&gt; 直接从主内存中读取数据的效率不高，所以都会对应的 &lt;code&gt;CPU&lt;/code&gt; 高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时来读取就是修改之前的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/可见性.webp&quot; alt=&quot;可见性&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 关键字就是用于保证内存可见性，当线程A更新了 volatile 修饰的变量时，它会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;volatile&lt;/code&gt; 关键词修饰的变量每次读取都会得到最新的数据，不管哪个线程对这个变量的修改都会立即刷新到主内存。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;和加锁也能能保证可见性，实现原理就是在释放锁之前其余线程是访问不到这个共享变量的。但是和 &lt;code&gt;volatile&lt;/code&gt; 相比开销较大。&lt;/p&gt;

&lt;h2 id=&quot;顺序性&quot;&gt;顺序性&lt;/h2&gt;

&lt;p&gt;以下这段代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;int a = 100 ; //1
int b = 200 ; //2
int c = a + b ; //3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常情况下的执行顺序应该是 &lt;code&gt;1&amp;gt;&amp;gt;2&amp;gt;&amp;gt;3&lt;/code&gt;。但是有时 &lt;code&gt;JVM&lt;/code&gt; 为了提高整体的效率会进行指令重排导致执行的顺序可能是 &lt;code&gt;2&amp;gt;&amp;gt;1&amp;gt;&amp;gt;3&lt;/code&gt;。但是 &lt;code&gt;JVM&lt;/code&gt; 也不能是什么都进行重排，是在保证最终结果和代码顺序执行结果一致的情况下才可能进行重排。&lt;/p&gt;

&lt;p&gt;重排在单线程中不会出现问题，但在多线程中会出现数据不一致的问题。&lt;/p&gt;

&lt;p&gt;Java 中可以使用 &lt;code&gt;volatile&lt;/code&gt; 来保证顺序性，&lt;code&gt;synchronized 和 lock&lt;/code&gt; 也可以来保证有序性，和保证原子性的方式一样，通过同一段时间只能一个线程访问来实现的。&lt;/p&gt;

&lt;p&gt;除了通过 &lt;code&gt;volatile&lt;/code&gt; 关键字显式的保证顺序之外， &lt;code&gt;JVM&lt;/code&gt; 还通过 &lt;code&gt;happen-before&lt;/code&gt; 原则来隐式的保证顺序性。&lt;/p&gt;

&lt;p&gt;其中有一条就是适用于 &lt;code&gt;volatile&lt;/code&gt; 关键字的，针对于 &lt;code&gt;volatile&lt;/code&gt; 关键字的写操作肯定是在读操作之前，也就是说读取的值肯定是最新的。&lt;/p&gt;

&lt;h1 id=&quot;volatile的应用&quot;&gt;volatile的应用&lt;/h1&gt;

&lt;h2 id=&quot;双重检查锁的单列模式&quot;&gt;双重检查锁的单列模式&lt;/h2&gt;

&lt;p&gt;可以用 &lt;code&gt;volatile&lt;/code&gt; 实现一个双重检查锁的单例模式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public class Singleton {
        private static volatile Singleton singleton;

        private Singleton() {
        }

        public static Singleton getInstance() {
            if (singleton == null) {
                synchronized (Singleton.class) {
                    if (singleton == null) {
                        singleton = new Singleton();
                    }
                }
            }
            return singleton;
        }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 &lt;code&gt;volatile&lt;/code&gt; 关键字主要是为了防止指令重排。 如果不用 &lt;code&gt;volatile&lt;/code&gt; ，&lt;code&gt;singleton = new Singleton();&lt;/code&gt;，这段代码其实是分为三步：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分配内存空间。(1)&lt;/li&gt;
  &lt;li&gt;初始化对象。(2)&lt;/li&gt;
  &lt;li&gt;将 &lt;code&gt;singleton&lt;/code&gt; 对象指向分配的内存地址。(3)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;加上 &lt;code&gt;volatile&lt;/code&gt; 是为了让以上的三步操作顺序执行，反之有可能第三步在第二步之前被执行就有可能导致某个线程拿到的单例对象还没有初始化，以致于使用报错。&lt;/p&gt;

&lt;h2 id=&quot;控制停止线程的标记&quot;&gt;控制停止线程的标记&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    private volatile boolean flag ;
    private void run(){
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (flag) {
                    doSomeThing();
                }
            }
        });
    }

    private void stop(){
        flag = false ;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里如果没有用 volatile 来修饰 flag ，就有可能其中一个线程调用了 &lt;code&gt;stop()&lt;/code&gt;方法修改了 flag 的值并不会立即刷新到主内存中，导致这个循环并不会立即停止。&lt;/p&gt;

&lt;p&gt;这里主要利用的是 &lt;code&gt;volatile&lt;/code&gt; 的内存可见性。&lt;/p&gt;

&lt;p&gt;总结一下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; 关键字只能保证可见性，顺序性，&lt;strong&gt;不能保证原子性&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;对锁的一些认知-有哪些锁&quot;&gt;对锁的一些认知 有哪些锁&lt;/h1&gt;

&lt;h2 id=&quot;同一进程&quot;&gt;同一进程&lt;/h2&gt;

&lt;h3 id=&quot;重入锁&quot;&gt;重入锁&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;ReentrantLock&lt;/code&gt; 获取锁的时候会判断当前线程是否为获取锁的线程，如果是则将同步的状态 +1 ,释放锁的时候则将状态 -1。只有将同步状态的次数置为 0 的时候才会最终释放锁&lt;/p&gt;

&lt;h3 id=&quot;读写锁&quot;&gt;读写锁&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;ReentrantReadWriteLock&lt;/code&gt; ,同时维护一对锁：读锁和写锁。当写线程访问时则其他所有锁都将阻塞，读线程访问时则不会。通过读写锁的分离可以很大程度的提高并发量和吞吐量。&lt;/p&gt;

&lt;h2 id=&quot;不同进程&quot;&gt;不同进程&lt;/h2&gt;

&lt;p&gt;分布式锁：&lt;/p&gt;

&lt;h3 id=&quot;基于数据库&quot;&gt;基于数据库&lt;/h3&gt;

&lt;p&gt;可以创建一张表，将其中的某个字段设置为&lt;code&gt;唯一索引&lt;/code&gt;，当多个请求过来的时候只有新建记录成功的请求才算获取到锁，当使用完毕删除这条记录的时候即释放锁。&lt;/p&gt;

&lt;p&gt;存在的问题:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据库单点问题，挂了怎么办？&lt;/li&gt;
  &lt;li&gt;不是重入锁，同一进程无法在释放锁之前再次获得锁，因为数据库中已经存在了一条记录了。&lt;/li&gt;
  &lt;li&gt;锁是非阻塞的，一旦 &lt;code&gt;insert&lt;/code&gt; 失败则会立即返回，并不会进入阻塞队列只能下一次再次获取。&lt;/li&gt;
  &lt;li&gt;锁没有失效时间，如果那个进程解锁失败那就没有请求可以再次获取锁了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决方案:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据库切换为主从，不存在单点。&lt;/li&gt;
  &lt;li&gt;在表中加入一个同步状态字段，每次获取锁的是加 1 ，释放锁的时候&lt;code&gt;-1&lt;/code&gt;，当状态为 0 的时候就删除这条记录，即释放锁。&lt;/li&gt;
  &lt;li&gt;非阻塞的情况可以用 &lt;code&gt;while&lt;/code&gt; 循环来实现，循环的时候记录时间，达到 X 秒记为超时，&lt;code&gt;break&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;可以开启一个定时任务每隔一段时间扫描找出多少 X 秒都没有被删除的记录，主动删除这条记录。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;基于-redis&quot;&gt;基于 Redis&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;setNX(key) setEX(timeout)&lt;/code&gt; 命令，只有在该 &lt;code&gt;key&lt;/code&gt; 不存在的时候创建这个 &lt;code&gt;key&lt;/code&gt;，就相当于获取了锁。由于有超时时间，所以过了规定时间会自动删除，这样也可以避免死锁。&lt;/p&gt;

&lt;h3 id=&quot;基于-zk&quot;&gt;基于 ZK&lt;/h3&gt;

&lt;h1 id=&quot;reentrantlock-实现原理&quot;&gt;ReentrantLock 实现原理&lt;/h1&gt;

&lt;p&gt;使用 &lt;code&gt;synchronized&lt;/code&gt; 来做同步处理时，锁的获取和释放都是隐式的，实现的原理是通过编译后加上不同的机器指令来实现。&lt;/p&gt;

&lt;p&gt;而 &lt;code&gt;ReentrantLock&lt;/code&gt; 就是一个普通的类，它是基于 &lt;code&gt;AQS(AbstractQueuedSynchronizer)&lt;/code&gt;来实现的。&lt;/p&gt;

&lt;p&gt;是一个&lt;strong&gt;重入锁&lt;/strong&gt;：一个线程获得了锁之后仍然可以&lt;strong&gt;反复&lt;/strong&gt;的加锁，不会出现自己阻塞自己的情况。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;AQS&lt;/code&gt; 是 &lt;code&gt;Java&lt;/code&gt; 并发包里实现锁、同步的一个重要的基础框架。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;锁类型&quot;&gt;锁类型&lt;/h2&gt;

&lt;p&gt;ReentrantLock 分为&lt;strong&gt;公平锁&lt;/strong&gt;和&lt;strong&gt;非公平锁&lt;/strong&gt;，可以通过构造方法来指定具体类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    //默认非公平锁
    public ReentrantLock() {
        sync = new NonfairSync();
    }

    //公平锁
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认一般使用&lt;strong&gt;非公平锁&lt;/strong&gt;，它的效率和吞吐量都比公平锁高的多(后面会分析具体原因)。&lt;/p&gt;

&lt;h2 id=&quot;获取锁&quot;&gt;获取锁&lt;/h2&gt;

&lt;p&gt;通常的使用方式如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    private ReentrantLock lock = new ReentrantLock();
    public void run() {
        lock.lock();
        try {
            //do bussiness
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;公平锁获取锁&quot;&gt;公平锁获取锁&lt;/h3&gt;

&lt;p&gt;首先看下获取锁的过程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public void lock() {
        sync.lock();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到是使用 &lt;code&gt;sync&lt;/code&gt;的方法，而这个方法是一个抽象方法，具体是由其子类(&lt;code&gt;FairSync&lt;/code&gt;)来实现的，以下是公平锁的实现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;        final void lock() {
            acquire(1);
        }

        //AbstractQueuedSynchronizer 中的 acquire()
        public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;amp;&amp;amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一步是尝试获取锁(&lt;code&gt;tryAcquire(arg)&lt;/code&gt;),这个也是由其子类实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (!hasQueuedPredecessors() &amp;amp;&amp;amp;
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &amp;lt; 0)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先会判断 &lt;code&gt;AQS&lt;/code&gt; 中的 &lt;code&gt;state&lt;/code&gt; 是否等于 0，0 表示目前没有其他线程获得锁，当前线程就可以尝试获取锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:尝试之前会利用 &lt;code&gt;hasQueuedPredecessors()&lt;/code&gt; 方法来判断 AQS 的队列中中是否有其他线程，如果有则不会尝试获取锁(&lt;strong&gt;这是公平锁特有的情况&lt;/strong&gt;)。&lt;/p&gt;

&lt;p&gt;如果队列中没有线程就利用 CAS 来将 AQS 中的 state 修改为1，也就是获取锁，获取成功则将当前线程置为获得锁的独占线程(&lt;code&gt;setExclusiveOwnerThread(current)&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;state&lt;/code&gt; 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(&lt;code&gt;ReentrantLock&lt;/code&gt; 支持重入)，是则需要将 &lt;code&gt;state + 1&lt;/code&gt;，并将值更新。&lt;/p&gt;

&lt;h4 id=&quot;写入队列&quot;&gt;写入队列&lt;/h4&gt;

&lt;p&gt;如果 &lt;code&gt;tryAcquire(arg)&lt;/code&gt; 获取锁失败，则需要用 &lt;code&gt;addWaiter(Node.EXCLUSIVE)&lt;/code&gt; 将当前线程写入队列中。&lt;/p&gt;

&lt;p&gt;写入之前需要将当前线程包装为一个 &lt;code&gt;Node&lt;/code&gt; 对象(&lt;code&gt;addWaiter(Node.EXCLUSIVE)&lt;/code&gt;)。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;AQS 中的队列是由 Node 节点组成的双向链表实现的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;包装代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先判断队列是否为空，不为空时则将封装好的 &lt;code&gt;Node&lt;/code&gt; 利用 &lt;code&gt;CAS&lt;/code&gt; 写入队尾，如果出现并发写入失败就需要调用 &lt;code&gt;enq(node);&lt;/code&gt; 来写入了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个处理逻辑就相当于&lt;code&gt;自旋&lt;/code&gt;加上 &lt;code&gt;CAS&lt;/code&gt; 保证一定能写入队列。&lt;/p&gt;

&lt;h4 id=&quot;挂起等待线程&quot;&gt;挂起等待线程&lt;/h4&gt;

&lt;p&gt;写入队列之后需要将当前线程挂起(利用&lt;code&gt;acquireQueued(addWaiter(Node.EXCLUSIVE), arg)&lt;/code&gt;)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先会根据 &lt;code&gt;node.predecessor()&lt;/code&gt; 获取到上一个节点是否为头节点，如果是则尝试获取一次锁，获取成功就万事大吉了。&lt;/p&gt;

&lt;p&gt;如果不是头节点，或者获取锁失败，则会根据上一个节点的 &lt;code&gt;waitStatus&lt;/code&gt; 状态来处理(&lt;code&gt;shouldParkAfterFailedAcquire(p, node)&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;waitStatus&lt;/code&gt; 用于记录当前节点的状态，如节点取消、节点等待等。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shouldParkAfterFailedAcquire(p, node)&lt;/code&gt; 返回当前线程是否需要挂起，如果需要则调用 &lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他是利用 &lt;code&gt;LockSupport&lt;/code&gt; 的 &lt;code&gt;part&lt;/code&gt; 方法来挂起当前线程的，直到被唤醒。&lt;/p&gt;

&lt;h3 id=&quot;非公平锁获取锁&quot;&gt;非公平锁获取锁&lt;/h3&gt;

&lt;p&gt;公平锁与非公平锁的差异主要在获取锁：&lt;/p&gt;

&lt;p&gt;公平锁就相当于买票，后来的人需要排到队尾依次买票，&lt;strong&gt;不能插队&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;而非公平锁则没有这些规则，是&lt;strong&gt;抢占模式&lt;/strong&gt;，每来一个人不会去管队列如何，直接尝试获取锁。&lt;/p&gt;

&lt;p&gt;非公平锁:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;        final void lock() {
            //直接尝试获取锁
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公平锁:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;        final void lock() {
            acquire(1);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还要一个重要的区别是在尝试获取锁时&lt;code&gt;tryAcquire(arg)&lt;/code&gt;，非公平锁是不需要判断队列中是否还有其他线程，也是直接尝试获取锁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                //没有 !hasQueuedPredecessors() 判断
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &amp;lt; 0) // overflow
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;释放锁-1&quot;&gt;释放锁&lt;/h2&gt;

&lt;p&gt;公平锁和非公平锁的释放流程都是一样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public void unlock() {
        sync.release(1);
    }

    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
                   //唤醒被挂起的线程
                unparkSuccessor(h);
            return true;
        }
        return false;
    }

    //尝试释放锁
    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }        
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先会判断当前线程是否为获得锁的线程，由于是重入锁所以需要将 &lt;code&gt;state&lt;/code&gt; 减到 0 才认为完全释放锁。&lt;/p&gt;

&lt;p&gt;释放之后需要调用 &lt;code&gt;unparkSuccessor(h)&lt;/code&gt; 来唤醒被挂起的线程。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。&lt;/p&gt;

&lt;p&gt;所以也就能解释非公平锁的效率会被公平锁更高。&lt;/p&gt;

&lt;h1 id=&quot;concurrenthashmap-实现原理&quot;&gt;ConcurrentHashMap 实现原理&lt;/h1&gt;

&lt;p&gt;由于 &lt;code&gt;HashMap&lt;/code&gt; 是一个线程不安全的容器，主要体现在容量大于&lt;code&gt;总量*负载因子&lt;/code&gt;发生扩容时会出现环形链表从而导致死循环。&lt;/p&gt;

&lt;p&gt;因此需要支持线程安全的并发容器 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 。&lt;/p&gt;

&lt;h2 id=&quot;jdk17-实现&quot;&gt;JDK1.7 实现&lt;/h2&gt;

&lt;h3 id=&quot;数据结构&quot;&gt;数据结构&lt;/h3&gt;

&lt;h3&gt;&lt;img src=&quot;/img/ConcurrentHashMap.webp&quot; alt=&quot;ConcurrentHashMap&quot; /&gt;&lt;/h3&gt;

&lt;p&gt;如图所示，是由 &lt;code&gt;Segment&lt;/code&gt; 数组、&lt;code&gt;HashEntry&lt;/code&gt; 数组组成，和 &lt;code&gt;HashMap&lt;/code&gt; 一样，仍然是数组加链表组成。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 采用了分段锁技术，其中 &lt;code&gt;Segment&lt;/code&gt; 继承于 &lt;code&gt;ReentrantLock&lt;/code&gt;。不会像 &lt;code&gt;HashTable&lt;/code&gt; 那样不管是 &lt;code&gt;put&lt;/code&gt; 还是 &lt;code&gt;get&lt;/code&gt; 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 &lt;code&gt;CurrencyLevel&lt;/code&gt; (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 &lt;code&gt;Segment&lt;/code&gt; 时，不会影响到其他的 &lt;code&gt;Segment&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;get-方法&quot;&gt;get 方法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 的 &lt;code&gt;get&lt;/code&gt; 方法是非常高效的，因为整个过程都不需要加锁。&lt;/p&gt;

&lt;p&gt;只需要将 &lt;code&gt;Key&lt;/code&gt; 通过 &lt;code&gt;Hash&lt;/code&gt; 之后定位到具体的 &lt;code&gt;Segment&lt;/code&gt; ，再通过一次 &lt;code&gt;Hash&lt;/code&gt; 定位到具体的元素上。由于 &lt;code&gt;HashEntry&lt;/code&gt; 中的 &lt;code&gt;value&lt;/code&gt; 属性是用 &lt;code&gt;volatile&lt;/code&gt; 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值(&lt;a href=&quot;https://github.com/crossoverJie/Java-Interview/blob/master/MD/Threadcore.md#可见性&quot;&gt;volatile 相关知识点&lt;/a&gt;)。&lt;/p&gt;

&lt;h3 id=&quot;put-方法&quot;&gt;put 方法&lt;/h3&gt;

&lt;p&gt;内部 &lt;code&gt;HashEntry&lt;/code&gt; 类 ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    static final class HashEntry&amp;lt;K,V&amp;gt; {
        final int hash;
        final K key;
        volatile V value;
        volatile HashEntry&amp;lt;K,V&amp;gt; next;

        HashEntry(int hash, K key, V value, HashEntry&amp;lt;K,V&amp;gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然 HashEntry 中的 value 是用 &lt;code&gt;volatile&lt;/code&gt; 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。&lt;/p&gt;

&lt;p&gt;首先也是通过 Key 的 Hash 定位到具体的 Segment，在 put 之前会进行一次扩容校验。这里比 HashMap 要好的一点是：HashMap 是插入元素之后再看是否需要扩容，有可能扩容之后后续就没有插入就浪费了本次扩容(扩容非常消耗性能)。&lt;/p&gt;

&lt;p&gt;而 ConcurrentHashMap 不一样，它是在将数据插入之前检查是否需要扩容，之后再做插入操作。&lt;/p&gt;

&lt;h3 id=&quot;size-方法&quot;&gt;size 方法&lt;/h3&gt;

&lt;p&gt;每个 &lt;code&gt;Segment&lt;/code&gt; 都有一个 &lt;code&gt;volatile&lt;/code&gt; 修饰的全局变量 &lt;code&gt;count&lt;/code&gt; ,求整个 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 的 &lt;code&gt;size&lt;/code&gt; 时很明显就是将所有的 &lt;code&gt;count&lt;/code&gt; 累加即可。但是 &lt;code&gt;volatile&lt;/code&gt; 修饰的变量却不能保证多线程的原子性，所有直接累加很容易出现并发问题。&lt;/p&gt;

&lt;p&gt;但如果每次调用 &lt;code&gt;size&lt;/code&gt; 方法将其余的修改操作加锁效率也很低。所以做法是先尝试两次将 &lt;code&gt;count&lt;/code&gt; 累加，如果容器的 &lt;code&gt;count&lt;/code&gt; 发生了变化再加锁来统计 &lt;code&gt;size&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;至于 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 是如何知道在统计时大小发生了变化呢，每个 &lt;code&gt;Segment&lt;/code&gt; 都有一个 &lt;code&gt;modCount&lt;/code&gt; 变量，每当进行一次 &lt;code&gt;put remove&lt;/code&gt; 等操作，&lt;code&gt;modCount&lt;/code&gt; 将会 +1。只要 &lt;code&gt;modCount&lt;/code&gt; 发生了变化就认为容器的大小也在发生变化。&lt;/p&gt;

&lt;h2 id=&quot;jdk18-实现&quot;&gt;JDK1.8 实现&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/ConcurrentHashMap18.webp&quot; alt=&quot;ConcurrentHashMap18&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1.8 中的 ConcurrentHashMap 数据结构和实现与 1.7 还是有着明显的差异。&lt;/p&gt;

&lt;p&gt;其中抛弃了原有的 Segment 分段锁，而采用了 &lt;code&gt;CAS + synchronized&lt;/code&gt; 来保证并发安全性。&lt;/p&gt;

&lt;p&gt;也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。&lt;/p&gt;

&lt;p&gt;其中的 &lt;code&gt;val next&lt;/code&gt; 都用了 volatile 修饰，保证了可见性。&lt;/p&gt;

&lt;h3 id=&quot;put-方法-1&quot;&gt;put 方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;根据 key 计算出 hashcode 。&lt;/li&gt;
  &lt;li&gt;判断是否需要进行初始化。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;f&lt;/code&gt; 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。&lt;/li&gt;
  &lt;li&gt;如果当前位置的 &lt;code&gt;hashcode == MOVED == -1&lt;/code&gt;,则需要进行扩容。&lt;/li&gt;
  &lt;li&gt;如果都不满足，则利用 synchronized 锁写入数据。&lt;/li&gt;
  &lt;li&gt;如果数量大于 &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; 则要转换为红黑树。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;get-方法-1&quot;&gt;get 方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。&lt;/li&gt;
  &lt;li&gt;如果是红黑树那就按照树的方式获取值。&lt;/li&gt;
  &lt;li&gt;都不满足那就按照链表的方式遍历获取值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结-1&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（&lt;code&gt;O(logn)&lt;/code&gt;），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;简单来说使用线程池有以下几个目的：&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;线程是稀缺资源，不能频繁的创建。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;解耦作用；线程的创建于执行完全分开，方便维护。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;应当将其放入一个池子中，可以给其他任务进行复用。&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;线程池原理&quot;&gt;线程池原理&lt;/h2&gt;

&lt;p&gt;谈到线程池就会想到池化技术，其中最核心的思想就是把宝贵的资源放到一个池子中；每次使用都从里面获取，用完之后又放回池子供其他人使用，有点吃大锅饭的意思。&lt;/p&gt;

&lt;p&gt;那在 Java 中又是如何实现的呢？&lt;/p&gt;

&lt;p&gt;在 JDK 1.5 之后推出了相关的 api，常见的创建线程池方式有以下几种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Executors.newCachedThreadPool()&lt;/code&gt;：无限线程池。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Executors.newFixedThreadPool(nThreads)&lt;/code&gt;：创建固定大小的线程池。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;Executors.newSingleThreadExecutor()&lt;/code&gt;：创建单个线程的线程池。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其实看这三种方式创建的源码就会发现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上还是利用 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 类实现的。&lt;/p&gt;

&lt;p&gt;所以我们重点来看下 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 是怎么玩的。&lt;/p&gt;

&lt;p&gt;首先是创建线程的 api：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, RejectedExecutionHandler handler) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这几个核心参数的作用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;corePoolSize&lt;/code&gt; 为线程池的基本大小。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt; 为线程池最大线程大小。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;keepAliveTime&lt;/code&gt; 和 &lt;code&gt;unit&lt;/code&gt; 则是线程空闲后的存活时间。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;workQueue&lt;/code&gt; 用于存放任务的阻塞队列。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;handler&lt;/code&gt; 当队列和最大线程池都满了之后的饱和策略。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;了解了这几个参数再来看看实际的运用。&lt;/p&gt;

&lt;p&gt;通常我们都是使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;threadPool.execute(new Job());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的方式来提交一个任务到线程池中，所以核心的逻辑就是 &lt;code&gt;execute()&lt;/code&gt; 函数了。&lt;/p&gt;

&lt;p&gt;在具体分析之前先了解下线程池中所定义的状态，这些状态都和线程的执行密切相关：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;RUNNING&lt;/code&gt; 自然是运行状态，指可以接受任务执行队列里的任务&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;SHUTDOWN&lt;/code&gt; 指调用了 &lt;code&gt;shutdown()&lt;/code&gt; 方法，不再接受新任务了，但是队列里的任务得执行完毕。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;STOP&lt;/code&gt; 指调用了 &lt;code&gt;shutdownNow()&lt;/code&gt; 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;TIDYING&lt;/code&gt; 所有任务都执行完毕，在调用 &lt;code&gt;shutdown()/shutdownNow()&lt;/code&gt; 中都会尝试更新为这个状态。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;TERMINATED&lt;/code&gt; 终止状态，当执行 &lt;code&gt;terminated()&lt;/code&gt; 后会更新为这个状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后看看 &lt;code&gt;execute()&lt;/code&gt; 方法是如何处理的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;获取当前线程池的状态。&lt;/li&gt;
  &lt;li&gt;当前线程数量小于 coreSize 时创建一个新的线程运行。&lt;/li&gt;
  &lt;li&gt;如果当前线程处于运行状态，并且写入阻塞队列成功。&lt;/li&gt;
  &lt;li&gt;双重检查，再次获取线程状态；如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。&lt;/li&gt;
  &lt;li&gt;如果当前线程池为空就新创建一个线程并执行。&lt;/li&gt;
  &lt;li&gt;如果在第三步的判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;如何配置线程&quot;&gt;如何配置线程&lt;/h3&gt;

&lt;p&gt;流程聊完了再来看看上文提到了几个核心参数应该如何配置呢？&lt;/p&gt;

&lt;p&gt;有一点是肯定的，线程池肯定是不是越大越好。&lt;/p&gt;

&lt;p&gt;通常我们是需要根据这批任务执行的性质来确定的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;IO 密集型任务：由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2&lt;/li&gt;
  &lt;li&gt;CPU 密集型任务（大量复杂的运算）应当分配较少的线程，比如 CPU 个数相当的大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然这些都是经验值，最好的方式还是根据实际情况测试得出最佳配置。&lt;/p&gt;

&lt;h3 id=&quot;优雅的关闭线程池&quot;&gt;优雅的关闭线程池&lt;/h3&gt;

&lt;p&gt;有运行任务自然也有关闭任务，从上文提到的 5 个状态就能看出如何来关闭线程池。&lt;/p&gt;

&lt;p&gt;其实无非就是两个方法 &lt;code&gt;shutdown()/shutdownNow()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;但他们有着重要的区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;shutdown()&lt;/code&gt; 执行后停止接受新任务，会把队列的任务执行完毕。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;shutdownNow()&lt;/code&gt; 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;两个方法都会中断线程，用户可自行判断是否需要响应中断。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;shutdownNow()&lt;/code&gt; 要更简单粗暴，可以根据实际场景选择不同的方法。&lt;/p&gt;

&lt;p&gt;我通常是按照以下方式关闭线程池的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;        long start = System.currentTimeMillis();
        for (int i = 0; i &amp;lt;= 5; i++) {
            pool.execute(new Job());
        }

        pool.shutdown();

        while (!pool.awaitTermination(1, TimeUnit.SECONDS)) {
            LOGGER.info(&quot;线程还在执行。。。&quot;);
        }
        long end = System.currentTimeMillis();
        LOGGER.info(&quot;一共处理了【{}】&quot;, (end - start));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;pool.awaitTermination(1, TimeUnit.SECONDS)&lt;/code&gt; 会每隔一秒钟检查一次是否执行完毕（状态为 &lt;code&gt;TERMINATED&lt;/code&gt;），当从 while 循环退出时就表明线程池已经完全终止了。&lt;/p&gt;

&lt;h2 id=&quot;springboot-使用线程池&quot;&gt;SpringBoot 使用线程池&lt;/h2&gt;

&lt;p&gt;2018 年了，SpringBoot 盛行；来看看在 SpringBoot 中应当怎么配置和使用线程池。&lt;/p&gt;

&lt;p&gt;既然用了 SpringBoot ，那自然得发挥 Spring 的特性，所以需要 Spring 来帮我们管理线程池：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class TreadPoolConfig {


    /**
     * 消费队列线程
     * @return
     */
    @Bean(value = &quot;consumerQueueThreadPool&quot;)
    public ExecutorService buildConsumerQueueThreadPool(){
        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
                .setNameFormat(&quot;consumer-queue-thread-%d&quot;).build();

        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());

        return pool ;
    }



}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用时：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    @Resource(name = &quot;consumerQueueThreadPool&quot;)
    private ExecutorService consumerQueueThreadPool;


    @Override
    public void execute() {

        //消费队列
        for (int i = 0; i &amp;lt; 5; i++) {
            consumerQueueThreadPool.execute(new ConsumerQueueThread());
        }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实也挺简单，就是创建了一个线程池的 bean，在使用时直接从 Spring 中取出即可。&lt;/p&gt;

&lt;h2 id=&quot;监控线程池&quot;&gt;监控线程池&lt;/h2&gt;

&lt;p&gt;谈到了 SpringBoot，也可利用它 actuator 组件来做线程池的监控。&lt;/p&gt;

&lt;p&gt;线程怎么说都是稀缺资源，对线程池的监控可以知道自己任务执行的状况、效率等。&lt;/p&gt;

&lt;h2 id=&quot;线程池隔离&quot;&gt;线程池隔离&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程池看似很美好，但也会带来一些问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果我们很多业务都依赖于同一个线程池,当其中一个业务因为各种不可控的原因消耗了所有的线程，导致线程池全部占满。&lt;/p&gt;

&lt;p&gt;这样其他的业务也就不能正常运转了，这对系统的打击是巨大的。&lt;/p&gt;

&lt;p&gt;比如我们 Tomcat 接受请求的线程池，假设其中一些响应特别慢，线程资源得不到回收释放；线程池慢慢被占满，最坏的情况就是整个应用都不能提供服务。&lt;/p&gt;

&lt;p&gt;所以我们需要将线程池&lt;strong&gt;进行隔离&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;通常的做法是按照业务进行划分：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;比如下单的任务用一个线程池，获取数据的任务用另一个线程池。这样即使其中一个出现问题把线程池耗尽，那也不会影响其他的任务运行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;hystrix-隔离&quot;&gt;hystrix 隔离&lt;/h3&gt;

&lt;p&gt;这样的需求 &lt;a href=&quot;https://github.com/Netflix/Hystrix&quot;&gt;Hystrix&lt;/a&gt; 已经帮我们实现了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Hystrix 是一款开源的容错插件，具有依赖隔离、系统容错降级等功能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面来看看 &lt;code&gt;Hystrix&lt;/code&gt; 简单的应用：&lt;/p&gt;

&lt;p&gt;首先需要定义两个线程池，分别用于执行订单、处理用户。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * Function:订单服务
 *
 * @author crossoverJie
 *         Date: 2018/7/28 16:43
 * @since JDK 1.8
 */
public class CommandOrder extends HystrixCommand&amp;lt;String&amp;gt; {

    private final static Logger LOGGER = LoggerFactory.getLogger(CommandOrder.class);

    private String orderName;

    public CommandOrder(String orderName) {


        super(Setter.withGroupKey(
                //服务分组
                HystrixCommandGroupKey.Factory.asKey(&quot;OrderGroup&quot;))
                //线程分组
                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;OrderPool&quot;))

                //线程池配置
                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                        .withCoreSize(10)
                        .withKeepAliveTimeMinutes(5)
                        .withMaxQueueSize(10)
                        .withQueueSizeRejectionThreshold(10000))

                .andCommandPropertiesDefaults(
                        HystrixCommandProperties.Setter()
                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))
        )
        ;
        this.orderName = orderName;
    }


    @Override
    public String run() throws Exception {

        LOGGER.info(&quot;orderName=[{}]&quot;, orderName);

        TimeUnit.MILLISECONDS.sleep(100);
        return &quot;OrderName=&quot; + orderName;
    }


}


/**
 * Function:用户服务
 *
 * @author crossoverJie
 *         Date: 2018/7/28 16:43
 * @since JDK 1.8
 */
public class CommandUser extends HystrixCommand&amp;lt;String&amp;gt; {

    private final static Logger LOGGER = LoggerFactory.getLogger(CommandUser.class);

    private String userName;

    public CommandUser(String userName) {


        super(Setter.withGroupKey(
                //服务分组
                HystrixCommandGroupKey.Factory.asKey(&quot;UserGroup&quot;))
                //线程分组
                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(&quot;UserPool&quot;))

                //线程池配置
                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                        .withCoreSize(10)
                        .withKeepAliveTimeMinutes(5)
                        .withMaxQueueSize(10)
                        .withQueueSizeRejectionThreshold(10000))

                //线程池隔离
                .andCommandPropertiesDefaults(
                        HystrixCommandProperties.Setter()
                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))
        )
        ;
        this.userName = userName;
    }


    @Override
    public String run() throws Exception {

        LOGGER.info(&quot;userName=[{}]&quot;, userName);

        TimeUnit.MILLISECONDS.sleep(100);
        return &quot;userName=&quot; + userName;
    }


}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;api&lt;/code&gt; 特别简洁易懂，具体详情请查看官方文档。&lt;/p&gt;

&lt;p&gt;然后模拟运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws Exception {
        CommandOrder commandPhone = new CommandOrder(&quot;手机&quot;);
        CommandOrder command = new CommandOrder(&quot;电视&quot;);


        //阻塞方式执行
        String execute = commandPhone.execute();
        LOGGER.info(&quot;execute=[{}]&quot;, execute);

        //异步非阻塞方式
        Future&amp;lt;String&amp;gt; queue = command.queue();
        String value = queue.get(200, TimeUnit.MILLISECONDS);
        LOGGER.info(&quot;value=[{}]&quot;, value);


        CommandUser commandUser = new CommandUser(&quot;张三&quot;);
        String name = commandUser.execute();
        LOGGER.info(&quot;name=[{}]&quot;, name);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到两个任务分成了两个线程池运行，他们之间互不干扰。&lt;/p&gt;

&lt;p&gt;获取任务任务结果支持同步阻塞和异步非阻塞方式，可自行选择。&lt;/p&gt;

&lt;p&gt;它的实现原理其实容易猜到：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;利用一个 Map 来存放不同业务对应的线程池。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;总结-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;池化技术确实在平时应用广泛，熟练掌握能提高不少效率。&lt;/p&gt;

&lt;p&gt;文末的 hystrix &lt;a href=&quot;https://github.com/crossoverJie/Java-Interview/tree/master/src/main/java/com/crossoverjie/hystrix&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">[toc]</summary></entry><entry><title type="html">渗透测试流程</title><link href="http://localhost:4000/_posts/2020-07-29-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/" rel="alternate" type="text/html" title="渗透测试流程" /><published>2020-07-29T00:00:00-04:00</published><updated>2020-07-29T00:00:00-04:00</updated><id>http://localhost:4000/_posts/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-29-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;明确目标&quot;&gt;明确目标&lt;/h1&gt;

&lt;h2 id=&quot;确定范围&quot;&gt;确定范围&lt;/h2&gt;

&lt;p&gt;IP、域名、内外网、整站、部分模块……&lt;/p&gt;

&lt;h2 id=&quot;确定规则&quot;&gt;确定规则&lt;/h2&gt;

&lt;p&gt;能渗透到什么程度,是发现漏洞即可还是需要利用该漏洞、时间限制、能否修改上传、能否提权……&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;目标系统介绍、重点保护对象及特性&lt;/p&gt;

  &lt;p&gt;是否允许破坏数据？&lt;/p&gt;

  &lt;p&gt;是否允许阻断业务正常运行&lt;/p&gt;

  &lt;p&gt;测试之前是否应当知会甲方安全部门，IP是否需要加白&lt;/p&gt;

  &lt;p&gt;接入方式？外网和内网？&lt;/p&gt;

  &lt;p&gt;测试是发现问题即可，还是尽可能发现更多问题&lt;/p&gt;

  &lt;p&gt;测试过程是否需要考虑社会工程手段&lt;/p&gt;

  &lt;p&gt;测试过程中要求完全仿真，除了破坏操作需要报备，其余手段不受限制还是如何&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;确定需求&quot;&gt;确定需求&lt;/h2&gt;

&lt;p&gt;上线前的web应用测试、业务逻辑漏洞测试、人员权限管理漏洞测试&lt;/p&gt;

&lt;h1 id=&quot;分析风险获得授权&quot;&gt;分析风险，获得授权&lt;/h1&gt;

&lt;p&gt;需分析渗透过程可能产生的风险：测试是否对系统产生影响、带宽占用、系统资源消耗、爆破测试行为或其他可能触发动态感知系统或其他告警机制、影响正常业务开展、服务器发生异常的应急、数据备份和恢复、测试人力物力成本……&lt;/p&gt;

&lt;p&gt;由乙方书写实施方案初稿提交给甲方或公司内部审核,审核通过后，测试人必须拿到正规的乙方书面委托授权书才能开工，代理商第三方授权不具备法律效力，若是第三方授权，必须拿到甲方给中间商的授权，且注明中间商有转让授权的权限，这样中间商下发的授权测试才是合法的。需要提前跟甲方确认是否能提供测试账号，测试账号最好覆盖各个权限级别，金融行业或者交易类的测试账号需要账户中有一定的余额……&lt;/p&gt;

&lt;h1 id=&quot;信息搜集&quot;&gt;信息搜集&lt;/h1&gt;

&lt;p&gt;信息搜集的方法很多，不详细阐述，大概列举如下:&lt;/p&gt;

&lt;p&gt;方 式：主动扫描+开放搜索&lt;/p&gt;

&lt;p&gt;基础信息：IP、网段、域名、端口……&lt;/p&gt;

&lt;p&gt;系统信息：操作系统版本……&lt;/p&gt;

&lt;p&gt;应用信息：各端口应用、例如web应用、邮件应用、脚本语言类型、目录结构、数据库类型、web框架……&lt;/p&gt;

&lt;p&gt;版本信息：所有探测到的版本&lt;/p&gt;

&lt;p&gt;服务信息: 服务器类型、版本&lt;/p&gt;

&lt;p&gt;人员信息: 域名注册人信息，web应用中网站发帖人的id,管理员姓名等&lt;/p&gt;

&lt;p&gt;防护信息：尝试探测防护设备&lt;/p&gt;

&lt;h1 id=&quot;漏洞探测&quot;&gt;漏洞探测&lt;/h1&gt;

&lt;p&gt;汇总信息搜集到的信息，使用与之匹配的漏洞检测策略&lt;/p&gt;

&lt;p&gt;方法:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1.漏扫:AWVS、AppScan、Nessus……&lt;/p&gt;

  &lt;p&gt;2.漏扫结果去exploit-db等位置找利用&lt;/p&gt;

  &lt;p&gt;3.在网上寻找验证POC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;内容:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;系统漏洞:系统没能及时更新补丁&lt;/p&gt;

  &lt;p&gt;Webserver漏洞:webserver配置问题……&lt;/p&gt;

  &lt;p&gt;Web应用漏洞:Web应用开发问题、错误页面未定义、后台暴露……&lt;/p&gt;

  &lt;p&gt;其他端口服务器漏洞:诸如21/8080(st2)/7001/22/3389……&lt;/p&gt;

  &lt;p&gt;通信安全：明文传输、token在cookie中传送……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;漏洞验证&quot;&gt;漏洞验证&lt;/h1&gt;

&lt;p&gt;通过自己经验分析可能成功利用的全部漏洞都验证一遍，结合实施环境，搭建模拟环境进行试验，利用成功后再实施在目标系统中&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;自动化验证:结合自动化扫描工具发现的结果&lt;/p&gt;

  &lt;p&gt;手工验证:利用公开资源进行验证&lt;/p&gt;

  &lt;p&gt;试验验证:自己搭建模拟环境进行验证&lt;/p&gt;

  &lt;p&gt;登录猜测:尝试猜测登录、万能密码、注入&lt;/p&gt;

  &lt;p&gt;业务漏洞验证:发现后该漏洞，进行验证&lt;/p&gt;

  &lt;p&gt;公开资源利用:exploit-db/wooyun/、渗透代码网站、通用、缺省口令、厂商的漏洞告警……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;信息分析&quot;&gt;信息分析&lt;/h1&gt;

&lt;p&gt;实施渗透的准备环节&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;精准攻击:利用4&amp;gt;探测到的EXP,进行精准攻击&lt;/p&gt;

  &lt;p&gt;绕过防御机制:检测是否有WAF等，绕过策略筹划&lt;/p&gt;

  &lt;p&gt;定制攻击路径:最佳攻击路径、主要根据薄弱入口，高内网权限位置，最终目标等&lt;/p&gt;

  &lt;p&gt;绕过检测机制：是否有检测机制，流量监控，杀毒软件，恶意代码（免杀）检测&lt;/p&gt;

  &lt;p&gt;攻击代码：试验得来的代码，包括不限于xss代码,sql注入语句……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;利用漏洞&quot;&gt;利用漏洞&lt;/h1&gt;

&lt;p&gt;实施攻击:根据前几步的结果，实施精准攻击&lt;/p&gt;

&lt;p&gt;获取内部信息:基础设施(网络连接、vpn、路由、网络拓扑、内网IT资产……)&lt;/p&gt;

&lt;p&gt;横向渗透:内网入侵、敏感目标&lt;/p&gt;

&lt;p&gt;持续性存在:一般情况，甲方不需要，rookit、后门、添加管理员账号、驻扎手法等&lt;/p&gt;

&lt;p&gt;清除痕迹:清理渗透相关日志（访问、操作），漏扫，上传文件等&lt;/p&gt;

&lt;h1 id=&quot;信息整理&quot;&gt;信息整理&lt;/h1&gt;

&lt;p&gt;整理渗透工具：整理渗透中使用的代码、POC、EXP等。&lt;/p&gt;

&lt;p&gt;整理收集信息：整个渗透过程中收集的一切信息。&lt;/p&gt;

&lt;p&gt;整理漏洞信息：整个渗透过程中利用成功的所有漏洞，各种脆弱位置信息，为书写渗透报告做准备。&lt;/p&gt;

&lt;h1 id=&quot;形成报告&quot;&gt;形成报告&lt;/h1&gt;

&lt;p&gt;按需整理：按照之前第一步跟甲方确认的范围、需求来整理资料，技术细节尽可能的详细，形成报告进行交付。&lt;/p&gt;

&lt;p&gt;补充介绍：需对漏洞成因，验证过程中带来的危害进行分析&lt;/p&gt;

&lt;p&gt;修补建议：给开发或运维人员提出合理高效安全的解决方案&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">虚拟机逃逸</title><link href="http://localhost:4000/_posts/2020-07-29-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8/" rel="alternate" type="text/html" title="虚拟机逃逸" /><published>2020-07-29T00:00:00-04:00</published><updated>2020-07-29T00:00:00-04:00</updated><id>http://localhost:4000/_posts/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-29-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;虚拟化方案有：&lt;strong&gt;软件虚拟化&lt;/strong&gt;、&lt;strong&gt;半虚拟化&lt;/strong&gt;、&lt;strong&gt;硬件虚拟化&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;软件虚拟化&quot;&gt;&lt;strong&gt;软件虚拟化&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;是指将虚拟机的指令流交给虚拟机核心层进行分析，将非特权指令直接交给CPU运行，特权指令交给虚拟机核心层执行。&lt;/p&gt;

&lt;h1 id=&quot;半虚拟化&quot;&gt;&lt;strong&gt;半虚拟化&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;是改造GuestOS(虚拟机内的系统)，使让GuestOS知道他在虚拟机环境中，使其只使用非特权指令（准确说是避免使用具有虚拟化缺陷的特权指令），需要用到特权操作时使用hypercall的方式请求虚拟机核心层代为完成&lt;/p&gt;

&lt;h1 id=&quot;硬件虚拟化&quot;&gt;&lt;strong&gt;硬件虚拟化&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;是芯片级别的虚拟化支持，克服x86虚拟化缺陷问题，无需改造GuestOS：将虚拟机运行在Ring1模式下，所有指令交给硬件执行。对于特权指令CPU不会直接执行，将其捕获交给虚拟机核心层进行处理&lt;/p&gt;

&lt;p&gt;典型代表：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;软件虚拟化：早期的vmware，qemu&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;半虚拟化：Xen&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;硬件虚拟化：vmware，kvm+qemu&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;逃逸方式1局域网攻击&quot;&gt;&lt;strong&gt;逃逸方式1：局域网攻击&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;此种方式不多说，因为本不属于逃逸范畴，但实际上却可以达到同等的目的。原理是利用局域网漏洞进行感染提权。著名代表就是永恒之蓝。&lt;/p&gt;

&lt;h1 id=&quot;逃逸方式2软件漏洞逃逸&quot;&gt;&lt;strong&gt;逃逸方式2：软件漏洞逃逸&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;Xen是重灾区域。半虚拟化系统无需硬件级别支持，效率极高的，但代价是改造GuestOS，虚拟机核心层需要大量代码来帮助GuestOS进行特权操作。是所有虚拟化方案中复杂度最高的一种。系统越复杂，安全性越低，所以Xen的半虚拟化经常被作为攻击的对象。曾听业内朋友说过思捷和威睿在竞标虚拟化时，威睿的团队的人经常给客户演示如何在Xen平台下做逃逸，导致思捷经常因为这个问题竞标失败。&lt;/p&gt;

&lt;h1 id=&quot;逃逸方式3硬件漏洞逃逸&quot;&gt;&lt;strong&gt;逃逸方式3：硬件漏洞逃逸&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;上面说了虚拟化的原理，再此做一次简单的总结：&lt;strong&gt;虚拟机运行在低权限的CPU状态，非指令交给CPU执行，特权指令交给虚拟机核心层执行&lt;/strong&gt;。若CPU有某种漏洞或后门：能使软件在低权限状态通过运行特定指令代码序列进入到高权限状态，那么虚拟机核心层则不再能对GuestOS运行的特权代码进行捕获处理。这时虚拟机内部的系统直接拥有了CPU的最高权限，可以随意践踏宿主系统的一切资源。此种攻击方式的代表：我不知道，但不代表没有，也许国家级别的安全实验室拥有此种技术。&lt;/p&gt;

&lt;p&gt;那么退一步，不取得最高权限，访问宿主机上的敏感数据是否可行？&lt;strong&gt;这个是可行的，17年底，18年初时，Intel/AMD公司的处理器纷纷爆出因指令预测机制未充分考虑旁路嗅探攻击。导致软件可以在Ring3的状态下，通过一些巧妙的手段嗅探出受CPU保护的敏感数据。&lt;/strong&gt;这个漏洞实际上对普通用户的影响甚小，但影响最大的则是各大云平台，因为云上任意一台虚拟机内，可以通过这个漏洞嗅探宿主机的数据，甚至是运行在同一个宿主机上其他虚拟机的数据。所以Intel/AMD出漏洞以后第一时间向各大云服务商披露硬件漏洞以及提供缓解方法。&lt;/p&gt;

&lt;h1 id=&quot;例子分析&quot;&gt;例子分析&lt;/h1&gt;

&lt;p&gt;VMware Workstation和Fusion中的拖放（DnD）功能含有越界内存访问漏洞。 这会允许访客在运行Workstation或Fusion的操作系统上执行代码。VMware实现了多种虚拟机（下文称为guest）与宿主机（下文称文host）之间的通信方式。其中一种方式是通过一个叫做Backdoor的接口，guest只需在用户态就可以通过该接口发送命令。VMware Tools也部分使用了这种接口来和host通信。&lt;/p&gt;

&lt;p&gt;针对Vmware的虚拟机逃逸的exploit源码GitHub早已公布(https://github.com/unamer/vmware_escape)。实现了从虚拟机到宿主机器的代码执行，弹出了熟悉的计算器。该开源代码，只需要将执行计算器部分的shellcode替换成其他具有恶意攻击的代码，就可以造成很大的危害。借鉴各位大神的分析，本文重点分析复现虚拟机逃逸典型漏洞CVE-2017-4901，当然还有其他几个CVE漏洞，能力有限，就不一一复现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;影响版本&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Vmware Workstation 12.5.5以前的版本&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">linux&amp;amp;win计划任务</title><link href="http://localhost:4000/_posts/2020-07-27-linux&win%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/" rel="alternate" type="text/html" title="linux&amp;win计划任务" /><published>2020-07-27T00:00:00-04:00</published><updated>2020-07-27T00:00:00-04:00</updated><id>http://localhost:4000/_posts/linux&amp;win%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-27-linux&amp;win%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;linux&quot;&gt;linux&lt;/h1&gt;

&lt;h2 id=&quot;at&quot;&gt;at&lt;/h2&gt;

&lt;p&gt;at在ubuntu，kali里面都是没有预先装好的&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;安装:sudo apt-get install at&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;at: invalid option -- '-'
Usage: at [-V] [-q x] [-f file] [-mMlbv] timespec ...
       at [-V] [-q x] [-f file] [-mMlbv] -t time
       at -c job ...
       atq [-V] [-q x]
       at [ -rd ] job ...
       atrm [-V] job ...
       batch
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;-V	版本&lt;/p&gt;

  &lt;p&gt;-q x	使用队列&lt;/p&gt;

  &lt;p&gt;-f file 使用文件&lt;/p&gt;

  &lt;p&gt;-m	发邮件&lt;/p&gt;

  &lt;p&gt;-M	不发邮件&lt;/p&gt;

  &lt;p&gt;-l	显示设置任务列表&lt;/p&gt;

  &lt;p&gt;-d x	删除编号为x的任务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;按ctrl+D来提交任务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;batch&quot;&gt;&lt;strong&gt;batch&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;batch不需要设置时间，那么不需要设置时间，它的任务是怎么执行的呢&lt;/p&gt;

&lt;p&gt;在系统平均负载量降到 0.8 以下时执行某项一次性的任务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-f file    使用文件里面的shell脚本
-q x　　　　将计划任务加入某个队列
-m    　　　发送邮件给用户
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;crontab&quot;&gt;&lt;strong&gt;crontab&lt;/strong&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;➜  ~ crontab --help
crontab: 不适用的选项 -- -
crontab: usage error: unrecognized option
usage:	crontab [-u user] file
	crontab [ -u user ] [ -i ] { -e | -l | -r }
		(default operation is replace, per 1003.2)
	-e	(edit user's crontab)
	-l	(list user's crontab)
	-r	(delete user's crontab)
	-i	(prompt before deleting user's crontab)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;-e　　　　进入编写
-l　　　　列出任务
-r　　　　删除任务
-i　　　　删除前给提示
-u　　　　指定某用户运行任务
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每条计划任务的格式书写如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;min 　　hour 　　day 　　month 　　week 　　[user] 　　command
0-59　　0-23　　 1-31　　1-12　　　0-7　　　　　　　　　　echo &quot;sijidou&quot; &amp;gt; /home/sijidou/Desktop/1.tx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面5个参数可以是这些形式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;每个参数间用空格隔开
*        表示任意
1,2      表示1,2号都可以（这里假设是day的值）
1-20    表示1号到20号都可以（这里假设是day的值）
/10      表示每隔10天就执行一次（这里假设是day的值）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举例:&lt;/p&gt;

&lt;p&gt;每月每周每日每小时51分的在桌面上生成有着”hello world”的1.txt文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;51 * * * * echo &quot;hello world&quot; &amp;gt; /home/sijidou/Desktop/1.tx
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;windows&quot;&gt;windows&lt;/h1&gt;

&lt;h2 id=&quot;at-1&quot;&gt;at&lt;/h2&gt;

&lt;p&gt;at命令是比较简单的一个命令，但是后面不常用了&lt;/p&gt;

&lt;p&gt;使用必须是administrator权限，并且win8之后没有这个命令了&lt;/p&gt;

&lt;h2 id=&quot;schtasks&quot;&gt;&lt;strong&gt;schtasks&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;schtasks功能丰富，应该算是windows下计划任务最主要的工具之一了&lt;/p&gt;

&lt;p&gt;适用环境是win7~win10都可以&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/Create         创建新计划任务。
/Delete         删除计划任务。
/Query          显示所有计划任务。
/Change         更改计划任务属性。
/Run            按需运行计划任务。
/End            中止当前正在运行的计划任务。
/ShowSid        显示与计划的任务名称相应的安全标识符。
创建新计划任务
SCHTASKS /Create [/S system [/U username [/P [password]]]][/RU username [/RP password]] /SC schedule [/MO modifier] [/D day][/M months][/I idletime]/TN taskname /TR taskrun [/ST starttime][/RIinterval] [{/ET endtime | /DU duration} [/K] [/XML xmlfile][/V1]] [/SD startdate] [/ED enddate] [/IT | /NP] [/Z] [/F]
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">IIS漏洞</title><link href="http://localhost:4000/_posts/2020-07-26-IIS%E6%BC%8F%E6%B4%9E/" rel="alternate" type="text/html" title="IIS漏洞" /><published>2020-07-26T00:00:00-04:00</published><updated>2020-07-26T00:00:00-04:00</updated><id>http://localhost:4000/_posts/IIS%E6%BC%8F%E6%B4%9E</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-26-IIS%E6%BC%8F%E6%B4%9E/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;iis&quot;&gt;IIS&lt;/h1&gt;

&lt;p&gt;IIS是由微软公司提供的基于运行Microsoft Windows的互联网基本服务。&lt;/p&gt;

&lt;p&gt;其是一种web服务组件，其中包括WEB服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面。&lt;/p&gt;

&lt;p&gt;目前,IIS一共发行了12个版本，从IIS1.0到IIS10.0,web市场上主要以IIS5.0到IIS10.0为主。&lt;/p&gt;

&lt;p&gt;对于IIS漏洞主要分布在缓冲区溢出、认证绕过、DOS拒绝服务、代码执行和信息泄露&lt;/p&gt;

&lt;h1 id=&quot;ms09-053cve-2009-3023&quot;&gt;MS09-053/CVE-2009-3023&lt;/h1&gt;

&lt;p&gt;Microsoft-IIS-FTPd服务MLST命令栈缓冲区溢出漏洞&lt;/p&gt;

&lt;p&gt;影响版本：IIS5.5、IIS5.1、IIS6.0&lt;/p&gt;

&lt;p&gt;漏洞详情：IIS内嵌的FTP服务器中存在栈溢出漏洞，如果远程攻击者对带有特制名称的目录发布了包含有通配符的FTP&lt;code&gt;NLST&lt;/code&gt;(name list)命令即可触发该溢出，导致拒绝服务或执行任意代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;msf5 &amp;gt; search ms09-053

Matching Modules
================

   #  Name                                           Disclosure Date  Rank    Check  Description
   -  ----                                           ---------------  ----    -----  -----------
   0  auxiliary/dos/windows/ftp/iis_list_exhaustion  2009-09-03       normal  No     Microsoft IIS FTP Server LIST Stack Exhaustion
   1  exploit/windows/ftp/ms09_053_ftpd_nlst         2009-08-31       great   No     MS09-053 Microsoft IIS FTP Server NLST Response Overflow
Interact with a module by name or index, for example use 1 or use exploit/windows/ftp/ms09_053_ftpd_nlst
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件：拥有写权限&lt;/p&gt;

&lt;p&gt;修补：修改NTFS文件权限或修改不允许FTP写权限或不允许FTP匿名登录或安装补丁&lt;/p&gt;

&lt;h1 id=&quot;认证绕过&quot;&gt;认证绕过&lt;/h1&gt;

&lt;p&gt;影响版本：IIS6.0、IIS7.5&lt;/p&gt;

&lt;p&gt;漏洞详情：对用户输入未经正确验证，攻击者可利用漏洞构造特殊数据，在服务器进程上下文中获取密码保护资源和查看源代码文件的未授权访问&lt;/p&gt;

&lt;p&gt;攻击手段：&lt;/p&gt;

&lt;p&gt;IIS6.0&lt;/p&gt;

&lt;p&gt;将&lt;code&gt;::$INDEX_ALLOCATION&lt;/code&gt;后缀添加到目录名称后，如&lt;code&gt;/admin::$INDEX_ALLOCATION/index.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;IIS7.5&lt;/p&gt;

&lt;p&gt;将&lt;code&gt;:$i30:$INDEX_ALLOCATION&lt;/code&gt;后缀添加到目录名称后，如&lt;code&gt;/admin:$i30:$INDEX_ALLOCATION/index.asp&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&quot;短文件名泄露&quot;&gt;短文件名泄露&lt;/h1&gt;

&lt;p&gt;影响版本：IIS5.0-IIS10.0&lt;/p&gt;

&lt;p&gt;漏洞详情：Windows支持以8.3格式生成与MS-DOS兼容的（短）文件名，以允许基于MS-DOS或16位Windows的程序访问这些文件。基于Windows的IIS服务器默认根目录C:\inetpub\wwwroot下的网页脚本文件和目录符合一定条件时，会生成相应的短文件名。此时，攻击者利用HTTP的DEBUG、OPTIONS、GET、POST、HEAD、TRACE等方法携带波浪号，可以对IIS服务器短文件名进行暴力猜解，依据返回的页面信息和状态码来确认真实存在的文件名，从而获取服务器敏感信息。&lt;/p&gt;

&lt;p&gt;检测脚本:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import sys
import httplib
import urlparse
import threading
import Queue
import time


class Scanner():
    def __init__(self, target):
        self.target = target.lower()
        if not self.target.startswith('http'):
            self.target = 'http://%s' % self.target
        self.scheme, self.netloc, self.path, params, query, fragment = \
                     urlparse.urlparse(target)
        if self.path[-1:] != '/':    # ends with slash
            self.path += '/'
        self.alphanum = 'abcdefghijklmnopqrstuvwxyz0123456789_-'
        self.files = []
        self.dirs = []
        self.queue = Queue.Queue()
        self.lock = threading.Lock()
        self.threads = []
        self.request_method = ''
        self.msg_queue = Queue.Queue()
        self.STOP_ME = False
        threading.Thread(target=self._print).start()

    def _conn(self):
        try:
            if self.scheme == 'https':
                conn = httplib.HTTPSConnection(self.netloc)
            else:
                conn = httplib.HTTPConnection(self.netloc)
            return conn
        except Exception, e:
            print '[_conn.Exception]', e
            return None

    def _get_status(self, path):
        try:
            conn = self._conn()
            conn.request(self.request_method, path)
            status = conn.getresponse().status
            conn.close()
            return status
        except Exception, e:
            raise Exception('[_get_status.Exception] %s' % str(e) )

    def is_vul(self):
        try:
            for _method in ['GET', 'OPTIONS']:
                self.request_method = _method
                status_1 = self._get_status(self.path + '/*~1*/a.aspx')    # an existed file/folder
                status_2 = self._get_status(self.path + '/l1j1e*~1*/a.aspx')    # not existed file/folder
                if status_1 == 404 and status_2 != 404:
                    return True
            return  False
        except Exception, e:
            raise Exception('[is_vul.Exception] %s' % str(e) )

    def run(self):
        for c in self.alphanum:
            self.queue.put( (self.path + c, '.*') )    # filename, extension
        for i in range(20):
            t = threading.Thread(target=self._scan_worker)
            self.threads.append(t)
            t.start()
        for t in self.threads:
            t.join()
        self.STOP_ME = True

    def report(self):
        print '-'* 64
        for d in self.dirs:
            print 'Dir:  %s' % d
        for f in self.files:
            print 'File: %s' % f
        print '-'*64
        print '%d Directories, %d Files found in total' % (len(self.dirs), len(self.files))
        print 'Note that * is a wildcard, matches any character zero or more times.'

    def _print(self):
        while not self.STOP_ME or (not self.msg_queue.empty()):
            if self.msg_queue.empty():
                time.sleep(0.05)
            else:
                print self.msg_queue.get()

    def _scan_worker(self):
        while True:
            try:
                url, ext = self.queue.get(timeout=1.0)
                status = self._get_status(url + '*~1' + ext + '/1.aspx')
                if status == 404:
                    self.msg_queue.put('[+] %s~1%s\t[scan in progress]' % (url, ext))

                    if len(url) - len(self.path)&amp;lt; 6:    # enum first 6 chars only
                        for c in self.alphanum:
                            self.queue.put( (url + c, ext) )
                    else:
                        if ext == '.*':
                            self.queue.put( (url, '') )

                        if ext == '':
                            self.dirs.append(url + '~1')
                            self.msg_queue.put('[+] Directory ' +  url + '~1\t[Done]')

                        elif len(ext) == 5 or (not ext.endswith('*')):    # .asp*
                            self.files.append(url + '~1' + ext)
                            self.msg_queue.put('[+] File ' + url + '~1' + ext + '\t[Done]')

                        else:
                            for c in 'abcdefghijklmnopqrstuvwxyz0123456789':
                                self.queue.put( (url, ext[:-1] + c + '*') )
                                if len(ext) &amp;lt; 4:    # &amp;lt; len('.as*')
                                    self.queue.put( (url, ext[:-1] + c) )

            except Queue.Empty,e:
                break
            except Exception, e:
                print '[Exception]', e


if __name__ == '__main__':
    if len(sys.argv) == 1:
        print 'Usage: python IIS_shortname_Scan.py http://www.target.com/'
        sys.exit()

    target = sys.argv[1]
    s = Scanner(target)
    if not s.is_vul():
        s.STOP_ME = True
        print 'Server is not vulnerable'
        sys.exit(0)

    print 'Server is vulnerable, please wait, scanning...'
    s.run()
    s.report()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;put漏洞&quot;&gt;PUT漏洞&lt;/h1&gt;

&lt;p&gt;漏洞详情：对IIS的错误配置导致的写权限漏洞。WEB服务器拓展里设置了&lt;code&gt;WebDAV&lt;/code&gt;为允许，同时网站权限配置开启了写入权限与脚本资源访问权限。通过该PUT漏洞可以写入webshell&lt;/p&gt;

&lt;p&gt;方法:&lt;/p&gt;

&lt;p&gt;https://www.codercto.com/a/48257.html&lt;/p&gt;

&lt;h1 id=&quot;ms15-034cve-2015-1635&quot;&gt;MS15-034/CVE-2015-1635&lt;/h1&gt;

&lt;p&gt;漏洞详情： 远程执行代码漏洞存在于 HTTP 协议堆栈 (HTTP.sys) 中，当 HTTP.sys 未正确分析经特殊设计的 HTTP 请求时会导致此漏洞。成功利用此漏洞的攻击者可以在系统帐户的上下文中执行任意代码。&lt;/p&gt;

&lt;p&gt;攻击手段： https://www.freebuf.com/articles/system/64185.html&lt;/p&gt;

&lt;h1 id=&quot;cve-2017-7269&quot;&gt;CVE-2017-7269&lt;/h1&gt;

&lt;p&gt;IIS远程代码执行漏洞&lt;/p&gt;

&lt;p&gt;影响版本：IIS6.0&lt;/p&gt;

&lt;p&gt;漏洞详情：开启&lt;code&gt;WebDAV&lt;/code&gt;服务的IIS 6.0被爆存在缓存区溢出漏洞导致远程代码执行，目前针对 Windows Server 2003 R2 可以稳定利用。&lt;/p&gt;

&lt;p&gt;攻击手段： https://github.com/zcgonvh/cve-2017-7269&lt;/p&gt;

&lt;h1 id=&quot;iis解析漏洞&quot;&gt;IIS解析漏洞&lt;/h1&gt;

&lt;p&gt;影响版本：IIS5.0-6.0、IIS7.0&lt;/p&gt;

&lt;p&gt;漏洞详情：&lt;/p&gt;

&lt;p&gt;1、IIS5.0-6.0下，如果一个目录以”xxx.asp”的形式命名，那么该目录下的所有类型文件都会被当做asp文件来进行解析执行&lt;/p&gt;

&lt;p&gt;2、IIS5.0-6.0下，如果一个文件的扩展名采用”.asp;*.jpg”的形式，那么该文件也会被当做asp文件解析执行&lt;/p&gt;

&lt;p&gt;3、IIS70下，如果php.ini中的cgi.cgi_pathinfo=1同时IIS7.0在Fast-CGI运行模式下，则可以在恶意文件后面添加&lt;code&gt;/.php&lt;/code&gt;使得其解析为php。如&lt;code&gt;http://192.168.61.141/789.jpg/.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参考链接：&lt;/p&gt;

&lt;p&gt;https://www.cnblogs.com/baifan2618/p/7704678.html&lt;/p&gt;

&lt;p&gt;https://blog.csdn.net/nzjdsds/article/details/96989492&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">GPC&amp;amp;绕过</title><link href="http://localhost:4000/_posts/2020-07-25-GPC&%E7%BB%95%E8%BF%87/" rel="alternate" type="text/html" title="GPC&amp;绕过" /><published>2020-07-25T00:00:00-04:00</published><updated>2020-07-25T00:00:00-04:00</updated><id>http://localhost:4000/_posts/GPC&amp;%E7%BB%95%E8%BF%87</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-25-GPC&amp;%E7%BB%95%E8%BF%87/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;PHP magic_quotes_gpc作用范围是：WEB客户服务端；作用时间：请求开始时&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;使用&quot;&gt;使用&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对于PHP magic_quotes_gpc=on的情况， 我们可以不对输入和输出数据库的字符串数据作addslashes()和&lt;a href=&quot;https://baike.baidu.com/item/stripslashes&quot;&gt;stripslashes&lt;/a&gt;()的操作,数据也会正常显示。如果此时你对输入的数据作了addslashes()处理，那么在输出的时候就必须使用stripslashes()去掉多余的&lt;a href=&quot;https://baike.baidu.com/item/反斜杠&quot;&gt;反斜杠&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于PHP magic_quotes_gpc=off 的情况,必须使用addslashes()对输入数据进行处理，但并不需要使用stripslashes()格式化输出，因为addslashes()并未将反斜杠一起写入数据库，只是帮助mysql完成了sql语句的执行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;实例&quot;&gt;实例&lt;/h1&gt;

&lt;p&gt;条件： PHP magic_quotes_gpc=off&lt;/p&gt;

&lt;p&gt;写入数据库的字符串未经过任何过滤处理。从数据库读出的字符串也未作任何处理。&lt;/p&gt;

&lt;p&gt;数据：  $data=”snow”’’sun” ; (snow和sun之间是四个连续的单引号).&lt;/p&gt;

&lt;p&gt;操作： 将字符串:”snow”’’sun” 写入数据库，&lt;/p&gt;

&lt;p&gt;结果： 出现sql语句错误，mysql不能顺利完成sql语句，写入数据库失败。&lt;/p&gt;

&lt;p&gt;数据库保存格式：无数据。&lt;/p&gt;

&lt;p&gt;输出数据格式：无数据。&lt;/p&gt;

&lt;p&gt;说明： 对于未经处理的单引号在写入数据库时会使sql语句发生错误。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;条件： PHP magic_quotes_gpc=off&lt;/p&gt;

&lt;p&gt;写入数据库的字符串经过函数addslashes()处理。从数据库读出的字符串未作任何处理。&lt;/p&gt;

&lt;p&gt;数据：  $data=”snow”’’sun” ; (snow和sun之间是四个连续的单引号).&lt;/p&gt;

&lt;p&gt;操作： 将字符串:”snow”’’sun” 写入数据库，&lt;/p&gt;

&lt;p&gt;结果： sql语句顺利执行，数据成功写入数据库&lt;/p&gt;

&lt;p&gt;数据库保存格式：snow”’’sun (和输入一样)&lt;/p&gt;

&lt;p&gt;输出数据格式：snow”’’sun (和输入一样)&lt;/p&gt;

&lt;p&gt;说明： addslashes()函数将单引号转换为\’的&lt;a href=&quot;https://baike.baidu.com/item/转义字符&quot;&gt;转义字符&lt;/a&gt;使sql语句成功执行，&lt;/p&gt;

&lt;p&gt;但\’并未作为数据存入数据库，数据库保存的是snow”’’sun 而并不是我们想象的snow\’\’\’\’sun&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;条件： PHP magic_quotes_gpc=on&lt;/p&gt;

&lt;p&gt;写入数据库的字符串未经过任何处理。从数据库读出的字符串未作任何处理。&lt;/p&gt;

&lt;p&gt;数据：  $data=”snow”’’sun” ; (snow和sun之间是四个连续的单引号).&lt;/p&gt;

&lt;p&gt;操作： 将字符串:”snow”’’sun” 写入数据库，&lt;/p&gt;

&lt;p&gt;结果： sql语句顺利执行，数据成功写入数据库&lt;/p&gt;

&lt;p&gt;数据库保存格式：snow”’’sun (和输入一样)&lt;/p&gt;

&lt;p&gt;输出数据格式：snow”’’sun (和输入一样)&lt;/p&gt;

&lt;p&gt;说明： PHP magic_quotes_gpc=on 将单引号转换为\’的&lt;a href=&quot;https://baike.baidu.com/item/转义字符&quot;&gt;转义字符&lt;/a&gt;使sql语句成功执行，&lt;/p&gt;

&lt;p&gt;但\’并未作为数据入数据库，数据库保存的是snow”’’sun而并不是我们想象的snow\’\’\’\’sun。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;条件： PHP magic_quotes_gpc=on&lt;/p&gt;

&lt;p&gt;写入数据库的字符串经过函数addlashes()处理。从数据库读出的字符串未作任何处理。&lt;/p&gt;

&lt;p&gt;数据：  $data=”snow”’’sun” ; (snow和sun之间是四个连续的单引号).&lt;/p&gt;

&lt;p&gt;操作： 将字符串:”snow”’’sun” 写入数据库，&lt;/p&gt;

&lt;p&gt;结果： sql语句顺利执行，数据成功写入数据库&lt;/p&gt;

&lt;p&gt;数据库保存格式：snow\’\’\’\’sun (添加了&lt;a href=&quot;https://baike.baidu.com/item/转义字符&quot;&gt;转义字符&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;输出数据格式：snow\’\’\’\’sun (添加了转义字符)&lt;/p&gt;

&lt;p&gt;说明： PHP magic_quotes_gpc=on 将单引号转换为\’的转义字符使sql语句成功执行，&lt;/p&gt;

&lt;p&gt;addslashes又将即将写入数据库的单引号转换为\’,后者的转换被作为数据写入&lt;/p&gt;

&lt;p&gt;数据库，数据库保存的是snow\’\’\’\’sun&lt;/p&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc]</summary></entry><entry><title type="html">MySql存储引擎</title><link href="http://localhost:4000/_posts/2020-07-22-MySql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" rel="alternate" type="text/html" title="MySql存储引擎" /><published>2020-07-22T00:00:00-04:00</published><updated>2020-07-22T00:00:00-04:00</updated><id>http://localhost:4000/_posts/MySql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-22-MySql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;什么是存储引擎&quot;&gt;什么是存储引擎&lt;/h1&gt;

&lt;p&gt;数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。&lt;/p&gt;

&lt;p&gt;现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。&lt;/p&gt;

&lt;p&gt;MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。&lt;/p&gt;

&lt;h1 id=&quot;mysql-57-支持的存储引擎&quot;&gt;MySQL 5.7 支持的存储引擎&lt;/h1&gt;

&lt;p&gt;MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 &lt;code&gt;SHOW ENGINES&lt;/code&gt; 语句来显示可用的数据库引擎和默认引擎。&lt;/p&gt;

&lt;p&gt;MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Support 列的值表示某种引擎是否能使用，&lt;code&gt;YES&lt;/code&gt;表示可以使用，&lt;code&gt;NO&lt;/code&gt;表示不能使用，&lt;code&gt;DEFAULT&lt;/code&gt;表示该引擎为当前默认的存储引擎。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;如何选择-mysql-存储引擎&quot;&gt;如何选择 MySQL 存储引擎&lt;/h1&gt;

&lt;p&gt;不同的存储引擎都有各自的特点，以适应不同的需求，如表所示。为了做出选择，首先要考虑每一个存储引擎提供了哪些不同的功能。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;MylSAM&lt;/th&gt;
      &lt;th&gt;MEMORY&lt;/th&gt;
      &lt;th&gt;InnoDB&lt;/th&gt;
      &lt;th&gt;Archive&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;存储限制&lt;/td&gt;
      &lt;td&gt;256TB&lt;/td&gt;
      &lt;td&gt;RAM&lt;/td&gt;
      &lt;td&gt;64TB&lt;/td&gt;
      &lt;td&gt;None&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持事务&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持全文索引&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持树索引&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持哈希索引&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持数据缓存&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持外键&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;1、事务安全
InnoDB支持事务安全,MyISAM和MEMORY两个不支持。&lt;/p&gt;

&lt;p&gt;2、储存限制
InnoDB有64TB的存储限制，MyISAM和MEMORY要是具体情况而定。&lt;/p&gt;

&lt;p&gt;3、空间使用
InnoDB对空间使用程度较高，MyISAM和MEMORY对空间使用程度较低。&lt;/p&gt;

&lt;p&gt;4、内存使用
InnoDB和MEMORY对内存使用程度较高，MyISAM对内存使用程度较低。&lt;/p&gt;

&lt;p&gt;5、插入数据的速度：
InnoDB插入数据的速度较低，MyISAM和MEMORY插入数据的速度较高。&lt;/p&gt;

&lt;p&gt;6、对外键的支持：
InnoDB对外键支持情况较好，MyISAM和MEMORY两个不支持外键。&lt;/p&gt;

&lt;p&gt;可以根据以下的原则来选择 MySQL 存储引擎：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。&lt;/li&gt;
  &lt;li&gt;如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。&lt;/li&gt;
  &lt;li&gt;如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。&lt;/li&gt;
  &lt;li&gt;如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三种引擎特点如下：
1、InnoDB存储引擎InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），其它存储引擎都是非事务安全表，支持行锁定和外键，MySQL5.5以后默认使用InnoDB存储引擎。&lt;/p&gt;

&lt;p&gt;InnoDB特点： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。&lt;/p&gt;

&lt;p&gt;如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。&lt;/p&gt;

&lt;p&gt;2、MyISAM存储引擎 MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务，不支持外键。&lt;/p&gt;

&lt;p&gt;MyISAM特点： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用&lt;/p&gt;

&lt;p&gt;3、MEMORY存储引擎 MEMORY存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。&lt;/p&gt;

&lt;p&gt;MEMORY特点： 所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。&lt;/p&gt;

&lt;p&gt;它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。&lt;/p&gt;

&lt;h1 id=&quot;mysql-默认存储引擎&quot;&gt;MySQL 默认存储引擎&lt;/h1&gt;

&lt;p&gt;nnoDB 是系统的默认引擎，支持可靠的事务处理。&lt;/p&gt;

&lt;p&gt;使用下面的语句可以修改数据库临时的默认存储引擎&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SET default_storage_engine=&amp;lt; 存储引擎名 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="sql" /><summary type="html">[toc]</summary></entry><entry><title type="html">密码学基础总结</title><link href="http://localhost:4000/_posts/2020-07-19-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="密码学基础总结" /><published>2020-07-19T00:00:00-04:00</published><updated>2020-07-19T00:00:00-04:00</updated><id>http://localhost:4000/_posts/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-19-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;基础概念&quot;&gt;基础概念&lt;/h1&gt;

&lt;h2 id=&quot;信息安全三要素cia&quot;&gt;信息安全三要素（CIA）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;机密性&lt;/li&gt;
  &lt;li&gt;完整性&lt;/li&gt;
  &lt;li&gt;可用性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扩展：&lt;/p&gt;

&lt;p&gt;六要素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;机密性&lt;/li&gt;
  &lt;li&gt;所有权&lt;/li&gt;
  &lt;li&gt;完整性&lt;/li&gt;
  &lt;li&gt;可认证性&lt;/li&gt;
  &lt;li&gt;可用性&lt;/li&gt;
  &lt;li&gt;实用性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;八要素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;机密性&lt;/li&gt;
  &lt;li&gt;完整性&lt;/li&gt;
  &lt;li&gt;可用性&lt;/li&gt;
  &lt;li&gt;隐私性&lt;/li&gt;
  &lt;li&gt;可认证性于可信任性&lt;/li&gt;
  &lt;li&gt;不可抵赖性&lt;/li&gt;
  &lt;li&gt;可说明性&lt;/li&gt;
  &lt;li&gt;可审计性&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;安全性攻击形式&quot;&gt;安全性攻击形式&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;被动攻击
    &lt;ul&gt;
      &lt;li&gt;截取&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;主动攻击
    &lt;ul&gt;
      &lt;li&gt;中断&lt;/li&gt;
      &lt;li&gt;篡改&lt;/li&gt;
      &lt;li&gt;伪造&lt;/li&gt;
      &lt;li&gt;重放&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;密码编码学&quot;&gt;密码编码学&lt;/h1&gt;

&lt;h2 id=&quot;保密体制&quot;&gt;保密体制&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;对称加密体制&lt;/li&gt;
  &lt;li&gt;非对称加密体制&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;认证体制&quot;&gt;认证体制&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;消息认证
    &lt;ul&gt;
      &lt;li&gt;消息认证码体制&lt;/li&gt;
      &lt;li&gt;数字签名&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;实体认证
    &lt;ul&gt;
      &lt;li&gt;生份鉴别协议&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;对称与非对称加密体制&quot;&gt;对称与非对称加密体制&lt;/h1&gt;

&lt;h2 id=&quot;对称加密体制&quot;&gt;对称加密体制&lt;/h2&gt;

&lt;p&gt;实用的秘钥必须完全保密，且要求加密秘钥和解密秘钥相同或由其中一个可以很容易推出另外一个&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;速度快，有很高的吞吐率，软硬件易于实现&lt;/li&gt;
  &lt;li&gt;秘钥相对较短&lt;/li&gt;
  &lt;li&gt;对称保密体制密文长度往往与明文相同，或扩张较小&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;秘钥分发需要安全通道&lt;/li&gt;
  &lt;li&gt;秘钥量大，难管理&lt;/li&gt;
  &lt;li&gt;难以解决不可否认性&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;非对称加密体制&quot;&gt;非对称加密体制&lt;/h2&gt;

&lt;p&gt;秘钥有两个，一个对外公开，另外一个必须保密，不能从公钥推到私钥，或者是计算困难&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;秘钥分发容易&lt;/li&gt;
  &lt;li&gt;秘钥管理简单&lt;/li&gt;
  &lt;li&gt;可以有效实现数字签名&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;速度慢&lt;/li&gt;
  &lt;li&gt;同等安全下，非对称密码体制对秘钥位数要多一些&lt;/li&gt;
  &lt;li&gt;非对称保密体制中，密文长度往往大于明文长度&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;柯克霍夫原则&quot;&gt;柯克霍夫原则&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;kerckhoffs princip&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;秘钥必须完全寓于秘钥中，即加密和解密算法的安全性取决于秘钥的安全性，而加密解密的过程和细节是公开的，只要秘钥是安全的，则攻击者无法推出明文&lt;/p&gt;

&lt;p&gt;实际应用中，攻击者的能力还会受到进一步限制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;破解密码系统的成本不超过被加密信息本身&lt;/li&gt;
  &lt;li&gt;破译密码系统时间不超过被加密信息的有效生命周期&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;密码学加密系统的五元组&quot;&gt;密码学加密系统的五元组&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;明文，密文，密钥，加密算法，解密算法
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;密码体制攻击类型&quot;&gt;密码体制攻击类型&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;唯密文攻击（Ciphertext only）
 破译者已知：加密算法、待破译的密文&lt;/li&gt;
  &lt;li&gt;已知明文攻击（Known plaintext）
 破译者已知：加密算法、一定数量的明文和对应的密文&lt;/li&gt;
  &lt;li&gt;选择明文攻击（Chosen plaintext） 
破译者已知：加密算法、选定的明文和对应的密文&lt;/li&gt;
  &lt;li&gt;选择密文攻击（Chosen ciphertext） 
破译者已知：加密算法、选定的密文和对应的明文&lt;/li&gt;
  &lt;li&gt;选择文本攻击（Chosen text）
破译者已知：加密算法、选定的明文和对应的密文、选定的密文和对应的明文&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;对加密系统的攻击类型前四种&quot;&gt;对加密系统的攻击类型（前四种）&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;1.已知明文攻击 （知道一些名密文对）
2选择明文攻击 （任意明文-&amp;gt;密文）
3.唯密文攻击 （只知道一些密文）    
4选择密文攻击（任意密文-&amp;gt;明文）
5.选择文本攻击（任意明文&amp;lt;-&amp;gt;任意密文）
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;攻击常用方法&quot;&gt;攻击常用方法&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;穷举&lt;/li&gt;
  &lt;li&gt;统计分析&lt;/li&gt;
  &lt;li&gt;数学分析&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;熵&quot;&gt;熵&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;随机事件x发生的概率的对数的相反数定义为该随机事件的自信息量，记为I（xi），设xi发生的概率为p（xi），则自信息量为：&lt;/em&gt;
&lt;script type=&quot;math/tex&quot;&gt;I(x)_{i} = - log_{2}p(x_{i})&lt;/script&gt;
底数为2，信息量单位为比特，如果以e为底数，单位为奈特&lt;/p&gt;

&lt;h1 id=&quot;古典密码&quot;&gt;古典密码&lt;/h1&gt;

&lt;h2 id=&quot;置换&quot;&gt;置换&lt;/h2&gt;

&lt;p&gt;置换：根据一定的规则重新排列明文，打破明文结构特性&lt;/p&gt;

&lt;h3 id=&quot;列置换&quot;&gt;列置换&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;明文按照秘钥规则按列换位并且得到密文&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/置换密码.png&quot; alt=&quot;置换密码&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;&lt;img src=&quot;/img/置换密码举例.png&quot; alt=&quot;置换密码举例&quot; /&gt;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/列置换.png&quot; alt=&quot;列置换&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/列置换2.png&quot; alt=&quot;列置换2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;周期置换&quot;&gt;周期置换&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;将明文按照固定长度分组，然后对每组按照某种排列位置得到密文&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;明文：“State Key Laboratory of Networking and Switching”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加密的密钥：S=(1 5 6 2 3)；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将明文分为七组，每组6个字符，不足6个的用双方规定好的字符进行填充，比如空格。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​      P’ = (StateK)(eyLabo)(ratory)(ofNetw)(orking)(andSwi)(tching)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对每组的字符进行加密，根据密钥S，可知将第1个字符放在第5个字符的位置，第5个字符放在第6个字符的位置，第6个字符放在第2个字符的位置，第2个字符放在第3个字符的位置，第3个字符放在第1个字符的位置，置换后P’如下：&lt;/p&gt;

    &lt;p&gt;P‘ = (aKttSe)(Loyaeb)(tyaorr)(Nwfeot)(kgrion)(dinSaw)(hgcitn)&lt;/p&gt;

    &lt;p&gt;所以得到的最终密文Pm = “aKttSeLoyaebtyaorrNwfeotkgriondinSawhgcitn”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;周期置换的解密方法就是加密的逆运算，只需求出密钥的逆置换即可。可以知道密钥S=(1 5 6 2 3)的逆置换S’ = (1 3 2 6 5)，所以只需将密文重新分组，通过S’的置换顺序就可以得出明文P&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;代换密码&quot;&gt;代换密码&lt;/h2&gt;

&lt;p&gt;代换，就是将明文中的一个字母由其它字母、数字或者符号替代的一种方法
代换密码建立一个代换表，加密时将需要加密的明文依次通过查表，替换为相应的字符，明文字符被逐个替换后，生成无任何意义的字符串，即密文。这样的代换表被称为密钥&lt;/p&gt;

&lt;h3 id=&quot;单表代换密码&quot;&gt;单表代换密码&lt;/h3&gt;

&lt;p&gt;单表代换是指英文字母在进行密码编码替换的时候，有一张对照表，也就是说，对于每一个字母，都是唯一对应的，如：&lt;/p&gt;

&lt;p&gt;26个源字母表为：abcdefghijklmnopqrstuvwxyz&lt;/p&gt;

&lt;p&gt;代换的字母表为：qwertyuiopasdfghjklzxcvbnm&lt;/p&gt;

&lt;p&gt;在加密时，按照设计好的对照表对每一个明文字母进行替换，如a替换为q，b替换为w等。&lt;/p&gt;

&lt;h3 id=&quot;放射密码&quot;&gt;放射密码&lt;/h3&gt;

&lt;p&gt;加法密码和乘法密码结合就构成仿射密码，仿射密码的加密和解密算法是：
&lt;script type=&quot;math/tex&quot;&gt;C=EK(m)=(k_{1}m+k_{2})modn\\
M = DK(C)=k_{3}(C-k_{2})mod n\\
(k_{3}Xk_{1})mod 26=1\\&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;仿射密码具有可逆性的条件是:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;gcd(k1, n)=1&lt;/code&gt;. 当k1=1时，仿射密码变为加法密码，当k2=0时，仿射密码变为乘法密码。
仿射密码中的密钥空间的大小为&lt;code&gt;nφ(n)&lt;/code&gt;，当&lt;code&gt;n&lt;/code&gt;为&lt;code&gt;26&lt;/code&gt;字母，&lt;code&gt;φ(n)=12&lt;/code&gt;，因此仿射密码的密钥空间为12×26 = 312&lt;/p&gt;

&lt;h4 id=&quot;例子&quot;&gt;例子&lt;/h4&gt;

&lt;p&gt;设放射密码加密函数为：&lt;code&gt;e(x)=11x+6(mod 26)&lt;/code&gt;,则有11^{-1}(mod26)=19,所以解密函数:&lt;code&gt;x=19[e(x)-6]=19e(x)+16(mod 26)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;设加密明文：&lt;code&gt;sorcery&lt;/code&gt;，转换为数字：&lt;code&gt;18,14,17,2,4,17,24&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;加密：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
11*
 \left[
 \begin{matrix}
   18 \\
   14 \\
   17\\
   2\\
   4\\
   17\\
   24\\
  \end{matrix}
  \right]
+
 \left[
 \begin{matrix}
   6 \\
   6 \\
   6\\
   6\\
   6\\
   6\\
   6\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   204 \\
   160\\
   193\\
  28\\
   50\\
   193\\
  270\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   22 \\
   4\\
   11\\
  2\\
   24\\
   11\\
  10\\
  \end{matrix}
  \right]
 (mod26)
&lt; =&gt;
 \left[
 \begin{matrix}
   W \\
   E\\
   L\\
   C\\
   y\\
   L\\
   K\\
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;
解密：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
19*
 \left[
 \begin{matrix}
   22 \\
   4 \\
   11\\
   2\\
   24\\
   11\\
   10\\
  \end{matrix}
  \right]
+
 \left[
 \begin{matrix}
   16 \\
   16 \\
   16\\
   16\\
   16\\
   16\\
   16\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   434 \\
   92\\
   225\\
  54\\
   472\\
   225\\
  206\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   18\\
   14\\
   17\\
  2\\
   4\\
   17\\
  24\\
  \end{matrix}
  \right]
 (mod26)
&lt; =&gt;
 \left[
 \begin{matrix}
   s \\
   o\\
   r\\
   c\\
   e\\
   r\\
   y\\
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;求逆元：&lt;strong&gt;扩展欧几里得算法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;多表代换&quot;&gt;多表代换&lt;/h3&gt;

&lt;h4 id=&quot;维吉尼亚密码&quot;&gt;维吉尼亚密码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/多表代换.png&quot; alt=&quot;多表代换&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例题：&lt;/p&gt;

&lt;p&gt;p=data security , k = best&lt;/p&gt;

&lt;p&gt;先将明文分解为长为4的序列：&lt;/p&gt;

&lt;p&gt;data 			secu 			rity&lt;/p&gt;

&lt;p&gt;每个序列用秘钥best加密&lt;/p&gt;

&lt;p&gt;密文：EELT  	TIUN	  SMLR&lt;/p&gt;

&lt;h4 id=&quot;playfair密码&quot;&gt;Playfair密码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/维吉尼亚密码.png&quot; alt=&quot;维吉尼亚密码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/playfair2.png&quot; alt=&quot;playfair2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例题：&lt;/p&gt;

&lt;p&gt;设秘钥为：PLAYFAIR IS A DIGRAM CIPHER&lt;/p&gt;

&lt;p&gt;字母矩阵：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\left[
 \begin{matrix}
  P&amp;L &amp;A &amp;Y&amp; F \\
   I/J&amp;R&amp;S&amp;D&amp;G\\
   M&amp;C&amp;H&amp;E&amp;B\\
   K&amp;N&amp;O&amp;Q&amp;T\\
   U&amp;V&amp;W&amp;X&amp;Z\\
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;明文：pI ay fa ir ci ph er&lt;/p&gt;

&lt;p&gt;密文: LA YF PY RS MR AM CD&lt;/p&gt;

&lt;h4 id=&quot;希尔密码&quot;&gt;希尔密码&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/希尔密码.png&quot; alt=&quot;希尔密码&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例题：&lt;/p&gt;

&lt;p&gt;明文：cyber，数字化：2,24,1,4,17&lt;/p&gt;

&lt;p&gt;秘钥:
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\left[
\begin{matrix}
  10&amp;5 &amp;12 &amp;0&amp; 0 \\
   3&amp;14&amp;21&amp;0&amp;0\\
   8&amp;9&amp;11&amp;0&amp;0\\
   0&amp;0&amp;0&amp;11&amp;8\\
   0&amp;0&amp;0&amp;3&amp;7\\
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;
加密：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
c=(2,24,1,4,17)
\left[
\begin{matrix}
  10&amp;5 &amp;12 &amp;0&amp; 0 \\
   3&amp;14&amp;21&amp;0&amp;0\\
   8&amp;9&amp;11&amp;0&amp;0\\
   0&amp;0&amp;0&amp;11&amp;8\\
   0&amp;0&amp;0&amp;3&amp;7\\
  \end{matrix}
  \right]
  =
  \left[
\begin{matrix}
  100 \\
   355\\
   539\\
   95\\
   151\\
  \end{matrix}
  \right]^{T}
  (mod26)=
  \left[
\begin{matrix}
  22 \\
   17\\
   19\\
   17\\
   21\\
  \end{matrix}
  \right]^{T}
  &lt;=&gt;
  \left[
  \begin{matrix}
  W\\
  R\\
  T\\
  R\\
  V
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;
解密秘钥：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
K^{-1}=
\left[
\begin{matrix}
21&amp;15&amp;17&amp;0&amp;0\\
21&amp;2&amp;16&amp;0&amp;0\\
25&amp;4&amp;3&amp;0&amp;0\\
0&amp;0&amp;0&amp;7&amp;18\\
0&amp;0&amp;0&amp;23&amp;11
\end{matrix}
\right] %]]&gt;&lt;/script&gt;
解密：
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
p=(22,17,19,17,21)
\left [
\begin{matrix}
21&amp;15&amp;17&amp;0&amp;0\\
21&amp;2&amp;16&amp;0&amp;0\\
25&amp;4&amp;3&amp;0&amp;0\\
0&amp;0&amp;0&amp;7&amp;18\\
0&amp;0&amp;0&amp;23&amp;11
\end{matrix}
\right ]
=
\left [
\begin{matrix}
1328\\
440\\
703\\
602\\
537
\end{matrix}
\right ]^{T}
(mod 26)
=
\left[
\begin{matrix}
2\\
24\\
1\\
4\\
17
\end{matrix}
\right ]
&lt;=&gt;
\left[
\begin{matrix}
c\\y\\
b\\
e\\
r
\end{matrix}
\right]^{T} %]]&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&quot;分组密码&quot;&gt;分组密码&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;分组密码（block cipher）是现代密码学中的重要体制之一，也是应用最广泛、影响最大的一种密码体制。其主要任务是提供数据保密性，也可以用在伪随机数生成器、序列密码、认证码和哈希函数的构造&lt;/p&gt;

  &lt;p&gt;分组密码又称为对称密码，具有加解密速度快、安全性好的特点。得到许多密码芯片的支持，在许多研究和应用领域中得到了广泛的应用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/分组密码流程.png&quot; alt=&quot;分组密码流程&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;扩散混乱&quot;&gt;扩散＆混乱&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;扩散：打乱明文，每一位比特明文的变化尽可能影响输出的密文序列比特，使得明文和密文之间的统计关系尽量复杂，即从密文不能获得明文的统计特性&lt;/li&gt;
  &lt;li&gt;混乱：打乱明文，加密过程中，明文，密文，秘钥间的关系尽可能复制，使从密文中不能获得密钥的任何统计特性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;feiste网络&quot;&gt;Feiste网络&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;用简单算法的乘积来近似表达复杂的替代变换&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加解密相似，只需要一个逆转的密钥编排算法，加解密算法部分完全一致&lt;/li&gt;
  &lt;li&gt;轮函数不必可逆&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;原理&quot;&gt;原理&lt;/h3&gt;

&lt;p&gt;F表示轮函数,Ki表示每一轮的子秘钥&lt;/p&gt;

&lt;h4 id=&quot;加密&quot;&gt;加密&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;i表示轮数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;将明文分割为左右两部分(L_{0},R_{0})\\
L_{i+1} = R_{i}\\
R_{i+1} = L_{i}\bigoplus F(R_{i},k_{i})\\&lt;/script&gt;

&lt;h4 id=&quot;解密&quot;&gt;解密&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;(i=n,n-1,…0)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;R_{i}  = L_{i+1}\\
l_{i} = R_{i+1}\bigoplus(L_{i+1},k_{i})\\
(L_{0},R_{0})为解密后的明文&lt;/script&gt;

&lt;h2 id=&quot;雪崩效应&quot;&gt;雪崩效应&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/雪崩效应.png&quot; alt=&quot;雪崩效应&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;sp网络&quot;&gt;SP网络&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/sp网络.png&quot; alt=&quot;sp网络&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SP网络具有雪崩效应&lt;/p&gt;

&lt;h2 id=&quot;子秘钥生成方法&quot;&gt;子秘钥生成方法&lt;/h2&gt;

&lt;p&gt;子秘钥生成是迭代分组算法的一个重要部分，轮函数Ｆ的功能是在子秘钥的参与和控制下实现的&lt;/p&gt;

&lt;p&gt;子秘钥评价指标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;简单，速度快&lt;/li&gt;
  &lt;li&gt;种子秘钥的所有比特对每个子秘钥比特的影响大致相同&lt;/li&gt;
  &lt;li&gt;没有弱秘钥&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;轮函数ｆ设计准则&quot;&gt;轮函数Ｆ设计准则&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;非线性&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;依赖Ｓ盒&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可逆性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;雪崩效应&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;des加密&quot;&gt;DES加密&lt;/h1&gt;

&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;分组加密：明文密文为64位分组长度&lt;/li&gt;
  &lt;li&gt;密码算法：同一个算法&lt;/li&gt;
  &lt;li&gt;密钥长度：56位，存在弱秘钥，但是可以避开&lt;/li&gt;
  &lt;li&gt;采用混乱和扩散组合,每个组先代换后置换，共16轮&lt;/li&gt;
  &lt;li&gt;易于实现,速度快&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;流程&quot;&gt;流程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/des加密.png&quot; alt=&quot;des加密&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;初始置换ip&quot;&gt;初始置换(IP)&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/初始置换.png&quot; alt=&quot;初始置换&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;轮变换&quot;&gt;轮变换&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/轮变换.png&quot; alt=&quot;轮变换&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;f函数&quot;&gt;F函数&lt;/h2&gt;

&lt;h3 id=&quot;扩展置换&quot;&gt;扩展置换&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;又叫E盒&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;扩展置置换目标是IP置换后获得的右半部分R0，将32位输入扩展为48位(分为4位×8组)输出。&lt;/p&gt;

&lt;p&gt;扩展置换目的有两个：生成与密钥相同长度的数据以进行异或运算；提供更长的结果，在后续的替代运算中可以进行压缩。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/E盒.png&quot; alt=&quot;E盒&quot; /&gt;&lt;/p&gt;

&lt;p&gt;表中的数字代表位，两列黄色数据是扩展的数据，可以看出，扩展的数据是从相邻两组分别取靠近的一位，4位变为6位。靠近32位的位为1，靠近1位的位为32。表中第二行的4取自上组中的末位，9取自下组中的首位。&lt;/p&gt;

&lt;h3 id=&quot;秘钥加&quot;&gt;秘钥加&lt;/h3&gt;

&lt;p&gt;E扩展输出的49位与48位子秘钥逐位异或,输出48位数据&lt;/p&gt;

&lt;h3 id=&quot;代换盒&quot;&gt;代换盒&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;S盒&lt;/p&gt;

  &lt;p&gt;目的:非线性变换&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;压缩后的密钥与扩展分组异或以后得到48位的数据，将这个数据送人S盒，进行替代运算。替代由8个不同的S盒完成，每个S盒有6位输入4位输出。48位输入分为8个6位的分组，一个分组对应一个S盒，对应的S盒对各组进行代替操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/S盒.png&quot; alt=&quot;S盒&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　一个S盒就是一个4行16列的表，盒中的每一项都是一个4位的数。S盒的6个输入确定了其对应的输出在哪一行哪一列，输入的高低两位做为行数H，中间四位做为列数L，在S-BOX中查找第H行L列对应的数据(&amp;lt;32)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;S盒代替时DES算法的关键步骤，所有的其他的运算都是线性的，易于分析，而S盒是非线性的，相比于其他步骤，提供了更好安全性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;p盒置换&quot;&gt;P盒置换&lt;/h3&gt;

&lt;p&gt;S盒代替运算的32位输出按照P盒进行置换。该置换把输入的每位映射到输出位，任何一位不能被映射两次，也不能被略去,映射规则如下表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;16&lt;/th&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;th&gt;20&lt;/th&gt;
      &lt;th&gt;21&lt;/th&gt;
      &lt;th&gt;29&lt;/th&gt;
      &lt;th&gt;12&lt;/th&gt;
      &lt;th&gt;28&lt;/th&gt;
      &lt;th&gt;17&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;表中的数字代表原数据中此位置的数据在新数据中的位置，即原数据块的第16位放到新数据的第1位，第7位放到第2位，……依此类推，第25位放到第32位。&lt;/p&gt;

&lt;p&gt;例如0x10A1 0001进行P盒置换后变为0x8000 0886。&lt;/p&gt;

&lt;p&gt;最后，P盒置换的结果与最初的64位分组左半部分L0异或，然后左、右半部分交换，接着开始另一轮。&lt;/p&gt;

&lt;h2 id=&quot;ip-1末置换&quot;&gt;IP-1末置换&lt;/h2&gt;

&lt;p&gt;末置换是初始置换的逆过程，DES最后一轮后，左、右两半部分并未进行交换，而是两部分合并形成一个分组做为末置换的输入。末置换规则如下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;40&lt;/th&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;th&gt;48&lt;/th&gt;
      &lt;th&gt;16&lt;/th&gt;
      &lt;th&gt;56&lt;/th&gt;
      &lt;th&gt;24&lt;/th&gt;
      &lt;th&gt;64&lt;/th&gt;
      &lt;th&gt;32&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;39&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;47&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;55&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;63&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;38&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;62&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;37&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;53&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
      &lt;td&gt;61&lt;/td&gt;
      &lt;td&gt;29&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;36&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;52&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;60&lt;/td&gt;
      &lt;td&gt;28&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;35&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;43&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;51&lt;/td&gt;
      &lt;td&gt;19&lt;/td&gt;
      &lt;td&gt;59&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;42&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;58&lt;/td&gt;
      &lt;td&gt;26&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;33&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;41&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;49&lt;/td&gt;
      &lt;td&gt;17&lt;/td&gt;
      &lt;td&gt;57&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;置换方法同上，此处省略。&lt;/p&gt;

&lt;h2 id=&quot;des安全性&quot;&gt;DES安全性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;互补性&lt;/li&gt;
  &lt;li&gt;弱秘钥&lt;/li&gt;
  &lt;li&gt;迭代轮数&lt;/li&gt;
  &lt;li&gt;秘钥长度&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3重des&quot;&gt;3重DES&lt;/h2&gt;

&lt;p&gt;优点:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;秘钥长度增加到112位或168为,有效克服穷举&lt;/li&gt;
  &lt;li&gt;相对于DES,增强了抗差分分析和线性分析&lt;/li&gt;
  &lt;li&gt;DES升级到3重DES成本低&lt;/li&gt;
  &lt;li&gt;对密码分析攻击由很强的免疫力&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不足:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;处理速度慢&lt;/li&gt;
  &lt;li&gt;秘钥长度增加了,但是明文分组的长度没有变化,任为63位,就效率和安全性与秘钥的增长不匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;des分析方法&quot;&gt;DES分析方法&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;穷举&lt;/li&gt;
  &lt;li&gt;差分分析&lt;/li&gt;
  &lt;li&gt;线性分析&lt;/li&gt;
  &lt;li&gt;积分攻击&lt;/li&gt;
  &lt;li&gt;中间相遇攻击&lt;/li&gt;
  &lt;li&gt;相关秘钥攻击&lt;/li&gt;
  &lt;li&gt;侧信道攻击&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;aes&quot;&gt;AES&lt;/h1&gt;

&lt;h2 id=&quot;aes的基本结构&quot;&gt;AES的基本结构&lt;/h2&gt;

&lt;p&gt;AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;AES&lt;/th&gt;
      &lt;th&gt;密钥长度（32位比特字)&lt;/th&gt;
      &lt;th&gt;分组长度(32位比特字)&lt;/th&gt;
      &lt;th&gt;加密轮数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AES-128&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AES-192&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AES-256&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。
AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。&lt;/p&gt;

&lt;p&gt;AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示：
&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES.png&quot; alt=&quot;AES&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在假设明文分组P为”abcdefghijklmnop”，则对应上面生成的状态矩阵图如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES1.png&quot; alt=&quot;AES1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，0x61为字符a的十六进制表示。可以看到，明文经过AES加密后，已经面目全非。&lt;/p&gt;

&lt;p&gt;类似地，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES2.jpeg&quot; alt=&quot;AES2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，设K = “abcdefghijklmnop”，则K0 = a, K15 = p, W[0] = K0 K1 K2 K3 = “abcd”。&lt;/p&gt;

&lt;p&gt;AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图也展示了AES解密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作。&lt;/p&gt;

&lt;h2 id=&quot;字节代换&quot;&gt;字节代换&lt;/h2&gt;

&lt;p&gt;AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/AES_s.png&quot; alt=&quot;AES_s&quot; /&gt;&lt;/p&gt;

&lt;p&gt;状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。状态矩阵经字节代换后的图如下：
&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/字节变换.png&quot; alt=&quot;字节变换&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;字节代换逆操作&quot;&gt;字节代换逆操作&lt;/h2&gt;

&lt;p&gt;逆字节代换也就是查逆S盒来变换,此处不展示&lt;/p&gt;

&lt;h2 id=&quot;行移位&quot;&gt;行移位&lt;/h2&gt;

&lt;p&gt;行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/行位移.jpeg&quot; alt=&quot;行位移&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;行移位的逆变换&quot;&gt;行移位的逆变换&lt;/h2&gt;

&lt;p&gt;行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节。&lt;/p&gt;

&lt;h2 id=&quot;列混合&quot;&gt;列混合&lt;/h2&gt;

&lt;p&gt;列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/列混合.png&quot; alt=&quot;列混合&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;列混合逆运算&quot;&gt;列混合逆运算&lt;/h2&gt;

&lt;p&gt;逆向列混合变换可由下图的矩阵乘法定义&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/home/admin233/Documents/verylazycat.github.io/img/列混合逆.png&quot; alt=&quot;列混合逆&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;轮秘钥加&quot;&gt;轮秘钥加&lt;/h2&gt;

&lt;p&gt;轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作&lt;/p&gt;

&lt;p&gt;轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位。&lt;/p&gt;

&lt;h2 id=&quot;秘钥扩展&quot;&gt;秘钥扩展&lt;/h2&gt;

&lt;h2 id=&quot;aes解密&quot;&gt;AES解密&lt;/h2&gt;

&lt;h1 id=&quot;hash函数&quot;&gt;Hash函数&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;消息空间到像空间的不可逆映射&lt;/p&gt;

  &lt;p&gt;像通常叫数字指纹,消息摘要,散列值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;h=H(M)&lt;/script&gt;

&lt;h2 id=&quot;性质&quot;&gt;性质&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;H可应用于&lt;code&gt;任意&lt;/code&gt;长度的消息&lt;/li&gt;
  &lt;li&gt;H输出固定长度&lt;/li&gt;
  &lt;li&gt;对于任意给定消息x,计算H(x)比较容易,用硬件和软件均可实现&lt;/li&gt;
  &lt;li&gt;单向性:对于给定散列值h,找到H(x)=h的消息x在计算上不可行&lt;/li&gt;
  &lt;li&gt;抗弱碰撞性:对于给定的消息x,找到满足y!=x且H(x)=H(y)的消息y在计算上不可行&lt;/li&gt;
  &lt;li&gt;抗强碰撞性:找到满足H(x)=H(y)的偶对(x,y)在计算上不可行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;数字签名&lt;/li&gt;
  &lt;li&gt;生成程序或文档的”数字指纹”&lt;/li&gt;
  &lt;li&gt;用于安全传输和存储口令&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;md5&quot;&gt;MD5&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;单向散列算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;功能&quot;&gt;功能&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不同的输入得到的不同的结果（唯一性）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;根据128位的输出结果不可能反推出输入的信息（不可逆）；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;算法&quot;&gt;算法&lt;/h3&gt;

&lt;h4 id=&quot;填充&quot;&gt;&lt;strong&gt;填充&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在MD5算法中，首先需要对信息进行填充，使其位长对512求余的结果等于448，&lt;strong&gt;并且填充必须进行，即使其位长对512求余的结果等于448&lt;/strong&gt;。因此，信息的位长（Bits Length）将被扩展至N*512+448，N为一个非负整数，N可以是零。&lt;/p&gt;

&lt;p&gt;填充的方法如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在这个结果后面附加一个以64位二进制表示的填充前信息长度（单位为Bit），如果二&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进制表示的填充前信息长度超过64位，则取低64位。&lt;/p&gt;

&lt;p&gt;经过这两步的处理，信息的位长=N&lt;em&gt;512+448+64=(N+1）&lt;/em&gt;512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。&lt;/p&gt;

&lt;h4 id=&quot;初始化变量&quot;&gt;&lt;strong&gt;初始化变量&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;初始的128位值为初试链接变量，这些参数用于第一轮的运算，以大端&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%AD%97%E8%8A%82%E5%BA%8F&quot;&gt;字节序&lt;/a&gt;来表示，他们分别为： A=0x01234567，B=0x89ABCDEF，C=0xFEDCBA98，D=0x76543210。&lt;/p&gt;

&lt;p&gt;（每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即大端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476）&lt;/p&gt;

&lt;h4 id=&quot;处理分组数据&quot;&gt;&lt;strong&gt;处理分组数据&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;每一分组的算法流程如下：&lt;/p&gt;

&lt;p&gt;第一分组需要将上面四个链接变量复制到另外四个变量中：A到a，B到b，C到c，D到d。从第二分组开始的变量为上一分组的运算结果，即A = a， B = b， C = c， D = d。&lt;/p&gt;

&lt;p&gt;主循环有四轮（MD4只有三轮），每轮循环都很相似。第一轮进行16次操作。每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向左&lt;strong&gt;环移&lt;/strong&gt;一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。&lt;/p&gt;

&lt;p&gt;以下是每次操作中用到的四个非线性函数（每轮一个）&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;F( X ,Y ,Z ) = ( X &amp;amp; Y )&lt;/td&gt;
      &lt;td&gt;( (~X) &amp;amp; Z )&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;G( X ,Y ,Z ) = ( X &amp;amp; Z )&lt;/td&gt;
      &lt;td&gt;( Y &amp;amp; (~Z) )&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;H( X ,Y ,Z ) =X ^ Y ^ Z&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;I( X ,Y ,Z ) =Y ^ ( X&lt;/td&gt;
      &lt;td&gt;(~Z) )&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;（&amp;amp;是与（And），&lt;/td&gt;
      &lt;td&gt;是或（Or），~是非（Not），^是异或（Xor））&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这四个函数的说明：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。&lt;/p&gt;

&lt;p&gt;F是一个逐位运算的函数。即，如果X，那么Y，否则Z。函数H是逐位奇偶操作符。&lt;/p&gt;

&lt;p&gt;假设Mj表示消息的第j个子分组（从0到15），常数ti是4294967296*abs( sin(i) ）的整数部分，i 取值从1到64，单位是弧度。（4294967296=2的32次方）&lt;/p&gt;

&lt;p&gt;现定义：&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + F(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + G(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + H(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + I(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;现定义：&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + F(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + G(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + H(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + I(b,c,d) + Mj + ti) « s)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：“«”表示循环左移位，不是左移位。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这四轮（共64步）是：&lt;/p&gt;

&lt;p&gt;第一轮&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,M0 ,7 ,0xd76aa478 )&lt;/p&gt;

&lt;p&gt;FF(d ,a ,b ,c ,M1 ,12 ,0xe8c7b756 )&lt;/p&gt;

&lt;p&gt;FF(c ,d ,a ,b ,M2 ,17 ,0x242070db )&lt;/p&gt;

&lt;p&gt;FF(b ,c ,d ,a ,M3 ,22 ,0xc1bdceee )&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,M4 ,7 ,0xf57c0faf )&lt;/p&gt;

&lt;p&gt;FF(d ,a ,b ,c ,M5 ,12 ,0x4787c62a )&lt;/p&gt;

&lt;p&gt;FF(c ,d ,a ,b ,M6 ,17 ,0xa8304613 )&lt;/p&gt;

&lt;p&gt;FF(b ,c ,d ,a ,M7 ,22 ,0xfd469501)&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,M8 ,7 ,0x698098d8 )&lt;/p&gt;

&lt;p&gt;FF(d ,a ,b ,c ,M9 ,12 ,0x8b44f7af )&lt;/p&gt;

&lt;p&gt;FF(c ,d ,a ,b ,M10 ,17 ,0xffff5bb1 )&lt;/p&gt;

&lt;p&gt;FF(b ,c ,d ,a ,M11 ,22 ,0x895cd7be )&lt;/p&gt;

&lt;p&gt;FF(a ,b ,c ,d ,M12 ,7 ,0x6b901122 )&lt;/p&gt;

&lt;p&gt;FF(d ,a ,b ,c ,M13 ,12 ,0xfd987193 )&lt;/p&gt;

&lt;p&gt;FF(c ,d ,a ,b ,M14 ,17 ,0xa679438e )&lt;/p&gt;

&lt;p&gt;FF(b ,c ,d ,a ,M15 ,22 ,0x49b40821 )&lt;/p&gt;

&lt;p&gt;第二轮&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,M1 ,5 ,0xf61e2562 )&lt;/p&gt;

&lt;p&gt;GG(d ,a ,b ,c ,M6 ,9 ,0xc040b340 )&lt;/p&gt;

&lt;p&gt;GG(c ,d ,a ,b ,M11 ,14 ,0x265e5a51 )&lt;/p&gt;

&lt;p&gt;GG(b ,c ,d ,a ,M0 ,20 ,0xe9b6c7aa )&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,M5 ,5 ,0xd62f105d )&lt;/p&gt;

&lt;p&gt;GG(d ,a ,b ,c ,M10 ,9 ,0x02441453 )&lt;/p&gt;

&lt;p&gt;GG(c ,d ,a ,b ,M15 ,14 ,0xd8a1e681 )&lt;/p&gt;

&lt;p&gt;GG(b ,c ,d ,a ,M4 ,20 ,0xe7d3fbc8 )&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,M9 ,5 ,0x21e1cde6 )&lt;/p&gt;

&lt;p&gt;GG(d ,a ,b ,c ,M14 ,9 ,0xc33707d6 )&lt;/p&gt;

&lt;p&gt;GG(c ,d ,a ,b ,M3 ,14 ,0xf4d50d87 )&lt;/p&gt;

&lt;p&gt;GG(b ,c ,d ,a ,M8 ,20 ,0x455a14ed )&lt;/p&gt;

&lt;p&gt;GG(a ,b ,c ,d ,M13 ,5 ,0xa9e3e905 )&lt;/p&gt;

&lt;p&gt;GG(d ,a ,b ,c ,M2 ,9 ,0xfcefa3f8 )&lt;/p&gt;

&lt;p&gt;GG(c ,d ,a ,b ,M7 ,14 ,0x676f02d9 )&lt;/p&gt;

&lt;p&gt;GG(b ,c ,d ,a ,M12 ,20 ,0x8d2a4c8a )&lt;/p&gt;

&lt;p&gt;第三轮&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,M5 ,4 ,0xfffa3942 )&lt;/p&gt;

&lt;p&gt;HH(d ,a ,b ,c ,M8 ,11 ,0x8771f681 )&lt;/p&gt;

&lt;p&gt;HH(c ,d ,a ,b ,M11 ,16 ,0x6d9d6122 )&lt;/p&gt;

&lt;p&gt;HH(b ,c ,d ,a ,M14 ,23 ,0xfde5380c )&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,M1 ,4 ,0xa4beea44 )&lt;/p&gt;

&lt;p&gt;HH(d ,a ,b ,c ,M4 ,11 ,0x4bdecfa9 )&lt;/p&gt;

&lt;p&gt;HH(c ,d ,a ,b ,M7 ,16 ,0xf6bb4b60 )&lt;/p&gt;

&lt;p&gt;HH(b ,c ,d ,a ,M10 ,23 ,0xbebfbc70 )&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,M13 ,4 ,0x289b7ec6 )&lt;/p&gt;

&lt;p&gt;HH(d ,a ,b ,c ,M0 ,11 ,0xeaa127fa )&lt;/p&gt;

&lt;p&gt;HH(c ,d ,a ,b ,M3 ,16 ,0xd4ef3085 )&lt;/p&gt;

&lt;p&gt;HH(b ,c ,d ,a ,M6 ,23 ,0x04881d05 )&lt;/p&gt;

&lt;p&gt;HH(a ,b ,c ,d ,M9 ,4 ,0xd9d4d039 )&lt;/p&gt;

&lt;p&gt;HH(d ,a ,b ,c ,M12 ,11 ,0xe6db99e5 )&lt;/p&gt;

&lt;p&gt;HH(c ,d ,a ,b ,M15 ,16 ,0x1fa27cf8 )&lt;/p&gt;

&lt;p&gt;HH(b ,c ,d ,a ,M2 ,23 ,0xc4ac5665 )&lt;/p&gt;

&lt;p&gt;第四轮&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,M0 ,6 ,0xf4292244 )&lt;/p&gt;

&lt;p&gt;II(d ,a ,b ,c ,M7 ,10 ,0x432aff97 )&lt;/p&gt;

&lt;p&gt;II(c ,d ,a ,b ,M14 ,15 ,0xab9423a7 )&lt;/p&gt;

&lt;p&gt;II(b ,c ,d ,a ,M5 ,21 ,0xfc93a039 )&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,M12 ,6 ,0x655b59c3 )&lt;/p&gt;

&lt;p&gt;II(d ,a ,b ,c ,M3 ,10 ,0x8f0ccc92 )&lt;/p&gt;

&lt;p&gt;II(c ,d ,a ,b ,M10 ,15 ,0xffeff47d )&lt;/p&gt;

&lt;p&gt;II(b ,c ,d ,a ,M1 ,21 ,0x85845dd1 )&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,M8 ,6 ,0x6fa87e4f )&lt;/p&gt;

&lt;p&gt;II(d ,a ,b ,c ,M15 ,10 ,0xfe2ce6e0 )&lt;/p&gt;

&lt;p&gt;II(c ,d ,a ,b ,M6 ,15 ,0xa3014314 )&lt;/p&gt;

&lt;p&gt;II(b ,c ,d ,a ,M13 ,21 ,0x4e0811a1 )&lt;/p&gt;

&lt;p&gt;II(a ,b ,c ,d ,M4 ,6 ,0xf7537e82 )&lt;/p&gt;

&lt;p&gt;II(d ,a ,b ,c ,M11 ,10 ,0xbd3af235 )&lt;/p&gt;

&lt;p&gt;II(c ,d ,a ,b ,M2 ,15 ,0x2ad7d2bb )&lt;/p&gt;

&lt;p&gt;II(b ,c ,d ,a ,M9 ,21 ,0xeb86d391 )&lt;/p&gt;

&lt;p&gt;所有这些完成之后，将a、b、c、d分别在原来基础上再加上A、B、C、D。&lt;/p&gt;

&lt;p&gt;即a = a + A，b = b + B，c = c + C，d = d + D&lt;/p&gt;

&lt;p&gt;然后用下一分组数据继续运行以上算法。&lt;/p&gt;

&lt;h4 id=&quot;输出&quot;&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;最后的输出是a、b、c和d的级联。&lt;/p&gt;

&lt;p&gt;当你按照我上面所说的方法实现MD5算法以后，你可以用以下几个信息对你做出来的程序作一个简单的测试，看看程序有没有错误。&lt;/p&gt;

&lt;p&gt;MD5 (“”) = d41d8cd98f00b204e9800998ecf8427e&lt;/p&gt;

&lt;p&gt;MD5 (“a”) = 0cc175b9c0f1b6a831c399e269772661&lt;/p&gt;

&lt;p&gt;MD5 (“abc”) = 900150983cd24fb0d6963f7d28e17f72&lt;/p&gt;

&lt;p&gt;MD5 (“message digest”) = f96b697d7cb7938d525a2f31aaf161d0&lt;/p&gt;

&lt;p&gt;MD5 (“abcdefghijklmnopqrstuvwxyz”) = c3fcd3d76192e4007dfb496cca67e13b&lt;/p&gt;

&lt;p&gt;MD5 (“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz”) =&lt;/p&gt;

&lt;p&gt;f29939a25efabaef3b87e2cbfe641315&lt;/p&gt;

&lt;p&gt;MD5 (“8a683566bcc7801226b3d8b0cf35fd97”) =cf2cb5c89c5e5eeebef4a76becddfcfd&lt;/p&gt;

&lt;p&gt;MD5加密字符串实例&lt;/p&gt;

&lt;p&gt;现以字符串“jklmn”为例。&lt;/p&gt;

&lt;p&gt;该字符串在内存中表示为：6A 6B 6C 6D 6E（从左到右为低地址到高地址，后同），信息长度为40 bits， 即0x28。&lt;/p&gt;

&lt;p&gt;对其填充，填充至448位，即56字节。结果为：&lt;/p&gt;

&lt;p&gt;6A 6B 6C 6D 6E 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&lt;/p&gt;

&lt;p&gt;剩下64位，即8字节填充填充前信息位长，按小端字节序填充剩下的8字节，结果为。&lt;/p&gt;

&lt;p&gt;6A 6B 6C 6D 6E 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 28 00 00 00 00 00 00 00&lt;/p&gt;

&lt;p&gt;（64字节，512 bits）&lt;/p&gt;

&lt;p&gt;初始化A、B、C、D四个变量。&lt;/p&gt;

&lt;p&gt;将这64字节填充后数据分成16个小组（程序中对应为16个数组），即：&lt;/p&gt;

&lt;p&gt;M0：6A 6B 6C 6D （这是内存中的顺序，按照小端字节序原则，对应数组M(0)的值为0x6D6C6B6A，下同）&lt;/p&gt;

&lt;p&gt;M1：6E 80 00 00&lt;/p&gt;

&lt;p&gt;M2：00 00 00 00&lt;/p&gt;

&lt;p&gt;…..&lt;/p&gt;

&lt;p&gt;M14：28 00 00 00&lt;/p&gt;

&lt;p&gt;M15：00 00 00 00&lt;/p&gt;

&lt;p&gt;经过“&lt;strong&gt;3. 分组数据处理&lt;/strong&gt;”后，a、b、c、d值分别为0xD8523F60、0x837E0144、0x517726CA、0x1BB6E5FE&lt;/p&gt;

&lt;p&gt;在内存中为a：60 3F 52 D8&lt;/p&gt;

&lt;p&gt;b：44 01 7E 83&lt;/p&gt;

&lt;p&gt;c：CA 26 77 51&lt;/p&gt;

&lt;p&gt;d：FE E5 B6 1B&lt;/p&gt;

&lt;p&gt;a、b、c、d按内存顺序输出即为最终结果：603F52D844017E83CA267751FEE5B61B。这就是字符串“jklmn”的MD5值。&lt;/p&gt;

&lt;h2 id=&quot;sha1&quot;&gt;SHA1&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;MD5算法得出的MD5值长度为16个字节（8&lt;em&gt;16=128位） 
SHA1算法得出的SHA1值长度为20个字节（8&lt;/em&gt;20=160位）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;算法-1&quot;&gt;算法&lt;/h3&gt;

&lt;h4 id=&quot;填充信息&quot;&gt;填充信息&lt;/h4&gt;

&lt;p&gt;和MD5算法类似，对信息的第一步也是填充信息直至满足条件。&lt;/p&gt;

&lt;p&gt;填充的过程如下：
1.先判断文件（消息）的大小（长度） mod 512 == 448 mod 512 ，就是大小（长度）对512求余等于448。（这里的512、448是“位”为单位，转成“字节”就是64、56，即mod 64 == 56 mod 64）&lt;/p&gt;

&lt;p&gt;2.如果大小（长度）满足 mod 512 == 448 mod 512，就在文件（消息）的末尾处添加64位（8字节）的值，值的内容是原消息的长度（以位为单位）&lt;/p&gt;

&lt;p&gt;3.如果大小（长度）不满足要求，就执行以下操作：
（1）填充1个1
（2）填充0，直到满足满足过程的第一步。&lt;/p&gt;

&lt;p&gt;注意：这里是以位为单位，假如是以字节为单位，第一个填充的是0x80（1000 0000），然后就填0x0
举例：消息内容为“gnubd”，就能得到以下内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-reStructuredText&quot;&gt;67 6E 62 75 64 80 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 28 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还需要注意到的是最后原消息的长度是以大端存储的方式存到内存中的，这里与MD5的存储是有区别的。&lt;/p&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;h1 id=&quot;消息认证&quot;&gt;消息认证&lt;/h1&gt;

&lt;h2 id=&quot;作用目的&quot;&gt;作用&amp;amp;目的&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;验证信息来源的真实性&lt;/li&gt;
  &lt;li&gt;验证消息的完整性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;认证函数实现&quot;&gt;认证函数实现&lt;/h2&gt;

&lt;h3 id=&quot;消息认证码mac&quot;&gt;消息认证码(MAC)&lt;/h3&gt;

&lt;p&gt;消息认证码的输入包括任意长度的消息和一个发送者与接收者之间的共享的密钥，它可以输出固定长度的数据，这个数据成为&lt;strong&gt;MAC值&lt;/strong&gt;。
 根据任意长度的雄性输出固定长度的数据，这一点和散列函数很类似。但是单向散列函数中计算散列值时不需要密钥，相对地，消息认证码中则需要使用发送者与接收者之间的共享密钥。
 要计算MAC必须持有共享密钥，没有共享密钥的人就无法计算MAC值，消息认证正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生1比特的变化，MAC值一会产生变化，消息认证码正是利用这一性质来确认完整性的。
 &lt;strong&gt;消息认证码是一种与密钥相关联的单向散列函数&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;基于des消息认证码&quot;&gt;基于DES消息认证码&lt;/h3&gt;

&lt;h3 id=&quot;基于hash消息认证码&quot;&gt;基于Hash消息认证码&lt;/h3&gt;

&lt;h4 id=&quot;hmac算法&quot;&gt;HMAC算法&lt;/h4&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;h1 id=&quot;公钥密码&quot;&gt;公钥密码&lt;/h1&gt;

&lt;h2 id=&quot;提出原因&quot;&gt;提出原因&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;秘钥分发问题&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;密钥更新共享的方式有以下几种类型：
A 选择密钥并手工传递给 B,在这样的一个情境中，A 和 B都是确实存在且可信的。而在互联网环境中，A 和 B 之间要建立信任关系，会很困难。&lt;/li&gt;
  &lt;li&gt;第三方 C 选择密钥分别手工传递给 A , B,在复杂的互联网环境中，C 如何将密钥安全的分发给 A和B，要保证其安全性也很困难。&lt;/li&gt;
  &lt;li&gt;用 A , B 原有共享密钥传送新密钥,这是一种相对安全的方式，但是互联网环境中需要A和B要有一份复杂的密钥交换协议，才可以实现新密钥的共享。&lt;/li&gt;
  &lt;li&gt;与 A , B 分别有共享密钥的第三方 C 传送新密钥给 A 和（或） B,此过程也需要一份复杂的密钥交换协议来确保C能够将密钥安全的分发给 A 和 B。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;秘钥管理问题&lt;/p&gt;

    &lt;p&gt;除了密钥的更新问题困难以外，还有对密钥管理的问题仍然存在。在对称密码算法中必须要对密钥进行管理，但是对密钥的管理又十分的困难。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;例如：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;  N 个用户集需要 N(N-1)/2 个共享密钥，当用户量增大时，密钥空间急剧增大。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;n = 100 时，  C(100,2) = 4,995&lt;/li&gt;
      &lt;li&gt;n = 5000时， C(5000,2) = 12,497,500&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数字签名问题&lt;/p&gt;

    &lt;p&gt;传统加密算法无法实现抗抵赖的需求。在对称加密算法中，共享的密钥是通信双方都知道的 ，所以无法使用共享的密钥来对对方的身份进行确认。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;单向陷门函数&quot;&gt;单向陷门函数&lt;/h2&gt;

&lt;p&gt;单向陷门函数可以被定义为如下函数f：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给出f的定义域中的任意元素x,  f(x)的计算是容易的；&lt;/li&gt;
  &lt;li&gt;给出y=f (x)中的y要计算x时，若知道设计函数f时结合进去的某种信息（该信息称为陷门），则容易计算；若不知道该信息，则难以计算。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前人们主要是基于如下的数学上的困难问题来设计单向函数和公钥密码体制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大整数分解问题(如公钥密码体制RSA)；&lt;/li&gt;
  &lt;li&gt;有限域上的离散对数问题(如公钥密码体制ElGamal):&lt;/li&gt;
  &lt;li&gt;椭圆曲线上的离散对数问题(如公钥密码体制ECC)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;为什么要用公钥密码&quot;&gt;为什么要用公钥密码&lt;/h2&gt;

&lt;p&gt;（1） 机密性的实现
发送方用接收方的公钥加密消息，接收方用自己的私钥来解密。
（2） 数字签名
发送方用自己的私钥来签名消息，接收方通过发送方对应的公钥来鉴别消息，并且发送方不能对自己的签名进行否认。
（3） 密钥分发和协商
发送方和接收方基于公钥密码系统容易实现在公开信道上的大规模的密钥分发和协商。&lt;/p&gt;

&lt;h2 id=&quot;dh秘钥交换&quot;&gt;DH秘钥交换&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;DH，全称为“Diffie-Hellman”，这是一种确保共享KEY安全穿越不安全网络的方法，换句话说就是密钥一致协议，由公开密钥密码体制的奠基人Diffie和Hellman所提出的一种思想&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的说就是允许两名用户在公开媒体上交换信息以生成“一致”的、可以共享的密钥。也就是由甲方产出一对密钥（公钥、私钥），乙方依照甲方公钥产生乙方密钥对（公钥、私钥）。它可以让双方在完全没有对方任何预先信息的条件下通过不安全信道建立起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。&lt;/p&gt;

&lt;h3 id=&quot;dh密钥交换模型分析&quot;&gt;DH密钥交换模型分析&lt;/h3&gt;

&lt;p&gt;我们还是以甲乙双方发送数据为模型进行分析&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;甲方（消息发送方，下同）构建密钥对（公钥+私钥），甲方公布公钥给乙方（消息接收方，下同）&lt;/li&gt;
  &lt;li&gt;乙方以甲方发送过来的公钥作为参数构造密钥对（公钥+私钥），将构造出来的公钥公布给甲方&lt;/li&gt;
  &lt;li&gt;甲方用“甲方的私钥+乙方的公钥”构造本地密钥&lt;/li&gt;
  &lt;li&gt;乙方用“乙方的私钥+甲方的公钥”构造本地的密钥&lt;/li&gt;
  &lt;li&gt;这个时候，&lt;strong&gt;甲乙两方本地新构造出来的密钥应该一样&lt;/strong&gt;，甲乙双方可以通过本地密钥进行数据的加密和解密&lt;/li&gt;
  &lt;li&gt;然后就可以&lt;strong&gt;使用AES这类对称加密算法进行数据的安全传送&lt;/strong&gt;了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dh数学原理&quot;&gt;DH数学原理&lt;/h3&gt;

&lt;p&gt;有两个全局公开的参数，一个素数p和一个整数g，g是p的一个原根。&lt;/p&gt;

&lt;p&gt;服务端的私钥和公钥分别是a和A，客户端的私钥和公钥分别是b和B；&lt;/p&gt;

&lt;p&gt;服务端根据a、p、g，可以计算出公钥A；&lt;/p&gt;

&lt;p&gt;服务端将g, p, A明文传送给客户端，客户端可以计算自己的公钥B，以及共享密钥K；&lt;/p&gt;

&lt;p&gt;客户端将B明文发送给服务端，服务端也可以计算出共享密钥K。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/DH.png&quot; alt=&quot;DH&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;安全问题-中间人攻击&quot;&gt;安全问题-中间人攻击&lt;/h3&gt;

&lt;p&gt;在最初的描述中，迪菲-赫尔曼密钥交换本身并没有提供通讯双方的身份验证服务，因此它很容易受到中间人攻击。 
一个中间人“丙”在信道的中央进行两次迪菲－赫尔曼密钥交换，一次和甲，另一次和乙，就能够成功的向甲假装自己是乙，反之亦然。
而攻击者可以解密（读取和存储）任何一个人的信息并重新加密信息，然后传递给另一个人。因此通常都需要一个能够验证通讯双方身份的机制来防止这类攻击。
&lt;strong&gt;有很多种安全身份验证解决方案使用到了迪菲－赫尔曼密钥交换。例如当甲和乙共有一个公钥基础设施时，可以将他们的返回密钥进行签名。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;rsa&quot;&gt;RSA&lt;/h2&gt;

&lt;p&gt;RSA公钥算法是由 MIT (麻省理工学院, Massachusetts Institute of Technology) 的Rivest, Shamir和Adleman在1978年提出来的。RSA方案是被最广泛接受并实现的通用公开密钥密码算法，目前已成为公钥密码的国际标准。该算法的数学基础是初等数论中的欧拉定理，其安全性建立在大整数因子分解的困难性之上。&lt;/p&gt;

&lt;h3 id=&quot;密钥的生成&quot;&gt;密钥的生成&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;选择两个大素数 &lt;code&gt;p&lt;/code&gt;，&lt;code&gt;q&lt;/code&gt;，（p，q为互异素数，需要保密）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;n= p *q\\
\Phi(n)=(p-1)*(q-1)&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;选择整数 &lt;code&gt;e&lt;/code&gt; 使&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
gcd(\phi(n),e)=1\\
1 &lt; e &lt;\phi(n) %]]&gt;&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;计算d&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;d*e=1mod\phi(n)&lt;/script&gt;

&lt;p&gt;得到：公钥 为&lt;code&gt;{e,n}&lt;/code&gt;； 私钥为&lt;code&gt;{d}&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;加密-1&quot;&gt;加密&lt;/h3&gt;

&lt;p&gt;明文:M&lt;/p&gt;

&lt;p&gt;密文:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
接受(e,n)\\
M分组,长度问L(L&lt;log_{2}n)M=m_{1}m_{2}...\\
加密算法:c_{i}=m_{i}^{e}(modn) %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;解密-1&quot;&gt;解密&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;m_{i}=c^{d}_{i}mod(n)&lt;/script&gt;

&lt;h3 id=&quot;安全性&quot;&gt;安全性&lt;/h3&gt;

&lt;h4 id=&quot;攻击方式&quot;&gt;攻击方式&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;因子分解&lt;/p&gt;

    &lt;p&gt;​	分解n&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;针对参数攻击&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;共模攻击&lt;/li&gt;
      &lt;li&gt;低指数攻击&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;elgamal&quot;&gt;ElGamal&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;该算法安全性依赖于计算有限域上离散对数难题：求解离散对数(目前)是困难的,其逆运算指数运算简单。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;秘钥生成&quot;&gt;秘钥生成&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;随机选取一个满足安全要求的大素数p,生成有限域z_{p}的一个生成元g&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选取一个随机数x(1&amp;lt;x&amp;lt;p-1),计算:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;y=g^{x}(modp)&lt;/script&gt;

    &lt;p&gt;&lt;code&gt;公钥为(y,g,p),私钥为x&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;加密-2&quot;&gt;加密&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;接受(y,g,p)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;消息m分组为长度为L(L&amp;lt;log_{2}p)的消息分组m=m_{1}m_{2}….&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对第i块消息(1&amp;lt;=i&amp;lt;=t)随机选择整数r_{i},1&amp;lt;r_{i}&amp;lt;p-1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
c_{i}=g^{r_{i}}(modp)\\
c^{'}_{i}=m_{i}y^{r_{i}}(modp)(1&lt;=i&lt;t) %]]&gt;&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将密文C=(c_{i},c^{‘}_{1})…..发给接受方&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;解密-2&quot;&gt;解密&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;接受密文&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计算:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
m_{i}=(c^{'}_{i}/c^{x}_{i})(mod p)\\
(1&lt;=i&lt;=t) %]]&gt;&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;得到明文:&lt;/p&gt;

    &lt;p&gt;m=m1m2…&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;安全性-1&quot;&gt;安全性&lt;/h3&gt;

&lt;h4 id=&quot;小步大步算法&quot;&gt;小步大步算法&lt;/h4&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;h4 id=&quot;指数积分法&quot;&gt;指数积分法&lt;/h4&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;h2 id=&quot;椭圆曲线公钥加密&quot;&gt;椭圆曲线公钥加密&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。据研究，160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一般情况下，椭圆曲线可用下列方程式来表示，其中a,b,c,d为系数。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E:y^2=ax^3+ bx^2+c^x+d&lt;/script&gt;

&lt;h3 id=&quot;椭圆曲线的运算规则&quot;&gt;椭圆曲线的运算规则&lt;/h3&gt;

&lt;h3 id=&quot;加法&quot;&gt;加法&lt;/h3&gt;

&lt;p&gt;过曲线上的两点A、B画一条直线，找到直线与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A+B，即为加法。如下图所示：A + B = C&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/加法.png&quot; alt=&quot;加法&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;二倍运算&quot;&gt;二倍运算&lt;/h3&gt;

&lt;p&gt;上述方法无法解释A + A，即两点重合的情况。因此在这种情况下，将椭圆曲线在A点的切线，与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A + A，即2A，即为二倍运算。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2倍.png&quot; alt=&quot;2倍&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;正负取反&quot;&gt;正负取反&lt;/h3&gt;

&lt;p&gt;将A关于x轴对称位置的点定义为-A，即椭圆曲线的正负取反运算。&lt;/p&gt;

&lt;h3 id=&quot;无穷远点&quot;&gt;无穷远点&lt;/h3&gt;

&lt;p&gt;如果将A与-A相加，过A与-A的直线平行于y轴，可以认为直线与椭圆曲线相交于无穷远点。&lt;/p&gt;

&lt;p&gt;综上，定义了A+B、2A运算，因此给定椭圆曲线的某一点G，可以求出2G、3G（即G + 2G）、4G……。即：当给定G点时，已知x，求xG点并不困难。反之，已知xG点，求x则非常困难。此即为椭圆曲线加密算法背后的数学原理。&lt;/p&gt;

&lt;p&gt;….&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;具体算法参考书籍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;对称密码体制vs公钥密码体制&quot;&gt;对称密码体制Vs公钥密码体制&lt;/h2&gt;

&lt;p&gt;对称密码体制的缺陷：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 密钥分配问题：通信双方要进行加密通信，需要通过秘密的安全信道协商加密密钥，而这种安全信道可能很难实现
 密钥管理问题：在有多个用户的网络中，任何两个用户之间都需要有共享的密钥，当网络中的用户n很大时，需要管理的密钥数目非常大，为n(n-1)/2
没有签名功能：当主体A收到主体B的电子文挡(电子数据)时，无法向第三方证明此电子文档确实来源于B。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公钥密码体制重点考察三个领域的问题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;密钥交换：通信双方交换会话密钥，以加密通信双方后续连接所传输的信息。每次逻辑连接使用一把新的会话密钥，用完就丢弃。
通信保密：将公钥作为加密密钥，私钥作为解密密钥，通信双方不需要交换密钥就可以实现保密通信。
数字签名：将私钥作为加密密钥，公钥作为解密密钥，可实现由一个用户对数据加密而使多个用户解读。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在公钥密码体制以前的整个密码学史中，所有的密码算法，包括古典密码和现代密码，都是基于替换和置换这两个基本工具。而公钥密码体制则为密码学的发展提供了新的理论和技术基础， 一方面公钥密码算法的基本工具不再是代换和置换，而是数学函数； 另一方面公钥密码算法是以非对称的形式使用两个密钥，两个密钥的使用对保密性、密钥分配、签名、认证等都有着深刻的意义。&lt;/p&gt;

&lt;p&gt;公钥算法加密解密速度慢。误区：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;公开密钥密码算法更安全
公开密钥密码使对称密钥密码过时了 # 数字签名
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;数字签名解决的问题&quot;&gt;数字签名解决的问题&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;A发送消息给B：A（不可抵赖）——————&amp;gt;B（不可伪造）（不可重用）
(1)不可抵赖     (假如：A可以否认发过该消息，B无法证明A确实发了该消息)
(2)不可伪造 	    (假如：B伪造一个不同的消息，但声称是从A收到的）
(3)不可重用		(假如：签名没有和消息绑定)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;安全模型性质&quot;&gt;安全模型,性质&lt;/h2&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;h2 id=&quot;rsa签名算法以及存在的安全问题&quot;&gt;RSA签名算法以及存在的安全问题&lt;/h2&gt;

&lt;p&gt;如果不使用HASH函数&lt;/p&gt;

&lt;p&gt;1.（存在性伪造）使用“已知消息攻击”
利用RSA的乘法特性，可以进行如下攻击
假设 y1=sigk(m1)和y2=sigk(m2) 是签名者曾经签署的有效签名，
那么 verk (m1m2 mod n, y1y2 mod n) = true&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;（选择性伪造）利用“选择消息攻击”
假设攻击者要对消息 m 伪造一个签名，m=m1m2mod n。
假设攻击者能请求签名者为 m1 和 m2 签名(结果分别为y1和y2)，
那么， y1 y2 mod n 就是消息 m 的有效签名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对抗攻击的方法：使用HASH函数
私钥签名，公钥验证&lt;/p&gt;

&lt;h2 id=&quot;elgamal签名算法以及存在的安全问题&quot;&gt;ElGamal签名算法以及存在的安全问题&lt;/h2&gt;

&lt;h2 id=&quot;特殊的签名算法以及适应的应用场景&quot;&gt;特殊的签名算法以及适应的应用场景&lt;/h2&gt;

&lt;h1 id=&quot;密码协议&quot;&gt;密码协议&lt;/h1&gt;

&lt;h1 id=&quot;秘钥管理&quot;&gt;秘钥管理&lt;/h1&gt;

&lt;h2 id=&quot;原则&quot;&gt;原则&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;区分秘钥管理的策略和机制&lt;/li&gt;
  &lt;li&gt;完全安全原则&lt;/li&gt;
  &lt;li&gt;最小权利原则&lt;/li&gt;
  &lt;li&gt;责任分离原则&lt;/li&gt;
  &lt;li&gt;秘钥分级原则&lt;/li&gt;
  &lt;li&gt;秘钥更换原则&lt;/li&gt;
  &lt;li&gt;秘钥有足够长度&lt;/li&gt;
  &lt;li&gt;密码体制不同,秘钥管理也不同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;几类秘钥作用&quot;&gt;几类秘钥作用&lt;/h2&gt;</content><author><name></name></author><category term="安全" /><summary type="html">[toc] 基础概念</summary></entry><entry><title type="html">IP报文</title><link href="http://localhost:4000/_posts/2020-07-18-IP%E6%8A%A5%E6%96%87/" rel="alternate" type="text/html" title="IP报文" /><published>2020-07-18T00:00:00-04:00</published><updated>2020-07-18T00:00:00-04:00</updated><id>http://localhost:4000/_posts/IP%E6%8A%A5%E6%96%87</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-18-IP%E6%8A%A5%E6%96%87/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;p&gt;IP报文是在网络层传输的数据单元，也叫IP数据报&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/IP报文.png&quot; alt=&quot;IP报文&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;版本：IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首部长度：IP报头的长度。固定部分的长度（20字节）和可变部分的长度之和。共占4位。最大为1111，即10进制的15，代表IP报头的最大长度可以为15个32bits（4字节），也就是最长可为15*4=60字节，除去固定部分的长度20字节，可变部分的长度最大为40字节。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务类型：Type Of Service。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;总长度：IP报文的总长度。报头的长度和数据部分的长度之和。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标识：唯一的标识主机发送的每一分数据报。通常每发送一个报文，它的值加一。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标志：共3位。R、DF、MF三位。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生存时间：IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为0时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定，当前值为 64。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;协议：指出IP报文携带的数据使用的是那种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程（不同的协议有专门不同的进程处理）。和端口号类似，此处采用协议号，TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首部校验和：计算IP头部的校验和，检查IP报头的完整性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;源IP地址：标识IP数据报的源端设备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目的IP地址：标识IP数据报的目的地址。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="计算机网络" /><summary type="html">[toc]</summary></entry><entry><title type="html">jvm总结</title><link href="http://localhost:4000/_posts/2020-07-17-jvm%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="jvm总结" /><published>2020-07-17T00:00:00-04:00</published><updated>2020-07-17T00:00:00-04:00</updated><id>http://localhost:4000/_posts/jvm%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/_posts/2020-07-17-jvm%E6%80%BB%E7%BB%93/">&lt;p&gt;[toc]&lt;/p&gt;

&lt;h1 id=&quot;jvm-的主要组成部分&quot;&gt;JVM 的主要组成部分&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/img/jvm.png&quot; alt=&quot;jvm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到Runtime data area中的method area。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Execution engine（执行引擎）：执行classes中的指令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作用 ：首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能&lt;/p&gt;

&lt;h1 id=&quot;java程序运行机制步骤&quot;&gt;Java程序运行机制步骤&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名为.class；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;运行字节码的工作是由解释器(java命令)来完成的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/java_run.png&quot; alt=&quot;java_run&quot; /&gt;&lt;/p&gt;

&lt;p&gt;的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构&lt;/p&gt;

&lt;h1 id=&quot;jvm-运行时数据区&quot;&gt;JVM 运行时数据区&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域&lt;/strong&gt;。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/数据区.png&quot; alt=&quot;数据区&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；&lt;/li&gt;
  &lt;li&gt;Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；&lt;/li&gt;
  &lt;li&gt;本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；&lt;/li&gt;
  &lt;li&gt;Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；&lt;/li&gt;
  &lt;li&gt;方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;深拷贝和浅拷贝&quot;&gt;深拷贝和浅拷贝&lt;/h1&gt;

&lt;p&gt;浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，&lt;/p&gt;

&lt;p&gt;深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，&lt;/p&gt;

&lt;p&gt;使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。&lt;/p&gt;

&lt;p&gt;浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。&lt;/p&gt;

&lt;p&gt;深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。&lt;/p&gt;

&lt;h1 id=&quot;堆栈区别&quot;&gt;堆栈区别&lt;/h1&gt;

&lt;h2 id=&quot;物理地址&quot;&gt;物理地址&lt;/h2&gt;

&lt;p&gt;堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）&lt;/p&gt;

&lt;p&gt;栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。&lt;/p&gt;

&lt;h2 id=&quot;内存分别&quot;&gt;内存分别&lt;/h2&gt;

&lt;p&gt;堆因为是不连续的，所以分配的内存是在&lt;code&gt;运行期&lt;/code&gt;确认的，因此大小不固定。一般堆大小远远大于栈。&lt;/p&gt;

&lt;p&gt;栈是连续的，所以分配的内存大小要在&lt;code&gt;编译期&lt;/code&gt;就确认，大小是固定的。&lt;/p&gt;

&lt;h2 id=&quot;存放的内容&quot;&gt;存放的内容&lt;/h2&gt;

&lt;p&gt;堆存放的是对象的实例和数组。因此该区更关注的是数据的存储&lt;/p&gt;

&lt;p&gt;栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;静态变量放在方法区&lt;/p&gt;

  &lt;p&gt;静态的对象还是放在堆&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;程序的可见度&quot;&gt;程序的可见度&lt;/h2&gt;

&lt;p&gt;堆对于整个应用程序都是共享、可见的。&lt;/p&gt;

&lt;p&gt;栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同&lt;/p&gt;

&lt;h1 id=&quot;hotspot虚拟机对象&quot;&gt;HotSpot虚拟机对象&lt;/h1&gt;

&lt;h2 id=&quot;对象的创建&quot;&gt;对象的创建&lt;/h2&gt;

&lt;p&gt;说到对象的创建，首先让我们看看 &lt;code&gt;Java&lt;/code&gt; 中提供的几种对象创建方式：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Header&lt;/th&gt;
      &lt;th&gt;解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;new&lt;/td&gt;
      &lt;td&gt;调用了构造函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用class的newInstance&lt;/td&gt;
      &lt;td&gt;调用了构造函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用constructor类的newInstance&lt;/td&gt;
      &lt;td&gt;调用了构造函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用clone&lt;/td&gt;
      &lt;td&gt;没有调用构造函数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;使用反序列化&lt;/td&gt;
      &lt;td&gt;没有调用构造函数&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对象创建的主要流程:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;new Classs&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;类是否加载&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分配内存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发处理&lt;/p&gt;

    &lt;p&gt;CAS同步处理或者本地线程分配缓存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初始化&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;将分配的内存空间都初始化为0&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;init方法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虚拟机遇到一条new指令时，先检查常量池是否已经加载相应的类，如果没有，必须先执行相应的类加载。类加载通过后，接下来分配内存。若Java堆中内存是绝对规整的，使用“指针碰撞“方式分配内存；如果不是规整的，就从空闲列表中分配，叫做”空闲列表“方式。划分内存时还需要考虑一个问题-并发，也有两种方式: CAS同步处理，或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。然后内存空间初始化操作，接着是做一些必要的对象设置(元信息、哈希码…)，最后执行&lt;init&gt;方法&lt;/init&gt;&lt;/p&gt;

&lt;h2 id=&quot;为对象分配内存&quot;&gt;为对象分配内存&lt;/h2&gt;

&lt;p&gt;类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。&lt;/li&gt;
  &lt;li&gt;空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/内存分配.png&quot; alt=&quot;内存分配&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;并发安全问题&quot;&gt;并发安全问题&lt;/h2&gt;

&lt;p&gt;对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/线程安全.png&quot; alt=&quot;线程安全&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;对象的访问定位&quot;&gt;对象的访问定位&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;程序需要通过 &lt;code&gt;JVM&lt;/code&gt; 栈上的引用访问堆中的具体对象。对象的访问方式取决于 &lt;code&gt;JVM&lt;/code&gt; 虚拟机的实现。目前主流的访问方式有 &lt;strong&gt;句柄&lt;/strong&gt; 和 &lt;strong&gt;直接指针&lt;/strong&gt; 两种方式&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;指针：&lt;/strong&gt; 指向对象，代表一个对象在内存中的起始地址。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;句柄：&lt;/strong&gt; 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;句柄访问&quot;&gt;句柄访问&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;堆中划分出一块内存来作为&lt;strong&gt;句柄池&lt;/strong&gt;，引用中存储对象的&lt;strong&gt;句柄地址&lt;/strong&gt;，而句柄中包含了&lt;strong&gt;对象实例数据&lt;/strong&gt;与&lt;strong&gt;对象类型数据&lt;/strong&gt;各自的&lt;strong&gt;具体地址&lt;/strong&gt;信息，具体构造如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/句柄访问.png&quot; alt=&quot;句柄访问&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;：引用中存储的是&lt;strong&gt;稳定&lt;/strong&gt;的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变&lt;strong&gt;句柄中&lt;/strong&gt;的&lt;strong&gt;实例数据指针&lt;/strong&gt;，而&lt;strong&gt;引用&lt;/strong&gt;本身不需要修改&lt;/p&gt;

&lt;h3 id=&quot;直接指针&quot;&gt;直接指针&lt;/h3&gt;

&lt;p&gt;如果使用&lt;strong&gt;直接指针&lt;/strong&gt;访问，&lt;strong&gt;引用&lt;/strong&gt; 中存储的直接就是&lt;strong&gt;对象地址&lt;/strong&gt;，那么&lt;code&gt;Java&lt;/code&gt;堆对象内部的布局中就必须考虑如何放置访问&lt;strong&gt;类型数据&lt;/strong&gt;的相关信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/直接指针.png&quot; alt=&quot;直接指针&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;：速度更&lt;strong&gt;快&lt;/strong&gt;，节省了&lt;strong&gt;一次指针定位&lt;/strong&gt;的时间开销。由于对象的访问在&lt;code&gt;Java&lt;/code&gt;中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式&lt;/p&gt;

&lt;h1 id=&quot;内存溢出异常&quot;&gt;内存溢出异常&lt;/h1&gt;

&lt;p&gt;内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。&lt;/p&gt;

&lt;p&gt;但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。&lt;/p&gt;

&lt;h1 id=&quot;java垃圾回收机制&quot;&gt;Java垃圾回收机制&lt;/h1&gt;

&lt;p&gt;在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。&lt;/p&gt;

&lt;h1 id=&quot;gc&quot;&gt;GC&lt;/h1&gt;

&lt;p&gt;GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存&lt;/p&gt;

&lt;p&gt;回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动&lt;/p&gt;

&lt;p&gt;回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法&lt;/p&gt;

&lt;h1 id=&quot;垃圾回收的优点和原理&quot;&gt;垃圾回收的优点和原理&lt;/h1&gt;

&lt;p&gt;java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时不再考虑内存管理的问题。&lt;/p&gt;

&lt;p&gt;由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。&lt;/p&gt;

&lt;p&gt;垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。&lt;/p&gt;

&lt;p&gt;垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。&lt;/p&gt;

&lt;p&gt;程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。&lt;/p&gt;

&lt;p&gt;垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。&lt;/p&gt;

&lt;h1 id=&quot;垃圾回收器的基本原理&quot;&gt;垃圾回收器的基本原理&lt;/h1&gt;

&lt;p&gt;对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。&lt;/p&gt;

&lt;p&gt;通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。&lt;/p&gt;

&lt;p&gt;可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。&lt;/p&gt;

&lt;h1 id=&quot;java引用类型&quot;&gt;Java引用类型&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;强引用：发生 gc 的时候不会被回收。&lt;/li&gt;
  &lt;li&gt;软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。&lt;/li&gt;
  &lt;li&gt;弱引用：有用但不是必须的对象，在下一次GC时会被回收。&lt;/li&gt;
  &lt;li&gt;虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;判断对象是否可以被回收&quot;&gt;判断对象是否可以被回收&lt;/h1&gt;

&lt;p&gt;垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；&lt;/li&gt;
  &lt;li&gt;可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="jvm" /><summary type="html">[toc]</summary></entry></feed>