<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-09T18:22:46+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">imod</title><subtitle>lazycat&lt;br/&gt;
&lt;a href=&quot;mailto:verylazycat@outlook.com&quot;&gt;
  &lt;i class=&quot;fas fa-envelope&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
&lt;a href=&quot;https://github.com/verylazycat&quot;&gt;
  &lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
# &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=auto height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=1350981812&amp;auto=1&amp;height=66&quot;&gt;
# &gt;&lt;/iframe&gt;
</subtitle><entry><title type="html">linux笔记</title><link href="http://localhost:4000/_posts/2020-05-09-linux%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="linux笔记" /><published>2020-05-09T00:00:00+08:00</published><updated>2020-05-09T00:00:00+08:00</updated><id>http://localhost:4000/_posts/linux%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-09-linux%E7%AC%94%E8%AE%B0/">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;unix和linux区别&quot;&gt;Unix和Linux区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;开源性
Linux是一款开源操作系统，不需要付费，即可使用；Unix是一款对源码实行知识产权保护的传统商业软件，使用需要付费授权使用。&lt;/li&gt;
  &lt;li&gt;跨平台性
Linux操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix操作系统跨平台性能较弱，大多需与硬件配套使用。&lt;/li&gt;
  &lt;li&gt;可视化界面
Linux除了进行命令行操作，还有窗体管理系统；Unix只是命令行下的系统。&lt;/li&gt;
  &lt;li&gt;硬件环境
Linux操作系统对硬件的要求较低，安装方法更易掌握；Unix对硬件要求比较苛刻，按照难度较大。&lt;/li&gt;
  &lt;li&gt;用户群体
Linux的用户群体很广泛，个人和企业均可使用；Unix的用户群体比较窄，多是安全性要求高的大型企业使用，如银行、电信部门等，或者Unix硬件厂商使用，如Sun等。相比于Unix操作系统，Linux操作系统更受广大计算机爱好者的喜爱，主要原因是Linux操作系统具有Unix操作系统的全部功能，并且能够在普通PC计算机上实现全部的Unix特性，开源免费的特性，更容易普及使用&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux-内核&quot;&gt;Linux 内核&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;系统内存管理&lt;/li&gt;
  &lt;li&gt;应用程序管理&lt;/li&gt;
  &lt;li&gt;硬件设备管理&lt;/li&gt;
  &lt;li&gt;文件系统管理&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux的基本组件&quot;&gt;Linux的基本组件&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Linux内核、Shell、GUI,文件系统、应用程序&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux-的体系结构&quot;&gt;Linux 的体系结构&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/linux.png&quot; alt=&quot;linux&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。
内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、平台架构相关的代码(Architecture-Dependent Kernel Code)&lt;/p&gt;

&lt;p&gt;Linux 体系结构要分为用户空间和内核空间的原因&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1、现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问的寄存器不同。&lt;/li&gt;
  &lt;li&gt;2、Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用户空间和内核空间是程序执行的&lt;strong&gt;两种不同的状态&lt;/strong&gt;，我们可以通过两种方式完成用户空间到内核空间的转移：1）系统调用；2）硬件中断&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;bash和dos之间的基本区别&quot;&gt;BASH和DOS之间的基本区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BASH和DOS控制台之间的主要区别在于3个方面：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BASH命令区分大小写，而DOS命令则不区分;&lt;/li&gt;
  &lt;li&gt;在BASH下，/ character是目录分隔符，\作为转义字符。在DOS下，/用作命令参数分隔符，\是目录分隔符&lt;/li&gt;
  &lt;li&gt;DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，扩展名为3个字符。BASH没有遵循这样的惯例&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux-开机启动过程&quot;&gt;Linux 开机启动过程&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1、主机加电自检，加载 BIOS 硬件信息。&lt;/p&gt;

&lt;p&gt;2、读取 MBR 的引导文件(GRUB、LILO)。&lt;/p&gt;

&lt;p&gt;3、引导 Linux 内核。&lt;/p&gt;

&lt;p&gt;4、运行第一个进程 init (进程号永远为 1 )。&lt;/p&gt;

&lt;p&gt;5、进入相应的运行级别。&lt;/p&gt;

&lt;p&gt;6、运行终端，输入用户名和密码&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux系统缺省的运行级别&quot;&gt;Linux系统缺省的运行级别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;关机。&lt;/li&gt;
  &lt;li&gt;单机用户模式。&lt;/li&gt;
  &lt;li&gt;字符界面的多用户模式(不支持网络)。&lt;/li&gt;
  &lt;li&gt;字符界面的多用户模式。&lt;/li&gt;
  &lt;li&gt;未分配使用。&lt;/li&gt;
  &lt;li&gt;图形界面的多用户模式。&lt;/li&gt;
  &lt;li&gt;重启&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux-使用的进程间通信方式&quot;&gt;Linux 使用的进程间通信方式&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1、管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。&lt;/p&gt;

&lt;p&gt;2、信号(signal) 。&lt;/p&gt;

&lt;p&gt;3、消息队列。&lt;/p&gt;

&lt;p&gt;4、共享内存。&lt;/p&gt;

&lt;p&gt;5、信号量。&lt;/p&gt;

&lt;p&gt;6、套接字(socket)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux-有哪些系统日志文件&quot;&gt;Linux 有哪些系统日志文件&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重要的是 &lt;code&gt;/var/log/messages&lt;/code&gt; 日志文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux系统桌面环境&quot;&gt;Linux系统桌面环境&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;KDE或Gnome&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;交换空间&quot;&gt;交换空间&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;交换空间是Linux使用的一定空间，用于临时保存一些并发运行的程序。当RAM没有足够的内存来容纳正在执行的所有程序时，就会发生这种情况。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;root帐户&quot;&gt;root帐户&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;root帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为每个帐户分配不同的权限。每次安装Linux时都是默认帐户&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;lilo&quot;&gt;LILO&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LILO是Linux的引导加载程序。它主要用于将Linux操作系统加载到主内存中，以便它可以开始运行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;bash&quot;&gt;BASH&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BASH是Bourne Again SHell的缩写。它由Steve Bourne编写，作为原始Bourne Shell（由/ bin / sh表示）的替代品。它结合了原始版本的Bourne Shell的所有功能，以及其他功能，使其更容易使用。从那以后，它已被改编为运行Linux的大多数系统的默认shell；推荐&lt;code&gt;zsh&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;cli&quot;&gt;CLI&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;命令行界面（英语&lt;strong&gt;：command-line interface&lt;/strong&gt;，缩写]：CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（CUI）。&lt;/p&gt;

&lt;p&gt;通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。因为，命令行界面的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;gui&quot;&gt;GUI&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。&lt;/p&gt;

&lt;p&gt;图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;开源优势&quot;&gt;开源优势&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开源允许你将软件（包括源代码）免费分发给任何感兴趣的人。然后，人们可以添加功能，甚至可以调试和更正源代码中的错误。它们甚至可以让它运行得更好，然后再次自由地重新分配这些增强的源代码。这最终使社区中的每个人受益&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux-文件系统&quot;&gt;Linux 文件系统&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;也就是说在 Linux 系统中有一个重要的概念&lt;strong&gt;：一切都是文件&lt;/strong&gt;。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。&lt;/p&gt;

&lt;p&gt;Linux 支持 5 种文件类型，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/LINUX_FILE.png&quot; alt=&quot;LINUX_FILE&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux-的目录结构&quot;&gt;Linux 的目录结构&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/LINUX_THREE.png&quot; alt=&quot;LINUX_THREE&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;/bin： 存放二进制可执行文件(ls,cat,mkdir等)，常用命令一般都在这里；&lt;/li&gt;
  &lt;li&gt;/etc： 存放系统管理和配置文件；&lt;/li&gt;
  &lt;li&gt;/home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；&lt;/li&gt;
  &lt;li&gt;/usr &lt;strong&gt;： 用于存放系统应用程序；&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;**/opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；&lt;/li&gt;
  &lt;li&gt;/proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；&lt;/li&gt;
  &lt;li&gt;/root： 超级用户（系统管理员）的主目录（特权阶级o）；&lt;/li&gt;
  &lt;li&gt;/sbin: 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；&lt;/li&gt;
  &lt;li&gt;/dev： 用于存放设备文件；&lt;/li&gt;
  &lt;li&gt;/mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；&lt;/li&gt;
  &lt;li&gt;/boot： 存放用于系统引导时使用的各种文件；&lt;/li&gt;
  &lt;li&gt;**/lib **： 存放着和系统运行相关的库文件 ；&lt;/li&gt;
  &lt;li&gt;/tmp： 用于存放各种临时文件，是公用的临时文件存储点；&lt;/li&gt;
  &lt;li&gt;/var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；&lt;/li&gt;
  &lt;li&gt;/lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;inode&quot;&gt;inode&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。&lt;/p&gt;

&lt;p&gt;操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。&lt;/p&gt;

&lt;p&gt;文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。&lt;/p&gt;

&lt;p&gt;每一个文件都有对应的inode，里面包含了与该文件有关的一些信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;linux-文件系统通过-i-节点把文件的逻辑结构和物理结构转换的工作过程&quot;&gt;&lt;strong&gt;Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;inode 节点是一个 64 字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息。在 inode 节点表中最重要的内容是磁盘地址表。在磁盘地址表中有 13 个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。
Linux 文件系统通过把 inode 节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的 inode 节点号，通过该 inode 节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;硬链接和软链接&quot;&gt;硬链接和软链接&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1）硬链接&lt;/p&gt;

&lt;p&gt;由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）软链接&lt;/p&gt;

&lt;p&gt;软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际场景下，基本是使用软链接。总结区别如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;raid&quot;&gt;RAID&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统只会把它当做一个硬盘。&lt;/p&gt;

&lt;p&gt;RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应用中，可以依据自己的实际需求选择不同的 RAID 方案&lt;/p&gt;

&lt;p&gt;Linux 性能调优都有哪几种方法？&lt;/p&gt;

&lt;p&gt;1、Disabling daemons (关闭 daemons)。
2、Shutting down the GUI (关闭 GUI)。
3、Changing kernel parameters (改变内核参数)。
4、Kernel parameters (内核参数)。
5、Tuning the processor subsystem (处理器子系统调优)。
6、Tuning the memory subsystem (内存子系统调优)。
7、Tuning the file system (文件系统子系统调优)。
8、Tuning the network subsystem（网络子系统调优)&lt;/p&gt;</content><author><name></name></author><category term="linux" /><summary type="html">Unix和Linux区别</summary></entry><entry><title type="html">BIO&amp;amp;NIO&amp;amp;AIO</title><link href="http://localhost:4000/_posts/2020-05-08-BIO&NIO&AIO/" rel="alternate" type="text/html" title="BIO&amp;NIO&amp;AIO" /><published>2020-05-08T00:00:00+08:00</published><updated>2020-05-08T00:00:00+08:00</updated><id>http://localhost:4000/_posts/BIO&amp;NIO&amp;AIO</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-08-BIO&amp;NIO&amp;AIO/">&lt;p&gt;Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;同步与异步&quot;&gt;&lt;strong&gt;同步与异步&lt;/strong&gt;&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;同步：&lt;/strong&gt; 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;异步：&lt;/strong&gt; 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同步和异步的区别最大在于异步的调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;阻塞和非阻塞&quot;&gt;&lt;strong&gt;阻塞和非阻塞&lt;/strong&gt;&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;阻塞：&lt;/strong&gt; 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;非阻塞：&lt;/strong&gt; 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;bio-blocking-io&quot;&gt;BIO (Blocking I/O)&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成&lt;/p&gt;

&lt;h4 id=&quot;传统-bio&quot;&gt;传统 BIO&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/BIO.png&quot; alt=&quot;BIO&quot; /&gt;&lt;/p&gt;

&lt;p&gt;采用 &lt;strong&gt;BIO 通信模型&lt;/strong&gt; 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在 &lt;code&gt;while(true)&lt;/code&gt; 循环中服务端会调用 &lt;code&gt;accept()&lt;/code&gt; 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。&lt;/p&gt;

&lt;p&gt;如果要让 &lt;strong&gt;BIO 通信模型&lt;/strong&gt; 能够同时处理多个客户端请求，就必须使用多线程（主要原因是 &lt;code&gt;socket.accept()&lt;/code&gt;、 &lt;code&gt;socket.read()&lt;/code&gt;、 &lt;code&gt;socket.write()&lt;/code&gt; 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 &lt;strong&gt;一请求一应答通信模型&lt;/strong&gt; 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 &lt;strong&gt;线程池机制&lt;/strong&gt; 改善，线程池还可以让线程的创建和回收成本相对较低。使用&lt;code&gt;FixedThreadPool&lt;/code&gt; 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型（N 可以远远大于 M），下面一节”伪异步 BIO”中会详细介绍到。&lt;/p&gt;

&lt;h4 id=&quot;我们再设想一下当客户端并发访问量增加后这种模型会出现什么问题&quot;&gt;&lt;strong&gt;我们再设想一下当客户端并发访问量增加后这种模型会出现什么问题？&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，创建和销毁线程都是重量级的系统函数。如果并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;伪异步-io&quot;&gt;伪异步 IO&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽&lt;/p&gt;

&lt;p&gt;伪异步IO模型图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/伪异步io.png&quot; alt=&quot;伪异步io&quot; /&gt;&lt;/p&gt;

&lt;p&gt;采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如上图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。&lt;/p&gt;

&lt;p&gt;伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层任然是同步阻塞的BIO模型，因此无法从根本上解决问题。&lt;/p&gt;

&lt;p&gt;在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;nio-new-io&quot;&gt;NIO (New I/O)&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。&lt;/p&gt;

&lt;p&gt;NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 &lt;code&gt;Socket&lt;/code&gt; 和 &lt;code&gt;ServerSocket&lt;/code&gt; 相对应的 &lt;code&gt;SocketChannel&lt;/code&gt; 和 &lt;code&gt;ServerSocketChannel&lt;/code&gt; 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NIO的特性/NIO与IO区别&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;non-blocking-io非阻塞io&quot;&gt;Non-blocking IO（非阻塞IO）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;IO流是阻塞的，NIO流是不阻塞的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。&lt;/p&gt;

&lt;p&gt;Java IO的各种流是阻塞的。这意味着，当一个线程调用 &lt;code&gt;read()&lt;/code&gt; 或 &lt;code&gt;write()&lt;/code&gt; 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了&lt;/p&gt;

&lt;h4 id=&quot;buffer缓冲区&quot;&gt;Buffer(缓冲区)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。&lt;/p&gt;

&lt;p&gt;在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。&lt;/p&gt;

&lt;p&gt;最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。&lt;/p&gt;

&lt;h4 id=&quot;channel-通道&quot;&gt;Channel (通道)&lt;/h4&gt;

&lt;p&gt;NIO 通过Channel（通道） 进行读写。&lt;/p&gt;

&lt;p&gt;通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。&lt;/p&gt;

&lt;h4 id=&quot;selectors选择器&quot;&gt;Selectors(选择器)&lt;/h4&gt;

&lt;p&gt;NIO有选择器，而IO没有。&lt;/p&gt;

&lt;p&gt;选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;nio-读数据和写数据方式&quot;&gt;NIO 读数据和写数据方式&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常来说NIO中的所有IO都是从 Channel（通道） 开始的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。&lt;/li&gt;
  &lt;li&gt;从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据读取和写入操作图示：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;channel&lt;/code&gt; —»»&lt;code&gt;buffer&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;channel&lt;/code&gt; ««—-&lt;code&gt;buffer&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;nio核心组件简单介绍&quot;&gt;NIO核心组件简单介绍&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;NIO 包含下面几个核心的组件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Channel(通道)&lt;/li&gt;
  &lt;li&gt;Buffer(缓冲区)&lt;/li&gt;
  &lt;li&gt;Selector(选择器)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整个NIO体系包含的类远远不止这三个，只能说这三个是NIO体系的“核心API”&lt;/p&gt;

&lt;h2 id=&quot;aio-asynchronous-io&quot;&gt;AIO (Asynchronous I/O)&lt;/h2&gt;

&lt;p&gt;AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。&lt;/p&gt;

&lt;p&gt;AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的，这一点可以从底层IO线程模型解释。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;从操作系统上理解&quot;&gt;从操作系统上理解&lt;/h4&gt;

&lt;p&gt;考虑下面两种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用系统调用&lt;code&gt;read&lt;/code&gt;从socket里读取一段数据&lt;/li&gt;
  &lt;li&gt;用系统调用&lt;code&gt;read&lt;/code&gt;从一个磁盘文件读取一段数据到内存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于第一种情况，算作block，因为Linux无法知道网络上对方是否会发数据。如果没数据发过来，对于调用&lt;code&gt;read&lt;/code&gt;的程序来说，就只能“等”。&lt;/p&gt;

&lt;p&gt;对于第二种情况，&lt;strong&gt;不算做block&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于磁盘文件IO，Linux总是不视作Block&lt;/p&gt;

&lt;p&gt;一个解释是，所谓“Block”是指操作系统可以预见这个Block会发生才会主动Block。例如当读取TCP连接的数据时，如果发现Socket buffer里没有数据就可以确定定对方还没有发过来，于是Block；而对于普通磁盘文件的读写，也许磁盘运作期间会抖动，会短暂暂停，但是操作系统无法预见这种情况，只能视作不会Block，照样执行&lt;/p&gt;

&lt;p&gt;基于这个基本的设定，在讨论IO时，一定要严格区分网络IO和磁盘文件IO。NIO和后文讲到的IO多路复用只对网络IO有意义。&lt;/p&gt;

&lt;h1 id=&quot;bio&quot;&gt;BIO&lt;/h1&gt;

&lt;p&gt;有了Block的定义，就可以讨论BIO和NIO了。BIO是Blocking IO的意思。在类似于网络中进行&lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;connect&lt;/code&gt;一类的系统调用时会被卡住。&lt;/p&gt;

&lt;p&gt;举个例子，当用&lt;code&gt;read&lt;/code&gt;去读取网络的数据时，是无法预知对方是否已经发送数据的。因此在收到数据之前，能做的只有等待，直到对方把数据发过来，或者等到网络超时。&lt;/p&gt;

&lt;p&gt;对于单线程的网络服务，这样做就会有卡死的问题。因为当等待时，整个线程会被挂起，无法执行，也无法做其他的工作。&lt;/p&gt;

&lt;p&gt;这种Block是不会影响同时运行的其他程序（进程）的，因为现代操作系统都是多任务的，任务之间的切换是抢占式的。这里Block只是指Block当前的进程。&lt;/p&gt;

&lt;p&gt;网络服务为了同时响应多个并发的网络请求，必须实现为多线程的。每个线程处理一个网络请求。线程数随着并发连接数线性增长。这的确能奏效。实际上2000年之前很多网络服务器就是这么实现的。但这带来两个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;线程越多，Context Switch就越多，而Context Switch是一个比较重的操作，会无谓浪费大量的CPU。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个线程会占用一定的内存作为线程的栈。比如有1000个线程同时运行，每个占用1MB内存，就占用了1个G的内存。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;问题的关键在于，当调用&lt;code&gt;read&lt;/code&gt;接受网络请求时，有数据到了就用，没数据到时，实际上是可以干别的。使用大量线程，仅仅是因为Block发生，没有其他办法。&lt;/p&gt;

&lt;p&gt;当然你可能会说，是不是可以弄个线程池呢？这样既能并发的处理请求，又不会产生大量线程。但这样会限制最大并发的连接数。比如你弄4个线程，那么最大4个线程都Block了就没法响应更多请求了。&lt;/p&gt;

&lt;p&gt;要是操作IO接口时，操作系统能够总是直接告诉有没有数据，而不是Block去等就好了。于是，NIO登场&lt;/p&gt;

&lt;h1 id=&quot;nio&quot;&gt;NIO&lt;/h1&gt;

&lt;p&gt;NIO是指将IO模式设为“Non-Blocking”模式。在Linux下，一般是这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void setnonblocking(int fd) {
    int flags = fcntl(fd, F_GETFL, 0);
    fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在BIO模式下，调用read，如果发现没数据已经到达，就会Block住。&lt;/p&gt;

&lt;p&gt;在NIO模式下，调用read，如果发现没数据已经到达，就会立刻返回-1, 并且errno被设为&lt;code&gt;EAGAIN&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;于是，一段NIO的代码，大概就可以写成这个样子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct timespec sleep_interval{.tv_sec = 0, .tv_nsec = 1000};
ssize_t nbytes;
while (1) {
    /* 尝试读取 */
    if ((nbytes = read(fd, buf, sizeof(buf))) &amp;lt; 0) {
        if (errno == EAGAIN) { // 没数据到
            perror(&quot;nothing can be read&quot;);
        } else {
            perror(&quot;fatal error&quot;);
            exit(EXIT_FAILURE);
        }
    } else { // 有数据
        process_data(buf, nbytes);
    }
    // 处理其他事情，做完了就等一会，再尝试
    nanosleep(sleep_interval, NULL);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码很容易理解，就是轮询，不断的尝试有没有数据到达，有了就处理，没有(得到&lt;code&gt;EWOULDBLOCK&lt;/code&gt;或者&lt;code&gt;EAGAIN&lt;/code&gt;)就等一小会再试。这比之前BIO好多了，起码程序不会被卡死了&lt;/p&gt;

&lt;p&gt;但这样会带来两个新问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果有大量文件描述符都要等，那么就得一个一个的read。这会带来大量的Context Switch（&lt;code&gt;read&lt;/code&gt;是系统调用，每调用一次就得在用户态和核心态切换一次）&lt;/li&gt;
  &lt;li&gt;休息一会的时间不好把握。这里是要猜多久之后数据才能到。等待时间设的太长，程序响应延迟就过大；设的太短，就会造成过于频繁的重试，干耗CPU而已。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要是操作系统能一口气告诉程序，哪些数据到了就好了。&lt;/p&gt;

&lt;p&gt;于是IO多路复用被搞出来解决这个问题&lt;/p&gt;

&lt;h1 id=&quot;io多路复用&quot;&gt;IO多路复用&lt;/h1&gt;

&lt;p&gt;IO多路复用（IO Multiplexing) 是这么一种机制：程序注册一组socket文件描述符给操作系统，表示“我要监视这些fd是否有IO事件发生，有了就告诉程序处理”。&lt;/p&gt;

&lt;p&gt;IO多路复用是要和NIO一起使用的。尽管在操作系统级别，NIO和IO多路复用是两个相对独立的事情。NIO仅仅是指IO API总是能立刻返回，不会被Blocking；而IO多路复用仅仅是操作系统提供的一种便利的通知机制。操作系统并不会强制这俩必须得一起用——你可以用NIO，但不用IO多路复用，就像上一节中的代码；也可以只用IO多路复用 + BIO，这时效果还是当前线程被卡住。但是，&lt;strong&gt;IO多路复用和NIO是要配合一起使用才有实际意义&lt;/strong&gt;。因此，在使用IO多路复用之前，请总是先把fd设为&lt;code&gt;O_NONBLOCK&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;对IO多路复用，还存在一些常见的误解，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;❌IO多路复用是指多个数据流共享同一个Socket&lt;/strong&gt;。其实IO多路复用说的是多个Socket，只不过操作系统是一起监听他们的事件而已。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;多个数据流共享同一个TCP连接的场景的确是有，比如Http2 Multiplexing就是指Http2通讯中中多个逻辑的数据流共享同一个TCP连接。但这与IO多路复用是完全不同的问题。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;❌IO多路复用是NIO，所以总是不Block的&lt;/strong&gt;。其实IO多路复用的关键API调用(&lt;code&gt;select&lt;/code&gt;，&lt;code&gt;poll&lt;/code&gt;，&lt;code&gt;epoll_wait&lt;/code&gt;）总是Block的，正如下文的例子所讲。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;❌&lt;strong&gt;IO多路复用和NIO一起减少了IO&lt;/strong&gt;。实际上，IO本身（网络数据的收发）无论用不用IO多路复用和NIO，都没有变化。请求的数据该是多少还是多少；网络上该传输多少数据还是多少数据。IO多路复用和NIO一起仅仅是解决了调度的问题，避免CPU在这个过程中的浪费，使系统的瓶颈更容易触达到网络带宽，而非CPU或者内存。要提高IO吞吐，还是提高硬件的容量（例如，用支持更大带宽的网线、网卡和交换机）和依靠并发传输（例如HDFS的数据多副本并发传输&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;操作系统级别提供了一些接口来支持IO多路复用，最老掉牙的是&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;poll&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;select&quot;&gt;select&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;select&lt;/code&gt;长这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它接受3个文件描述符的数组，分别监听读取(&lt;code&gt;readfds&lt;/code&gt;)，写入(&lt;code&gt;writefds&lt;/code&gt;)和异常(&lt;code&gt;expectfds&lt;/code&gt;)事件。那么一个 IO多路复用的代码大概是这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct timeval tv = {.tv_sec = 1, .tv_usec = 0};

ssize_t nbytes;
while(1) {
    FD_ZERO(&amp;amp;read_fds);
    setnonblocking(fd1);
    setnonblocking(fd2);
    FD_SET(fd1, &amp;amp;read_fds);
    FD_SET(fd2, &amp;amp;read_fds);
    // 把要监听的fd拼到一个数组里，而且每次循环都得重来一次...
    if (select(FD_SETSIZE, &amp;amp;read_fds, NULL, NULL, &amp;amp;tv) &amp;lt; 0) { // block住，直到有事件到达
        perror(&quot;select出错了&quot;);
        exit(EXIT_FAILURE);
    }
    for (int i = 0; i &amp;lt; FD_SETSIZE; i++) {
        if (FD_ISSET(i, &amp;amp;read_fds)) {
            /* 检测到第[i]个读取fd已经收到了，这里假设buf总是大于到达的数据，所以可以一次read完 */
            if ((nbytes = read(i, buf, sizeof(buf))) &amp;gt;= 0) {
                process_data(nbytes, buf);
            } else {
                perror(&quot;读取出错了&quot;);
                exit(EXIT_FAILURE);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，为了&lt;code&gt;select&lt;/code&gt;需要构造一个fd数组（这里为了简化，没有构造要监听写入和异常事件的fd数组）。之后，用&lt;code&gt;select&lt;/code&gt;监听了&lt;code&gt;read_fds&lt;/code&gt;中的多个socket的读取时间。调用&lt;code&gt;select&lt;/code&gt;后，程序会Block住，直到一个事件发生了，或者等到最大1秒钟(&lt;code&gt;tv&lt;/code&gt;定义了这个时间长度）就返回。之后，需要遍历所有注册的fd，挨个检查哪个fd有事件到达(&lt;code&gt;FD_ISSET&lt;/code&gt;返回true)。如果是，就说明数据已经到达了，可以读取fd了。读取后就可以进行数据的处理。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;select&lt;/code&gt;有一些发指的缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;select&lt;/code&gt;能够支持的最大的fd数组的长度是1024。这对要处理高并发的web服务器是不可接受的。&lt;/li&gt;
  &lt;li&gt;fd数组按照监听的事件分为了3个数组，为了这3个数组要分配3段内存去构造，而且每次调用&lt;code&gt;select&lt;/code&gt;前都要重设它们（因为&lt;code&gt;select&lt;/code&gt;会改这3个数组)；调用&lt;code&gt;select&lt;/code&gt;后，这3数组要从用户态复制一份到内核态；事件到达后，要遍历这3数组。很不爽。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;select&lt;/code&gt;返回后要挨个遍历fd，找到被“SET”的那些进行处理。这样比较低效。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;select&lt;/code&gt;是无状态的，即每次调用&lt;code&gt;select&lt;/code&gt;，内核都要重新检查所有被注册的fd的状态。&lt;code&gt;select&lt;/code&gt;返回后，这些状态就被返回了，内核不会记住它们；到了下一次调用，内核依然要重新检查一遍。于是查询的效率很低。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;poll&quot;&gt;poll&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;poll&lt;/code&gt;与&lt;code&gt;select&lt;/code&gt;类似于。它大概长这样&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CQL&quot;&gt;int poll(struct pollfd *fds, nfds_t nfds, int timeout);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;poll&lt;/code&gt;的代码例子和&lt;code&gt;select&lt;/code&gt;差不多，因此也就不赘述了。有意思的是&lt;code&gt;poll&lt;/code&gt;这个单词的意思是“轮询”，所以很多中文资料都会提到对IO进行“轮询”。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;poll&lt;/code&gt;优化了&lt;code&gt;select&lt;/code&gt;的一些问题。比如不再有3个数组，而是1个&lt;code&gt;polldfd&lt;/code&gt;结构的数组了，并且也不需要每次重设了。数组的个数也没有了1024的限制。但其他的问题依旧：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;依然是无状态的，性能的问题与&lt;code&gt;select&lt;/code&gt;差不多一样；&lt;/li&gt;
  &lt;li&gt;应用程序仍然无法很方便的拿到那些“有事件发生的fd“，还是需要遍历所有注册的fd。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前来看，高性能的web服务器都不会使用&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;poll&lt;/code&gt;。他们俩存在的意义仅仅是“兼容性”，因为很多操作系统都实现了这两个系统调用。&lt;/p&gt;

&lt;p&gt;如果是追求性能的话，在BSD/macOS上提供了kqueue api；在Salorias中提供了/dev/poll（可惜该操作系统已经凉凉)；而在Linux上提供了epoll api。它们的出现彻底解决了&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;poll&lt;/code&gt;的问题。Java NIO，nginx等在对应的平台的上都是使用这些api实现。&lt;/p&gt;

&lt;p&gt;因为大部分情况下我会用Linux做服务器，所以下文以Linux epoll为例子来解释多路复用是怎么工作的。&lt;/p&gt;

&lt;h1 id=&quot;用epoll实现的io多路复用&quot;&gt;用epoll实现的IO多路复用&lt;/h1&gt;

&lt;p&gt;epoll是Linux下的IO多路复用的实现。这里单开一章是因为它非常有代表性，并且Linux也是目前最广泛被作为服务器的操作系统。细致的了解epoll对整个IO多路复用的工作原理非常有帮助。&lt;/p&gt;

&lt;p&gt;与&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;poll&lt;/code&gt;不同，要使用epoll是需要先创建一下的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int epfd = epoll_create(10);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;epoll_create&lt;/code&gt;在内核层创建了一个数据表，接口会返回一个“epoll的文件描述符”指向这个表。注意，接口参数是一个表达要监听事件列表的长度的数值。但不用太在意，因为epoll内部随后会根据事件注册和事件注销动态调整epoll中表格的大小。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/epoll.png&quot; alt=&quot;epoll&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么epoll要创建一个用文件描述符来指向的表呢？这里有两个好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;epoll是有状态的，不像&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;poll&lt;/code&gt;那样每次都要重新传入所有要监听的fd，这避免了很多无谓的数据复制。epoll的数据是用接口&lt;code&gt;epoll_ctl&lt;/code&gt;来管理的（增、删、改）。&lt;/li&gt;
  &lt;li&gt;epoll文件描述符在进程被fork时，子进程是可以继承的。这可以给对多进程共享一份epoll数据，实现并行监听网络请求带来便利。但这超过了本文的讨论范围，就此打住。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;epoll创建后，第二步是使用&lt;code&gt;epoll_ctl&lt;/code&gt;接口来注册要监听的事件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中第一个参数就是上面创建的&lt;code&gt;epfd&lt;/code&gt;。第二个参数&lt;code&gt;op&lt;/code&gt;表示如何对文件名进行操作，共有3种。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;EPOLL_CTL_ADD&lt;/code&gt; - 注册一个事件&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EPOLL_CTL_DEL&lt;/code&gt; - 取消一个事件的注册&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;EPOLL_CTL_MOD&lt;/code&gt; - 修改一个事件的注册&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第三个参数是要操作的fd，这里必须是支持NIO的fd（比如socket）。第四个参数是一个&lt;code&gt;epoll_event&lt;/code&gt;的类型的数据，表达了注册的事件的具体信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef union epoll_data {
    void    *ptr;
    int      fd;
    uint32_t u32;
    uint64_t u64;
} epoll_data_t;

struct epoll_event {
    uint32_t     events;    /* Epoll events */
    epoll_data_t data;      /* User data variable */
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比方说，想关注一个fd1的读取事件事件，并采用边缘触发(下文会解释什么是边缘触发），大概要这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct epoll_data ev;
ev.events = EPOLLIN | EPOLLET; // EPOLLIN表示读事件；EPOLLET表示边缘触发
ev.data.fd = fd1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;epoll_ctl&lt;/code&gt;就可以灵活的注册/取消注册/修改注册某个fd的某些事件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/epoll_ctl.png&quot; alt=&quot;epoll_ctl&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第三步，使用&lt;code&gt;epoll_wait&lt;/code&gt;来等待事件的发生&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-CQL&quot;&gt;int epoll_wait(int epfd, struct epoll_event *evlist, int maxevents, int timeout);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特别留意，这一步是”block”的。只有当注册的事件至少有一个发生，或者&lt;code&gt;timeout&lt;/code&gt;达到时，该调用才会返回。这与&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;poll&lt;/code&gt;几乎一致。但不一样的地方是&lt;code&gt;evlist&lt;/code&gt;，它是&lt;code&gt;epoll_wait&lt;/code&gt;的返回数组，里面&lt;strong&gt;只包含那些被触发的事件对应的fd&lt;/strong&gt;，而不是像&lt;code&gt;select&lt;/code&gt;和&lt;code&gt;poll&lt;/code&gt;那样返回所有注册的fd。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/epoll_wait.png&quot; alt=&quot;epoll_wait&quot; /&gt;&lt;/p&gt;

&lt;p&gt;综合起来，一段比较完整的epoll代码大概是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#define MAX_EVENTS 10
struct epoll_event ev, events[MAX_EVENTS];
int nfds, epfd, fd1, fd2;

// 假设这里有两个socket，fd1和fd2，被初始化好。
// 设置为non blocking
setnonblocking(fd1);
setnonblocking(fd2);

// 创建epoll
epfd = epoll_create(MAX_EVENTS);
if (epollfd == -1) {
    perror(&quot;epoll_create1&quot;);
    exit(EXIT_FAILURE);
}

//注册事件
ev.events = EPOLLIN | EPOLLET;
ev.data.fd = fd1;
if (epoll_ctl(epollfd, EPOLL_CTL_ADD, fd1, &amp;amp;ev) == -1) {
    perror(&quot;epoll_ctl: error register fd1&quot;);
    exit(EXIT_FAILURE);
}
if (epoll_ctl(epollfd, EPOLL_CTL_ADD, fd2, &amp;amp;ev) == -1) {
    perror(&quot;epoll_ctl: error register fd2&quot;);
    exit(EXIT_FAILURE);
}

// 监听事件
for (;;) {
    nfds = epoll_wait(epdf, events, MAX_EVENTS, -1);
    if (nfds == -1) {
        perror(&quot;epoll_wait&quot;);
        exit(EXIT_FAILURE);
    }

    for (n = 0; n &amp;lt; nfds; ++n) { // 处理所有发生IO事件的fd
        process_event(events[n].data.fd);
        // 如果有必要，可以利用epoll_ctl继续对本fd注册下一次监听，然后重新epoll_wait
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的基于IO多路复用的代码都会遵循这样的写法：注册——监听事件——处理——再注册，无限循环下去。&lt;/p&gt;</content><author><name></name></author><category term="java" /><summary type="html">Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了</summary></entry><entry><title type="html">git常用命令</title><link href="http://localhost:4000/_posts/2020-05-08-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="alternate" type="text/html" title="git常用命令" /><published>2020-05-08T00:00:00+08:00</published><updated>2020-05-08T00:00:00+08:00</updated><id>http://localhost:4000/_posts/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-08-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">&lt;p&gt;&lt;img src=&quot;/img/git.png&quot; alt=&quot;git&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;workspace&lt;/code&gt;：工作区&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;index/stage&lt;/code&gt;：暂存区&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;repository&lt;/code&gt;:厂库区&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;remoter&lt;/code&gt;远程厂库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Git的设置文件为&lt;code&gt;.gitconfig&lt;/code&gt;，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;#查看配置
git config --list

#编辑配置
git config -e [--global]

#设置提交代码用户配置
git config --global user.name  &quot;[name]&quot;
git config --global user.email &quot;[email address]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建代码库&quot;&gt;创建代码库&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;git init
git clone  url
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;增加删除&quot;&gt;增加/删除&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;#添加到暂存区
git add file  

#添加指定目录到暂存区
git add  dir

#添加当前目录所有文件到暂存区
git add . 

#对于同一个文件的多处变化，可以实现分次提交
git add -p

# 删除工作区文件，并且将这次删除放入暂存区
git rm [file1] [file2]

# 停止追踪指定文件，但该文件会保留在工作区
git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
git mv [file-original] [file-renamed]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;代码提交&quot;&gt;代码提交&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# 提交暂存区到仓库区
git commit -m [message]

# 提交暂存区的指定文件到仓库区
git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
git commit -a

# 提交时显示所有diff信息
git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
git commit --amend [file1] [file2] 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;分支&quot;&gt;分支&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;
# 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]

# 本地存在一个分支，名称叫：develop_chen，但远程没有怎么办？

git push origin develop_chen

这样就在远程建立一个和本地一样的分支 

git branch --set-upstream-to=origin/develop  develop  本地分支和远程分支简历跟踪关系
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;标签&quot;&gt;标签&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;查看信息&quot;&gt;查看信息&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的代码差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog

# 从本地master拉取代码更新当前分支：branch 一般为master
$ git rebase [branch]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;远程同步&quot;&gt;远程同步&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ git remote update  --更新远程仓储
# 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;撤销&quot;&gt;撤销&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;合并&quot;&gt;合并&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;git checkout dev           #切换到dev开发分支
git pull
git checkout master
git merge dev              #合并dev分支到master上
git push origin master     #将代码推到master上
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="git" /><summary type="html"></summary></entry><entry><title type="html">JAVA一些问题三</title><link href="http://localhost:4000/_posts/2020-05-07-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%89/" rel="alternate" type="text/html" title="JAVA一些问题三" /><published>2020-05-07T00:00:00+08:00</published><updated>2020-05-07T00:00:00+08:00</updated><id>http://localhost:4000/_posts/JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%89</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-07-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%89/">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;并行和并发有什么区别&quot;&gt;&lt;strong&gt;并行和并发有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。&lt;/li&gt;
  &lt;li&gt;并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。&lt;/li&gt;
  &lt;li&gt;在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程和进程的区别&quot;&gt;&lt;strong&gt;线程和进程的区别？&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;守护线程是什么&quot;&gt;&lt;strong&gt;守护线程是什么？&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建线程有哪几种方式&quot;&gt;&lt;strong&gt;创建线程有哪几种方式&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①. 继承Thread类创建线程类&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。&lt;/li&gt;
  &lt;li&gt;创建Thread子类的实例，即创建了线程对象。&lt;/li&gt;
  &lt;li&gt;调用线程对象的start()方法来启动该线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;②. 通过Runnable接口创建线程类&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。&lt;/li&gt;
  &lt;li&gt;创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。&lt;/li&gt;
  &lt;li&gt;调用线程对象的start()方法来启动该线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;③. 通过Callable和Future创建线程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。&lt;/li&gt;
  &lt;li&gt;创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。&lt;/li&gt;
  &lt;li&gt;使用FutureTask对象作为Thread对象的target创建并启动新线程。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;runnable-和-callable-区别&quot;&gt;runnable 和 callable 区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有点深的问题了，也看出一个Java程序员学习知识的广度。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程有哪些状态&quot;&gt;&lt;strong&gt;线程有哪些状态&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。&lt;/p&gt;

&lt;p&gt;就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。&lt;/p&gt;

&lt;p&gt;运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。&lt;/p&gt;

&lt;p&gt;阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。&lt;/p&gt;

&lt;p&gt;死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;sleep-和-wait-区别&quot;&gt;&lt;strong&gt;sleep() 和 wait() 区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep()  方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。&lt;/p&gt;

&lt;p&gt;wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;notify和-notifyall有什么区别&quot;&gt;&lt;strong&gt;notify()和 notifyAll()有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。&lt;/p&gt;

&lt;p&gt;当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait  线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。&lt;/p&gt;

&lt;p&gt;优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized  代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程的-run和-start有什么区别&quot;&gt;&lt;strong&gt;线程的 run()和 start()有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。&lt;/p&gt;

&lt;p&gt;start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态，  这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。&lt;/p&gt;

&lt;p&gt;run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;创建线程池有哪几种方式&quot;&gt;&lt;strong&gt;创建线程池有哪几种方式&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①. newFixedThreadPool(int nThreads)&lt;/p&gt;

&lt;p&gt;创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。&lt;/p&gt;

&lt;p&gt;②. newCachedThreadPool()&lt;/p&gt;

&lt;p&gt;创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。&lt;/p&gt;

&lt;p&gt;③. newSingleThreadExecutor()&lt;/p&gt;

&lt;p&gt;这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。&lt;/p&gt;

&lt;p&gt;④. newScheduledThreadPool(int corePoolSize)&lt;/p&gt;

&lt;p&gt;创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程池都有哪些状态&quot;&gt;&lt;strong&gt;线程池都有哪些状态&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。&lt;/p&gt;

&lt;p&gt;线程池各个状态切换框架图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/线程池.png&quot; alt=&quot;线程池&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;线程池中-submit和-execute方法有什么区别&quot;&gt;&lt;strong&gt;线程池中 submit()和 execute()方法有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;接收的参数不一样&lt;/li&gt;
  &lt;li&gt;submit有返回值，而execute没有&lt;/li&gt;
  &lt;li&gt;submit方便Exception处理&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;在-java-程序中怎么保证多线程的运行安全&quot;&gt;&lt;strong&gt;在 java 程序中怎么保证多线程的运行安全&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程安全在三个方面体现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；&lt;/li&gt;
  &lt;li&gt;可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；&lt;/li&gt;
  &lt;li&gt;有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;多线程锁的升级原理是什么&quot;&gt;&lt;strong&gt;多线程锁的升级原理是什么&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。&lt;/p&gt;

&lt;p&gt;锁升级的图示过程:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/锁升级.png&quot; alt=&quot;锁升级&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;什么是死锁&quot;&gt;&lt;strong&gt;什么是死锁&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;怎么防止死锁&quot;&gt;&lt;strong&gt;怎么防止死锁&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;死锁的四个必要条件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源&lt;/li&gt;
  &lt;li&gt;请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放&lt;/li&gt;
  &lt;li&gt;不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放&lt;/li&gt;
  &lt;li&gt;环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。&lt;/p&gt;

&lt;p&gt;理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。&lt;/p&gt;

&lt;p&gt;所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。&lt;/p&gt;

&lt;p&gt;此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;threadlocal-是什么有哪些使用场景&quot;&gt;&lt;strong&gt;ThreadLocal 是什么？有哪些使用场景&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web  服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;说一下-synchronized-底层实现原理&quot;&gt;&lt;strong&gt;说一下 synchronized 底层实现原理&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。&lt;/p&gt;

&lt;p&gt;Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;普通同步方法，锁是当前实例对象&lt;/li&gt;
  &lt;li&gt;静态同步方法，锁是当前类的class对象&lt;/li&gt;
  &lt;li&gt;同步方法块，锁是括号里面的对象&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;synchronized-和-volatile-的区别是什么&quot;&gt;&lt;strong&gt;synchronized 和 volatile 的区别是什么&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。&lt;/li&gt;
  &lt;li&gt;volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。&lt;/li&gt;
  &lt;li&gt;volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。&lt;/li&gt;
  &lt;li&gt;volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。&lt;/li&gt;
  &lt;li&gt;volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;synchronized-和-lock-有什么区别&quot;&gt;&lt;strong&gt;synchronized 和 Lock 有什么区别&lt;/strong&gt;&lt;/h2&gt;

    &lt;ol&gt;
      &lt;li&gt;首先synchronized是java内置关键字，在jvm层面，Lock是个java类；&lt;/li&gt;
      &lt;li&gt;synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；&lt;/li&gt;
      &lt;li&gt;synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；&lt;/li&gt;
      &lt;li&gt;用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；&lt;/li&gt;
      &lt;li&gt;synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；&lt;/li&gt;
      &lt;li&gt;Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;synchronized-和-reentrantlock-区别是什么&quot;&gt;&lt;strong&gt;synchronized 和 ReentrantLock 区别是什么&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁&lt;/li&gt;
  &lt;li&gt;ReentrantLock可以获取各种锁的信息&lt;/li&gt;
  &lt;li&gt;ReentrantLock可以灵活地实现多路通知&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;atomic-的原理&quot;&gt;&lt;strong&gt;atomic 的原理&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。&lt;/p&gt;

&lt;p&gt;Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题&lt;/p&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">并行和并发有什么区别</summary></entry><entry><title type="html">JAVA一些问题二</title><link href="http://localhost:4000/_posts/2020-05-06-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%BA%8C/" rel="alternate" type="text/html" title="JAVA一些问题二" /><published>2020-05-06T00:00:00+08:00</published><updated>2020-05-06T00:00:00+08:00</updated><id>http://localhost:4000/_posts/JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%BA%8C</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-06-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%BA%8C/">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;java-容器都有哪些&quot;&gt;&lt;strong&gt;java 容器都有哪些&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2&gt;&lt;img src=&quot;/img/容器.png&quot; alt=&quot;容器&quot; /&gt;&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;collection-和-collections-有什么区别&quot;&gt;&lt;strong&gt;Collection 和 Collections 有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;java.util.Collection &lt;/code&gt;是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java  类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set&lt;/li&gt;
  &lt;li&gt;Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;listsetmap-之间的区别是什么&quot;&gt;&lt;strong&gt;List、Set、Map 之间的区别是什么&lt;img src=&quot;/img/区别.png&quot; alt=&quot;区别&quot; /&gt;&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;hashmap-和-hashtable-有什么区别&quot;&gt;&lt;strong&gt;HashMap 和 Hashtable 有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法&lt;/li&gt;
  &lt;li&gt;hashTable同步的，而HashMap是非同步的，效率上比hashTable要高&lt;/li&gt;
  &lt;li&gt;hashMap允许空键值，而hashTable不允许。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;如何决定使用-hashmap-还是-treemap&quot;&gt;&lt;strong&gt;如何决定使用 HashMap 还是 TreeMap&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;hashmap-的实现原理&quot;&gt;&lt;strong&gt;HashMap 的实现原理&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&lt;/p&gt;

&lt;p&gt;HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。&lt;/p&gt;

&lt;p&gt;当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。&lt;/p&gt;

&lt;p&gt;需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;hashset-的实现原理&quot;&gt;&lt;strong&gt;HashSet 的实现原理&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;HashSet底层由HashMap实现&lt;/li&gt;
  &lt;li&gt;HashSet的值存放于HashMap的key上&lt;/li&gt;
  &lt;li&gt;HashMap的value统一为PRESENT&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;arraylist-和-linkedlist-的区别&quot;&gt;**ArrayList 和 LinkedList 的区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;数组和-list-之间的转换&quot;&gt;&lt;strong&gt;数组和 List 之间的转换&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;List转换成为数组：调用ArrayList的toArray方法。&lt;/li&gt;
  &lt;li&gt;数组转换成为List：调用Arrays的asList方法。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;arraylist-和-vector-的区别&quot;&gt;**ArrayList 和 Vector 的区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。&lt;/li&gt;
  &lt;li&gt;ArrayList比Vector快，它因为有同步，不会过载。&lt;/li&gt;
  &lt;li&gt;ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;array-和-arraylist-区别&quot;&gt;&lt;strong&gt;Array 和 ArrayList 区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Array可以容纳基本类型和对象，而ArrayList只能容纳对象。&lt;/li&gt;
  &lt;li&gt;Array是指定大小的，而ArrayList大小是固定的。&lt;/li&gt;
  &lt;li&gt;Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;-queue-中-poll和-remove区别&quot;&gt;** Queue 中 poll()和 remove()区别**&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;哪些集合类是线程安全的&quot;&gt;&lt;strong&gt;哪些集合类是线程安全的&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。&lt;/li&gt;
  &lt;li&gt;statck：堆栈类，先进后出。&lt;/li&gt;
  &lt;li&gt;hashtable：就比hashmap多了个线程安全。&lt;/li&gt;
  &lt;li&gt;enumeration：枚举，相当于迭代器&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;迭代器-iterator-是什么&quot;&gt;&lt;strong&gt;迭代器 Iterator 是什么&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;iterator-怎么使用有什么特点&quot;&gt;&lt;strong&gt;Iterator 怎么使用？有什么特点&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java中的Iterator功能比较简单，并且只能单向移动：&lt;/p&gt;

&lt;p&gt;(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。&lt;/p&gt;

&lt;p&gt;(2) 使用next()获得序列中的下一个元素。&lt;/p&gt;

&lt;p&gt;(3) 使用hasNext()检查序列中是否还有元素。&lt;/p&gt;

&lt;p&gt;(4) 使用remove()将迭代器新返回的元素删除。&lt;/p&gt;

&lt;p&gt;Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;iterator-和-listiterator-有什么区别&quot;&gt;&lt;strong&gt;Iterator 和 ListIterator 有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。&lt;/li&gt;
  &lt;li&gt;Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。&lt;/li&gt;
  &lt;li&gt;ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">java 容器都有哪些</summary></entry><entry><title type="html">新型冠状肺炎数据可视化</title><link href="http://localhost:4000/_posts/2020-05-06-%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E8%82%BA%E7%82%8E%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="alternate" type="text/html" title="新型冠状肺炎数据可视化" /><published>2020-05-06T00:00:00+08:00</published><updated>2020-05-06T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E8%82%BA%E7%82%8E%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-06-%E6%96%B0%E5%9E%8B%E5%86%A0%E7%8A%B6%E8%82%BA%E7%82%8E%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">&lt;h4 id=&quot;时间20200110--20200412&quot;&gt;时间:2020.01.10 ~ 2020.04.12&lt;/h4&gt;

&lt;h4 id=&quot;国内数据&quot;&gt;国内数据&lt;/h4&gt;

&lt;h4 id=&quot;主要数据来源&quot;&gt;主要数据来源：&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-http&quot;&gt;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5
https://view.inews.qq.com/g2/getOnsInfo?name=disease_other
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后续网站可能没有维护，在此保存了&lt;code&gt;sql&lt;/code&gt;文件:&lt;code&gt;cov.sql&lt;/code&gt;,您只需导入即可&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用前请修改相应的&lt;code&gt;sql&lt;/code&gt;连接配置&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;spider.py &lt;/code&gt;&amp;amp; &lt;code&gt;utils.py&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt; conn = pymysql.connect(host=&quot;######&quot;, user=&quot;#####&quot;, password=&quot;#######&quot;, db=&quot;cov&quot;, charset=&quot;utf8&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/img/cov.jpg&quot; alt=&quot;cov&quot; /&gt;&lt;/p&gt;

&lt;p&gt;项目地址:https://github.com/verylazycat/COV_2020&lt;/p&gt;</content><author><name></name></author><category term="数据可视化" /><summary type="html">时间:2020.01.10 ~ 2020.04.12</summary></entry><entry><title type="html">JAVA一些问题一</title><link href="http://localhost:4000/_posts/2020-05-05-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%80/" rel="alternate" type="text/html" title="JAVA一些问题一" /><published>2020-05-05T00:00:00+08:00</published><updated>2020-05-05T00:00:00+08:00</updated><id>http://localhost:4000/_posts/JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%80</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-05-JAVA%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E4%B8%80/">&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;jdk--jre区别&quot;&gt;&lt;code&gt;JDK&lt;/code&gt; &amp;amp; &lt;code&gt;JRE&lt;/code&gt;区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;JRE&lt;/code&gt;:Java RunTime Environment&lt;/p&gt;

&lt;p&gt;&lt;code&gt;JDK&lt;/code&gt;:Java Development Kit&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;JDK顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器&lt;code&gt;javac&lt;/code&gt;，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/jdk&amp;amp;jre.png&quot; alt=&quot;jdk&amp;amp;jre&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;-和equals区别&quot;&gt;&lt;code&gt;==&lt;/code&gt; 和&lt;code&gt;equals&lt;/code&gt;区别&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;==&lt;/code&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;基本类型:&lt;code&gt;==&lt;/code&gt;比较值是否相同&lt;/li&gt;
      &lt;li&gt;引用类型:&lt;code&gt;==&lt;/code&gt;比较引用是否相同&lt;/li&gt;
    &lt;/ol&gt;

    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String x = &quot;string&quot;;
String y = &quot;string&quot;;
String z = new String(&quot;string&quot;);
System.out.println(x==y);  //true
System.out.println(x==z);  //false
System.out.println(x.equals(y));  //true
System.out.println(x.equals(z));  //true
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;equals&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;String&lt;/code&gt;和&lt;code&gt;Integer&lt;/code&gt;重写了equals方法,默认&lt;code&gt;equals&lt;/code&gt;比较有相同值的对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;static class  Cat{
        private  String name;
        public Cat(String name){
            this.name = name;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
    public static void main(String[] args) {
        Cat cat1  = new Cat(&quot;one&quot;);
        Cat cat2 = new Cat(&quot;one&quot;);
        System.out.println(cat1.equals(cat2)); // false
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;equals源码 (本质就是&lt;code&gt;==&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public boolean equals(Object var1) {
    return this == var1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;String 重写了&lt;code&gt;equals&lt;/code&gt;，源码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public boolean equals(Object var1) {
    if (this == var1) {
        return true;
    } else {
        if (var1 instanceof String) {
            String var2 = (String)var1;
            int var3 = this.value.length;
            if (var3 == var2.value.length) {
                char[] var4 = this.value;
                char[] var5 = var2.value;
                for(int var6 = 0; var3-- != 0; ++var6) {
                    if (var4[var6] != var5[var6]) {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：&lt;code&gt;==&lt;/code&gt;用于值的比较,&lt;code&gt;equals&lt;/code&gt;用于引用的比较，不过String ,Integer等重写了&lt;code&gt;equals&lt;/code&gt;，所以一般情况下，&lt;code&gt;equals&lt;/code&gt;比较值是否相同&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;hashcode相同equals一定为true吗&quot;&gt;&lt;code&gt;hashcode&lt;/code&gt;相同,&lt;code&gt;equals&lt;/code&gt;一定为&lt;code&gt;true&lt;/code&gt;吗?&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不一定，反例如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String str1 = &quot;通话&quot;;
String str2 = &quot;重地&quot;;
//        str:1179395 | str2:1179395
System.out.println(String.format(&quot;str:%d | str2:%d&quot;,str1.hashCode(),str2.hashCode()));
//        false
System.out.println(str1.equals(str2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在散列表中，&lt;code&gt;hashcode&lt;/code&gt;相等则两个键值对的哈希值相等，然而哈希值相等，并不能得出键值对相等&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;final&quot;&gt;&lt;code&gt;final&lt;/code&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;final&lt;/code&gt;修饰的类叫最终类，，不能被继承&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;final&lt;/code&gt;修饰的方法不能被重写&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;final&lt;/code&gt;修饰的变量叫常量，必须被初始化，之后不能被修改&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;mathround-15值&quot;&gt;Math.round(-1.5)值&lt;/h2&gt;

    &lt;p&gt;-1&lt;/p&gt;

    &lt;p&gt;中间值0.5向右取&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;java基础数据类型&quot;&gt;Java基础数据类型&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;byte&lt;/li&gt;
  &lt;li&gt;boolean&lt;/li&gt;
  &lt;li&gt;char&lt;/li&gt;
  &lt;li&gt;short&lt;/li&gt;
  &lt;li&gt;int&lt;/li&gt;
  &lt;li&gt;float&lt;/li&gt;
  &lt;li&gt;long&lt;/li&gt;
  &lt;li&gt;double&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;字符串操作类&quot;&gt;字符串操作类&lt;/h2&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;StringBuffer&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;StringBuilder&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;code&gt;String&lt;/code&gt;声明的是不可变的对象，每次操作都会产生新的&lt;code&gt;String&lt;/code&gt;对象，然后指针指向新的对象，&lt;code&gt;StringBuffer&lt;/code&gt;和&lt;code&gt;StringBuilder&lt;/code&gt;可以在原有的对象上操作．&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt;和&lt;code&gt;StringBuilder&lt;/code&gt;区别：&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt;是线程安全的，而&lt;code&gt;StringBuilder&lt;/code&gt;是非线程安全的，但是&lt;code&gt;StringBuilder&lt;/code&gt;性能高于&lt;code&gt;SringBuffer&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;string-stri与-string-strnew-stringi一样吗&quot;&gt;String str=”i”与 String str=new String(“i”)一样吗？&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不一样，内存分配方式不一样．String str=”i”的方式，java 虚拟机会将其分配到&lt;code&gt;常量池&lt;/code&gt;中；而 String str=new String(“i”) 则会被分到&lt;code&gt;堆内存&lt;/code&gt;中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;如何将字符串反转&quot;&gt;如何将字符串反转？&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用&lt;code&gt;StringBuilder&lt;/code&gt;或者&lt;code&gt;StringBuffer&lt;/code&gt;的&lt;code&gt;reverse()&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
		StringBuilder str = new StringBuilder(&quot;hello&quot;);
		System.out.println(str.reverse());    //olleh
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;string-类的常用方法都有那些&quot;&gt;&lt;strong&gt;String 类的常用方法都有那些&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;indexOf()：返回指定字符的索引&lt;/li&gt;
  &lt;li&gt;charAt()：返回指定索引处的字符&lt;/li&gt;
  &lt;li&gt;replace()：字符串替换&lt;/li&gt;
  &lt;li&gt;trim()：去除字符串两端空白&lt;/li&gt;
  &lt;li&gt;split()：分割字符串，返回一个分割后的字符串数组&lt;/li&gt;
  &lt;li&gt;getBytes()：返回字符串的 byte 类型数组&lt;/li&gt;
  &lt;li&gt;length()：返回字符串长度&lt;/li&gt;
  &lt;li&gt;toLowerCase()：将字符串转成小写字母&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;toUpperCase()：将字符串转成大写字符&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;substring()：截取字符串&lt;/li&gt;
  &lt;li&gt;equals()：字符串比较&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String str = new String(&quot; Hello &quot;);
		System.out.println(str.indexOf('o'));
		System.out.println(str.charAt(1));
		System.out.println(str.replace('o', 'O'));
		System.out.println(str.trim());
		System.out.println(str.getBytes());
		System.out.println(str.length());
		System.out.println(str.toLowerCase());
		System.out.println(str.toUpperCase());
		System.out.println(str.substring(1, 3));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;抽象类必须要有抽象方法吗&quot;&gt;&lt;strong&gt;抽象类必须要有抽象方法吗&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;abstract class Cat {
    public static void sayHi() {
        System.out.println(&quot;hi~&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;普通类和抽象类有哪些区别&quot;&gt;&lt;strong&gt;普通类和抽象类有哪些区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;普通类不能包含抽象方法，抽象类可以包含抽象方法&lt;/li&gt;
  &lt;li&gt;抽象类不能直接实例化，普通类可以直接实例化&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;抽象类能使用-final-修饰吗&quot;&gt;&lt;strong&gt;抽象类能使用 final 修饰吗&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;接口和抽象类有什么区别&quot;&gt;&lt;strong&gt;接口和抽象类有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口&lt;/li&gt;
  &lt;li&gt;构造函数：抽象类可以有构造函数；接口不能有&lt;/li&gt;
  &lt;li&gt;main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法&lt;/li&gt;
  &lt;li&gt;实现数量：类可以实现很多个接口；但是只能继承一个抽象类&lt;/li&gt;
  &lt;li&gt;访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;java-中-io-流分为几种&quot;&gt;&lt;strong&gt;java 中 IO 流分为几种&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;按功能来分：输入流（input）、输出流（output）。&lt;/p&gt;

&lt;p&gt;按类型来分：字节流和字符流。&lt;/p&gt;

&lt;p&gt;字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;bionioaio-有什么区别&quot;&gt;&lt;strong&gt;&lt;code&gt;BIO&lt;/code&gt;、&lt;code&gt;NIO&lt;/code&gt;、&lt;code&gt;AIO&lt;/code&gt; 有什么区别&lt;/strong&gt;&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低&lt;/li&gt;
  &lt;li&gt;NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用&lt;/li&gt;
  &lt;li&gt;AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;files的常用方法都有哪些&quot;&gt;&lt;strong&gt;Files的常用方法都有哪些&lt;/strong&gt;&lt;/h2&gt;

    &lt;ol&gt;
      &lt;li&gt;Files.exists()：检测文件路径是否存在&lt;/li&gt;
      &lt;li&gt;Files.createFile()：创建文件&lt;/li&gt;
      &lt;li&gt;Files.createDirectory()：创建文件夹&lt;/li&gt;
      &lt;li&gt;Files.delete()：删除一个文件或目录&lt;/li&gt;
      &lt;li&gt;Files.copy()：复制文件&lt;/li&gt;
      &lt;li&gt;Files.move()：移动文件&lt;/li&gt;
      &lt;li&gt;Files.size()：查看文件个数&lt;/li&gt;
      &lt;li&gt;Files.read()：读取文件&lt;/li&gt;
      &lt;li&gt;Files.write()：写入文件&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">JDK &amp;amp; JRE区别</summary></entry><entry><title type="html">数据结构－线性表</title><link href="http://localhost:4000/_posts/2020-05-04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="alternate" type="text/html" title="数据结构－线性表" /><published>2020-05-04T00:00:00+08:00</published><updated>2020-05-04T00:00:00+08:00</updated><id>http://localhost:4000/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-04-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/">&lt;h4 id=&quot;创建线性表和链表实现表之间的链接并去掉重复&quot;&gt;创建线性表和链表，实现表之间的链接，并去掉重复&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;error.h&amp;gt;

//数据类型声明
typedef int DataType;

//顺序表实现
//顺序表结构定义
typedef struct orderList
{
    DataType *value;//数据
    size_t size;//当前数据大小
    size_t max;//最大存储容量
}orderList;

//创建orderList
orderList *CreateOrderList(void)
{
    orderList *list = NULL;
    list = malloc(sizeof(orderList *));
    if (list == NULL)
    {
        perror(&quot;malloc:&quot;);
        exit(EXIT_FAILURE);
    }
    else
    {
        printf(&quot;顺序表创建成功!,adress:%p\n&quot;,list);
        printf(&quot;---------------------------------------\n&quot;);
        return list;
    }
}

//orderList 初始化
//max : 最大长度
int OrderListInit(orderList *list,size_t max)
{
    list-&amp;gt;value = malloc(sizeof(DataType) * max);
    if (list-&amp;gt;value == NULL)
    {
        perror(&quot;malloc&quot;);
        // exit(EXIT_FAILURE);
        return -1;
    }
    list-&amp;gt;size = 0;
    list-&amp;gt;max = max;
    return 1;
}

//顺序表插入值，当插入-1退出
//有缺陷，不能插入-1
void InsertOrderList(orderList *list)
{
    if (list == NULL)
    {
        printf(&quot;list is not create or init \n&quot;);
        exit(EXIT_FAILURE);
    }
    printf(&quot;Enter the value you want,while enter -1 exit:\n&quot;);
    //计数，是否达到上限
    DataType temp = 0;
    for ( int i = 0; i &amp;lt; list-&amp;gt;max; i++)
    {
        scanf(&quot;%d&quot;,&amp;amp;temp);
        if (temp == -1)
        {
            printf(&quot;exit\n&quot;);
            printf(&quot;---------------------------------------\n&quot;);
            break;            
        }
        list-&amp;gt;value[i] =  temp;
        list-&amp;gt;size++;
    }
}

//打印
void DisplayOrderList(orderList *list)
{
    if (list == NULL)
    {
        printf(&quot;list is not create or init \n&quot;);
        exit(EXIT_FAILURE);
    }
    for (int  i = 0; i &amp;lt; list-&amp;gt;size; i++)
    {
        printf(&quot;value:%d\tsize:%ld,max:%ld\taddress:%p\n&quot;,list-&amp;gt;value[i], list-&amp;gt;size,list-&amp;gt;max,&amp;amp;list-&amp;gt;value[i]);
    }
    printf(&quot;---------------------------------------\n&quot;);
}

//链接两个线性表

orderList *linkTwoOrderList(orderList *listDes,orderList *listFrom)
{
    //先判断输入是否合法
    if (listDes == NULL)
    {
        printf(&quot;listDes is not create or init \n&quot;);
        exit(EXIT_FAILURE);
    }
    if (listFrom == NULL)
    {
        printf(&quot;listFrom is not create or init \n&quot;);
        exit(EXIT_FAILURE);
    }
    orderList *list = NULL;
    list = malloc(sizeof(orderList *));
    if (list == NULL)
    {
        printf(&quot;listFrom is not create or init \n&quot;);
        exit(EXIT_FAILURE);
    }
    list-&amp;gt;max = listDes-&amp;gt;max + listFrom-&amp;gt;max;
    list-&amp;gt;value = malloc(sizeof(DataType)*list-&amp;gt;max);
    list-&amp;gt;size = 0;
    if (list == NULL)
    {
        perror(&quot;malloc:&quot;);
        exit(EXIT_FAILURE);
    }
    //两次循环，填充list
    //注意顺序，from ---&amp;gt;&amp;gt; des
    int temp = 0;
    for (int  i = 0; i &amp;lt; listDes-&amp;gt;size; i++,temp ++)
    {
        list-&amp;gt;value[i] = listDes-&amp;gt;value[i];
        list-&amp;gt;size ++;
    }
    for (int  i = 0; i &amp;lt; listFrom-&amp;gt;size; i++,temp++)
    {
        list-&amp;gt;value[temp] = listFrom-&amp;gt;value[i];
        list-&amp;gt;size ++;
    }
    printf(&quot;链接成功\n&quot;);
    return list;
}
//删除array某值
//不越界情况下
void DelArrayIndex(orderList *array,int size)
{
int i,j,k=0;
    for(i=0;i&amp;lt;size;++i)
    {
        for(j=i+1;j&amp;lt;size &amp;amp;&amp;amp; array-&amp;gt;value[i]-array-&amp;gt;value[j];++j);
        if(!(j-size))
            array-&amp;gt;value[k++]=array-&amp;gt;value[i];
    }
    //调整array size
    array-&amp;gt;size = k;
}
//去重
orderList *RemoveRepeatValue(orderList *list)
{
    if (list == NULL)
    {
        printf(&quot;Invalid list\n&quot;);
        exit(EXIT_FAILURE);
    }
    DelArrayIndex(list,list-&amp;gt;size);
    return list;
}
// -------------------------------------------------

//单链表实现
//node定义
typedef struct listNode
{
    DataType value;
    struct  listNode *next;
}listNode;

//list定义
typedef struct List
{
    listNode *head;
    listNode *tail;
    size_t len;
}List;

//list创建
List *CreateList(void )
{
    List *list  = NULL;
    list = malloc(sizeof(List *));
    if(list == NULL)
    {
        perror(&quot;malloc:&quot;);
        exit(EXIT_FAILURE);
    }
    list-&amp;gt;head = NULL;
    list-&amp;gt;tail = NULL;
    list-&amp;gt;len = 0;
    return list;
}
//尾插
//.....
//在表头插入节点
int InserNode(List *dlist,DataType data)
{
    listNode *pNode = NULL;
    pNode = malloc(sizeof(listNode *));
    if (pNode == NULL)
    {
        perror(&quot;malloc&quot;);
        return -1;
    }
    pNode-&amp;gt;value = data;
    pNode-&amp;gt;next = NULL;
    // pNode-&amp;gt;prev = NULL;

    if (dlist-&amp;gt;len == 0)//表示当前链表无节点
    {
        dlist-&amp;gt;head = pNode;
        dlist-&amp;gt;tail = pNode;
    }
    else//已有节点
    {
        pNode-&amp;gt;next = dlist-&amp;gt;head;
        // dlist-&amp;gt;head-&amp;gt;prev = pNode;
        dlist-&amp;gt;head = pNode;
    }
    dlist-&amp;gt;len ++;
    return 0;
}


//print list
void DisplayList(List *list)
{
    if(list == NULL)
    {
        perror(&quot;malloc:&quot;);
        exit(EXIT_FAILURE);
    }
    if(list-&amp;gt;len == 0)
    {
        printf(&quot;list is Empty\n&quot;);
        exit(EXIT_SUCCESS);
    }
    listNode *temp = list-&amp;gt;head;//一定不要直接操作list,要间接操作!!!!!!
    for (int i = 0; i &amp;lt; list-&amp;gt;len; i++)
    {
        printf(&quot;value=%d\tadress=%p\tnextAdress=%p\n&quot;,temp-&amp;gt;value,temp,temp-&amp;gt;next);
        //交换
        temp = temp-&amp;gt;next;
    }
}
//链接
List  *linkTwoList(List *desList,List *fromList)
{
    if(desList == NULL || fromList == NULL)
    {
        printf(&quot;Invalid List\n&quot;);
        exit(EXIT_FAILURE);
    }
    List *list = NULL;
    list = malloc(sizeof(List *));
    if(list == NULL)
    {
        perror(&quot;malloc:&quot;);
        exit(EXIT_FAILURE);
    }
    list-&amp;gt;len = desList-&amp;gt;len + fromList-&amp;gt;len;
    list-&amp;gt;head = desList-&amp;gt;head;
    desList-&amp;gt;tail-&amp;gt;next = fromList-&amp;gt;head;
    list-&amp;gt;tail = fromList-&amp;gt;tail;
    return list;
}

void pur_LinkList(List *L){
	listNode *p,*s,*q;
	p=L-&amp;gt;head-&amp;gt;next;
	if(!p)	
        return;
	while(p)
	{
        //固定p所指结点，向后遍历，寻找与之数据域相同的结点
		q=p;
		while(q-&amp;gt;next)				
		{
            //在这里将q-&amp;gt;next所指的结点存放数据与p作比较
			if(q-&amp;gt;next-&amp;gt;value==p-&amp;gt;value)	
			{
				s=q-&amp;gt;next;
				q-&amp;gt;next=s-&amp;gt;next;
				free(s);
                L-&amp;gt;len --;
			}
			else q=q-&amp;gt;next;
		}
		p=p-&amp;gt;next;
	}
}

// #define __BUILD_OderList__
#define __BUILD_List_
int main(int argc, char const *argv[])
{
    #ifdef __BUILD_OderList__
    //创建
    orderList *listOne = CreateOrderList();
    orderList *listTwo = CreateOrderList();
    orderList *listTree = CreateOrderList();
    //init
    printf(&quot;orderOne:&quot;);
    OrderListInit(listOne,5);
    //插入
    InsertOrderList(listOne);
    printf(&quot;orderTwo:&quot;);
    OrderListInit(listTwo,5);
    InsertOrderList(listTwo);
    //printf
    DisplayOrderList(listOne);
    DisplayOrderList(listTwo);
    //链接
    listTree = linkTwoOrderList(listOne,listTwo);
    printf(&quot;listOne 链接 listTwo:\n&quot;);
    DisplayOrderList(listTree);
    //去重
    listTree = RemoveRepeatValue(listTree);
    printf(&quot;去掉重复元素:\n&quot;);
    DisplayOrderList(listTree);
    #endif    
    //--------------------------------
    #ifdef  __BUILD_List_
    List *listOne = CreateList();
    List *listTwo = CreateList();
    List *listThres = CreateList();
    //插值
    InserNode(listOne,1);
    InserNode(listOne,1);
    InserNode(listOne,0);
    //插值
    InserNode(listTwo,4);
    InserNode(listTwo,3);
    InserNode(listTwo,2);
    printf(&quot;初始化完成\n&quot;);
    printf(&quot;listOne:\n&quot;);
    DisplayList(listOne);
    printf(&quot;-----------------------------------\n&quot;);
    printf(&quot;listTwo:\n&quot;);
    DisplayList(listTwo);
    printf(&quot;-----------------------------------\n&quot;);
    listThres = linkTwoList(listOne,listTwo);
    printf(&quot;链接成功:\n&quot;);
    DisplayList(listThres);
    printf(&quot;-----------------------------------\n&quot;);
    pur_LinkList(listThres);
    printf(&quot;去重成功:\n&quot;);
    DisplayList(listThres);
    #endif
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="数据结构" /><summary type="html">创建线性表和链表，实现表之间的链接，并去掉重复</summary></entry><entry><title type="html">jdbc笔记</title><link href="http://localhost:4000/_posts/2020-05-02-jdbc%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="jdbc笔记" /><published>2020-05-02T00:00:00+08:00</published><updated>2020-05-02T00:00:00+08:00</updated><id>http://localhost:4000/_posts/jdbc%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-02-jdbc%E7%AC%94%E8%AE%B0/">&lt;h2 id=&quot;jdbc笔记&quot;&gt;jdbc笔记&lt;/h2&gt;

&lt;h4 id=&quot;jdbc双层架构&quot;&gt;jdbc双层架构&lt;/h4&gt;

&lt;h4&gt;&lt;img src=&quot;/img/jdbc1.png&quot; alt=&quot;jdbc1&quot; /&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;作用：此架构中，Java Applet 或应用直接访问数据源。&lt;/li&gt;
  &lt;li&gt;条件:要求 Driver 能与访问的数据库交互&lt;/li&gt;
  &lt;li&gt;机制:用户命令传给数据库或其他数据源，随之结果被返回。&lt;/li&gt;
  &lt;li&gt;部署:数据源可以在另一台机器上，用户通过网络连接，称为 C/S配置（可以是内联网或互联网）&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;jdbc三层架构&lt;img src=&quot;/img/jdbc2.png&quot; alt=&quot;jdbc2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;侧架构特殊之处在于，引入中间层服务.&lt;/p&gt;

&lt;p&gt;流程：命令和结构都会经过该层。&lt;/p&gt;

&lt;p&gt;吸引：可以增加企业数据的访问控制，以及多种类型的更新；另外，也可简化应用的部署，并在多数情况下有性能优势。&lt;/p&gt;

&lt;p&gt;历史趋势： 以往，因性能问题，中间层都用 C 或 C++ 编写，随着优化编译器（将 Java 字节码 转为 高效的  特定机器码）和技术的发展，如EJB，Java 开始用于中间层的开发这也让 Java 的优势突显出现出来，使用 Java  作为服务器代码语言，JDBC随之被重视。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;步骤&quot;&gt;步骤&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;加载驱动&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;建立连接&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Connection  conn = DriverManager.getConnection(URL,USER,PASSWORD);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;执行sql&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String sql = &quot;select * from details&quot;;
注意没有分号
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;结果&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;while(rs.next()){
                    System.out.println(rs.getString(&quot;字段&quot;));
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;释放资源&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;rs.close();
conn.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.sql.*;

public class mysqltest {
    public static final String URL = &quot;jdbc:mysql://localhost:3306/cov&quot;;
    public static  final  String USER = &quot;admin&quot;;
    public static final String PASSWORD = &quot;admin&quot;;
    public static void main(String[] args) {
       //加载驱动
        try {
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
            Connection conn = null;
            try {
                conn = DriverManager.getConnection(URL,USER,PASSWORD);
                System.out.println(&quot;连接成功&quot;);
                Statement statement = conn.createStatement();
                String sql = &quot;select * from details&quot;;
                ResultSet rs;
                rs = statement.executeQuery(sql);
                while(rs.next()){
                    System.out.println(rs.getString(&quot;city&quot;));
                }
                rs.close();
                conn.close();
            } catch (SQLException throwables) {
                System.out.println(&quot;连接失败&quot;);
                throwables.printStackTrace();
            }
        } catch (ClassNotFoundException e) {
            System.out.println(&quot;驱动加载失败&quot;);
            e.printStackTrace();
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;外部配置信息建立连接&quot;&gt;外部配置信息建立连接&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;在resource下新建文件mysqlproperties&quot;&gt;在resource下新建文件&lt;code&gt;mysql.properties&lt;/code&gt;&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/cov
user=admin
password=admin
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;配置文件读取&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Properties properties = new Properties();
        FileInputStream inputStream = new FileInputStream(&quot;resource/mysql.properties&quot;);  //注意路径
        properties.load(inputStream);

        String driver = properties.getProperty(&quot;driver&quot;);
        String url = properties.getProperty(&quot;url&quot;);
        String user = properties.getProperty(&quot;user&quot;);
        String pwd=properties.getProperty(&quot;password&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取配置信息更好方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//通过反射
InputStream inputStream = this(当前类的Class对象).getResourceAsStream(&quot;/mysql.properties&quot;); 
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><category term="JAVA" /><summary type="html">jdbc笔记</summary></entry><entry><title type="html">sql-server复习</title><link href="http://localhost:4000/_posts/2020-05-02-sql-server%E5%A4%8D%E4%B9%A0%E4%B8%80/" rel="alternate" type="text/html" title="sql-server复习" /><published>2020-05-02T00:00:00+08:00</published><updated>2020-05-02T00:00:00+08:00</updated><id>http://localhost:4000/_posts/sql-server%E5%A4%8D%E4%B9%A0%E4%B8%80</id><content type="html" xml:base="http://localhost:4000/_posts/2020-05-02-sql-server%E5%A4%8D%E4%B9%A0%E4%B8%80/">&lt;h2 id=&quot;sql-server复习一&quot;&gt;sql-server复习一&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;基础概念&quot;&gt;基础概念&lt;/h4&gt;

    &lt;ol&gt;
      &lt;li&gt;数据库(Data)&lt;/li&gt;
      &lt;li&gt;数据库(Database)&lt;/li&gt;
      &lt;li&gt;数据库管理系统(DBMS)&lt;/li&gt;
      &lt;li&gt;数据库系统(DBS)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库系统组成&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;数据库&lt;/li&gt;
      &lt;li&gt;数据库管理系统&lt;/li&gt;
      &lt;li&gt;应用程序&lt;/li&gt;
      &lt;li&gt;数据库管理员&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DBMS主要功能&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;数据库的定义功能:定义语言DDL来定义数据库的三级结构、两级映象，定义数据的完整性约束、保密限制等约束&lt;/li&gt;
      &lt;li&gt;数据库的操纵功能：操纵语言DML实现对数据的基本操作，数据查询和数据更新&lt;/li&gt;
      &lt;li&gt;数据库的保护功能：数据库恢复、数据库的并发控制、数据完整性控制、数据安全性控制&lt;/li&gt;
      &lt;li&gt;数据库的维护功能：数据库的数据载入、转换、转储、数据库的改组以及性能监控工能&lt;/li&gt;
      &lt;li&gt;数据字典（DD）：对数据库的操作都要通过DD才能实现，DD还存放数据库运行时的统计信息&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库管理员(DBA)职责&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;决定数据库中的信息内容和结构：数据库中要存放哪些信息，DBA要参与决策&lt;/li&gt;
      &lt;li&gt;决定数据库的存储结构和存取策略：DBA要综合各用户的应用要求，和数据库设计人员共同决定数据的存储结构和存取策略，以求获得较高的存取效率和存储空间利用率&lt;/li&gt;
      &lt;li&gt;定义数据的安全性要求和完整性约束条件：DBA的重要职责是保证数据库的安全性和完整性&lt;/li&gt;
      &lt;li&gt;监控数据库的使用和运行：DBA还有一个重要职责就是监视数据库系统的运行情况，及时处理运行过程中出现的问题。比如系统发生各种故障时，数据库会因此遭到不同程度的破坏，DBA必须在最短时间内将数据库恢复到正确状态，并尽可能不影响或少影响计算机系统其他部分的正常运行&lt;/li&gt;
      &lt;li&gt;数据库的改进、重组或重构：DBA还负责在系统运行期间监视系统的空间利用率、处理效率等性能指标，对运行情况进行记录、统计分析，依靠工作实践并根据实际应用环境，不断改进数据库设计&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;三级模式体系结构&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;外部级（External）&lt;/li&gt;
      &lt;li&gt;概念级（Conceptual）&lt;/li&gt;
      &lt;li&gt;内部级（Internal）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模式/内模式映像
由于这两级的数据结构可能不一致，即记录类型、字段类型的命名和组成可能不一样，因此需要这个映像说明概念记录和内部记录之间的对应性。模式/内模式映像一般是放在内模式中描述的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;外模式/模式映像
 外模式/模式映像一般是放在外模式中描述的。三级模式结构中，模式即全局逻辑结构是数据库的中心与关键，它独立于其他层次。因此设计数据库模式结构时应首先确定数据库的逻辑模式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据独立性（Data Independence）&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;物理数据独立性
如果数据库的内模式要修改，即数据库的物理结构有所变化，那么只要对模式/内模式映像做相应的修改即可。&lt;/li&gt;
      &lt;li&gt;逻辑数据独立性  &lt;br /&gt;
   如果数据库的概念模式要修改，譬如增加记录类型或增加数据项，那么只要对外模式/模式映像做相应的修改，可以使外模式和应用程序尽可能保持不变。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据处理的三个阶段&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;概念数据模型：&lt;/p&gt;

        &lt;p&gt;独立于计算机系统的数据模型，完全不涉及信息在计算机中的表示，只是用来描述某个特定组织所关心的信息结构&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;逻辑数据模型：&lt;/p&gt;

        &lt;p&gt;是直接面向数据库的逻辑结构，它是对现实世界的第二层抽象。这类模型直接与DBMS有关，简称“逻辑模型”。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;ER&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ER（实体─联系方法）图提供了表示实体型、属性和联系的方法：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;实体型：用矩形表示，矩形框内写明实体名。&lt;/li&gt;
      &lt;li&gt;属性：用椭圆形表示，并用无向边将其与相应的实体型连接起来。&lt;img src=&quot;/img/er.png&quot; alt=&quot;er&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1:1，1:N或M:N）&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;img src=&quot;/img/联系.png&quot; alt=&quot;联系&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;二元联系主&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;一对一联系（1:1）：如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为l:1&lt;/li&gt;
      &lt;li&gt;一对多联系（1:N）：如果对于实体集A中的每一个实体，实体集B中有N（N≥0）个实体与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系，记为1:N&lt;/li&gt;
      &lt;li&gt;多对多联系（M:N）：如果对于实体集A中的每一个实体，实体集B中有N（N≥0）个实体与之联系，反之，对于实体集B中的每一个实体，实体集A中也有M（M≥0）个实体与之联系，则称实体集A与实体集B具有多对多联系，记为M:N&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;三元联系和一元联系&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;三元联系是三个实体之间的联系，这些实体之间也存在着一对一、一对多或多对多的联系。例如，对于课程、教师与参考书3个实体，如果一门课程可以有多个教师讲授，使用若干本参考书，而每一个教师只讲授一门课程，每一本参考书只供一门课程使用，则课程与教师、参考书之间的联系是一对多的&lt;/li&gt;
  &lt;li&gt;同一个实体集内的各实体之间也可以存在一对一、一对多、多对多的联系，称为一元联系。例如，一个公司的所有员工组成的实体集内部具有领导与被领导的联系，即某一员工（经理）领导若干名员工，而一个员工仅被另外一个员工（经理）直接领导，因此这是一对多的联&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;逻辑模型&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;在数据库系统中，传统的逻辑模型有层次模型、网状模型和关系模型三种，非传统的逻辑模型有面向对象模型（Object-Oriented model，OO）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;逻辑模型中的数据描述&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;字段（field）：标记实体属性的命名单位称为字段或数据项。字段的命名往往和属性名相同。例如学生有学号、姓名、性别、年龄等字段。&lt;/li&gt;
      &lt;li&gt;记录（record）：字段的有序集合称为记录。一般用一个记录描述一个实体，所以记录又可以定义为能完整地描述一个实体的字段集。&lt;/li&gt;
      &lt;li&gt;文件（file）： 同一类记录的集合称为文件。文件是用来描述实体集的。
关键码（key）： 能惟一标识文件中每个记录的字段或字段集，称为记录的关键码（简称为键）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;层次数据模型的数据结构&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;在数据库中定义满足下面两个条件的基本层次联系的集合为层次模型。有且只有一个结点没有双亲结点，这个结点称为根结点；&lt;/li&gt;
      &lt;li&gt;根以外的其他结点有且只有一个双亲结点&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;层次模型的优点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;层次模型的数据结构比较简单清晰。&lt;/li&gt;
      &lt;li&gt;层次数据库的查询效率高。因为层次模型中记录之间的联系用有向边表示，这种联系在DBMS中常常用指针来实现。因此这种联系也就是记录之间的存取路径。当要存取某个结点的记录值，DBMS就沿着这一条路径很快找到该记录值，所以，层次数据库的查询性能优于关系数据库，不低于网状数据库。&lt;/li&gt;
      &lt;li&gt;层次数据模型提供了良好的完整性支持。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;层次模型的缺点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;现实世界中很多联系是非层次型的，如结点之间具有多对多联系。&lt;/li&gt;
      &lt;li&gt;一个结点具有多个双亲等，层次模型表示这类联系的方法很笨拙，只能通过引入冗余数据（易产生不一致性）或创建非自然的数据结构（引入虚拟结点）来解决。对插入和删除操作的限制比较多，因此应用程序的编写比较复杂。&lt;/li&gt;
      &lt;li&gt;查询子女结点必须通过双亲结点。&lt;/li&gt;
      &lt;li&gt;由于结构严密，层次命令趋于程序化&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网状数据模型的数据结构&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型：允许一个以上的结点无双亲；一个结点可以有多于一个的双亲。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网状数据模型的优点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;能够更为直接地描述现实世界，如一个结点可以有多个双亲。结点之间可以有多种联系。&lt;/li&gt;
      &lt;li&gt;具有良好的性能，存取效率较高&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网状数据模型的缺点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握。&lt;/li&gt;
      &lt;li&gt;网状模型的DDL、DML复杂，并且要嵌入某一种高级语言（如COBOL、C）中。因此用户不易掌握和使用。&lt;/li&gt;
      &lt;li&gt;由于记录之间的联系是通过存取路径实现的，应用程序在访问数据时必须选择适当的存取路径，因此，用户必须了解系统结构的细节。这样就加重了编写应用程序的负担&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系数据模型的数据结构&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;关系（Relation）： 一个关系对应通常说的一张表，如表2.2中的这张学生登记表。元组（Tuple） 表中的一行即为一个元组。&lt;/li&gt;
      &lt;li&gt;属性（Attribute）： 表中的一列即为一个属性，给每一个属性起一个名称即属性名。如这张表有6列，对应6个属性：学号，姓名，年龄，性别，系名和年级。&lt;/li&gt;
      &lt;li&gt;码（Key）： 也称为码键。表中的某个属性组，它可以惟一确定一个元组，如表2.2中的学号，可以惟一确定一个学生，也就成为本关系的码。&lt;/li&gt;
      &lt;li&gt;域（Domain）： 属性的取值范围，如人的年龄一般在1～150岁之间，大学生年龄属性的域是（14～38），性别的域是（男，女），系名的域是一个学校所有系名的集合。分量 元组中的一个属性值。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系模式&lt;/p&gt;

    &lt;p&gt;关系名（属性l，属性2，…，属性n）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系数据模型优点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;关系模型与非关系模型不同，它是建立在严格的数学概念的基础上的。&lt;/li&gt;
      &lt;li&gt;关系模型的概念单一。无论实体还是实体之间的联系都用关系来表示。对数据的检索和更新结果也是关系（即表）。所以其数据结构简单、清晰，用户易懂易用。&lt;/li&gt;
      &lt;li&gt;关系模型的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关系数据模型缺点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;由于存取路径对用户透明，查询效率往往不如非关系数据模型。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;面向对象模型&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;对象（Object）： 对象是现实世界中实体的模型化，与记录概念相仿，但远比记录复杂。每个对象有一个惟一的标识符，把状态（State）和行为（Behavior）封装（Encapsulate）在一起。其中，对象的状态是该对象属性值的集合，对象的行为是在对象状态上操作的方法集。&lt;/li&gt;
      &lt;li&gt;类（Class）： 将属性集和方法集相同的所有对象组合在一起，构成了一个类。类的属性值域可以是基本数据类型（整型、实型、字符串型），也可以是记录类型和集合类型。也就是类可以有嵌套结构。系统中所有的类组成了一个有根的有向无环图，叫类层次&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;面向对象数据库系统的优点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;能有效地表达客观世界和有效地查询信息：面向对象方法综合了在关系数据库中发展的全部工程原理、系统分析、软件工程和专家系统领域的内容。&lt;/li&gt;
      &lt;li&gt;可维护性好：在耦合性和内聚性方面，面向对象数据模型的性能尤为突出。&lt;/li&gt;
      &lt;li&gt;能很好地解决“阻抗不匹配”（impedance mismatch）问题：应用程序语言与数据库管理系统对数据类型支持的不一致问题，这一问题通常称之为阻抗不匹配问题&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;面向对象数据库系统的缺点&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;技术还不成熟：面向对象模型还存在着标准化问题，是否修改SQL以适应面向对象的程序，还是用新的对象查询语言来代替它，目前还没有解决。&lt;/li&gt;
      &lt;li&gt;面向对象系统开发的有关原理才刚开始，只是具有雏形，还需要一段时间的研究。但在可靠性、成本等方面还是令人可以接受的。&lt;/li&gt;
      &lt;li&gt;理论还需完善：到现在为止没有关于面向对象分析的一套清晰的概念模型，怎样设计独立于物理存储的信息还不明确&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="sql-server复习" /><summary type="html">sql-server复习一</summary></entry></feed>