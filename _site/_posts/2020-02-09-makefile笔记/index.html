<h2 id="makefile">Makefile</h2>

<p>假设当前<code>HOME</code>目录下有如下目录:<code>src</code>,<code>incl</code>,<code>bin</code>,<code>lib</code></p>

<ul>
  <li>src:源码</li>
  <li>incl:头文件</li>
  <li>bin:执行程序</li>
  <li>lib:动态/静态库</li>
</ul>

<h4 id="makefile代码">Makefile代码</h4>

<pre><code class="language-makefile">hello:hello.c
	gcc -I${HOME}/incl -c hello.c
	gcc -o hello hello.o
	rm -f hello.o
	mv hello ${HOME}/bin
</code></pre>

<h4 id="makefile结构">Makefile结构</h4>

<p>Makefile里主要包含了五个东西：变量定义、显式规则、隐晦规则、文件指示和注释。</p>

<p>1、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</p>

<p>2、显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。 刚才写的疑似shell脚本的Makefile全部都是显示规则。</p>

<p>3、隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。</p>

<p>4、文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样。</p>

<p>5、注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符。</p>

<h4 id="复杂一些的makefile">复杂一些的Makefile</h4>

<p>隐晦规则</p>

<pre><code class="language-makefile">.SUFFIXES: .cpp .c
.cpp.o:
	g++ ${INCL} -c $&lt;

.c.o:
	gcc ${INCL} -c $&lt;
</code></pre>

<p>这个隐晦规则其实就是说明后缀为cpp的文件怎么编译成.o，后缀为c的文件怎么编译成.o</p>

<pre><code class="language-makefile">#隐含规则
INCL=-I${HOME}/incl

.SUFFIXES: .cpp .c
.cpp.o:
	g++ ${INCL} -c $&lt;

.c.o:
	gcc ${INCL} -c $&lt;

#C++编译
hellocpp:hellocpp.o
	echo "开始编译"
	g++ -o hellocpp hellocpp.o
	rm -f hellocpp.o
	mv hellocpp ${HOME}/bin
	echo "编译结束"

#C编译
hello:hello.o
	echo "开始编译"
	gcc -o hello hello.o
	rm -f hello.o
	mv hello ${HOME}/bin
	echo "编译结束"
</code></pre>

<h4 id="预定义变量">预定义变量</h4>

<ul>
  <li>
    <p>$* 　　不包含扩展名的目标文件名称。</p>
  </li>
  <li>
    <p>$+ 　　所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件。</p>
  </li>
  <li>
    <p>$&lt; 　　第一个依赖文件的名称。</p>
  </li>
  <li>
    <p>$? 　　所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚。</p>
  </li>
  <li>
    <p>$@ 　  目标的完整名称。</p>
  </li>
  <li>
    <p>$^ 　　所有的依赖文件，以空格分开，不包含重复的依赖文件。</p>
  </li>
  <li>
    <p>$%        如果目标是归档成员，则该变量表示目标的归档成员名称</p>
  </li>
</ul>

<pre><code class="language-makefile">#最后形成的Makefile
INCL=-I${HOME}/incl
BIN=$(HOME)/bin
OBJ1=hellocpp.o
OBJ2=hello.o

.SUFFIXES: .cpp .c
.cpp.o:
	g++ ${INCL} -c $&lt;

.c.o:
	gcc ${INCL} -c $&lt;

all: hellocpp hello

#C++编译
hellocpp:${OBJ1}
	@echo "============开始编译============"
	g++ -o $@ $?
	@rm -f ${OBJ1}
	@mv $@ ${BIN}
	@echo "============编译结束============"
	@echo ""

#C编译
hello:${OBJ2}
	@echo "============开始编译============"
	gcc -o $@ $?
	@rm -f ${OBJ2}
	@mv $@ ${BIN}
	@echo "============编译结束============"
	@echo ""
</code></pre>

