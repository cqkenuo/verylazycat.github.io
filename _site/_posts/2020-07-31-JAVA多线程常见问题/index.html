<!DOCTYPE html>
<html>

<head>
  
  <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>JAVA多线程常见问题 | lazycat</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="JAVA多线程常见问题" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="[toc]" />
<meta property="og:description" content="[toc]" />
<link rel="canonical" href="http://localhost:4000/_posts/2020-07-31-JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" />
<meta property="og:url" content="http://localhost:4000/_posts/2020-07-31-JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" />
<meta property="og:site_name" content="lazycat" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-07-31T00:00:00-04:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"http://localhost:4000/_posts/2020-07-31-JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","headline":"JAVA多线程常见问题","dateModified":"2020-07-31T00:00:00-04:00","datePublished":"2020-07-31T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/_posts/2020-07-31-JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},"description":"[toc]","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  
  
  <meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1"
/>
<meta
  http-equiv="content-type"
  content="text/html; charset=utf-8"
/>
<link
  rel="alternate"
  href="/feed.xml"
  title="RSS"
  type="application/rss+xml"
/>

  
  <link
  rel="apple-touch-icon-precomposed"
  href="https://pic.cr173.com/up/2017-8/2017841818322084.jpg"
/>
<link
  rel="shortcut
  icon"
  href="https://pic.cr173.com/up/2017-8/2017841818322084.jpg"
/>

  
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/combine/gh/poole/lanyon@v1.1.0/public/css/poole.min.css,gh/poole/lanyon@v1.1.0/public/css/lanyon.min.css"
/>

  
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"
/>

  
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/Dreamer-Paul/Pio@2.4/static/pio.min.css"
/>
<script
  async="async"
  src="https://cdn.jsdelivr.net/combine/gh/Dreamer-Paul/Pio@2.4/static/l2d.min.js,gh/Dreamer-Paul/Pio@2.4/static/pio.min.js"
  onload='
      let pio_container = document.createElement("div");
      pio_container.classList.add("pio-container");
      pio_container.classList.add("right");
      pio_container.style.bottom = "-2rem";
      pio_container.style.zIndex = "1";
      document.body.insertAdjacentElement("beforeend", pio_container);
      let pio_action = document.createElement("div");
      pio_action.classList.add("pio-action");
      pio_container.insertAdjacentElement("beforeend", pio_action);
      let pio_canvas = document.createElement("canvas");
      pio_canvas.id = "pio";
      pio_canvas.style.width = "14rem";
      pio_canvas.width = "600";
      pio_canvas.height = "800";
      pio_container.insertAdjacentElement("beforeend", pio_canvas);
      let pio = new Paul_Pio({
        "mode": "fixed",
        "hidden": true,
        "night": "for(let i=7; i<16; ++i) if(document.body.classList.contains(`theme-base-0`+i.toString(16))) { document.body.classList.remove(`theme-base-0`+i.toString(16)); document.body.classList.add(`theme-base-0`+((i-6)%9+7).toString(16)); break; }",
        "content": {
          "link": ["https://jekyll-theme-WuK.wu-kan.cn"],
          "skin": ["要换成我的朋友吗？", "让她放个假吧~"],
          "hidden": true,
          "custom": [{
            "selector": "a",
            "type": "link",
          }, {
            "selector": ".sidebar-toggle",
            "text": "打开侧边栏叭~"
          }, {
            "selector": ".effect-info",
            "text": "哇，你发现了什么！"
          }, {
            "selector": "#sidebar-search-input",
            "text": "想搜索什么呢？很多干货哦！"
          }, {
            "selector": "#toc",
            "text": "这是目录~"
          }, {
            "selector": ".page-title",
            "text": "这是标题~"
          }, {
            "selector": ".v",
            "text": "评论没有审核，要对自己的发言负责哦~"
          }]
        },
        "model": [
          "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/33/model.2018.bls-winter.json",
          "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/platelet-2/model.json",
          "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/xiaomai/xiaomai.model.json",
          "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/mashiro/seifuku.model.json",
          "https:\/\/cdn.jsdelivr.net/gh/imuncle/live2d/model/Violet/14.json",
          "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/Kobayaxi/Kobayaxi.model.json",
          "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/mikoto/mikoto.model.json",
          "https:\/\/cdn.jsdelivr.net/gh/xiaoski/live2d_models_collection/uiharu/uiharu.model.json"]
      });'
></script>

  
  <script
  src='https://zz.bdstatic.com/linksubmit/push.js'
  async="async"
></script>

  
  <script
  async="async"
  src="https://www.googletagmanager.com/gtag/js?id=UA-163543967-1"
  onload="
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-163543967-1');"
></script>

  
  <style>
  .wrap {
    transition-property: width,background-size,transform;
    transition-duration: .3s;
    transition-timing-function: ease-in-out;
    min-height: 100%;
    display: inline-block;
    background-size: 100% auto;
    background-position: 0% 0%;
    background-repeat: no-repeat;
    background-attachment: fixed;
    background-image: url(http://img.mp.sohu.com/upload/20170801/1eefea1125e6414d8af68aa91920cdf5_th.png);
  }
  @media (min-aspect-ratio: 2400/1850) {
    .wrap {
      background-image: url(http://img.mp.sohu.com/upload/20170801/1eefea1125e6414d8af68aa91920cdf5_th.png);
    }
  }
  .sidebar-overlay #sidebar-checkbox:checked ~ .wrap {
    width: calc(100% - 14rem);
    background-size: calc(100% - 14rem) auto;
    transform: translateX(14rem);
  }
  .layout-reverse.sidebar-overlay #sidebar-checkbox:checked ~ .wrap {
    transform: translateX(0);
  }
</style>

  
  <style>
  .sidebar,
  html,
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: PingFang SC, Menlo, Monaco, "Courier New", Microsoft JhengHei, monospace;
  }
</style>

  
  <style>
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-weight: bold;
  }
</style>

  
  <style>
  img {
    display: inline-block;
    margin: 0;
  }
</style>

  
  <style>
  ::-webkit-scrollbar {
    width: 3px;
    height: 3px;
  }
  ::-webkit-scrollbar-thumb {
    background-image: linear-gradient(45deg, Cyan 0%, Magenta 50%, Yellow 100%);
  }
</style>

  
  <style>
  ::selection {
    color: White;
    background: Black;
  }
</style>

  
</head>

<body
  class="theme-base-07 sidebar-overlay">
  
  
  
  <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
  <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox"
     />
  <!-- Toggleable sidebar -->
  <div class="sidebar" id="sidebar">
    
    <div class="sidebar-item">
      <div class="effect effect-right_to_left">
        <img class="effect-img" src="https://pic.cr173.com/up/2017-8/2017841818322084.jpg" alt="img" />
        <div class="effect-info">
          lazycat<br/>
<a href="mailto:verylazycat@outlook.com">
  <i class="fas fa-envelope"></i>
</a>
<a href="https://github.com/verylazycat">
  <i class="fab fa-github"></i>
</a>

        </div>
      </div>
    </div>
    
    <nav class="sidebar-nav">
      
      <a class="sidebar-nav-item" href="/">
        <i class="fas fa-home fa-fw"></i> 首页
      </a>
      
      <a class="sidebar-nav-item" href="/comments/">
        <i class="fas fa-comments fa-fw"></i> 留言
      </a>
      
      <a class="sidebar-nav-item" href="/tags/">
        <i class="fas fa-tags fa-fw"></i> 标签
      </a>
      
      <a class="sidebar-nav-item" href="/archive/">
        <i class="fas fa-archive fa-fw"></i> 归档
      </a>
      
      <a class="sidebar-nav-item" href="/merger/">
        <i class="fas fa-coffee fa-fw"></i> 打赏
      </a>
      
    </nav>
    <div class="sidebar-item">
      
      <style>
  #sidebar-search-input {
    background: none;
    border: none;
    color: White;
    width: 100%;
  }
  #sidebar-search-results-container {
    overflow: auto auto;
    max-height: 50vh;
  }
</style>
<input
  id="sidebar-search-input"
  placeholder="搜索博文"
/>
<ol
  id="sidebar-search-results-container"
></ol>
<script
  src='https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.7/dest/simple-jekyll-search.min.js'
  async='async'
  onload='
    SimpleJekyllSearch({
      json: "/assets/simple-jekyll-search/search.json",
      searchInput: document.getElementById("sidebar-search-input"),
      resultsContainer: document.getElementById("sidebar-search-results-container"),
      searchResultTemplate: `<li><a href="{url}">{title}</a></li>`,
      limit: 999,
      fuzzy: true
    })'
></script>

      
      
      <style>
  #toc {
    overflow: auto auto;
    max-height: 50vh;
  }
</style>

      <ol id="toc">
  <li><a href="#java%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2">JAVA上下文切换</a></li>
  <li><a href="#%E6%AD%BB%E9%94%81">死锁</a></li>
  <li><a href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6">资源限制</a></li>
  <li><a href="#synchronized%E5%8E%9F%E7%90%86">synchronized原理</a></li>
  <li><a href="#%E9%94%81%E4%BC%98%E5%8C%96">锁优化</a></li>
  <li><a href="#%E8%BD%BB%E9%87%8F%E9%94%81">轻量锁</a></li>
  <li><a href="#%E8%A7%A3%E9%94%81">解锁</a></li>
  <li><a href="#%E5%81%8F%E5%90%91%E9%94%81">偏向锁</a></li>
  <li><a href="#%E9%87%8A%E6%94%BE%E9%94%81">释放锁</a></li>
  <li><a href="#%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96">其他优化</a>
    <ol>
      <li><a href="#%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B">适应性自旋</a></li>
    </ol>
  </li>
  <li><a href="#java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83">JAVA多线程三大核心</a>
    <ol>
      <li><a href="#%E5%8E%9F%E5%AD%90%E6%80%A7">原子性</a></li>
      <li><a href="#%E5%8F%AF%E8%A7%81%E6%80%A7">可见性</a></li>
      <li><a href="#%E9%A1%BA%E5%BA%8F%E6%80%A7">顺序性</a></li>
    </ol>
  </li>
  <li><a href="#volatile%E7%9A%84%E5%BA%94%E7%94%A8">volatile的应用</a>
    <ol>
      <li><a href="#%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E7%9A%84%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F">双重检查锁的单列模式</a></li>
      <li><a href="#%E6%8E%A7%E5%88%B6%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A0%87%E8%AE%B0">控制停止线程的标记</a></li>
    </ol>
  </li>
  <li><a href="#%E5%AF%B9%E9%94%81%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%A4%E7%9F%A5-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81">对锁的一些认知 有哪些锁</a>
    <ol>
      <li><a href="#%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B">同一进程</a>
        <ol>
          <li><a href="#%E9%87%8D%E5%85%A5%E9%94%81">重入锁</a></li>
          <li><a href="#%E8%AF%BB%E5%86%99%E9%94%81">读写锁</a></li>
        </ol>
      </li>
      <li><a href="#%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B">不同进程</a>
        <ol>
          <li><a href="#%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93">基于数据库</a></li>
          <li><a href="#%E5%9F%BA%E4%BA%8E-redis">基于 Redis</a></li>
          <li><a href="#%E5%9F%BA%E4%BA%8E-zk">基于 ZK</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#reentrantlock-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">ReentrantLock 实现原理</a>
    <ol>
      <li><a href="#%E9%94%81%E7%B1%BB%E5%9E%8B">锁类型</a></li>
      <li><a href="#%E8%8E%B7%E5%8F%96%E9%94%81">获取锁</a>
        <ol>
          <li><a href="#%E5%85%AC%E5%B9%B3%E9%94%81%E8%8E%B7%E5%8F%96%E9%94%81">公平锁获取锁</a>
            <ol>
              <li><a href="#%E5%86%99%E5%85%A5%E9%98%9F%E5%88%97">写入队列</a></li>
              <li><a href="#%E6%8C%82%E8%B5%B7%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B">挂起等待线程</a></li>
            </ol>
          </li>
          <li><a href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E8%8E%B7%E5%8F%96%E9%94%81">非公平锁获取锁</a></li>
        </ol>
      </li>
      <li><a href="#%E9%87%8A%E6%94%BE%E9%94%81-1">释放锁</a></li>
      <li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
    </ol>
  </li>
  <li><a href="#concurrenthashmap-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">ConcurrentHashMap 实现原理</a>
    <ol>
      <li><a href="#jdk17-%E5%AE%9E%E7%8E%B0">JDK1.7 实现</a>
        <ol>
          <li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li>
          <li><a href="#get-%E6%96%B9%E6%B3%95">get 方法</a></li>
          <li><a href="#put-%E6%96%B9%E6%B3%95">put 方法</a></li>
          <li><a href="#size-%E6%96%B9%E6%B3%95">size 方法</a></li>
        </ol>
      </li>
      <li><a href="#jdk18-%E5%AE%9E%E7%8E%B0">JDK1.8 实现</a>
        <ol>
          <li><a href="#put-%E6%96%B9%E6%B3%95-1">put 方法</a></li>
          <li><a href="#get-%E6%96%B9%E6%B3%95-1">get 方法</a></li>
        </ol>
      </li>
      <li><a href="#%E6%80%BB%E7%BB%93-1">总结</a></li>
      <li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86">线程池原理</a>
        <ol>
          <li><a href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B">如何配置线程</a></li>
          <li><a href="#%E4%BC%98%E9%9B%85%E7%9A%84%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0">优雅的关闭线程池</a></li>
        </ol>
      </li>
      <li><a href="#springboot-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0">SpringBoot 使用线程池</a></li>
      <li><a href="#%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0">监控线程池</a></li>
      <li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB">线程池隔离</a>
        <ol>
          <li><a href="#hystrix-%E9%9A%94%E7%A6%BB">hystrix 隔离</a></li>
        </ol>
      </li>
      <li><a href="#%E6%80%BB%E7%BB%93-2">总结</a></li>
    </ol>
  </li>
  <li><a href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1">线程通信</a>
    <ol>
      <li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
      <li><a href="#%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6">等待通知机制</a></li>
      <li><a href="#join-%E6%96%B9%E6%B3%95">join() 方法</a></li>
      <li><a href="#volatile-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98">volatile 共享内存</a></li>
      <li><a href="#countdownlatch-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7">CountDownLatch 并发工具</a></li>
      <li><a href="#cyclicbarrier-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7">CyclicBarrier 并发工具</a></li>
      <li><a href="#%E7%BA%BF%E7%A8%8B%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD">线程响应中断</a></li>
      <li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-awaittermination-%E6%96%B9%E6%B3%95">线程池 awaitTermination() 方法</a></li>
      <li><a href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1">管道通信</a></li>
    </ol>
  </li>
</ol>
      
      
      <style>
  .sidebar-checkbox {
    display: none;
  }
  .sidebar-toggle {
    position: fixed;
  }
</style>

      
      <style>
  .effect {
    margin: 1rem;
    perspective: 900px;
  }
  .effect-info {
    text-align: center;
    backface-visibility: hidden;
    position: absolute;
    top: 0;
    transform-style: preserve-3d;
  }
  .effect-img {
    z-index: 11;
    width: 100%;
    height: 100%;
    position: relative;
    transition: all 0.5s ease-in-out;
  }
  .effect-img:before {
    position: absolute;
    display: block;
  }
  .effect-right_to_left .effect-img {
    transform-origin: 0% 50%;
  }
  .effect-right_to_left:hover .effect-img {
    transform: rotate3d(0, 1, 0, -180deg);
  }
</style>

      
      <div>
  <i class="fas fa-cog fa-spin fa-fw"></i>
  <span id="run_time_day">
    <i class="fas fa-spinner fa-pulse"></i>
  </span>天
  <span id="run_time_hour">
    <i class="fas fa-spinner fa-pulse"></i>
  </span>时
  <span id="run_time_minute">
    <i class="fas fa-spinner fa-pulse"></i>
  </span>分
  <span id="run_time_second">
    <i class="fas fa-spinner fa-pulse"></i>
  </span>秒
  <script>
    setInterval(function (d,h,m,s,b) {
      function setzero(i) {
        return i < 10 ? "0" + i : i;
      }
      let BirthDay = new Date(b);
      let today = new Date();
      let timeold = (today.getTime() - BirthDay.getTime());
      let sectimeold = timeold / 1000;
      let secondsold = Math.floor(sectimeold);
      let msPerDay = 24 * 60 * 60 * 1000;
      let e_daysold = timeold / msPerDay;
      let daysold = Math.floor(e_daysold);
      let e_hrsold = (e_daysold - daysold) * 24;
      let hrsold = Math.floor(e_hrsold);
      let e_minsold = (e_hrsold - hrsold) * 60;
      let minsold = Math.floor((e_hrsold - hrsold) * 60);
      let seconds = Math.floor((e_minsold - minsold) * 60);
      d.textContent = daysold;
      h.textContent = setzero(hrsold);
      m.textContent = setzero(minsold);
      s.textContent = setzero(seconds);
    },
    1000,
    document.getElementById("run_time_day"),
    document.getElementById("run_time_hour"),
    document.getElementById("run_time_minute"),
    document.getElementById("run_time_second"),
    "05/02/2020 11:03:56")// 这是我第一篇博客的时间
  </script>
</div>

      
      <div>
  <div>
    <i class="fas fa-eye fa-fw"></i>
    <span id="busuanzi_value_page_pv">
      <i class="fas fa-spinner fa-pulse"></i>
    </span>次
  </div>
  <div>
    <i class="fas fa-paw fa-fw"></i>
    <span id="busuanzi_value_site_pv">
      <i class="fas fa-spinner fa-pulse"></i>
    </span>枚
  </div>
  <div>
    <i class="fas fa-user-friends fa-fw"></i>
    <span id="busuanzi_value_site_uv">
      <i class="fas fa-spinner fa-pulse"></i>
    </span>人
  </div>
  <script
    src='https://cdn.jsdelivr.net/npm/busuanzi@2.3.0'
    async='async'
  ></script>
</div>

      
      <div>
  <i class="fas fa-copyright fa-fw"></i>
  2020-2022 lazycat
</div>

      
      <div>
  <i class="fas fa-info-circle fa-fw"></i>
  <a href="http://beian.miit.gov.cn">
    蜀ICP备20011774号
  </a>
</div>

      
      
    </div>
  </div>
  <!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. -->
  
  <div class="wrap">
    
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
/>
<script
  src="https://cdn.jsdelivr.net/combine/npm/katex@0.11.1/dist/katex.min.js,npm/katex@0.11.1/dist/contrib/mathtex-script-type.min.js,npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  defer="defer"
  onload='renderMathInElement(document.body, { delimiters: [{ left: "$", right: "$", display: false }] })'
></script>



<style>
  pre.language-mermaid,
  code.language-mermaid {
    display: none;
  }
</style>
<script
  src="https://cdn.jsdelivr.net/npm/mermaid@8.5.1/dist/mermaid.min.js"
  defer="defer"
  onload='
    for(let x of document.getElementsByClassName("language-mermaid"))
      if(x.nodeName=="CODE")
      {
        let m = document.createElement("div");
        m.classList.add("mermaid");
        m.textContent = x.textContent;
        x.parentNode.insertAdjacentElement("beforebegin", m);
      }'
></script>



<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/combine/npm/prismjs@1.20.0/plugins/line-numbers/prism-line-numbers.min.css,npm/prismjs@1.20.0/plugins/toolbar/prism-toolbar.min.css,gh/PrismJS/prism-themes@1955cfef6953b3a59e66016e8a1e016b45d6cc79/themes/prism-nord.min.css"
/>
<script
  src="https://cdn.jsdelivr.net/combine/npm/prismjs@1.20.0/components/prism-core.min.js,npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js,npm/prismjs@1.20.0/plugins/line-numbers/prism-line-numbers.min.js,npm/prismjs@1.20.0/plugins/toolbar/prism-toolbar.min.js"
  defer="defer"
  onload='
    Prism.plugins.autoloader.languages_path = "https:\/\/cdn.jsdelivr.net/npm/prismjs/components/";
    for(let x of document.getElementsByTagName("pre"))
      x.classList.add("line-numbers");
    Prism.plugins.toolbar.registerButton("select-code", function (env) {
      let button = document.createElement("button");
      button.textContent = "select this " + env.language;
      button.addEventListener("click", function () {
        if (document.body.createTextRange) {
          let range = document.body.createTextRange();
          range.moveToElementText(env.element);
          range.select();
        } else if (window.getSelection) {
          let selection = window.getSelection();
          let range = document.createRange();
          range.selectNodeContents(env.element);
          selection.removeAllRanges();
            selection.addRange(range);
        }
      });
      return button;
    })'
></script>



<style>
  pre {
    max-height: 50vh;
    overflow: auto;
  }
</style>


<style>
  @media (min-width: 56em) {
    .container {
      max-width: 66.6%;
    }
  }
</style>


<style>
  .masthead,
  .container.content {
    padding-top: 1rem;
    padding-bottom: 1rem;
    box-shadow: 0 0 .75rem rgba(0, 0, 0, 0.1);
    background-color: rgba(255, 255, 255, 0.95);
    animation-duration: 2s;
    animation-name: fadeIn;
  }
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
</style>



<div class="masthead">
  <h3 class="container masthead-title">
    
    JAVA多线程常见问题
    <a href="/" title="Home">
      <small>
        lazycat
      </small>
    </a>
    
  </h3>
</div>

<div class="container content">
  <div class="post">
  <span class="post-date">
    
    <i class="fas fa-calendar-day fa-fw"></i>
    31 Jul 2020
    
    
    <i class="fas fa-file-word fa-fw"></i>
    28117字
    
    
    <i class="fas fa-clock fa-fw"></i>
    94分
    
    
    <span class="leancloud-visitors" id="/_posts/2020-07-31-JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" data-xid="/_posts/2020-07-31-JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" data-flag-title="JAVA多线程常见问题">
      <i class="fas fa-book-reader fa-fw"></i>
      <span class="leancloud-visitors-count">
        <i class="fas fa-spinner fa-pulse"></i>
      </span>次
    </span>
    
    
    
    <i class="fas fa-tag fa-fw"></i>
    JAVA
    
    
    <br/>
<i class="fas fa-coffee fa-fw"></i>
<a href="/merger/">如果这篇博客帮助到你，可以请我喝一杯咖啡~</a>
<br/>
<i class="fab fa-creative-commons-by fa-fw"></i>
<a
  href="https://creativecommons.org/licenses/by/4.0/deed.zh"
  rel="license">
  CC BY 4.0
</a>
（除特别声明或转载文章外）

    
  </span>
  <p>[toc]</p>

<h1 id="java上下文切换">JAVA上下文切换</h1>

<p>多线程并不一定是要在多核处理器才支持的，就算是单核也是可以支持多线程的。 CPU 通过给每个线程分配一定的时间片，由于时间非常短通常是几十毫秒，所以 CPU 可以不停的切换线程执行任务从而达到了多线程的效果。</p>

<p>但是由于在线程切换的时候需要保存本次执行的信息(<a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/MemoryAllocation.md#程序计数器">详见</a>)，在该线程被 CPU 剥夺时间片后又再次运行恢复上次所保存的信息的过程就称为上下文切换。</p>

<blockquote>
  <p>上下文切换是非常耗效率的。</p>
</blockquote>

<p>通常有以下解决方案:</p>

<ul>
  <li>采用无锁编程，比如将数据按照 <code>Hash(id)</code> 进行取模分段，每个线程处理各自分段的数据，从而避免使用锁。</li>
  <li>采用 CAS(compare and swap) 算法，如 <code>Atomic</code> 包就是采用 CAS 算法(<a href="https://github.com/crossoverJie/JCSprout/blob/master/MD/Threadcore.md#原子性">详见</a>)。</li>
  <li>合理的创建线程，避免创建了一些线程但其中大部分都是处于 <code>waiting</code> 状态，因为每当从 <code>waiting</code> 状态切换到 <code>running</code> 状态都是一次上下文切换。</li>
</ul>

<h1 id="死锁">死锁</h1>

<p>死锁的场景一般是：线程 A 和线程 B 都在互相等待对方释放锁，或者是其中某个线程在释放锁的时候出现异常如死循环之类的。这时就会导致系统不可用。</p>

<p>常用的解决方案如下：</p>

<ul>
  <li>尽量一个线程只获取一个锁。</li>
  <li>一个线程只占用一个资源。</li>
  <li>尝试使用定时锁，至少能保证锁最终会被释放。</li>
</ul>

<h1 id="资源限制">资源限制</h1>

<p>当在带宽有限的情况下一个线程下载某个资源需要 <code>1M/S</code>,当开 10 个线程时速度并不会乘 10 倍，反而还会增加时间，毕竟上下文切换比较耗时。</p>

<p>如果是受限于资源的话可以采用集群来处理任务，不同的机器来处理不同的数据，就类似于开始提到的无锁编程。</p>

<h1 id="synchronized原理">synchronized原理</h1>

<p>众所周知 <code>synchronized</code> 关键字是解决并发问题常用解决方案，有以下三种使用方式:</p>

<ul>
  <li>同步普通方法，锁的是当前对象。</li>
  <li>同步静态方法，锁的是当前 <code>Class</code> 对象。</li>
  <li>同步块，锁的是 <code>()</code> 中的对象。</li>
</ul>

<p>实现原理： <code>JVM</code> 是通过进入、退出对象监视器( <code>Monitor</code> )来实现对方法、同步块的同步的。</p>

<p>具体实现是在编译之后在同步方法调用前加入一个 <code>monitor.enter</code> 指令，在退出方法和异常处插入 <code>monitor.exit</code> 的指令。</p>

<p>其本质就是对一个对象监视器( <code>Monitor</code> )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。</p>

<p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 <code>monitor.exit</code> 之后才能尝试继续获取锁。</p>

<p><img src="/img/synchronized.webp" alt="synchronized" /></p>

<p>通过一段代码来演示:</p>

<pre><code class="language-java">    public static void main(String[] args) {
        synchronized (Synchronize.class){
            System.out.println("Synchronize");
        }
    }
</code></pre>

<p>使用 <code>javap -c Synchronize</code> 可以查看编译之后的具体信息。</p>

<pre><code>public class com.crossoverjie.synchronize.Synchronize {
  public com.crossoverjie.synchronize.Synchronize();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // class com/crossoverjie/synchronize/Synchronize
       2: dup
       3: astore_1
       **4: monitorenter**
       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
       8: ldc           #4                  // String Synchronize
      10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      13: aload_1
      **14: monitorexit**
      15: goto          23
      18: astore_2
      19: aload_1
      20: monitorexit
      21: aload_2
      22: athrow
      23: return
    Exception table:
       from    to  target type
           5    15    18   any
          18    21    18   any
}
</code></pre>

<p>可以看到在同步块的入口和出口分别有 <code>monitorenter,monitorexit</code> 指令。</p>

<h1 id="锁优化">锁优化</h1>

<p><code>synchronized</code>  很多都称之为重量锁，<code>JDK1.6</code> 中对 <code>synchronized</code> 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了<code>偏向锁</code>和<code>轻量锁</code>。</p>

<h1 id="轻量锁">轻量锁</h1>

<p>当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(<code>Lock Record</code>)区域，同时将锁对象的对象头中 <code>Mark Word</code> 拷贝到锁记录中，再尝试使用 <code>CAS</code> 将 <code>Mark Word</code> 更新为指向锁记录的指针。</p>

<p>如果更新<strong>成功</strong>，当前线程就获得了锁。</p>

<p>如果更新<strong>失败</strong> <code>JVM</code> 会先检查锁对象的 <code>Mark Word</code> 是否指向当前线程的锁记录。</p>

<p>如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。</p>

<p>不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，<strong>轻量锁就会膨胀为重量锁</strong>。</p>

<h1 id="解锁">解锁</h1>

<p>轻量锁的解锁过程也是利用 <code>CAS</code> 来实现的，会尝试锁记录替换回锁对象的 <code>Mark Word</code> 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为<code>重量锁</code>)</p>

<p>轻量锁能提升性能的原因是：</p>

<p>认为大多数锁在整个同步周期都不存在竞争，所以使用 <code>CAS</code> 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 <code>CAS</code> 的开销，甚至比重量锁更慢。</p>

<h1 id="偏向锁">偏向锁</h1>

<p>为了进一步的降低获取锁的代价，<code>JDK1.6</code> 之后还引入了偏向锁。</p>

<p>偏向锁的特征是:锁不存在多线程竞争，并且应由一个线程多次获得锁。</p>

<p>当线程访问同步块时，会使用 <code>CAS</code> 将线程 ID 更新到锁对象的 <code>Mark Word</code> 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。</p>

<h1 id="释放锁">释放锁</h1>

<p>当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 <code>Mark Word</code> 设置为无锁或者是轻量锁状态。</p>

<p>偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 <code>-XX:-UseBiasedLocking</code> 来关闭偏向锁，并默认进入轻量锁。</p>

<h1 id="其他优化">其他优化</h1>

<h2 id="适应性自旋">适应性自旋</h2>

<p>在使用 <code>CAS</code> 时，如果操作失败，<code>CAS</code> 会自旋再次尝试。由于自旋是需要消耗 <code>CPU</code> 资源的，所以如果长期自旋就白白浪费了 <code>CPU</code>。<code>JDK1.6</code>加入了适应性自旋:</p>

<blockquote>
  <p>如果某个锁自旋很少成功获得，那么下一次就会减少自旋。</p>
</blockquote>

<h1 id="java多线程三大核心">JAVA多线程三大核心</h1>

<h2 id="原子性">原子性</h2>

<p><code>Java</code> 的原子性就和数据库事务的原子性差不多，一个操作中要么全部执行成功或者失败。</p>

<p><code>JMM</code> 只是保证了基本的原子性，但类似于 <code>i++</code> 之类的操作，看似是原子操作，其实里面涉及到:</p>

<ul>
  <li>获取 i 的值。</li>
  <li>自增。</li>
  <li>再赋值给 i。</li>
</ul>

<p>这三步操作，所以想要实现 <code>i++</code> 这样的原子操作就需要用到 <code>synchronized</code> 或者是 <code>lock</code> 进行加锁处理。</p>

<p>如果是基础类的自增操作可以使用 <code>AtomicInteger</code> 这样的原子类来实现(其本质是利用了 <code>CPU</code> 级别的 的 <code>CAS</code> 指令来完成的)。</p>

<p>其中用的最多的方法就是: <code>incrementAndGet()</code> 以原子的方式自增。 源码如下:</p>

<pre><code class="language-java">public final long incrementAndGet() {
        for (;;) {
            long current = get();
            long next = current + 1;
            if (compareAndSet(current, next))
                return next;
        }
    }
</code></pre>

<p>首先是获得当前的值，然后自增 +1。接着则是最核心的 <code>compareAndSet()</code> 来进行原子更新。</p>

<pre><code class="language-java">public final boolean compareAndSet(long expect, long update) {
        return unsafe.compareAndSwapLong(this, valueOffset, expect, update);
    }
</code></pre>

<p>其逻辑就是判断当前的值是否被更新过，是否等于 <code>current</code>，如果等于就说明没有更新过然后将当前的值更新为 <code>next</code>，如果不等于则返回<code>false</code> 进入循环，直到更新成功为止。</p>

<p>还有其中的 <code>get()</code> 方法也很关键，返回的是当前的值，当前值用了 <code>volatile</code> 关键词修饰，保证了内存可见性。</p>

<pre><code class="language-java"> private volatile int value;
</code></pre>

<h2 id="可见性">可见性</h2>

<p>现代计算机中，由于 <code>CPU</code> 直接从主内存中读取数据的效率不高，所以都会对应的 <code>CPU</code> 高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时来读取就是修改之前的数据。</p>

<p><img src="/img/可见性.webp" alt="可见性" /></p>

<p>如上图所示。</p>

<p><code>volatile</code> 关键字就是用于保证内存可见性，当线程A更新了 volatile 修饰的变量时，它会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。</p>

<p>使用 <code>volatile</code> 关键词修饰的变量每次读取都会得到最新的数据，不管哪个线程对这个变量的修改都会立即刷新到主内存。</p>

<p><code>synchronized</code>和加锁也能能保证可见性，实现原理就是在释放锁之前其余线程是访问不到这个共享变量的。但是和 <code>volatile</code> 相比开销较大。</p>

<h2 id="顺序性">顺序性</h2>

<p>以下这段代码:</p>

<pre><code class="language-java">int a = 100 ; //1
int b = 200 ; //2
int c = a + b ; //3
</code></pre>

<p>正常情况下的执行顺序应该是 <code>1&gt;&gt;2&gt;&gt;3</code>。但是有时 <code>JVM</code> 为了提高整体的效率会进行指令重排导致执行的顺序可能是 <code>2&gt;&gt;1&gt;&gt;3</code>。但是 <code>JVM</code> 也不能是什么都进行重排，是在保证最终结果和代码顺序执行结果一致的情况下才可能进行重排。</p>

<p>重排在单线程中不会出现问题，但在多线程中会出现数据不一致的问题。</p>

<p>Java 中可以使用 <code>volatile</code> 来保证顺序性，<code>synchronized 和 lock</code> 也可以来保证有序性，和保证原子性的方式一样，通过同一段时间只能一个线程访问来实现的。</p>

<p>除了通过 <code>volatile</code> 关键字显式的保证顺序之外， <code>JVM</code> 还通过 <code>happen-before</code> 原则来隐式的保证顺序性。</p>

<p>其中有一条就是适用于 <code>volatile</code> 关键字的，针对于 <code>volatile</code> 关键字的写操作肯定是在读操作之前，也就是说读取的值肯定是最新的。</p>

<h1 id="volatile的应用">volatile的应用</h1>

<h2 id="双重检查锁的单列模式">双重检查锁的单列模式</h2>

<p>可以用 <code>volatile</code> 实现一个双重检查锁的单例模式：</p>

<pre><code class="language-java">    public class Singleton {
        private static volatile Singleton singleton;

        private Singleton() {
        }

        public static Singleton getInstance() {
            if (singleton == null) {
                synchronized (Singleton.class) {
                    if (singleton == null) {
                        singleton = new Singleton();
                    }
                }
            }
            return singleton;
        }

    }
</code></pre>

<p>这里的 <code>volatile</code> 关键字主要是为了防止指令重排。 如果不用 <code>volatile</code> ，<code>singleton = new Singleton();</code>，这段代码其实是分为三步：</p>

<ul>
  <li>分配内存空间。(1)</li>
  <li>初始化对象。(2)</li>
  <li>将 <code>singleton</code> 对象指向分配的内存地址。(3)</li>
</ul>

<p>加上 <code>volatile</code> 是为了让以上的三步操作顺序执行，反之有可能第三步在第二步之前被执行就有可能导致某个线程拿到的单例对象还没有初始化，以致于使用报错。</p>

<h2 id="控制停止线程的标记">控制停止线程的标记</h2>

<pre><code class="language-java">    private volatile boolean flag ;
    private void run(){
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (flag) {
                    doSomeThing();
                }
            }
        });
    }

    private void stop(){
        flag = false ;
    }
</code></pre>

<p>这里如果没有用 volatile 来修饰 flag ，就有可能其中一个线程调用了 <code>stop()</code>方法修改了 flag 的值并不会立即刷新到主内存中，导致这个循环并不会立即停止。</p>

<p>这里主要利用的是 <code>volatile</code> 的内存可见性。</p>

<p>总结一下:</p>

<ul>
  <li><code>volatile</code> 关键字只能保证可见性，顺序性，<strong>不能保证原子性</strong>。</li>
</ul>

<h1 id="对锁的一些认知-有哪些锁">对锁的一些认知 有哪些锁</h1>

<h2 id="同一进程">同一进程</h2>

<h3 id="重入锁">重入锁</h3>

<p>使用 <code>ReentrantLock</code> 获取锁的时候会判断当前线程是否为获取锁的线程，如果是则将同步的状态 +1 ,释放锁的时候则将状态 -1。只有将同步状态的次数置为 0 的时候才会最终释放锁</p>

<h3 id="读写锁">读写锁</h3>

<p>使用 <code>ReentrantReadWriteLock</code> ,同时维护一对锁：读锁和写锁。当写线程访问时则其他所有锁都将阻塞，读线程访问时则不会。通过读写锁的分离可以很大程度的提高并发量和吞吐量。</p>

<h2 id="不同进程">不同进程</h2>

<p>分布式锁：</p>

<h3 id="基于数据库">基于数据库</h3>

<p>可以创建一张表，将其中的某个字段设置为<code>唯一索引</code>，当多个请求过来的时候只有新建记录成功的请求才算获取到锁，当使用完毕删除这条记录的时候即释放锁。</p>

<p>存在的问题:</p>

<ul>
  <li>数据库单点问题，挂了怎么办？</li>
  <li>不是重入锁，同一进程无法在释放锁之前再次获得锁，因为数据库中已经存在了一条记录了。</li>
  <li>锁是非阻塞的，一旦 <code>insert</code> 失败则会立即返回，并不会进入阻塞队列只能下一次再次获取。</li>
  <li>锁没有失效时间，如果那个进程解锁失败那就没有请求可以再次获取锁了。</li>
</ul>

<p>解决方案:</p>

<ul>
  <li>数据库切换为主从，不存在单点。</li>
  <li>在表中加入一个同步状态字段，每次获取锁的是加 1 ，释放锁的时候<code>-1</code>，当状态为 0 的时候就删除这条记录，即释放锁。</li>
  <li>非阻塞的情况可以用 <code>while</code> 循环来实现，循环的时候记录时间，达到 X 秒记为超时，<code>break</code>。</li>
  <li>可以开启一个定时任务每隔一段时间扫描找出多少 X 秒都没有被删除的记录，主动删除这条记录。</li>
</ul>

<h3 id="基于-redis">基于 Redis</h3>

<p>使用 <code>setNX(key) setEX(timeout)</code> 命令，只有在该 <code>key</code> 不存在的时候创建这个 <code>key</code>，就相当于获取了锁。由于有超时时间，所以过了规定时间会自动删除，这样也可以避免死锁。</p>

<h3 id="基于-zk">基于 ZK</h3>

<h1 id="reentrantlock-实现原理">ReentrantLock 实现原理</h1>

<p>使用 <code>synchronized</code> 来做同步处理时，锁的获取和释放都是隐式的，实现的原理是通过编译后加上不同的机器指令来实现。</p>

<p>而 <code>ReentrantLock</code> 就是一个普通的类，它是基于 <code>AQS(AbstractQueuedSynchronizer)</code>来实现的。</p>

<p>是一个<strong>重入锁</strong>：一个线程获得了锁之后仍然可以<strong>反复</strong>的加锁，不会出现自己阻塞自己的情况。</p>

<blockquote>
  <p><code>AQS</code> 是 <code>Java</code> 并发包里实现锁、同步的一个重要的基础框架。</p>
</blockquote>

<h2 id="锁类型">锁类型</h2>

<p>ReentrantLock 分为<strong>公平锁</strong>和<strong>非公平锁</strong>，可以通过构造方法来指定具体类型：</p>

<pre><code class="language-java">    //默认非公平锁
    public ReentrantLock() {
        sync = new NonfairSync();
    }

    //公平锁
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }
</code></pre>

<p>默认一般使用<strong>非公平锁</strong>，它的效率和吞吐量都比公平锁高的多(后面会分析具体原因)。</p>

<h2 id="获取锁">获取锁</h2>

<p>通常的使用方式如下:</p>

<pre><code class="language-java">    private ReentrantLock lock = new ReentrantLock();
    public void run() {
        lock.lock();
        try {
            //do bussiness
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
</code></pre>

<h3 id="公平锁获取锁">公平锁获取锁</h3>

<p>首先看下获取锁的过程：</p>

<pre><code class="language-java">    public void lock() {
        sync.lock();
    }
</code></pre>

<p>可以看到是使用 <code>sync</code>的方法，而这个方法是一个抽象方法，具体是由其子类(<code>FairSync</code>)来实现的，以下是公平锁的实现:</p>

<pre><code class="language-java">        final void lock() {
            acquire(1);
        }

        //AbstractQueuedSynchronizer 中的 acquire()
        public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;&amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
        }
</code></pre>

<p>第一步是尝试获取锁(<code>tryAcquire(arg)</code>),这个也是由其子类实现：</p>

<pre><code class="language-java">        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (!hasQueuedPredecessors() &amp;&amp;
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &lt; 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
    }
</code></pre>

<p>首先会判断 <code>AQS</code> 中的 <code>state</code> 是否等于 0，0 表示目前没有其他线程获得锁，当前线程就可以尝试获取锁。</p>

<p><strong>注意</strong>:尝试之前会利用 <code>hasQueuedPredecessors()</code> 方法来判断 AQS 的队列中中是否有其他线程，如果有则不会尝试获取锁(<strong>这是公平锁特有的情况</strong>)。</p>

<p>如果队列中没有线程就利用 CAS 来将 AQS 中的 state 修改为1，也就是获取锁，获取成功则将当前线程置为获得锁的独占线程(<code>setExclusiveOwnerThread(current)</code>)。</p>

<p>如果 <code>state</code> 大于 0 时，说明锁已经被获取了，则需要判断获取锁的线程是否为当前线程(<code>ReentrantLock</code> 支持重入)，是则需要将 <code>state + 1</code>，并将值更新。</p>

<h4 id="写入队列">写入队列</h4>

<p>如果 <code>tryAcquire(arg)</code> 获取锁失败，则需要用 <code>addWaiter(Node.EXCLUSIVE)</code> 将当前线程写入队列中。</p>

<p>写入之前需要将当前线程包装为一个 <code>Node</code> 对象(<code>addWaiter(Node.EXCLUSIVE)</code>)。</p>

<blockquote>
  <p>AQS 中的队列是由 Node 节点组成的双向链表实现的。</p>
</blockquote>

<p>包装代码:</p>

<pre><code class="language-java">    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }
</code></pre>

<p>首先判断队列是否为空，不为空时则将封装好的 <code>Node</code> 利用 <code>CAS</code> 写入队尾，如果出现并发写入失败就需要调用 <code>enq(node);</code> 来写入了。</p>

<pre><code class="language-java">    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
</code></pre>

<p>这个处理逻辑就相当于<code>自旋</code>加上 <code>CAS</code> 保证一定能写入队列。</p>

<h4 id="挂起等待线程">挂起等待线程</h4>

<p>写入队列之后需要将当前线程挂起(利用<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>)：</p>

<pre><code class="language-java">    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
</code></pre>

<p>首先会根据 <code>node.predecessor()</code> 获取到上一个节点是否为头节点，如果是则尝试获取一次锁，获取成功就万事大吉了。</p>

<p>如果不是头节点，或者获取锁失败，则会根据上一个节点的 <code>waitStatus</code> 状态来处理(<code>shouldParkAfterFailedAcquire(p, node)</code>)。</p>

<p><code>waitStatus</code> 用于记录当前节点的状态，如节点取消、节点等待等。</p>

<p><code>shouldParkAfterFailedAcquire(p, node)</code> 返回当前线程是否需要挂起，如果需要则调用 <code>parkAndCheckInterrupt()</code>：</p>

<pre><code class="language-java">    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
</code></pre>

<p>他是利用 <code>LockSupport</code> 的 <code>part</code> 方法来挂起当前线程的，直到被唤醒。</p>

<h3 id="非公平锁获取锁">非公平锁获取锁</h3>

<p>公平锁与非公平锁的差异主要在获取锁：</p>

<p>公平锁就相当于买票，后来的人需要排到队尾依次买票，<strong>不能插队</strong>。</p>

<p>而非公平锁则没有这些规则，是<strong>抢占模式</strong>，每来一个人不会去管队列如何，直接尝试获取锁。</p>

<p>非公平锁:</p>

<pre><code class="language-java">        final void lock() {
            //直接尝试获取锁
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
</code></pre>

<p>公平锁:</p>

<pre><code class="language-java">        final void lock() {
            acquire(1);
        }
</code></pre>

<p>还要一个重要的区别是在尝试获取锁时<code>tryAcquire(arg)</code>，非公平锁是不需要判断队列中是否还有其他线程，也是直接尝试获取锁：</p>

<pre><code class="language-java">        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                //没有 !hasQueuedPredecessors() 判断
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &lt; 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
</code></pre>

<h2 id="释放锁-1">释放锁</h2>

<p>公平锁和非公平锁的释放流程都是一样的：</p>

<pre><code class="language-java">    public void unlock() {
        sync.release(1);
    }

    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null &amp;&amp; h.waitStatus != 0)
                   //唤醒被挂起的线程
                unparkSuccessor(h);
            return true;
        }
        return false;
    }

    //尝试释放锁
    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }        
</code></pre>

<p>首先会判断当前线程是否为获得锁的线程，由于是重入锁所以需要将 <code>state</code> 减到 0 才认为完全释放锁。</p>

<p>释放之后需要调用 <code>unparkSuccessor(h)</code> 来唤醒被挂起的线程。</p>

<h2 id="总结">总结</h2>

<p>由于公平锁需要关心队列的情况，得按照队列里的先后顺序来获取锁(会造成大量的线程上下文切换)，而非公平锁则没有这个限制。</p>

<p>所以也就能解释非公平锁的效率会被公平锁更高。</p>

<h1 id="concurrenthashmap-实现原理">ConcurrentHashMap 实现原理</h1>

<p>由于 <code>HashMap</code> 是一个线程不安全的容器，主要体现在容量大于<code>总量*负载因子</code>发生扩容时会出现环形链表从而导致死循环。</p>

<p>因此需要支持线程安全的并发容器 <code>ConcurrentHashMap</code> 。</p>

<h2 id="jdk17-实现">JDK1.7 实现</h2>

<h3 id="数据结构">数据结构</h3>

<h3><img src="/img/ConcurrentHashMap.webp" alt="ConcurrentHashMap" /></h3>

<p>如图所示，是由 <code>Segment</code> 数组、<code>HashEntry</code> 数组组成，和 <code>HashMap</code> 一样，仍然是数组加链表组成。</p>

<p><code>ConcurrentHashMap</code> 采用了分段锁技术，其中 <code>Segment</code> 继承于 <code>ReentrantLock</code>。不会像 <code>HashTable</code> 那样不管是 <code>put</code> 还是 <code>get</code> 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 <code>CurrencyLevel</code> (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 <code>Segment</code> 时，不会影响到其他的 <code>Segment</code>。</p>

<h3 id="get-方法">get 方法</h3>

<p><code>ConcurrentHashMap</code> 的 <code>get</code> 方法是非常高效的，因为整个过程都不需要加锁。</p>

<p>只需要将 <code>Key</code> 通过 <code>Hash</code> 之后定位到具体的 <code>Segment</code> ，再通过一次 <code>Hash</code> 定位到具体的元素上。由于 <code>HashEntry</code> 中的 <code>value</code> 属性是用 <code>volatile</code> 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值(<a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/Threadcore.md#可见性">volatile 相关知识点</a>)。</p>

<h3 id="put-方法">put 方法</h3>

<p>内部 <code>HashEntry</code> 类 ：</p>

<pre><code class="language-java">    static final class HashEntry&lt;K,V&gt; {
        final int hash;
        final K key;
        volatile V value;
        volatile HashEntry&lt;K,V&gt; next;

        HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
</code></pre>

<p>虽然 HashEntry 中的 value 是用 <code>volatile</code> 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。</p>

<p>首先也是通过 Key 的 Hash 定位到具体的 Segment，在 put 之前会进行一次扩容校验。这里比 HashMap 要好的一点是：HashMap 是插入元素之后再看是否需要扩容，有可能扩容之后后续就没有插入就浪费了本次扩容(扩容非常消耗性能)。</p>

<p>而 ConcurrentHashMap 不一样，它是在将数据插入之前检查是否需要扩容，之后再做插入操作。</p>

<h3 id="size-方法">size 方法</h3>

<p>每个 <code>Segment</code> 都有一个 <code>volatile</code> 修饰的全局变量 <code>count</code> ,求整个 <code>ConcurrentHashMap</code> 的 <code>size</code> 时很明显就是将所有的 <code>count</code> 累加即可。但是 <code>volatile</code> 修饰的变量却不能保证多线程的原子性，所有直接累加很容易出现并发问题。</p>

<p>但如果每次调用 <code>size</code> 方法将其余的修改操作加锁效率也很低。所以做法是先尝试两次将 <code>count</code> 累加，如果容器的 <code>count</code> 发生了变化再加锁来统计 <code>size</code>。</p>

<p>至于 <code>ConcurrentHashMap</code> 是如何知道在统计时大小发生了变化呢，每个 <code>Segment</code> 都有一个 <code>modCount</code> 变量，每当进行一次 <code>put remove</code> 等操作，<code>modCount</code> 将会 +1。只要 <code>modCount</code> 发生了变化就认为容器的大小也在发生变化。</p>

<h2 id="jdk18-实现">JDK1.8 实现</h2>

<p><img src="/img/ConcurrentHashMap18.webp" alt="ConcurrentHashMap18" /></p>

<p>1.8 中的 ConcurrentHashMap 数据结构和实现与 1.7 还是有着明显的差异。</p>

<p>其中抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p>

<p>也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。</p>

<p>其中的 <code>val next</code> 都用了 volatile 修饰，保证了可见性。</p>

<h3 id="put-方法-1">put 方法</h3>

<ul>
  <li>根据 key 计算出 hashcode 。</li>
  <li>判断是否需要进行初始化。</li>
  <li><code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
  <li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
  <li>如果都不满足，则利用 synchronized 锁写入数据。</li>
  <li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ul>

<h3 id="get-方法-1">get 方法</h3>

<ul>
  <li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li>
  <li>如果是红黑树那就按照树的方式获取值。</li>
  <li>都不满足那就按照链表的方式遍历获取值。</li>
</ul>

<h2 id="总结-1">总结</h2>

<p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（<code>O(logn)</code>），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p>

<blockquote>
  <p>简单来说使用线程池有以下几个目的：</p>

  <ul>
    <li>
      <p>线程是稀缺资源，不能频繁的创建。</p>
    </li>
    <li>
      <p>解耦作用；线程的创建于执行完全分开，方便维护。</p>
    </li>
    <li>
      <p>应当将其放入一个池子中，可以给其他任务进行复用。</p>
    </li>
  </ul>
</blockquote>

<h2 id="线程池原理">线程池原理</h2>

<p>谈到线程池就会想到池化技术，其中最核心的思想就是把宝贵的资源放到一个池子中；每次使用都从里面获取，用完之后又放回池子供其他人使用，有点吃大锅饭的意思。</p>

<p>那在 Java 中又是如何实现的呢？</p>

<p>在 JDK 1.5 之后推出了相关的 api，常见的创建线程池方式有以下几种：</p>

<ul>
  <li><code>Executors.newCachedThreadPool()</code>：无限线程池。</li>
  <li><code>Executors.newFixedThreadPool(nThreads)</code>：创建固定大小的线程池。</li>
  <li><code>Executors.newSingleThreadExecutor()</code>：创建单个线程的线程池。</li>
</ul>

<p>其实看这三种方式创建的源码就会发现：</p>

<pre><code class="language-java">    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;());
    }
</code></pre>

<p>实际上还是利用 <code>ThreadPoolExecutor</code> 类实现的。</p>

<p>所以我们重点来看下 <code>ThreadPoolExecutor</code> 是怎么玩的。</p>

<p>首先是创建线程的 api：</p>

<pre><code class="language-java">ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) 
</code></pre>

<p>这几个核心参数的作用：</p>

<ul>
  <li><code>corePoolSize</code> 为线程池的基本大小。</li>
  <li><code>maximumPoolSize</code> 为线程池最大线程大小。</li>
  <li><code>keepAliveTime</code> 和 <code>unit</code> 则是线程空闲后的存活时间。</li>
  <li><code>workQueue</code> 用于存放任务的阻塞队列。</li>
  <li><code>handler</code> 当队列和最大线程池都满了之后的饱和策略。</li>
</ul>

<p>了解了这几个参数再来看看实际的运用。</p>

<p>通常我们都是使用:</p>

<pre><code class="language-java">threadPool.execute(new Job());
</code></pre>

<p>这样的方式来提交一个任务到线程池中，所以核心的逻辑就是 <code>execute()</code> 函数了。</p>

<p>在具体分析之前先了解下线程池中所定义的状态，这些状态都和线程的执行密切相关：</p>

<ul>
  <li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li>
  <li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li>
  <li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li>
  <li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li>
  <li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li>
</ul>

<p>然后看看 <code>execute()</code> 方法是如何处理的：</p>

<ol>
  <li>获取当前线程池的状态。</li>
  <li>当前线程数量小于 coreSize 时创建一个新的线程运行。</li>
  <li>如果当前线程处于运行状态，并且写入阻塞队列成功。</li>
  <li>双重检查，再次获取线程状态；如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</li>
  <li>如果当前线程池为空就新创建一个线程并执行。</li>
  <li>如果在第三步的判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略。</li>
</ol>

<h3 id="如何配置线程">如何配置线程</h3>

<p>流程聊完了再来看看上文提到了几个核心参数应该如何配置呢？</p>

<p>有一点是肯定的，线程池肯定是不是越大越好。</p>

<p>通常我们是需要根据这批任务执行的性质来确定的。</p>

<ul>
  <li>IO 密集型任务：由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2</li>
  <li>CPU 密集型任务（大量复杂的运算）应当分配较少的线程，比如 CPU 个数相当的大小。</li>
</ul>

<p>当然这些都是经验值，最好的方式还是根据实际情况测试得出最佳配置。</p>

<h3 id="优雅的关闭线程池">优雅的关闭线程池</h3>

<p>有运行任务自然也有关闭任务，从上文提到的 5 个状态就能看出如何来关闭线程池。</p>

<p>其实无非就是两个方法 <code>shutdown()/shutdownNow()</code>。</p>

<p>但他们有着重要的区别：</p>

<ul>
  <li><code>shutdown()</code> 执行后停止接受新任务，会把队列的任务执行完毕。</li>
  <li><code>shutdownNow()</code> 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。</li>
</ul>

<blockquote>
  <p>两个方法都会中断线程，用户可自行判断是否需要响应中断。</p>
</blockquote>

<p><code>shutdownNow()</code> 要更简单粗暴，可以根据实际场景选择不同的方法。</p>

<p>我通常是按照以下方式关闭线程池的：</p>

<pre><code class="language-java">        long start = System.currentTimeMillis();
        for (int i = 0; i &lt;= 5; i++) {
            pool.execute(new Job());
        }

        pool.shutdown();

        while (!pool.awaitTermination(1, TimeUnit.SECONDS)) {
            LOGGER.info("线程还在执行。。。");
        }
        long end = System.currentTimeMillis();
        LOGGER.info("一共处理了【{}】", (end - start));
</code></pre>

<p><code>pool.awaitTermination(1, TimeUnit.SECONDS)</code> 会每隔一秒钟检查一次是否执行完毕（状态为 <code>TERMINATED</code>），当从 while 循环退出时就表明线程池已经完全终止了。</p>

<h2 id="springboot-使用线程池">SpringBoot 使用线程池</h2>

<p>2018 年了，SpringBoot 盛行；来看看在 SpringBoot 中应当怎么配置和使用线程池。</p>

<p>既然用了 SpringBoot ，那自然得发挥 Spring 的特性，所以需要 Spring 来帮我们管理线程池：</p>

<pre><code class="language-java">@Configuration
public class TreadPoolConfig {


    /**
     * 消费队列线程
     * @return
     */
    @Bean(value = "consumerQueueThreadPool")
    public ExecutorService buildConsumerQueueThreadPool(){
        ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
                .setNameFormat("consumer-queue-thread-%d").build();

        ExecutorService pool = new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue&lt;Runnable&gt;(5),namedThreadFactory,new ThreadPoolExecutor.AbortPolicy());

        return pool ;
    }



}
</code></pre>

<p>使用时：</p>

<pre><code class="language-java">    @Resource(name = "consumerQueueThreadPool")
    private ExecutorService consumerQueueThreadPool;


    @Override
    public void execute() {

        //消费队列
        for (int i = 0; i &lt; 5; i++) {
            consumerQueueThreadPool.execute(new ConsumerQueueThread());
        }

    }
</code></pre>

<p>其实也挺简单，就是创建了一个线程池的 bean，在使用时直接从 Spring 中取出即可。</p>

<h2 id="监控线程池">监控线程池</h2>

<p>谈到了 SpringBoot，也可利用它 actuator 组件来做线程池的监控。</p>

<p>线程怎么说都是稀缺资源，对线程池的监控可以知道自己任务执行的状况、效率等。</p>

<h2 id="线程池隔离">线程池隔离</h2>

<blockquote>
  <p>线程池看似很美好，但也会带来一些问题。</p>
</blockquote>

<p>如果我们很多业务都依赖于同一个线程池,当其中一个业务因为各种不可控的原因消耗了所有的线程，导致线程池全部占满。</p>

<p>这样其他的业务也就不能正常运转了，这对系统的打击是巨大的。</p>

<p>比如我们 Tomcat 接受请求的线程池，假设其中一些响应特别慢，线程资源得不到回收释放；线程池慢慢被占满，最坏的情况就是整个应用都不能提供服务。</p>

<p>所以我们需要将线程池<strong>进行隔离</strong>。</p>

<p>通常的做法是按照业务进行划分：</p>

<blockquote>
  <p>比如下单的任务用一个线程池，获取数据的任务用另一个线程池。这样即使其中一个出现问题把线程池耗尽，那也不会影响其他的任务运行。</p>
</blockquote>

<h3 id="hystrix-隔离">hystrix 隔离</h3>

<p>这样的需求 <a href="https://github.com/Netflix/Hystrix">Hystrix</a> 已经帮我们实现了。</p>

<blockquote>
  <p>Hystrix 是一款开源的容错插件，具有依赖隔离、系统容错降级等功能。</p>
</blockquote>

<p>下面来看看 <code>Hystrix</code> 简单的应用：</p>

<p>首先需要定义两个线程池，分别用于执行订单、处理用户。</p>

<pre><code class="language-java">/**
 * Function:订单服务
 *
 * @author crossoverJie
 *         Date: 2018/7/28 16:43
 * @since JDK 1.8
 */
public class CommandOrder extends HystrixCommand&lt;String&gt; {

    private final static Logger LOGGER = LoggerFactory.getLogger(CommandOrder.class);

    private String orderName;

    public CommandOrder(String orderName) {


        super(Setter.withGroupKey(
                //服务分组
                HystrixCommandGroupKey.Factory.asKey("OrderGroup"))
                //线程分组
                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey("OrderPool"))

                //线程池配置
                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                        .withCoreSize(10)
                        .withKeepAliveTimeMinutes(5)
                        .withMaxQueueSize(10)
                        .withQueueSizeRejectionThreshold(10000))

                .andCommandPropertiesDefaults(
                        HystrixCommandProperties.Setter()
                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))
        )
        ;
        this.orderName = orderName;
    }


    @Override
    public String run() throws Exception {

        LOGGER.info("orderName=[{}]", orderName);

        TimeUnit.MILLISECONDS.sleep(100);
        return "OrderName=" + orderName;
    }


}


/**
 * Function:用户服务
 *
 * @author crossoverJie
 *         Date: 2018/7/28 16:43
 * @since JDK 1.8
 */
public class CommandUser extends HystrixCommand&lt;String&gt; {

    private final static Logger LOGGER = LoggerFactory.getLogger(CommandUser.class);

    private String userName;

    public CommandUser(String userName) {


        super(Setter.withGroupKey(
                //服务分组
                HystrixCommandGroupKey.Factory.asKey("UserGroup"))
                //线程分组
                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey("UserPool"))

                //线程池配置
                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()
                        .withCoreSize(10)
                        .withKeepAliveTimeMinutes(5)
                        .withMaxQueueSize(10)
                        .withQueueSizeRejectionThreshold(10000))

                //线程池隔离
                .andCommandPropertiesDefaults(
                        HystrixCommandProperties.Setter()
                                .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD))
        )
        ;
        this.userName = userName;
    }


    @Override
    public String run() throws Exception {

        LOGGER.info("userName=[{}]", userName);

        TimeUnit.MILLISECONDS.sleep(100);
        return "userName=" + userName;
    }


}
</code></pre>

<hr />

<p><code>api</code> 特别简洁易懂，具体详情请查看官方文档。</p>

<p>然后模拟运行：</p>

<pre><code class="language-java">    public static void main(String[] args) throws Exception {
        CommandOrder commandPhone = new CommandOrder("手机");
        CommandOrder command = new CommandOrder("电视");


        //阻塞方式执行
        String execute = commandPhone.execute();
        LOGGER.info("execute=[{}]", execute);

        //异步非阻塞方式
        Future&lt;String&gt; queue = command.queue();
        String value = queue.get(200, TimeUnit.MILLISECONDS);
        LOGGER.info("value=[{}]", value);


        CommandUser commandUser = new CommandUser("张三");
        String name = commandUser.execute();
        LOGGER.info("name=[{}]", name);
    }
</code></pre>

<p>可以看到两个任务分成了两个线程池运行，他们之间互不干扰。</p>

<p>获取任务任务结果支持同步阻塞和异步非阻塞方式，可自行选择。</p>

<p>它的实现原理其实容易猜到：</p>

<blockquote>
  <p>利用一个 Map 来存放不同业务对应的线程池。</p>
</blockquote>

<h2 id="总结-2">总结</h2>

<p>池化技术确实在平时应用广泛，熟练掌握能提高不少效率。</p>

<p>文末的 hystrix <a href="https://github.com/crossoverJie/Java-Interview/tree/master/src/main/java/com/crossoverjie/hystrix">源码</a></p>

<h1 id="线程通信">线程通信</h1>

<h2 id="前言">前言</h2>

<p>开发中不免会遇到需要所有子线程执行完毕通知主线程处理某些逻辑的场景。</p>

<p>或者是线程 A 在执行到某个条件通知线程 B 执行某个操作。</p>

<p>可以通过以下几种方式实现：</p>

<h2 id="等待通知机制">等待通知机制</h2>

<blockquote>
  <p>等待通知模式是 Java 中比较经典的线程通信方式。</p>
</blockquote>

<p>两个线程通过对同一对象调用等待 wait() 和通知 notify() 方法来进行通讯。</p>

<p>如两个线程交替打印奇偶数：</p>

<pre><code class="language-java">public class TwoThreadWaitNotify {

    private int start = 1;

    private boolean flag = false;

    public static void main(String[] args) {
        TwoThreadWaitNotify twoThread = new TwoThreadWaitNotify();

        Thread t1 = new Thread(new OuNum(twoThread));
        t1.setName("A");


        Thread t2 = new Thread(new JiNum(twoThread));
        t2.setName("B");

        t1.start();
        t2.start();
    }

    /**
     * 偶数线程
     */
    public static class OuNum implements Runnable {
        private TwoThreadWaitNotify number;

        public OuNum(TwoThreadWaitNotify number) {
            this.number = number;
        }

        @Override
        public void run() {

            while (number.start &lt;= 100) {
                synchronized (TwoThreadWaitNotify.class) {
                    System.out.println("偶数线程抢到锁了");
                    if (number.flag) {
                        System.out.println(Thread.currentThread().getName() + "+-+偶数" + number.start);
                        number.start++;

                        number.flag = false;
                        TwoThreadWaitNotify.class.notify();

                    }else {
                        try {
                            TwoThreadWaitNotify.class.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }

            }
        }
    }


    /**
     * 奇数线程
     */
    public static class JiNum implements Runnable {
        private TwoThreadWaitNotify number;

        public JiNum(TwoThreadWaitNotify number) {
            this.number = number;
        }

        @Override
        public void run() {
            while (number.start &lt;= 100) {
                synchronized (TwoThreadWaitNotify.class) {
                    System.out.println("奇数线程抢到锁了");
                    if (!number.flag) {
                        System.out.println(Thread.currentThread().getName() + "+-+奇数" + number.start);
                        number.start++;

                        number.flag = true;

                        TwoThreadWaitNotify.class.notify();
                    }else {
                        try {
                            TwoThreadWaitNotify.class.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }
}
</code></pre>

<p>输出结果：</p>

<pre><code>t2+-+奇数93
t1+-+偶数94
t2+-+奇数95
t1+-+偶数96
t2+-+奇数97
t1+-+偶数98
t2+-+奇数99
t1+-+偶数100
</code></pre>

<p>这里的线程 A 和线程 B 都对同一个对象 <code>TwoThreadWaitNotify.class</code> 获取锁，A 线程调用了同步对象的 wait() 方法释放了锁并进入 <code>WAITING</code> 状态。</p>

<p>B 线程调用了 notify() 方法，这样 A 线程收到通知之后就可以从 wait() 方法中返回。</p>

<p>这里利用了 <code>TwoThreadWaitNotify.class</code> 对象完成了通信。</p>

<p>有一些需要注意:</p>

<ul>
  <li>wait() 、notify()、notifyAll() 调用的前提都是获得了对象的锁(也可称为对象监视器)。</li>
  <li>调用 wait() 方法后线程会释放锁，进入 <code>WAITING</code> 状态，该线程也会被移动到<strong>等待队列</strong>中。</li>
  <li>调用 notify() 方法会将<strong>等待队列</strong>中的线程移动到<strong>同步队列</strong>中，线程状态也会更新为 <code>BLOCKED</code></li>
  <li>从 wait() 方法返回的前提是调用 notify() 方法的线程释放锁，wait() 方法的线程获得锁。</li>
</ul>

<p>等待通知有着一个经典范式：</p>

<p>线程 A 作为消费者：</p>

<ol>
  <li>获取对象的锁。</li>
  <li>进入 while(判断条件)，并调用 wait() 方法。</li>
  <li>当条件满足跳出循环执行具体处理逻辑。</li>
</ol>

<p>线程 B 作为生产者:</p>

<ol>
  <li>获取对象锁。</li>
  <li>更改与线程 A 共用的判断条件。</li>
  <li>调用 notify() 方法。</li>
</ol>

<p>伪代码如下:</p>

<pre><code>//Thread A

synchronized(Object){
    while(条件){
        Object.wait();
    }
    //do something
}

//Thread B
synchronized(Object){
    条件=false;//改变条件
    Object.notify();
}
</code></pre>

<h2 id="join-方法">join() 方法</h2>

<pre><code class="language-java">    private static void join() throws InterruptedException {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("running");
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }) ;
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("running2");
                try {
                    Thread.sleep(4000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }) ;

        t1.start();
        t2.start();

        //等待线程1终止
        t1.join();

        //等待线程2终止
        t2.join();

        LOGGER.info("main over");
    }
</code></pre>

<p>输出结果:</p>

<pre><code>2018-03-16 20:21:30.967 [Thread-1] INFO  c.c.actual.ThreadCommunication - running2
2018-03-16 20:21:30.967 [Thread-0] INFO  c.c.actual.ThreadCommunication - running
2018-03-16 20:21:34.972 [main] INFO  c.c.actual.ThreadCommunication - main over
</code></pre>

<p>在  <code>t1.join()</code> 时会一直阻塞到 t1 执行完毕，所以最终主线程会等待 t1 和 t2 线程执行完毕。</p>

<p>其实从源码可以看出，join() 也是利用的等待通知机制：</p>

<p>核心逻辑:</p>

<pre><code class="language-java">    while (isAlive()) {
        wait(0);
    }
</code></pre>

<p>在 join 线程完成后会调用 notifyAll() 方法，是在 JVM 实现中调用，所以这里看不出来。</p>

<h2 id="volatile-共享内存">volatile 共享内存</h2>

<p>因为 Java 是采用共享内存的方式进行线程通信的，所以可以采用以下方式用主线程关闭 A 线程:</p>

<pre><code class="language-java">public class Volatile implements Runnable{

    private static volatile boolean flag = true ;

    @Override
    public void run() {
        while (flag){
            System.out.println(Thread.currentThread().getName() + "正在运行。。。");
        }
        System.out.println(Thread.currentThread().getName() +"执行完毕");
    }

    public static void main(String[] args) throws InterruptedException {
        Volatile aVolatile = new Volatile();
        new Thread(aVolatile,"thread A").start();


        System.out.println("main 线程正在运行") ;

        TimeUnit.MILLISECONDS.sleep(100) ;

        aVolatile.stopThread();

    }

    private void stopThread(){
        flag = false ;
    }
}
</code></pre>

<p>输出结果：</p>

<pre><code>thread A正在运行。。。
thread A正在运行。。。
thread A正在运行。。。
thread A正在运行。。。
thread A执行完毕
</code></pre>

<p>这里的 flag 存放于主内存中，所以主线程和线程 A 都可以看到。</p>

<p>flag 采用 volatile 修饰主要是为了内存可见性，更多内容可以查看<a href="http://crossoverjie.top/2018/03/09/volatile/">这里</a>。</p>

<h2 id="countdownlatch-并发工具">CountDownLatch 并发工具</h2>

<p>CountDownLatch 可以实现 join 相同的功能，但是更加的灵活。</p>

<pre><code class="language-java">    private static void countDownLatch() throws Exception{
        int thread = 3 ;
        long start = System.currentTimeMillis();
        final CountDownLatch countDown = new CountDownLatch(thread);
        for (int i= 0 ;i&lt;thread ; i++){
            new Thread(new Runnable() {
                @Override
                public void run() {
                    LOGGER.info("thread run");
                    try {
                        Thread.sleep(2000);
                        countDown.countDown();

                        LOGGER.info("thread end");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }

        countDown.await();
        long stop = System.currentTimeMillis();
        LOGGER.info("main over total time={}",stop-start);
    }
</code></pre>

<p>输出结果:</p>

<pre><code>2018-03-16 20:19:44.126 [Thread-0] INFO  c.c.actual.ThreadCommunication - thread run
2018-03-16 20:19:44.126 [Thread-2] INFO  c.c.actual.ThreadCommunication - thread run
2018-03-16 20:19:44.126 [Thread-1] INFO  c.c.actual.ThreadCommunication - thread run
2018-03-16 20:19:46.136 [Thread-2] INFO  c.c.actual.ThreadCommunication - thread end
2018-03-16 20:19:46.136 [Thread-1] INFO  c.c.actual.ThreadCommunication - thread end
2018-03-16 20:19:46.136 [Thread-0] INFO  c.c.actual.ThreadCommunication - thread end
2018-03-16 20:19:46.136 [main] INFO  c.c.actual.ThreadCommunication - main over total time=2012
</code></pre>

<p>CountDownLatch 也是基于 AQS(AbstractQueuedSynchronizer) 实现的，更多实现参考 <a href="http://crossoverjie.top/2018/01/25/ReentrantLock/">ReentrantLock 实现原理</a></p>

<ul>
  <li>初始化一个 CountDownLatch 时告诉并发的线程，然后在每个线程处理完毕之后调用 countDown() 方法。</li>
  <li>该方法会将 AQS 内置的一个 state 状态 -1 。</li>
  <li>最终在主线程调用 await() 方法，它会阻塞直到 <code>state == 0</code> 的时候返回。</li>
</ul>

<h2 id="cyclicbarrier-并发工具"><a href="https://crossoverjie.top/JCSprout/#/thread/thread-communication?id=cyclicbarrier-并发工具">CyclicBarrier 并发工具</a></h2>

<pre><code class="language-java">    private static void cyclicBarrier() throws Exception {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3) ;

        new Thread(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("thread run");
                try {
                    cyclicBarrier.await() ;
                } catch (Exception e) {
                    e.printStackTrace();
                }

                LOGGER.info("thread end do something");
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("thread run");
                try {
                    cyclicBarrier.await() ;
                } catch (Exception e) {
                    e.printStackTrace();
                }

                LOGGER.info("thread end do something");
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("thread run");
                try {
                    Thread.sleep(5000);
                    cyclicBarrier.await() ;
                } catch (Exception e) {
                    e.printStackTrace();
                }

                LOGGER.info("thread end do something");
            }
        }).start();

        LOGGER.info("main thread");
    }
</code></pre>

<p>CyclicBarrier 中文名叫做屏障或者是栅栏，也可以用于线程间通信。</p>

<p>它可以等待 N 个线程都达到某个状态后继续运行的效果。</p>

<ol>
  <li>首先初始化线程参与者。</li>
  <li>调用 <code>await()</code> 将会在所有参与者线程都调用之前等待。</li>
  <li>直到所有参与者都调用了 <code>await()</code> 后，所有线程从 <code>await()</code> 返回继续后续逻辑。</li>
</ol>

<p>运行结果:</p>

<pre><code>2018-03-18 22:40:00.731 [Thread-0] INFO  c.c.actual.ThreadCommunication - thread run
2018-03-18 22:40:00.731 [Thread-1] INFO  c.c.actual.ThreadCommunication - thread run
2018-03-18 22:40:00.731 [Thread-2] INFO  c.c.actual.ThreadCommunication - thread run
2018-03-18 22:40:00.731 [main] INFO  c.c.actual.ThreadCommunication - main thread
2018-03-18 22:40:05.741 [Thread-0] INFO  c.c.actual.ThreadCommunication - thread end do something
2018-03-18 22:40:05.741 [Thread-1] INFO  c.c.actual.ThreadCommunication - thread end do something
2018-03-18 22:40:05.741 [Thread-2] INFO  c.c.actual.ThreadCommunication - thread end do something
</code></pre>

<p>可以看出由于其中一个线程休眠了五秒，所有其余所有的线程都得等待这个线程调用 <code>await()</code> 。</p>

<p>该工具可以实现 CountDownLatch 同样的功能，但是要更加灵活。甚至可以调用 <code>reset()</code> 方法重置 CyclicBarrier (需要自行捕获 BrokenBarrierException 处理) 然后重新执行。</p>

<h2 id="线程响应中断">线程响应中断</h2>

<pre><code class="language-java">public class StopThread implements Runnable {
    @Override
    public void run() {

        while ( !Thread.currentThread().isInterrupted()) {
            // 线程执行具体逻辑
            System.out.println(Thread.currentThread().getName() + "运行中。。");
        }

        System.out.println(Thread.currentThread().getName() + "退出。。");

    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new StopThread(), "thread A");
        thread.start();

        System.out.println("main 线程正在运行") ;

        TimeUnit.MILLISECONDS.sleep(10) ;
        thread.interrupt();
    }


}
</code></pre>

<p>输出结果:</p>

<pre><code>thread A运行中。。
thread A运行中。。
thread A退出。。
</code></pre>

<p>可以采用中断线程的方式来通信，调用了 <code>thread.interrupt()</code> 方法其实就是将 thread 中的一个标志属性置为了 true。</p>

<p>并不是说调用了该方法就可以中断线程，如果不对这个标志进行响应其实是没有什么作用(这里对这个标志进行了判断)。</p>

<p><strong>但是如果抛出了 InterruptedException 异常，该标志就会被 JVM 重置为 false。</strong></p>

<h2 id="线程池-awaittermination-方法">线程池 awaitTermination() 方法</h2>

<p>如果是用线程池来管理线程，可以使用以下方式来让主线程等待线程池中所有任务执行完毕:</p>

<pre><code class="language-java">    private static void executorService() throws Exception{
        BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;&gt;(10) ;
        ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5,5,1, TimeUnit.MILLISECONDS,queue) ;
        poolExecutor.execute(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("running");
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        poolExecutor.execute(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("running2");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        poolExecutor.shutdown();
        while (!poolExecutor.awaitTermination(1,TimeUnit.SECONDS)){
            LOGGER.info("线程还在执行。。。");
        }
        LOGGER.info("main over");
    }
</code></pre>

<p>输出结果:</p>

<pre><code>2018-03-16 20:18:01.273 [pool-1-thread-2] INFO  c.c.actual.ThreadCommunication - running2
2018-03-16 20:18:01.273 [pool-1-thread-1] INFO  c.c.actual.ThreadCommunication - running
2018-03-16 20:18:02.273 [main] INFO  c.c.actual.ThreadCommunication - 线程还在执行。。。
2018-03-16 20:18:03.278 [main] INFO  c.c.actual.ThreadCommunication - 线程还在执行。。。
2018-03-16 20:18:04.278 [main] INFO  c.c.actual.ThreadCommunication - main over
</code></pre>

<p>使用这个 <code>awaitTermination()</code> 方法的前提需要关闭线程池，如调用了 <code>shutdown()</code> 方法。</p>

<p>调用了 <code>shutdown()</code> 之后线程池会停止接受新任务，并且会平滑的关闭线程池中现有的任务。</p>

<h2 id="管道通信">管道通信</h2>

<pre><code class="language-java">    public static void piped() throws IOException {
        //面向于字符 PipedInputStream 面向于字节
        PipedWriter writer = new PipedWriter();
        PipedReader reader = new PipedReader();

        //输入输出流建立连接
        writer.connect(reader);


        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("running");
                try {
                    for (int i = 0; i &lt; 10; i++) {

                        writer.write(i+"");
                        Thread.sleep(10);
                    }
                } catch (Exception e) {

                } finally {
                    try {
                        writer.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }

            }
        });
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                LOGGER.info("running2");
                int msg = 0;
                try {
                    while ((msg = reader.read()) != -1) {
                        LOGGER.info("msg={}", (char) msg);
                    }

                } catch (Exception e) {

                }
            }
        });
        t1.start();
        t2.start();
    }
</code></pre>

<p>输出结果:</p>

<pre><code>2018-03-16 19:56:43.014 [Thread-0] INFO  c.c.actual.ThreadCommunication - running
2018-03-16 19:56:43.014 [Thread-1] INFO  c.c.actual.ThreadCommunication - running2
2018-03-16 19:56:43.130 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=0
2018-03-16 19:56:43.132 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=1
2018-03-16 19:56:43.132 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=2
2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=3
2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=4
2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=5
2018-03-16 19:56:43.133 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=6
2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=7
2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=8
2018-03-16 19:56:43.134 [Thread-1] INFO  c.c.actual.ThreadCommunication - msg=9
</code></pre>

<p>Java 虽说是基于内存通信的，但也可以使用管道通信。</p>

<p>需要注意的是，输入流和输出流需要首先建立连接。这样线程 B 就可以收到线程 A 发出的消息了。</p>

<p>实际开发中可以灵活根据需求选择最适合的线程通信方式。</p>

</div>
<div class="v">
  <i class="fas fa-spinner fa-pulse"></i>
</div>
<script
  src='https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js'
  defer='defer'
  onload='
    new Valine({
      "el": document.getElementsByClassName("v")[0],
      "appId": "9hABRddSuEkTgqLrt1VSK5B1-gzGzoHsz",
      "appKey": "NJ7RwmgrxsF7KDzlqU7YewlL",
      "placeholder": "在这里评论吧！填写邮箱可以获得 Gravatar 头像和回复通知哦",
      "requiredFields": ["nick","mail"],
      "visitor": true,
      "recordIP": true
    })'
></script>

</div>
  </div>
  
  <label for="sidebar-checkbox" class="sidebar-toggle"></label>
  
</body>

</html>