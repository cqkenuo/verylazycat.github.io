<p>[toc]</p>

<h1 id="进程标示符pid">进程标示符pid</h1>

<p>类型:pid_t</p>

<p>命令:ps</p>

<ul>
  <li>getpid</li>
  <li>getppid</li>
</ul>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t getpid(void);
pid_t getppid(void);
</code></pre>

<h1 id="进程产生">进程产生</h1>

<ul>
  <li>fork</li>
  <li>vfork</li>
</ul>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t fork(void);
</code></pre>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t vfork(void);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
vfork():
Since glibc 2.12:
(_XOPEN_SOURCE &gt;= 500) &amp;&amp; ! (_POSIX_C_SOURCE &gt;= 200809L)
|| /* Since glibc 2.19: */ _DEFAULT_SOURCE
|| /* Glibc versions &lt;= 2.19: */ _BSD_SOURCE
Before glibc 2.12:
_BSD_SOURCE || _XOPEN_SOURCE &gt;= 500
</code></pre>

<p>fork()  creates  a new process by duplicating the calling process.  The
       new process is referred to as the child process.  The  calling  process
       is referred to as the parent process.</p>

<p>fork后父子进程区别:</p>

<ol>
  <li>返回值不同</li>
  <li>pid不同,ppid不同</li>
  <li>未决信号和文件锁不继承</li>
  <li>资源利用量清0</li>
</ol>

<p>init进程:1号,是所有的进程的祖先进程</p>

<p><code>调度器的调度策略决定那个进程先运行</code></p>

<p>在fork之前,尽量刷新所有的流:fflush<很重要></很重要></p>

<h1 id="进程消亡以及资源释放">进程消亡以及资源释放</h1>

<ul>
  <li>wait</li>
  <li>waitpid</li>
  <li>waitid</li>
  <li>wait3</li>
  <li>wait4</li>
</ul>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
pid_t wait(int *wstatus);
pid_t waitpid(pid_t pid, int *wstatus, int options);
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
/* This is the glibc and POSIX interface; see
NOTES for information on the raw system call. */
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
waitid():
Since glibc 2.26: _XOPEN_SOURCE &gt;= 500 ||
_POSIX_C_SOURCE &gt;= 200809L
Glibc 2.25 and earlier:
_XOPEN_SOURCE
|| /* Since glibc 2.12: */ _POSIX_C_SOURCE &gt;= 200809L
|| /* Glibc versions &lt;= 2.19: */ _BSD_SOURCE
</code></pre>

<h1 id="exec函数族">exec函数族</h1>

<pre><code class="language-c">#include &lt;unistd.h&gt;
extern char **environ;
int execl(const char *path, const char *arg, ...
/* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
/* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
/*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
char *const envp[]);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
execvpe(): _GNU_SOURCE
</code></pre>

<h1 id="用户权限以及组权限">用户权限以及组权限</h1>

<p>u+s</p>

<p>g+s</p>

<ul>
  <li>getuid</li>
  <li>geteuid</li>
</ul>

<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
uid_t getuid(void);
uid_t geteuid(void);
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
gid_t getgid(void);
gid_t getegid(void);
</code></pre>

<ul>
  <li>setuid</li>
</ul>

<pre><code>#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int setuid(uid_t uid);
</code></pre>

<ul>
  <li>setgid</li>
</ul>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int setgid(gid_t gid);
</code></pre>

<ul>
  <li>setreuid</li>
</ul>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int setreuid(uid_t ruid, uid_t euid);
int setregid(gid_t rgid, gid_t egid);
</code></pre>

<h1 id="解释器文件">解释器文件</h1>

<pre><code class="language-bash">#!bin/bash
</code></pre>

<h1 id="system">system</h1>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
int system(const char *command);
</code></pre>

<p><code>fork</code>+<code>exec</code>+<code>wait</code>封装</p>

<h1 id="进程会计">进程会计</h1>

<ul>
  <li>acct</li>
</ul>

<pre><code class="language-c">#include &lt;unistd.h&gt;
int acct(const char *filename);
</code></pre>

<p>不是标准,了解即可</p>

<h1 id="进程时间">进程时间</h1>

<ul>
  <li>times</li>
</ul>

<pre><code class="language-c">#include &lt;sys/times.h&gt;
clock_t times(struct tms *buf);
</code></pre>

<h1 id="守护进程">守护进程</h1>

<p>session:sid</p>

<ul>
  <li>setsid</li>
</ul>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
pid_t setsid(void);
</code></pre>

<ul>
  <li>getpgrp</li>
</ul>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int setpgid(pid_t pid, pid_t pgid);
pid_t getpgid(pid_t pid);
pid_t getpgrp(void);                 /* POSIX.1 version */
pid_t getpgrp(pid_t pid);            /* BSD version */
int setpgrp(void);                   /* System V version */
int setpgrp(pid_t pid, pid_t pgid);  /* BSD version */
</code></pre>

<p>单实例守护进程:锁文件:/var/run/name.pid</p>

<p>启动脚本文件: /etc/rc*…</p>

<h1 id="系统日志">系统日志</h1>

<p>syslogd服务</p>

<ul>
  <li>openlog</li>
  <li>syslog</li>
</ul>

<pre><code class="language-c">#include &lt;syslog.h&gt;
void openlog(const char *ident, int option, int facility);
void syslog(int priority, const char *format, ...);
void closelog(void);
void vsyslog(int priority, const char *format, va_list ap);
</code></pre>

