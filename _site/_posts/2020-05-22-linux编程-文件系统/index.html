<p>[toc]</p>

<h1 id="文件系统">文件系统</h1>

<h2 id="获取文件属性">获取文件属性</h2>

<ul>
  <li>stat</li>
</ul>

<p>stat, fstat, lstat, fstatat - get file status</p>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);
#include &lt;fcntl.h&gt;           /* Definition of AT_* constants */
#include &lt;sys/stat.h&gt;
int fstatat(int dirfd, const char *pathname, struct stat *statbuf,
            int flags);
</code></pre>

<h2 id="stat结构体">stat结构体</h2>

<pre><code class="language-c">struct stat {
dev_t     st_dev;         /* ID of device containing file */
ino_t     st_ino;         /* Inode number */
mode_t    st_mode;        /* File type and mode */
nlink_t   st_nlink;       /* Number of hard links */
uid_t     st_uid;         /* User ID of owner */
gid_t     st_gid;         /* Group ID of owner */
dev_t     st_rdev;        /* Device ID (if special file) */
off_t     st_size;        /* Total size, in bytes */
blksize_t st_blksize;     /* Block size for filesystem I/O */
blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

/* Since Linux 2.6, the kernel supports nanosecond
precision for the following timestamp fields.
For the details before Linux 2.6, see NOTES. */

struct timespec st_atim;  /* Time of last access */
struct timespec st_mtim;  /* Time of last modification */
struct timespec st_ctim;  /* Time of last status change */

#define st_atime st_atim.tv_sec      /* Backward compatibility */
#define st_mtime st_mtim.tv_sec
#define st_ctime st_ctim.tv_sec
};
</code></pre>

<p>获取文件大小测试程序</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
//获取文件大小函数
static off_t flen(const char *filename)
{
    //获取文件属性
    struct stat fileinfo;
    if(stat(filename,&amp;fileinfo) &lt; 0)
    {
        perror("stat()");
        exit(1);
    }
    return fileinfo.st_size;
}
</code></pre>

<p><strong>在 Linux 系统中，一个文件实际占用了多大的磁盘空间要看 st_blocks 的数量，而不是看 st_size 的大小</strong>;一般情况下文件系统的一个 block 的大小为 4KB，而每个 st_blocks 是 512B，所以一个有效文件站用磁盘空间最小的大小为 8 个 st_blocks</p>

<p>空洞文件</p>

<pre><code class="language-c"> int fd;
    fd = open(argv[1],O_WRONLY|O_CREAT|O_TRUNC,0600);
    if(fd  &lt; 0)
    {
        perror("open()");
        exit(0);
    }
    //偏移
//带上LL单位
    lseek(fd,5LL*1024LL*1024LL*1024LL - 1LL,SEEK_SET);
    write(fd,"",1);
    close(fd);
</code></pre>

<p>mode_t    st_mode</p>

<pre><code class="language-markdown">权限和文件类型，位图，权限位9位，类型3位，u+s 1位，g+s 1位，粘滞位(T位)1位。位图是用一位或几位数据表示某种状态
</code></pre>

<p>文件类型:<code>dcb-lsp</code></p>

<table>
  <thead>
    <tr>
      <th>d</th>
      <th>目录</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>c</td>
      <td>字符快设备文件</td>
    </tr>
    <tr>
      <td>b</td>
      <td>块文件</td>
    </tr>
    <tr>
      <td>-</td>
      <td>普通文件</td>
    </tr>
    <tr>
      <td>l</td>
      <td>符号链接文件</td>
    </tr>
    <tr>
      <td>s</td>
      <td>套接字文件</td>
    </tr>
    <tr>
      <td>p</td>
      <td>管道文件</td>
    </tr>
  </tbody>
</table>

<h2 id="文件权限更改">文件权限更改</h2>

<ul>
  <li>chmod</li>
  <li>fchmod</li>
</ul>

<pre><code class="language-c">#include &lt;sys/stat.h&gt;
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
#include &lt;fcntl.h&gt;           /* Definition of AT_* constants */
#include &lt;sys/stat.h&gt;
int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags);
</code></pre>

<h2 id="粘住位">粘住位</h2>

<p>t位</p>

<hr />

<p>文件系统:<code>FAT</code>,<code>UFS</code></p>

<h2 id="硬链接符号链接">硬链接&amp;符号链接</h2>

<p>硬链接与目录项是同义词,且建立硬链接有限制,不能给分区建立,不能给目录建立;符号链接优点:可跨分区,可以给目录建立</p>

<ul>
  <li>link</li>
</ul>

<pre><code class="language-c">#include &lt;unistd.h&gt;
int link(const char *oldpath, const char *newpath);
#include &lt;fcntl.h&gt;           /* Definition of AT_* constants */
#include &lt;unistd.h&gt;
int linkat(int olddirfd, const char *oldpath,
           int newdirfd, const char *newpath, int flags);
</code></pre>

<ul>
  <li>unlink</li>
</ul>

<pre><code class="language-c">#include &lt;unistd.h&gt;
int unlink(const char *pathname);
#include &lt;fcntl.h&gt;           /* Definition of AT_* constants */
#include &lt;unistd.h&gt;
int unlinkat(int dirfd, const char *pathname, int flags);
</code></pre>

<ul>
  <li>remove</li>
</ul>

<p>remove a file or directory</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
int remove(const char *pathname);
</code></pre>

<ul>
  <li>rename</li>
</ul>

<pre><code class="language-c">#include &lt;stdio.h&gt;
int rename(const char *oldpath, const char *newpath);
#include &lt;fcntl.h&gt;           /* Definition of AT_* constants */
#include &lt;stdio.h&gt;
int renameat(int olddirfd, const char *oldpath,
int newdirfd, const char *newpath);
int renameat2(int olddirfd, const char *oldpath,
int newdirfd, const char *newpath, unsigned int flags);
</code></pre>

<h2 id="文件时间">文件时间</h2>

<ul>
  <li>utime</li>
</ul>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;utime.h&gt;
int utime(const char *filename, const struct utimbuf *times);
#include &lt;sys/time.h&gt;
int utimes(const char *filename, const struct timeval times[2]);
</code></pre>

<h2 id="目录创建删除">目录创建&amp;删除</h2>

<ul>
  <li>mkdir</li>
</ul>

<pre><code class="language-c">#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
int mkdir(const char *pathname, mode_t mode);
#include &lt;fcntl.h&gt;           /* Definition of AT_* constants */
#include &lt;sys/stat.h&gt;
int mkdirat(int dirfd, const char *pathname, mode_t mode);
</code></pre>

<ul>
  <li>rmdir</li>
</ul>

<pre><code class="language-c">#include &lt;unistd.h&gt;
int rmdir(const char *pathname);
</code></pre>

<h2 id="修改工作路径">修改工作路径</h2>

<ul>
  <li>chdir</li>
</ul>

<pre><code class="language-c">#include &lt;unistd.h&gt;
int chdir(const char *path);
int fchdir(int fd);
</code></pre>

<p>突破安全限制,有缺陷</p>

<h2 id="获取当前工作路径">获取当前工作路径</h2>

<ul>
  <li>getcwd</li>
</ul>

<pre><code class="language-c">#include &lt;unistd.h&gt;
char *getcwd(char *buf, size_t size);
char *getwd(char *buf);
char *get_current_dir_name(void);
</code></pre>

<h2 id="目录glob函数">目录glob函数</h2>

<ul>
  <li>glob</li>
</ul>

<p>find pathnames <code>matching a pattern</code>, free memory from
       glob()</p>

<pre><code class="language-c">#include &lt;glob.h&gt;
int glob(const char *pattern, int flags,
int (*errfunc) (const char *epath, int eerrno),
glob_t *pglob);
void globfree(glob_t *pglob);
</code></pre>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;glob.h&gt;
//匹配的文件
#define PAT "/etc/a*.conf"
//返回错误的函数
int errfunc_(const char *epath,int eerror)
{
    puts(epath);
    fprintf(stderr,"error msg:%s\n",strerror(eerror));
    return 0;
}
int main(int argc, char const *argv[])
{
    glob_t       globres;
    int err = 0;
    err = glob(PAT,0,NULL,&amp;globres);
    if(err)
    {
        printf("error code = %d\n",err);
        exit(1);
    }
    for (size_t i = 0; i &lt; globres.gl_pathc; i++)
    {
        puts(globres.gl_pathv[i]);
    }
    globfree(&amp;globres);
    return 0;
}
</code></pre>

<ul>
  <li>opendir</li>
</ul>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
DIR *opendir(const char *name);
DIR *fdopendir(int fd);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
fdopendir():
Since glibc 2.10:
_POSIX_C_SOURCE &gt;= 200809L
Before glibc 2.10:
_GNU_SOURCE
</code></pre>

<ul>
  <li>closedir</li>
</ul>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
int closedir(DIR *dirp);
</code></pre>

<ul>
  <li>readdir</li>
</ul>

<pre><code class="language-c">#include &lt;dirent.h&gt;
struct dirent *readdir(DIR *dirp);
</code></pre>

<p>dirent结构体</p>

<pre><code class="language-c">struct dirent {
               ino_t          d_ino;       /* Inode number */
               off_t          d_off;       /* Not an offset; see below */
               unsigned short d_reclen;    /* Length of this record */
               unsigned char  d_type;      /* Type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* Null-terminated filename */
           };
</code></pre>

<p>获取文件名</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;dirent.h&gt;
#define PAT "/etc"
int main(int argc, char const *argv[])
{
    DIR *dp;
    struct dirent *cur;
    dp = opendir(PAT);
    if(dp == NULL)
    {
        perror("opendir");
        exit(1);
    }
    while ((cur = readdir(dp)) != NULL)
    {
         puts(cur-&gt;d_name);
    }
    closedir(dp);
    return 0;
}
</code></pre>

<ul>
  <li>rewenddir</li>
  <li>seekdir</li>
  <li>telldir</li>
</ul>

<hr />

<h2 id="系统数据文件和信息">系统数据文件和信息</h2>

<ul>
  <li>
    <p>/etc/passwd</p>

    <ul>
      <li>getpwuid</li>
      <li>getpwnam</li>
    </ul>

    <pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;pwd.h&gt;
struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);
int getpwnam_r(const char *name, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
int getpwuid_r(uid_t uid, struct passwd *pwd,
char *buf, size_t buflen, struct passwd **result);
</code></pre>

    <p>passwd结构体</p>
  </li>
</ul>

<pre><code class="language-c">struct passwd {
               char   *pw_name;       /* username */
               char   *pw_passwd;     /* user password */
               uid_t   pw_uid;        /* user ID */
               gid_t   pw_gid;        /* group ID */
               char   *pw_gecos;      /* user information */
               char   *pw_dir;        /* home directory */
               char   *pw_shell;      /* shell program */
           };
</code></pre>

<ul>
  <li>/etc/group
    <ul>
      <li>getgrgid</li>
      <li>getgrgrnam</li>
    </ul>
  </li>
  <li>
    <p>/etc/shadow</p>

    <ul>
      <li>getspnam</li>
    </ul>

    <pre><code class="language-c">#include &lt;shadow.h&gt;
struct spwd *getspnam(const char *name);
struct spwd *getspent(void);
void setspent(void);
void endspent(void);
struct spwd *fgetspent(FILE *stream);
struct spwd *sgetspent(const char *s);
int putspent(const struct spwd *p, FILE *stream);
int lckpwdf(void);
int ulckpwdf(void);
/* GNU extension */
#include &lt;shadow.h&gt;
int getspent_r(struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int getspnam_r(const char *name, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int fgetspent_r(FILE *stream, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
int sgetspent_r(const char *s, struct spwd *spbuf,
char *buf, size_t buflen, struct spwd **spbufp);
</code></pre>

    <p>spwd结构体</p>

    <pre><code class="language-c">struct spwd {
               char *sp_namp;     /* Login name */
               char *sp_pwdp;     /* Encrypted password */
               long  sp_lstchg;   /* Date of last change
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               long  sp_min;      /* Min # of days between changes */
               long  sp_max;      /* Max # of days between changes */
               long  sp_warn;     /* # of days before password expires
                                     to warn user to change it */
               long  sp_inact;    /* # of days after password expires
                                     until account is disabled */
               long  sp_expire;   /* Date when account expires
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               unsigned long sp_flag;  /* Reserved */
           };
</code></pre>

    <ul>
      <li>
        <p>crypt</p>

        <pre><code class="language-c">#define _XOPEN_SOURCE       /* See feature_test_macros(7) */
#include &lt;unistd.h&gt;
char *crypt(const char *key, const char *salt);
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include &lt;crypt.h&gt;
char *crypt_r(const char *key, const char *salt,
struct crypt_data *data);
Link with -lcrypt.
</code></pre>
      </li>
      <li>
        <p>getpass</p>
      </li>
    </ul>

    <pre><code class="language-c">#include &lt;unistd.h&gt;
char *getpass(const char *prompt);
</code></pre>
  </li>
  <li>
    <p>时间戳</p>

    <ul>
      <li>time</li>
    </ul>

    <pre><code class="language-c">#include &lt;time.h&gt;
time_t time(time_t *tloc);
</code></pre>

    <ul>
      <li>gmtime</li>
      <li>localtime</li>
    </ul>

    <pre><code class="language-c">#include &lt;time.h&gt;
char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);
char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);
struct tm *gmtime(const time_t *timep);
struct tm *gmtime_r(const time_t *timep, struct tm *result);
struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);
time_t mktime(struct tm *tm);
</code></pre>

    <p>tm结构体</p>

    <pre><code class="language-c">struct tm {
               int tm_sec;    /* Seconds (0-60) */
               int tm_min;    /* Minutes (0-59) */
               int tm_hour;   /* Hours (0-23) */
               int tm_mday;   /* Day of the month (1-31) */
               int tm_mon;    /* Month (0-11) */
               int tm_year;   /* Year - 1900 */
               int tm_wday;   /* Day of the week (0-6, Sunday = 0) */
               int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */
               int tm_isdst;  /* Daylight saving time */
           };
</code></pre>

    <ul>
      <li>strftime</li>
    </ul>

    <pre><code class="language-c">#include &lt;time.h&gt;
size_t strftime(char *s, size_t max, const char *format,
const struct tm *tm);
</code></pre>
  </li>
</ul>

<h2 id="进程环境">进程环境</h2>

<ul>
  <li>main函数</li>
</ul>

<pre><code class="language-c">int main(int argc,char *argv[])
//其实还有第三个参数,环境变量
</code></pre>

<ul>
  <li>进程的终止</li>
</ul>

<p>正常终止:</p>

<ol>
  <li>main函数返回</li>
  <li>调用exit</li>
  <li>调用_exit或者_Exit</li>
  <li>最后一个线程从其启动例程饭后</li>
  <li>最后一个线程调用pthread_exit</li>
</ol>

<p>异常终止:</p>

<ol>
  <li>调用abort</li>
  <li>接到一个信号并终止</li>
  <li>最后一个线程对其取消请求做出响应</li>
</ol>

<p>钩子函数</p>

<ul>
  <li>atexit</li>
</ul>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
int atexit(void (*function)(void));
</code></pre>

<ul>
  <li>
    <p>命令行参数分析</p>

    <ol>
      <li>getopt</li>
      <li>getopt_long</li>
    </ol>

    <pre><code class="language-c">#include &lt;unistd.h&gt;
int getopt(int argc, char * const argv[],
const char *optstring);
extern char *optarg;
extern int optind, opterr, optopt;
#include &lt;getopt.h&gt;
int getopt_long(int argc, char * const argv[],
const char *optstring,
const struct option *longopts, int *longindex);
int getopt_long_only(int argc, char * const argv[],
const char *optstring,
const struct option *longopts, int *longindex);
</code></pre>
  </li>
  <li>
    <p>环境变量</p>
  </li>
</ul>

<p>environ</p>

<pre><code class="language-c">extern char **environ;
</code></pre>

<p>getenv</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
char *getenv(const char *name);
char *secure_getenv(const char *name);
</code></pre>

<p>setenv</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
</code></pre>

<p>putenv</p>

<pre><code class="language-c">#include &lt;stdlib.h&gt;
int putenv(char *string);
</code></pre>

<ul>
  <li>c程序的存储空间布局</li>
</ul>

<p><code>pmap</code>命令查看</p>

<ul>
  <li>库</li>
</ul>

<ol>
  <li>动态库</li>
  <li>静态库</li>
  <li>手工装载库</li>
</ol>

<p>dlopen</p>

<p>dlclose</p>

<p>dlerror</p>

<p>dlsym</p>

<pre><code class="language-c">#include &lt;dlfcn.h&gt;
void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
#define _GNU_SOURCE
#include &lt;dlfcn.h&gt;
void *dlmopen (Lmid_t lmid, const char *filename, int flags);
Link with -ldl.   
    #include &lt;dlfcn.h&gt;
    void *dlopen(const char *filename, int flags);
int dlclose(void *handle);
#define _GNU_SOURCE
#include &lt;dlfcn.h&gt;
void *dlmopen (Lmid_t lmid, const char *filename, int flags);
#include &lt;dlfcn.h&gt;
char *dlerror(void);
void *dlsym(void *handle, const char *symbol);
#define _GNU_SOURCE
#include &lt;dlfcn.h&gt;
void *dlvsym(void *handle, char *symbol, char *version);
</code></pre>

<p>example</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
       #include &lt;stdlib.h&gt;
       #include &lt;dlfcn.h&gt;
       #include &lt;gnu/lib-names.h&gt;  /* Defines LIBM_SO (which will be a
                                      string such as "libm.so.6") */
       int
       main(void)
       {
           void *handle;
           double (*cosine)(double);
           char *error;

           handle = dlopen(LIBM_SO, RTLD_LAZY);
           if (!handle) {
               fprintf(stderr, "%s\n", dlerror());
               exit(EXIT_FAILURE);
           }

           dlerror();    /* Clear any existing error */

           cosine = (double (*)(double)) dlsym(handle, "cos");

           /* According to the ISO C standard, casting between function
              pointers and 'void *', as done above, produces undefined results.
              POSIX.1-2003 and POSIX.1-2008 accepted this state of affairs and
              proposed the following workaround:

                  *(void **) (&amp;cosine) = dlsym(handle, "cos");

              This (clumsy) cast conforms with the ISO C standard and will
              avoid any compiler warnings.

              The 2013 Technical Corrigendum to POSIX.1-2008 (a.k.a.
              POSIX.1-2013) improved matters by requiring that conforming
              implementations support casting 'void *' to a function pointer.
              Nevertheless, some compilers (e.g., gcc with the '-pedantic'
              option) may complain about the cast used in this program. */

           error = dlerror();
           if (error != NULL) {
               fprintf(stderr, "%s\n", error);
               exit(EXIT_FAILURE);
           }

           printf("%f\n", (*cosine)(2.0));
           dlclose(handle);
           exit(EXIT_SUCCESS);
       }
</code></pre>

<ul>
  <li>
    <p>函数跳转</p>

    <p>setjmp</p>

    <p>longjmp</p>
  </li>
  <li>
    <p>资源获取及控制</p>

    <p>getrlimit</p>

    <p>setrlimit</p>
  </li>
</ul>

<pre><code class="language-c">#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;
int getrlimit(int resource, struct rlimit *rlim);
int setrlimit(int resource, const struct rlimit *rlim);
int prlimit(pid_t pid, int resource, const struct rlimit *new_limit,
struct rlimit *old_limit);
</code></pre>

