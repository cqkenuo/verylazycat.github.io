<p>[toc]</p>

<h1 id="冒泡排序">冒泡排序</h1>

<p><img src="/img/冒泡排序.webp" alt="冒泡排序" /></p>

<pre><code class="language-c">void BubbleSort(int *array,int length)
{
    if (array == NULL)
    {
        fprintf(stderr,"empty\n");
        exit(1);
    }
    int temp = 0;
    for (size_t i = 0; i &lt; length; i++)
    {
        for (size_t j = i+1; j &lt; length; j++)
        {
            if (array[i] &gt; array[j])
            {
                temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            } 
        }          
    }
}
</code></pre>

<h1 id="选择排序">选择排序</h1>

<ol>
  <li>在一个长度为 N 的无序数组中，第一次遍历 n-1 个数找到最小的和第一个数交换。</li>
  <li>第二次从下一个数开始遍历 n-2 个数，找到最小的数和第二个数交换。</li>
  <li>重复以上操作直到第 n-1 次遍历最小的数和第 n-1 个数交换，排序完成</li>
</ol>

<p><img src="/img/选择排序.gif" alt="选择排序" /></p>

<pre><code class="language-c">void SelectSort(int *array,int length)
{
    if (array == NULL || length == 0)
    {
        fprintf(stderr,"empty\n");
        exit(1);
    }
    for (size_t i = 0; i &lt; length; i++)
    {
        int MinKey = array[i];
        for (size_t j = i; j &lt; length; j++)
        {
            if (MinKey &gt; array[j])
            {
                int temp = array[j];
                array[j] = MinKey;
                MinKey = temp;
            } 
        }
           array[i] = MinKey;
    }
}
</code></pre>

<h1 id="快速排序">快速排序</h1>

<ol>
  <li>
    <p>首先设定一个分界值，通过该分界值将数组分成左右两部分。</p>
  </li>
  <li>
    <p>将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。</p>
  </li>
  <li>
    <p>然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p>
  </li>
  <li>
    <p>重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了</p>

    <p><img src="/img/快速排序.gif" alt="快速排序" /></p>
  </li>
</ol>
