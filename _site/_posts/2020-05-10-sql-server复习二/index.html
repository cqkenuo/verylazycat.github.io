<p>[toc]</p>

<h1 id="关系模式">关系模式</h1>

<p>每个关系都有一个模式，称为关系模式(relation schema)，由一个关系名及它的所有属性名构成。一般表示为：关系名（属性1,属性2,…,属性n）</p>

<p>关系是一种规范化了的二维表格，具有如下性质：
属性值是原子的，不可分解。
没有重复元组。
没有行序。
理论上没有列序，但一般使用时都有列序</p>

<h1 id="关键码和表之间的联系">关键码和表之间的联系</h1>

<ol>
  <li>超键：在一个关系中，能惟一标识元组的属性或属性集称为关系的超键</li>
  <li>候选键：如果一个属性集能惟一标识元组，且又不含有多余的属性，那么这个属性集称为关系的候选键。</li>
  <li>主键：若一个关系中有多个候选键，则选其中的一个为关系的主键。</li>
  <li>外键：若一个关系R中包含有另一个关系S的主键所对应的属性组F，则称F为R的外键。并称关系S为参照关系，关系R为依赖关系。</li>
</ol>

<h1 id="基本的关系操作">基本的关系操作</h1>

<p>关系模型中常用的关系操作包括<code>查询（Query）</code>操作和<code>插入（Insert）</code>、<code>删除（Delete）</code>、<code>修改（Update）</code>操作。
查询操作又可以分为：<code>选择（Select）</code>、<code>投影（Project）</code>、<code>连接（Join）</code>、<code>除（Divide）</code>、<code>并（Union）</code>、<code>差（Except）</code>、<code>交（Intersection）</code>、<code>笛卡尔积等</code>。其中选择、投影、并、差、笛卡尔积是5种基本操作</p>

<h1 id="实体完整性entity-integrity约束">实体完整性（Entity Integrity）约束</h1>

<p>若属性（指一个或一组属性）A是基本关系R的主属性。则A不能取空值。</p>

<h1 id="参照完整性约束">参照完整性约束</h1>

<p>如果属性集K是关系模式R1的主键，K也是关系模式R2的外键，那么在R2的关系中，K的取值只允许两种可能，或者为空值，或者等于R1关系中某个主键值。
 这条规则的实质是“不允许引用不存在的实体”。
 在上述形式定义中，关系模式R1的关系称为“参照关系”，关系模式R2的关系称为“依赖关系”。</p>

<h1 id="用户定义的完整性规则">用户定义的完整性规则</h1>

<p>用户定义完整性约束（user defined integrity constraint）就是针对用户的具体应用环境，给出的具体数据的约束条件。 
用户可以针对具体的数据要求特征，设置完整性约束，由系统来检验实施，以使用统一的方法处理它们，不再由应用程序承担这项工作</p>

<h1 id="传统的集合运算">传统的集合运算</h1>

<ul>
  <li>并（Union）
      设关系R和S具有相同的关系模式，R和S的并是由属于R或属
  于S的元组构成的集合，记为R∪S。形式定义如下：
  R∪S≡{t | t∈R ∨ t∈S}，t是元组变量，R和S的元数相同。</li>
  <li>差（Difference）
      设关系R和S具有相同的关系模式，R和S的差是由属于R但不
  属于S的元组构成的集合，记为R－S。形式定义如下：
  R－S≡{ t | t∈R ∧ t∈S}，R和S的元数相同。</li>
  <li>交（intersection）
      关系R和S的交是由属于R又属于S的元组构成的集合，记为
R∩S，这里要求R和S定义在相同的关系模式上。形式定义如
下：
       R∩S≡{t︱t∈R ∧ t∈S}，R和S的元数相同。
由于R∩S = R-(R-S)，或R∩S = S-(S-R)，因此交操作不是一个独立的操作。</li>
  <li>笛卡儿积(Cartesian Product)
    设关系R和S的元数分别为r和s,定义R和S的一个(r+s)元的元
组集合，每个元组的前r个分量来自R的一个元组，后s个分量来自S的一个元组，记为R×S。
       R×S ≡{t|t=&lt;tr,ts&gt;∧tr∈R∧ts∈S}</li>
  <li>选择（Selection）
选择是在关系R中选择满足给定条件的所有元组构成的新关系。形式定义为：
σF(R)={t|t∈R∧F(t)=true}其中，F表示选择条件，它是一个逻辑表达式，取逻辑值“true”或“false”。在选择条件表达式F中，有时属性也用其排列序号来表示，常量值用单引号括起来。
例如，σ2＞ˊ3ˊ（R）表示从R中挑选第2个分量值大于3的元组所构成的关系。
书写时，为了与属性序号区别起见，常量用引号括起来，而属性序号或属性名不要用引号括起来。</li>
  <li>投影
关系R上的投影是从R中选择出若干属性列组成新的关系。形式定义为：
 πA(R)={t[A] | t∈R}
其中A为R中的属性列集合，其中A也可以用属性序号表示。 
投影操作是从列角度进行的运算。</li>
  <li>
    <p>连接（join）
连接（join）运算是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。</p>
  </li>
  <li>
    <h2 id="实例">实例</h2>
  </li>
</ul>

<p>例2.11 设教学数据库中有三个关系：
      学生关系   S(S#,SNAME,AGE,SEX)
      选课关系   SC(S#,C#,GRADE)<br />
      课程关系    C(C#,CNAME,TEACHER)
   用关系代数表达式表示查询语句。
  (1) 检索学习课程号为C2的学生学号与成绩。
        πS#,GRADE(σC#=‘C2’ (SC))
 (2) 检索学习课程号为C2的学生的学号与姓名。
         πS#,SNAME(σC#=‘C2’ (S ⋈ SC))
 (3) 检索选修课程名为MATHS的学生学号与姓名。
           πS#,SNAME(σCNAME=‘MATHS’ (S ⋈ SC ⋈ C))</p>

<p>(4) 检索选修课程号为C2或C4的学生学号。
           πS#(σC#=‘C2’ ∨C#=‘C4’(SC))
  (5) 检索至少选修课程号为C2和C4的学生学号。
           π1(σ1=4∧2=‘C2’ ∧5=‘C4’ (SC×SC))</p>

<hr />

<p>一般地有下列规律：
(1) 对于只涉及到选择、投影、连接的查询可用下列表达式表示：                <br />
             π(σ(R×S)) 	或者π(σ(R       S))
(2) 对于否定的操作，一般要用差操作表示，例如“检索不学C2课的学生姓名”。用下列表达式表示：
          πSNAME(S)-πSNAME(σCNO=’C2’(S       SC))但不能用下式表示：    		πSNAME(σCNO≠’C2’(S       SC))  <br />
⑶ 对于检索具有“全部”特征的操作，一般要用除法操作表示，例如“检索学习全部课程的学生学号”。用下列表达式表示：    <br />
         要用πSNO,CNO(SC)÷πCNO(C)表示</p>

<hr />

<h1 id="规范化原则">规范化原则</h1>

<p>关系模式有操作异常或冗余问题，就分解它</p>

<h1 id="函数依赖的定义">函数依赖的定义</h1>

<p>设有关系模式R(U)，X和Y是属性集U的子集，若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖（Functional Depend-
ency，简记为FD）于X，记作X→Y</p>

<h1 id="完全函数依赖和部分函数依赖">完全函数依赖和部分函数依赖</h1>

<p>假设在关系模式R(U)中，X和Y是属性集U的子集，且有X→Y，如果对于X的任一个真子集W，都有W→Y不成立，则称Y完全函数依赖于X，否则，称Y部分函数依赖于X。
 完全函数依赖说明了在依赖关系的决定项中没有多余的属性。
如函数依赖(SNO,CNO)→GRADE，TNAME→TAGE是完全函数依赖。 (SNO,CNO)→SNAME，(SNO,CNO)→CNAME，(SNO,CNO)→TNAME，(SNO,CNO)→TAGE都是部分函数依赖。</p>

<h1 id="fd和关键码的联系">FD和关键码的联系</h1>

<p>利用完全函数依赖和部分函数依赖可以说明函数依赖和键的关系：假设关系
模式R的属性集是U，X是U的一个子集。如果U部分函数依赖于X，则X是R的一个
超键。如果U完全函数依赖于X，则X是R的一个候选键。</p>

<h1 id="传递函数依赖">传递函数依赖</h1>

<p>假设在关系模式R(U)中，X 、Y和Z是属性集U的不同子集，如果X→Y（并且Y→X不成立），Y→Z，则称Z传递函数依赖X，或称X传递函数确定Z。
如函数依赖CNO→TNAME和TNAME→TAGE，所以R的函数依赖CNO→TAGE是传递函数依赖。</p>

<h1 id="armstrong推理">Armstrong推理</h1>

<p>从已知的一些函数依赖，可以推导出另外一些函数依赖，这就需要一系列的推理规则。称为Armstrong公理。</p>

<p>设U是关系模式R的属性集，F是R上成立的只涉及到U中属性的函数依赖集。FD的推理规则有以下三条：
 A1（自反性，Reflexivity）：若YXU，则X→Y在R上成立。
 A2（增广性，Augmentation）：若X→Y在R上成立，且ZU，则XZ→YZ在R上成立。
 A3（传递性，Transitivity）：若X→Y和Y→Z在R上成立，则X→Z在R上成立。</p>

<p>FD的其他五条推理规则:
(1) A4（合并性，Union）：｛ X→Y，X→Z ｝⊨X→YZ。
(2) A5（分解性，Decomposition）：  ｛ X→Y，ZY ｝ ⊨ X→Z 。
(3) A6（伪传递性）：｛ X→Y，WY→Z ｝⊨ WX→Z。
(4) A7（复合性，Composition）：  ｛ X→Y，W→Z ｝ ⊨ XW→YZ。</p>

<p>例：</p>

<pre><code class="language-markdown">例2.14  设关系R(ABCDE)上函数依赖集为F，并且F={A→BC，CD→E，B→D，E→A}。求出R的候选键。
解：已知A→BC，由分解性得A→B，A→C；又已知B→D，由传递性得 A→D；又由合并性得 A→CD，又已知CD→E，再由传递性得 A→E，因此，A是R的一个候选键。
同理可得R的另外三个候选键E、CD和BC。 
</code></pre>

<h1 id="关系的范式及规范化">关系的范式及规范化</h1>

<p>关系模式的好与坏，用什么标准衡量？这个标准就是模式的范式
（Normal Forms，简记为NF）。范式的种类与数据依赖有着直接的联系，基于FD的范式有1NF、2NF、3NF、BCNF等多种。
在不提及FD时，关系中是不可能有冗余的问题，但是当存在FD时，关系中就有可能存在数据冗余问题。
1NF是关系模式的基础；2NF已成为历史，一般不再提及；在数据库设计中最常用的是3NF和BCNF。</p>

<p>对于各种范式之间的联系有：</p>

<pre><code class="language-markdown">BCNF | 3NF | 2NF | 1NF
</code></pre>

<h1 id="范式">范式</h1>

<h2 id="第一范式">第一范式</h2>

<p>定义 如果关系模式R的每个关系r的属性值都是不可分的原子值，那么称R是第一范式（first normal form，简记为1NF）的模式。
满足1NF的关系称为规范化的关系，否则称为非规范化的关系。关系数据库研究的关系都是规范化的关系。例如关系模式R（NAME，
ADDRESS，PHONE），如果一个人有两个电话号码（PHONE），那么在关系中至少要出现两个元组，以便存储这两个号码。
1NF是关系模式应具备的最起码的条件。</p>

<p>非规范模式变为1NF：
   (1)  把不含单纯值的属性分解为多个原子值。
   (2)  把关系模式分解。</p>

<h2 id="第二范式">第二范式</h2>

<p>定义 如果关系模式R是1NF，且每个非主属性完全函数依赖于候选键，那么称R是第二范式（2NF）的模式。如果数据库模式中每个关系模式都是2NF，则称数据库模式为2NF的数据库模式。</p>

<pre><code class="language-markdown">例2.15 设关系模式R(SNO,CNO,GRADE,TNAME,TADDR) 。  
（SNO,CNO）是R的候选键。R上有两个函数依赖：
  (SNO,CNO)→(TNAME,TADDR)
   CNO→(TNAME,TADDR)
 前一个函数依赖是局部依赖，R不属于2NF模式。此时R的关系就会出现数据冗余和操作异常现象。
如果把R分解成R1(CNO,TNAME,TADDR)和R2(SNO,CNO,GRADE)后，局部依赖(SNO,CNO)→(TNAME,TADDR)就消失了。R1和R2都属于2NF模式。  
</code></pre>

<h2 id="第三范式">第三范式</h2>

<p>定义  如果关系模式R是1NF，且每个非主属性都不传递依赖于R的候选键，那么称R是第三范式（3NF）的模式。如果数据库模式中每个关系模式都是3NF，则称其为3NF的数据库模式 。</p>

<pre><code class="language-markdown">例  在例2.15中，R2是2NF模式，而且也已是3NF模式。
R1(CNO,TNAME,TADDR)是2NF模式，却不是3NF模式。这是因为R1中存在函数依赖CNO→TNAME和TNAME→TADDR，则CNO→TADDR是一个传递依赖。
如果把R2分解成R21(TNAME,TADDR)和R22(CNO,TNAME)后，CNO→TADDR就不会出现在R21和R22中。这样R21和R22都是3NF模式。 
</code></pre>

<h2 id="bc范式">BC范式</h2>

<p>定义 如果关系模式R是1NF，且每个属性都不传递依赖于R的候选键，那么称R是BCNF的模式。如果数据库模式中每个关系模式都是BCNF，则称为BCNF的数据库模式。
如果R是BCNF模式，那么R也是3NF模式。</p>

<pre><code class="language-markdown">例2.16 设关系模式C(CNO,CNAME,PCNO)的属性分别表示课程号、课程名和先修课程号。
CNO是主键，这里没有任何非主属性对CNO部分依赖或传递依赖，所以C属于3NF。
同时C中CNO是唯一的决定因素，所以C∈BCNF。 
</code></pre>

<pre><code class="language-markdown">例2.17 关系模式STJ(S，T，J)中，S表示学生，T表示教师，J表示课程。每一教师只教一门课。每门课有若干教师，某一学生选定某门课，就对应一个固定的教师。由语义可得到如下的函数依赖。
(S，J)→T；(S，T)→J；T→J。
这里(S，J)、(S，T)都是候诜键。
STJ是3NF，因为没有任何非主属性对键函数传递依赖或部分函数依赖。但STJ不是BCNF模式，是因为T是决定因素，而T不包含键。
3NF和BC范式是在函数依赖的条件下对模式分解所能达到的分离程度的测度。一个数据库中的关系模式如果都是BC范式，那么在函数依赖范畴内，它已经实现彻底的分离，已消除了插入和删除异常。
</code></pre>

<h1 id="无损分解">无损分解</h1>

<p>定义 当对关系模式R进行分解时，R的元组将分别在相应属性集进行投影而产生新的关系。如果对新的关系进行自然连接得到的元组集合与原关系完全一致，则称该分解为无损分解（lossless decompose）。否则称为有损分解。</p>

<h1 id="heath定理">Heath定理</h1>

<p>假设关系模式R分解为两个子关系模式R1和R2，如果R1∩R2至少包含其中一个子关系模式的主键，则此分解是无损分解。
      在例2.18中，R(SNO,CNAME,TNAME,GRADE)分解成两个子关系模式R1(SNO,CNAME,GRADE)和R2(CNAME,TNAME)，由于R1∩R2={CNAME}，而CNAME是关系模式R2的主键，由Heath定理，该分解为无损分解。</p>

<pre><code class="language-markdown">例：设有关系模式R（{SNO，Sname,CNO,Grade},                                 
        的一个分解为：
      R1(SNO,Sname),R2(SNO,CNO,Grade)
     因为R1∩R2=SNO, 由于SNO是R1的主键，则分解具有无损性连接。
</code></pre>

<h1 id="保持函数依赖分解">保持函数依赖分解</h1>

<p>模式分解的过程还必须保证数据的语义完整性。在做任何数据输入和修改时，只要每个关系模式本身的函数依赖被满足，就可以确保整个数据库中数据的语义完整性不受破坏。
定义：设ρ={R1(U1),R2(U2),…,Rn(Un)}是关系模式R(U)的一个分解，R的函数依赖集F在Ui上的投影为Fi，如果满足              ，则称ρ具有函数依赖保持性，也称该分解为保持依赖分解（preserve depend-ency decompose）</p>

<h1 id="3nf分解">3NF分解</h1>

<p>前在信息系统的设计中，广泛被采用的是“基于3NF的系统设计”方法 。
将R分解成多个3NF关系模式的步骤如下：
(1) 如果R不属于1NF，对其进行分解，使其满足1NF。
分解为1NF的方法可以直接将其多值属性进行分解，用分解后的多个单值属性集取代原来的属性。如关系模式R(NAME,ADDRESS,PHONE)中，假设每条记录至多有3个电话号码。此时可将多值属性分解为R1(NAME,ADDRESS,PHONE1,PHONE2,PHONE3)。有时，当多值属性取值较多时，为了防止出现大量的空值，一般将多值属性单独定义为一个实体。</p>

<p>(2) 如果R属于1NF但R不属于2NF，分解R使其满足2NF。
将关系模式分解为符合2NF条件的方法如下：
设关系模式R(U)，主键是W，R上还存在函数依赖X→Z，并且Z是非主属性和XW，那么W→Z就是一个局部依赖。此时应把R分解成两个模式R1(XZ)，主键是X和R2(Y)，其中Y=U-Z，主键仍是W，外键是X。</p>

<p>(3) 如果R属于2NF但R不属于3NF，分解R使其满足3NF。
将关系模式分解为符合3NF条件的方法如下：设关系模式R(U)，主键是W，R上还存在函数依赖X→Z。Z不含于X并且是非主属性，X不是候选键，那么W→Z就是一个传递函数依赖。
此时应把R分解成两个模式R1(XZ)，主键是X和R2(Y)，其中Y=U-Z，主键仍是W，外键是X。如在例2.15的关系模式R1(CNO,TNAME,TADDR)，取W={CNO}，X={TNAME}，Z={TADDR}，利用该方法就可以得到符合3NF的关系模式R11(TNAME,TADDR)和R12(CNO,TNAME)。</p>

<h1 id="事务四大特性及隔离级别">事务四大特性及隔离级别</h1>

<h2 id="特性">特性:</h2>

<ul>
  <li>原子性</li>
</ul>

<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚</p>

<ul>
  <li>一致性</li>
</ul>

<p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态</p>

<ul>
  <li>隔离性</li>
</ul>

<p>隔离性是当多个用户<code>并发</code>访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>

<ul>
  <li>持久性</li>
</ul>

<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>

<h2 id="隔离级别">隔离级别</h2>

<ul>
  <li>
    <p>脏读</p>

    <p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据</p>
  </li>
  <li>
    <p>不可重复读</p>

    <p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
  </li>
  <li>
    <p>虚读</p>

    <p>幻读是事务非独立执行时发生的一种现象</p>
  </li>
</ul>

