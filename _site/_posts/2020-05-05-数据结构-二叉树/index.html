<p>[toc]</p>

<h1 id="node结构">Node结构</h1>

<pre><code class="language-c">typedef struct BTNode{
    int data;
    struct BTNode *lChild;
    struct BTNode *rChild;
}BiTNode;
</code></pre>

<h1 id="先序创建二叉树">先序创建二叉树</h1>

<pre><code class="language-c">void CreateBiTree(BiTNode **T)
{
    int ch;
    scanf("%d",&amp;ch);
    if (ch == -1)
    {
        *T = NULL;
        return;
    }
    else
    {
        *T = (BiTNode *)malloc(sizeof(BiTNode));
        (*T)-&gt;data = ch;
        printf("输入%d的左子节点：",ch);
        CreateBiTree(&amp;((*T)-&gt;lChild));
        printf("输入%d的右子节点：",ch);
        CreateBiTree((&amp;(*T)-&gt;rChild));
    }

    return;
}
</code></pre>

<h1 id="先序遍历二叉树">先序遍历二叉树</h1>

<pre><code class="language-c">void PreOrderBiTree(BiTNode *T)
{
    if (T == NULL)
    {
        return;
    }
    else
    {
        printf("%d ",T-&gt;data);
        PreOrderBiTree(T-&gt;lChild);
        PreOrderBiTree(T-&gt;rChild);
    }
}
</code></pre>

<h1 id="中序遍历二叉树">中序遍历二叉树</h1>

<pre><code class="language-c">void MiddleOrderBiTree(BiTNode *T)
{
    if (T == NULL)
    {
        return;
    }
    else
    {
        MiddleOrderBiTree(T-&gt;lChild);
        printf("%d ",T-&gt;data);
        MiddleOrderBiTree(T-&gt;rChild);
    }
}
</code></pre>

<h1 id="后续遍历二叉树">后续遍历二叉树</h1>

<pre><code class="language-c">void PostOrderBiTree(BiTNode *T)
{
    if (T == NULL)
    {
        return;
    }
    else
    {
        PostOrderBiTree(T-&gt;lChild);
        PostOrderBiTree(T-&gt;rChild);
        printf("%d ",T-&gt;data);
    }
}
</code></pre>

<h1 id="分层遍历二叉树">分层遍历二叉树</h1>

<p>现将根节点入队，出队，若节点有左右孩子，则将左右孩子节点入队</p>

<pre><code class="language-c">#define NODE_NUMBER 100
void printTreeAtLevel(BiTNode *tree)
{
    //链式后续补充
	/*定义一个队列,用数组来实现
	 *假设 first = last = 0 队列空
	 *first = end  ; 队满
	 */
	BiTNode *queue[NODE_NUMBER] = {0} ; 
	BiTNode *root = tree ;
	BiTNode *queue_node ; 
	int first = 0 ; //队首
	int end   = 0 ; //队尾
	/*边界条件检测*/
	if( tree == NULL)
	{
		return ; 
	}
	/*将根节点入队*/
	queue[end] = root ;
	end++ ; 
	//while( end != 0 &amp;&amp; first != 0 &amp;&amp; root != NULL)
	do
	{
		queue_node = queue[first] ; 
		/*队首节点的左孩子存在，则入队*/
		if( queue_node-&gt;lChild != NULL)
		{
			queue[end] = queue_node-&gt;lChild ; 
			end++ ;
		}
		/*队首节点的右孩子存在，则入队*/
		if( queue_node-&gt;rChild != NULL )
		{
			queue[end] = queue_node-&gt;rChild ; 
			end++ ; 
		}
		printf("%d " ,queue_node-&gt;data) ; 
		first++ ; 
	}while( end != 0 &amp;&amp; first != 0 &amp;&amp; root != NULL &amp;&amp; end != first) ;
	printf("\n") ; 
}
</code></pre>

<h1 id="二叉树的深度">二叉树的深度</h1>

<pre><code class="language-c">int TreeDeep(BiTNode *T)
{
    int deep = 0;
    if (T != NULL)
    {
        int leftdeep = TreeDeep(T-&gt;lChild);
        int rightdeep = TreeDeep(T-&gt;rChild);
        deep = leftdeep &gt;= rightdeep?leftdeep+1:rightdeep+1;
    }
    return deep;
}
</code></pre>

<h1 id="叶子节点个数">叶子节点个数</h1>

<pre><code class="language-c">int LeafCount(BiTNode *T)
{
    static int count;
    if (T != NULL)
    {
        if (T-&gt;lChild == NULL &amp;&amp; T-&gt;rChild == NULL)
        {
            count++;
        }
        LeafCount(T-&gt;lChild);
        LeafCount(T-&gt;rChild);
    }
    return count;
}
</code></pre>

<h1 id="释放二叉树">释放二叉树</h1>

<pre><code class="language-c">void Free_Btree(BiTNode *T)
{
    if (T != NULL)
    {
        BiTNode *l = T-&gt;lChild;
        BiTNode *r = T-&gt;rChild;
        free(T);
        Free_Btree(l);
        Free_Btree(r);
    }
}
</code></pre>

