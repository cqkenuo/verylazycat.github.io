---
title: linux编程
tags: linux
---

[toc]

# ERROR

```sh
vim /usr/include/asm-generic/errno-base.h 
errno.h 
```

```c
#ifndef _ASM_GENERIC_ERRNO_BASE_H
#define _ASM_GENERIC_ERRNO_BASE_H

#define EPERM            1      /* Operation not permitted */
#define ENOENT           2      /* No such file or directory */
#define ESRCH            3      /* No such process */
#define EINTR            4      /* Interrupted system call */
#define EIO              5      /* I/O error */
#define ENXIO            6      /* No such device or address */
#define E2BIG            7      /* Argument list too long */
#define ENOEXEC          8      /* Exec format error */
#define EBADF            9      /* Bad file number */
#define ECHILD          10      /* No child processes */
#define EAGAIN          11      /* Try again */
#define ENOMEM          12      /* Out of memory */
#define EACCES          13      /* Permission denied */
#define EFAULT          14      /* Bad address */
#define ENOTBLK         15      /* Block device required */
#define EBUSY           16      /* Device or resource busy */
#define EEXIST          17      /* File exists */
#define EXDEV           18      /* Cross-device link */
#define ENODEV          19      /* No such device */
#define ENOTDIR         20      /* Not a directory */
#define EISDIR          21      /* Is a directory */
#define EINVAL          22      /* Invalid argument */
#define ENFILE          23      /* File table overflow */
#define EMFILE          24      /* Too many open files */
#define ENOTTY          25      /* Not a typewriter */
#define ETXTBSY         26      /* Text file busy */
#define EFBIG           27      /* File too large */
#define ENOSPC          28      /* No space left on device */
#define ESPIPE          29      /* Illegal seek */
#define EROFS           30      /* Read-only file system */
#define EMLINK          31      /* Too many links */
#define EPIPE           32      /* Broken pipe */
#define EDOM            33      /* Math argument out of domain of func */
#define ERANGE          34      /* Math result not representable */
#endif
```



# man手册

- 第一章:基本命令
- 第二章:系统调用
- 第三章:标准库函数
- 第七章:体系结构

## 宏和函数

宏占用编译时间,函数占用运行时间,不过更安全

# IO

`一切实现的基础`

`input`&`output`

实现:

1. `stdio`
2. `sysio`

优先考虑stdio,扩展性更好,不同平台底层不一样.

## errorno to error_msg

更直观展示错误内容

1. perror (关联全局变量errorno)
2. strerror

## FILE结构体

....

## 常用函数

- fopen
- fclose

```markdown
NAME
       fopen, fdopen, freopen - stream open functions
SYNOPSIS
       #include <stdio.h>
       FILE *fopen(const char *pathname, const char *mode);
       FILE *fdopen(int fd, const char *mode);
       FILE *freopen(const char *pathname, const char *mode, FILE *stream);
```

`const`参数,安全性;

`mode`:

| r    | for read                                                     |
| ---- | ------------------------------------------------------------ |
| r+   | reading and writing                                          |
| w    | truncate fileto zero length or create text  file  for  writing |
| w+   | open for reading and writing                                 |
| a    | open for appending                                           |
| a+   | open for reading and appending                               |

返回:

```markdown
RETURN VALUE
       Upon successful completion fopen(), fdopen()  and  freopen()  return  a
       FILE pointer.  Otherwise, NULL is returned and errno is set to indicate
       the error.
```

error 一个`全局变量`



FILE 创建的指针在栈,静态区,或者堆???

```c
FILE *fopen(const char *pathname, const char *mode);
```

在堆上;

如果一个操作成对出现使用,`一般`放在`堆`上

`是资源一定有上限`

fopen打开`流`是有上限的,一般体现出来的数量是`1021`,其实真实打开的是`1024`个,有`3`个默认`流`:`stdout`,`stdinput`,`stderr`

`Linux`具体限制参考:

`ulimit -a`

```sh
-t: cpu time (seconds)              unlimited
-f: file size (blocks)              unlimited
-d: data seg size (kbytes)          unlimited
-s: stack size (kbytes)             8192
-c: core file size (blocks)         0
-m: resident set size (kbytes)      unlimited
-u: processes                       31073
-n: file descriptors                1024
-l: locked-in-memory size (kbytes)  16384
-v: address space (kbytes)          unlimited
-x: file locks                      unlimited
-i: pending signals                 31073
-q: bytes in POSIX msg queues       819200
-e: max nice                        0
-r: max rt priority                 0
-N 15:                              unlimited

```

创建文件后的权限

具体公式:`0666 & ~umask`

-----

字符操作

- fgetc
- fputc

```c
#include <stdio.h>
int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
int ungetc(int c, FILE *stream);
//---------------------
int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
int ungetc(int c, FILE *stream);
```

return value

```markdown
fgetc(),  getc() and getchar() return the character read as an unsigned
char cast to an int or EOF on end of file or error.
fgets() returns s on success, and NULL on error or  when  end  of  file
occurs while no characters have been read.
ungetc() returns c on success, or EOF on error.

--------------------------

fgetc(),  getc() and getchar() return the character read as an unsigned
char cast to an int or `EOF` on end of file or error.
```

- fgets

```CQL
#include <stdio.h>
int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
int ungetc(int c, FILE *stream);
```

- fputs

```c
#include <stdio.h>
int fputc(int c, FILE *stream);
int fputs(const char *s, FILE *stream);
int putc(int c, FILE *stream);
int putchar(int c);
int puts(const char *s);
```

- fwrite

```c
#include <stdio.h>
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb,
              FILE *stream);
```

- printf

```c
#include <stdio.h>
int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int dprintf(int fd, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);
#include <stdarg.h>
int vprintf(const char *format, va_list ap);
int vfprintf(FILE *stream, const char *format, va_list ap);
int vdprintf(int fd, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);=
```

- scanf

```c
#include <stdio.h>
int scanf(const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);
int sscanf(const char *str, const char *format, ...);
#include <stdarg.h>
int vscanf(const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);
```

- fseek

```c
#include <stdio.h>
int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, const fpos_t *pos);
```

`whence`:

1. SEEK_SET
2.  SEEK_CUR
3. SEEK_END

 `long offset`注意长度限制,类型为long,有缺陷,`fseeko`修改了缺陷,如下:

```c
#include <stdio.h>
int fseeko(FILE *stream, off_t offset, int whence);
off_t ftello(FILE *stream);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
fseeko(), ftello():
_FILE_OFFSET_BITS == 64 || _POSIX_C_SOURCE >= 200112L
(defining the obsolete _LARGEFILE_SOURCE macro also works)
```

注意:

```markdown
On some architectures, both off_t and long are 32-bit types, but defin‐
       ing  _FILE_OFFSET_BITS  with  the value 64 (before including any header
       files) will turn off_t into a 64-bit type.
```

- ftell

```c
#include <stdio.h>
int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, const fpos_t *pos);
```
- fflush

```c
#include <stdio.h>
int fflush(FILE *stream);
```

注意:

 If the stream argument is NULL, fflush() flushes all open output streams.For a nonlocking counterpart, see unlocked_stdio(3).



缓冲区作用:合并系统调用

分类:

1. 行缓冲:换行时刷新,stdout
2. 全缓冲:满了就刷新,默认
3. 无缓冲:stderr

修改缓冲:

setvbuf

```c
#include <stdio.h>
void setbuf(FILE *stream, char *buf);
void setbuffer(FILE *stream, char *buf, size_t size);
void setlinebuf(FILE *stream);
int setvbuf(FILE *stream, char *buf, int mode, size_t size);
```

The mode argument must be one of the following three macros:

```markdown
_IONBF unbuffered
_IOLBF line buffered
_IOFBF fully buffered
```

- getline

```c
#include <stdio.h>
ssize_t getline(char **lineptr, size_t *n, FILE *stream);
ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);
Feature Test Macro Requirements for glibc (see feature_test_macros(7)):
getline(), getdelim():
Since glibc 2.10:
_POSIX_C_SOURCE >= 200809L
    Before glibc 2.10:
_GNU_SOURCE
```

对于段错误一定要仔细分析,可能是调用的函数引用了其他函数,但是没有初始化,这种容易出错;

- tmpnam

```c
#include <stdio.h>
char *tmpnam(char *s);
char *tmpnam_r(char *s);
```

- tmpfile

```c
#include <stdio.h>
FILE *tmpfile(void);
```

匿名文件

临时问阿金两个问题:

1. 不冲突
2. 及时销毁

## 文件描述符

