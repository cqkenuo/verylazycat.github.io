---
title: 密码学基础总结
tags: 安全
---
[toc]
# 基础概念

## 信息安全三要素（CIA）

- 机密性
- 完整性
- 可用性

扩展：

六要素：

- 机密性
- 所有权
- 完整性
- 可认证性
- 可用性
- 实用性

八要素：

- 机密性
- 完整性
- 可用性
- 隐私性
- 可认证性于可信任性
- 不可抵赖性
- 可说明性
- 可审计性

# 安全性攻击形式

- 被动攻击
  - 截取

- 主动攻击
  - 中断
  - 篡改
  - 伪造
  - 重放

# 密码编码学

## 保密体制

- 对称加密体制
- 非对称加密体制

## 认证体制

- 消息认证
  - 消息认证码体制
  - 数字签名
- 实体认证
  - 生份鉴别协议

# 对称与非对称加密体制

## 对称加密体制

实用的秘钥必须完全保密，且要求加密秘钥和解密秘钥相同或由其中一个可以很容易推出另外一个

- 优点

1. 速度快，有很高的吞吐率，软硬件易于实现
2. 秘钥相对较短
3. 对称保密体制密文长度往往与明文相同，或扩张较小

- 缺点

1. 秘钥分发需要安全通道
2. 秘钥量大，难管理
3. 难以解决不可否认性

## 非对称加密体制

秘钥有两个，一个对外公开，另外一个必须保密，不能从公钥推到私钥，或者是计算困难

- 优点

1. 秘钥分发容易
2. 秘钥管理简单
3. 可以有效实现数字签名

- 缺点

1. 速度慢
2. 同等安全下，非对称密码体制对秘钥位数要多一些
3. 非对称保密体制中，密文长度往往大于明文长度

# 柯克霍夫原则

> kerckhoffs princip

秘钥必须完全寓于秘钥中，即加密和解密算法的安全性取决于秘钥的安全性，而加密解密的过程和细节是公开的，只要秘钥是安全的，则攻击者无法推出明文

实际应用中，攻击者的能力还会受到进一步限制：

1. 破解密码系统的成本不超过被加密信息本身
2. 破译密码系统时间不超过被加密信息的有效生命周期

# 密码学加密系统的五元组

```
明文，密文，密钥，加密算法，解密算法
```

# 密码体制攻击类型

- 唯密文攻击（Ciphertext only）
   破译者已知：加密算法、待破译的密文  
- 已知明文攻击（Known plaintext）
   破译者已知：加密算法、一定数量的明文和对应的密文 
- 选择明文攻击（Chosen plaintext） 
  破译者已知：加密算法、选定的明文和对应的密文
- 选择密文攻击（Chosen ciphertext） 
  破译者已知：加密算法、选定的密文和对应的明文
- 选择文本攻击（Chosen text）
  破译者已知：加密算法、选定的明文和对应的密文、选定的密文和对应的明文

# 对加密系统的攻击类型（前四种）

```
1.已知明文攻击 （知道一些名密文对）
2选择明文攻击 （任意明文->密文）
3.唯密文攻击 （只知道一些密文）    
4选择密文攻击（任意密文->明文）
5.选择文本攻击（任意明文<->任意密文）
```

# 攻击常用方法

- 穷举
- 统计分析
- 数学分析

# 熵

*随机事件x发生的概率的对数的相反数定义为该随机事件的自信息量，记为I（xi），设xi发生的概率为p（xi），则自信息量为：*
$$
I(x)_{i} = - log_{2}p(x_{i})
$$
底数为2，信息量单位为比特，如果以e为底数，单位为奈特

# 古典密码

## 置换

置换：根据一定的规则重新排列明文，打破明文结构特性

### 列置换

> 明文按照秘钥规则按列换位并且得到密文

![置换密码](/img/置换密码.png)



### ![置换密码举例](/img/置换密码举例.png)

![列置换](/img/列置换.png)

![列置换2](/img/列置换2.png)

### 周期置换

> 将明文按照固定长度分组，然后对每组按照某种排列位置得到密文

**例子**:

-  明文：“State Key Laboratory of Networking and Switching”

- 加密的密钥：S=(1 5 6 2 3)；

- 将明文分为七组，每组6个字符，不足6个的用双方规定好的字符进行填充，比如空格。

​      P’ = (StateK)(eyLabo)(ratory)(ofNetw)(orking)(andSwi)(tching)

- 对每组的字符进行加密，根据密钥S，可知将第1个字符放在第5个字符的位置，第5个字符放在第6个字符的位置，第6个字符放在第2个字符的位置，第2个字符放在第3个字符的位置，第3个字符放在第1个字符的位置，置换后P'如下：

  P‘ = (aKttSe)(Loyaeb)(tyaorr)(Nwfeot)(kgrion)(dinSaw)(hgcitn)

  所以得到的最终密文Pm = "aKttSeLoyaebtyaorrNwfeotkgriondinSawhgcitn"

- 周期置换的解密方法就是加密的逆运算，只需求出密钥的逆置换即可。可以知道密钥S=(1 5 6 2 3)的逆置换S’ = (1 3 2 6 5)，所以只需将密文重新分组，通过S'的置换顺序就可以得出明文P

## 代换密码

代换，就是将明文中的一个字母由其它字母、数字或者符号替代的一种方法
代换密码建立一个代换表，加密时将需要加密的明文依次通过查表，替换为相应的字符，明文字符被逐个替换后，生成无任何意义的字符串，即密文。这样的代换表被称为密钥

### 单表代换密码

单表代换是指英文字母在进行密码编码替换的时候，有一张对照表，也就是说，对于每一个字母，都是唯一对应的，如：

26个源字母表为：abcdefghijklmnopqrstuvwxyz

代换的字母表为：qwertyuiopasdfghjklzxcvbnm

在加密时，按照设计好的对照表对每一个明文字母进行替换，如a替换为q，b替换为w等。

### 放射密码

加法密码和乘法密码结合就构成仿射密码，仿射密码的加密和解密算法是：
$$
C=EK(m)=(k_{1}m+k_{2})modn\\
M = DK(C)=k_{3}(C-k_{2})mod n\\
(k_{3}Xk_{1})mod 26=1\\
$$


仿射密码具有可逆性的条件是:

`gcd(k1, n)=1`. 当k1=1时，仿射密码变为加法密码，当k2=0时，仿射密码变为乘法密码。
仿射密码中的密钥空间的大小为`nφ(n)`，当`n`为`26`字母，`φ(n)=12`，因此仿射密码的密钥空间为12×26 = 312

#### 例子

设放射密码加密函数为：`e(x)=11x+6(mod 26)`,则有11^{-1}(mod26)=19,所以解密函数:`x=19[e(x)-6]=19e(x)+16(mod 26)`

设加密明文：`sorcery`，转换为数字：`18,14,17,2,4,17,24`





加密：
$$
11*
 \left[
 \begin{matrix}
   18 \\
   14 \\
   17\\
   2\\
   4\\
   17\\
   24\\
  \end{matrix}
  \right]
+
 \left[
 \begin{matrix}
   6 \\
   6 \\
   6\\
   6\\
   6\\
   6\\
   6\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   204 \\
   160\\
   193\\
  28\\
   50\\
   193\\
  270\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   22 \\
   4\\
   11\\
  2\\
   24\\
   11\\
  10\\
  \end{matrix}
  \right]
 (mod26)
< =>
 \left[
 \begin{matrix}
   W \\
   E\\
   L\\
   C\\
   y\\
   L\\
   K\\
  \end{matrix}
  \right]
$$
解密：
$$
19*
 \left[
 \begin{matrix}
   22 \\
   4 \\
   11\\
   2\\
   24\\
   11\\
   10\\
  \end{matrix}
  \right]
+
 \left[
 \begin{matrix}
   16 \\
   16 \\
   16\\
   16\\
   16\\
   16\\
   16\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   434 \\
   92\\
   225\\
  54\\
   472\\
   225\\
  206\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   18\\
   14\\
   17\\
  2\\
   4\\
   17\\
  24\\
  \end{matrix}
  \right]
 (mod26)
< =>
 \left[
 \begin{matrix}
   s \\
   o\\
   r\\
   c\\
   e\\
   r\\
   y\\
  \end{matrix}
  \right]
$$



> 求逆元：**扩展欧几里得算法**

### 多表代换

#### 维吉尼亚密码

![多表代换](/img/多表代换.png)

例题：

p=data security , k = best

先将明文分解为长为4的序列：

data 			secu 			rity

每个序列用秘钥best加密

密文：EELT  	TIUN	  SMLR

#### Playfair密码

![维吉尼亚密码](/img/维吉尼亚密码.png)



![playfair2](/img/playfair2.png)

例题：

设秘钥为：PLAYFAIR IS A DIGRAM CIPHER



字母矩阵：
$$
\left[
 \begin{matrix}
  P&L &A &Y& F \\
   I/J&R&S&D&G\\
   M&C&H&E&B\\
   K&N&O&Q&T\\
   U&V&W&X&Z\\
  \end{matrix}
  \right]
$$


明文：pI ay fa ir ci ph er

密文: LA YF PY RS MR AM CD

#### 希尔密码

![希尔密码](/img/希尔密码.png)

例题：

明文：cyber，数字化：2,24,1,4,17

秘钥:
$$
\left[
\begin{matrix}
  10&5 &12 &0& 0 \\
   3&14&21&0&0\\
   8&9&11&0&0\\
   0&0&0&11&8\\
   0&0&0&3&7\\
  \end{matrix}
  \right]
$$
加密：
$$
c=(2,24,1,4,17)
\left[
\begin{matrix}
  10&5 &12 &0& 0 \\
   3&14&21&0&0\\
   8&9&11&0&0\\
   0&0&0&11&8\\
   0&0&0&3&7\\
  \end{matrix}
  \right]
  =
  \left[
\begin{matrix}
  100 \\
   355\\
   539\\
   95\\
   151\\
  \end{matrix}
  \right]^{T}
  (mod26)=
  \left[
\begin{matrix}
  22 \\
   17\\
   19\\
   17\\
   21\\
  \end{matrix}
  \right]^{T}
  <=>
  \left[
  \begin{matrix}
  W\\
  R\\
  T\\
  R\\
  V
  \end{matrix}
  \right]
$$
解密秘钥：
$$
K^{-1}=
\left[
\begin{matrix}
21&15&17&0&0\\
21&2&16&0&0\\
25&4&3&0&0\\
0&0&0&7&18\\
0&0&0&23&11
\end{matrix}
\right]
$$
解密：
$$
p=(22,17,19,17,21)
\left [
\begin{matrix}
21&15&17&0&0\\
21&2&16&0&0\\
25&4&3&0&0\\
0&0&0&7&18\\
0&0&0&23&11
\end{matrix}
\right ]
=
\left [
\begin{matrix}
1328\\
440\\
703\\
602\\
537
\end{matrix}
\right ]^{T}
(mod 26)
=
\left[
\begin{matrix}
2\\
24\\
1\\
4\\
17
\end{matrix}
\right ]
<=>
\left[
\begin{matrix}
c\\y\\
b\\
e\\
r
\end{matrix}
\right]^{T}
$$





# 分组密码

> 分组密码（block cipher）是现代密码学中的重要体制之一，也是应用最广泛、影响最大的一种密码体制。其主要任务是提供数据保密性，也可以用在伪随机数生成器、序列密码、认证码和哈希函数的构造
>
> 分组密码又称为对称密码，具有加解密速度快、安全性好的特点。得到许多密码芯片的支持，在许多研究和应用领域中得到了广泛的应用

![分组密码流程](/img/分组密码流程.png)

## 扩散＆混乱

- 扩散：打乱明文，每一位比特明文的变化尽可能影响输出的密文序列比特，使得明文和密文之间的统计关系尽量复杂，即从密文不能获得明文的统计特性
- 混乱：打乱明文，加密过程中，明文，密文，秘钥间的关系尽可能复制，使从密文中不能获得密钥的任何统计特性

## Feiste网络

> 用简单算法的乘积来近似表达复杂的替代变换

优点：

1. 加解密相似，只需要一个逆转的密钥编排算法，加解密算法部分完全一致
2. 轮函数不必可逆

### 原理

F表示轮函数,Ki表示每一轮的子秘钥

#### 加密

> i表示轮数

$$
将明文分割为左右两部分(L_{0},R_{0})\\
L_{i+1} = R_{i}\\
R_{i+1} = L_{i}\bigoplus F(R_{i},k_{i})\\
$$

#### 解密

> (i=n,n-1,...0)

$$
R_{i}  = L_{i+1}\\
l_{i} = R_{i+1}\bigoplus(L_{i+1},k_{i})\\
(L_{0},R_{0})为解密后的明文
$$

## 雪崩效应

![雪崩效应](/img/雪崩效应.png)

## SP网络

![sp网络](/img/sp网络.png)

SP网络具有雪崩效应

## 子秘钥生成方法

子秘钥生成是迭代分组算法的一个重要部分，轮函数Ｆ的功能是在子秘钥的参与和控制下实现的

子秘钥评价指标：

- 简单，速度快
- 种子秘钥的所有比特对每个子秘钥比特的影响大致相同
- 没有弱秘钥

## 轮函数Ｆ设计准则

- 非线性

  > 依赖Ｓ盒

- 可逆性

- 雪崩效应

# DES加密

## 概述

- 分组加密：明文密文为64位分组长度
- 密码算法：同一个算法
- 密钥长度：56位，存在弱秘钥，但是可以避开
- 采用混乱和扩散组合,每个组先代换后置换，共16轮
- 易于实现,速度快

## 流程

![des加密](/img/des加密.png)

## 初始置换(IP)

![初始置换](/img/初始置换.png)

## 轮变换

![轮变换](/img/轮变换.png)

## F函数

### 扩展置换

> 又叫E盒

扩展置置换目标是IP置换后获得的右半部分R0，将32位输入扩展为48位(分为4位×8组)输出。

扩展置换目的有两个：生成与密钥相同长度的数据以进行异或运算；提供更长的结果，在后续的替代运算中可以进行压缩。

![E盒](/home/admin233/Documents/verylazycat.github.io/img/E盒.png)

表中的数字代表位，两列黄色数据是扩展的数据，可以看出，扩展的数据是从相邻两组分别取靠近的一位，4位变为6位。靠近32位的位为1，靠近1位的位为32。表中第二行的4取自上组中的末位，9取自下组中的首位。

### 秘钥加

E扩展输出的49位与48位子秘钥逐位异或,输出48位数据

### 代换盒

> S盒
>
> 目的:非线性变换

压缩后的密钥与扩展分组异或以后得到48位的数据，将这个数据送人S盒，进行替代运算。替代由8个不同的S盒完成，每个S盒有6位输入4位输出。48位输入分为8个6位的分组，一个分组对应一个S盒，对应的S盒对各组进行代替操作。

![S盒](/home/admin233/Documents/verylazycat.github.io/img/S盒.png)

　一个S盒就是一个4行16列的表，盒中的每一项都是一个4位的数。S盒的6个输入确定了其对应的输出在哪一行哪一列，输入的高低两位做为行数H，中间四位做为列数L，在S-BOX中查找第H行L列对应的数据(<32)

> S盒代替时DES算法的关键步骤，所有的其他的运算都是线性的，易于分析，而S盒是非线性的，相比于其他步骤，提供了更好安全性。

### P盒置换

S盒代替运算的32位输出按照P盒进行置换。该置换把输入的每位映射到输出位，任何一位不能被映射两次，也不能被略去,映射规则如下表:

| 16   | 7    | 20   | 21   | 29   | 12   | 28   | 17   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 15   | 23   | 26   | 5    | 18   | 31   | 10   |
| 2    | 8    | 24   | 14   | 32   | 27   | 3    | 9    |
| 19   | 13   | 30   | 6    | 22   | 11   | 4    | 25   |

表中的数字代表原数据中此位置的数据在新数据中的位置，即原数据块的第16位放到新数据的第1位，第7位放到第2位，……依此类推，第25位放到第32位。

例如0x10A1 0001进行P盒置换后变为0x8000 0886。

最后，P盒置换的结果与最初的64位分组左半部分L0异或，然后左、右半部分交换，接着开始另一轮。

## IP-1末置换

末置换是初始置换的逆过程，DES最后一轮后，左、右两半部分并未进行交换，而是两部分合并形成一个分组做为末置换的输入。末置换规则如下表：

| 40   | 8    | 48   | 16   | 56   | 24   | 64   | 32   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 39   | 7    | 47   | 15   | 55   | 23   | 63   | 31   |
| 38   | 6    | 46   | 14   | 54   | 22   | 62   | 30   |
| 37   | 5    | 45   | 13   | 53   | 21   | 61   | 29   |
| 36   | 4    | 44   | 12   | 52   | 20   | 60   | 28   |
| 35   | 3    | 43   | 11   | 51   | 19   | 59   | 27   |
| 34   | 2    | 42   | 10   | 50   | 18   | 58   | 26   |
| 33   | 1    | 41   | 9    | 49   | 17   | 57   | 25   |

置换方法同上，此处省略。

## DES安全性

- 互补性
- 弱秘钥
- 迭代轮数
- 秘钥长度

## 3重DES

优点:

- 秘钥长度增加到112位或168为,有效克服穷举
- 相对于DES,增强了抗差分分析和线性分析
- DES升级到3重DES成本低
- 对密码分析攻击由很强的免疫力



不足:

- 处理速度慢
- 秘钥长度增加了,但是明文分组的长度没有变化,任为63位,就效率和安全性与秘钥的增长不匹配

## DES分析方法

- 穷举
- 差分分析
- 线性分析
- 积分攻击
- 中间相遇攻击
- 相关秘钥攻击
- 侧信道攻击

# AES

## AES的基本结构

AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：

| AES     | 密钥长度（32位比特字) | 分组长度(32位比特字) | 加密轮数 |
| ------- | --------------------- | -------------------- | -------- |
| AES-128 | 4                     | 4                    | 10       |
| AES-192 | 6                     | 4                    | 12       |
| AES-256 | 8                     | 4                    | 14       |

轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。
AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。

AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示：
![AES](/home/admin233/Documents/verylazycat.github.io/img/AES.png)

现在假设明文分组P为"abcdefghijklmnop"，则对应上面生成的状态矩阵图如下

![AES1](/home/admin233/Documents/verylazycat.github.io/img/AES1.png)

上图中，0x61为字符a的十六进制表示。可以看到，明文经过AES加密后，已经面目全非。

类似地，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示：

![AES2](/home/admin233/Documents/verylazycat.github.io/img/AES2.jpeg)

上图中，设K = “abcdefghijklmnop”，则K0 = a, K15 = p, W[0] = K0 K1 K2 K3 = “abcd”。

AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。

![](/home/admin233/Documents/verylazycat.github.io/img/AES.jpeg)

上图也展示了AES解密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作。

## 字节代换

AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒



![AES_s](/home/admin233/Documents/verylazycat.github.io/img/AES_s.png)

状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。状态矩阵经字节代换后的图如下：
![字节变换](/home/admin233/Documents/verylazycat.github.io/img/字节变换.png)

## 字节代换逆操作

逆字节代换也就是查逆S盒来变换,此处不展示

## 行移位

行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示：

![行位移](/home/admin233/Documents/verylazycat.github.io/img/行位移.jpeg)

## 行移位的逆变换

行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节。

## 列混合

列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：

![列混合](/home/admin233/Documents/verylazycat.github.io/img/列混合.png)

## 列混合逆运算

逆向列混合变换可由下图的矩阵乘法定义

![列混合逆](/home/admin233/Documents/verylazycat.github.io/img/列混合逆.png)

## 轮秘钥加

轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作

轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位。

## 秘钥扩展

## AES解密

# Hash函数

> 消息空间到像空间的不可逆映射
>
> 像通常叫数字指纹,消息摘要,散列值

$$
h=H(M)
$$

## 性质

- H可应用于`任意`长度的消息
- H输出固定长度
- 对于任意给定消息x,计算H(x)比较容易,用硬件和软件均可实现
- 单向性:对于给定散列值h,找到H(x)=h的消息x在计算上不可行
- 抗弱碰撞性:对于给定的消息x,找到满足y!=x且H(x)=H(y)的消息y在计算上不可行
- 抗强碰撞性:找到满足H(x)=H(y)的偶对(x,y)在计算上不可行

## 应用

- 数字签名
- 生成程序或文档的"数字指纹"
- 用于安全传输和存储口令

## MD5

> 单向散列算法

### 功能

- 输入任意长度的信息，经过处理，输出为128位的信息（数字指纹）；

- 不同的输入得到的不同的结果（唯一性）；

- 根据128位的输出结果不可能反推出输入的信息（不可逆）； 

### 算法

#### **填充**

在MD5算法中，首先需要对信息进行填充，使其位长对512求余的结果等于448，**并且填充必须进行，即使其位长对512求余的结果等于448**。因此，信息的位长（Bits Length）将被扩展至N*512+448，N为一个非负整数，N可以是零。

填充的方法如下：

-    在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。

- 在这个结果后面附加一个以64位二进制表示的填充前信息长度（单位为Bit），如果二

进制表示的填充前信息长度超过64位，则取低64位。

经过这两步的处理，信息的位长=N*512+448+64=(N+1）*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。

#### **初始化变量**

初始的128位值为初试链接变量，这些参数用于第一轮的运算，以大端[字节序](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%AD%97%E8%8A%82%E5%BA%8F)来表示，他们分别为： A=0x01234567，B=0x89ABCDEF，C=0xFEDCBA98，D=0x76543210。

（每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即大端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476）

#### **处理分组数据**

每一分组的算法流程如下：

  第一分组需要将上面四个链接变量复制到另外四个变量中：A到a，B到b，C到c，D到d。从第二分组开始的变量为上一分组的运算结果，即A = a， B = b， C = c， D = d。

主循环有四轮（MD4只有三轮），每轮循环都很相似。第一轮进行16次操作。每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向左**环移**一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。

以下是每次操作中用到的四个非线性函数（每轮一个）

F( X ,Y ,Z ) = ( X & Y ) | ( (~X) & Z )

G( X ,Y ,Z ) = ( X & Z ) | ( Y & (~Z) )

H( X ,Y ,Z ) =X ^ Y ^ Z

I( X ,Y ,Z ) =Y ^ ( X | (~Z) )

（&是与（And），|是或（Or），~是非（Not），^是异或（Xor））

这四个函数的说明：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。

F是一个逐位运算的函数。即，如果X，那么Y，否则Z。函数H是逐位奇偶操作符。

假设Mj表示消息的第j个子分组（从0到15），常数ti是4294967296*abs( sin(i) ）的整数部分，i 取值从1到64，单位是弧度。（4294967296=2的32次方）

现定义：

FF(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + F(b,c,d) + Mj + ti) << s)

GG(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + G(b,c,d) + Mj + ti) << s)

HH(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + H(b,c,d) + Mj + ti) << s)

II(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + I(b,c,d) + Mj + ti) << s)

现定义：

FF(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + F(b,c,d) + Mj + ti) << s)

GG(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + G(b,c,d) + Mj + ti) << s)

HH(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + H(b,c,d) + Mj + ti) << s)

II(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + I(b,c,d) + Mj + ti) << s)

**注意：“<<”表示循环左移位，不是左移位。**

这四轮（共64步）是：

第一轮

FF(a ,b ,c ,d ,M0 ,7 ,0xd76aa478 )

FF(d ,a ,b ,c ,M1 ,12 ,0xe8c7b756 )

FF(c ,d ,a ,b ,M2 ,17 ,0x242070db )

FF(b ,c ,d ,a ,M3 ,22 ,0xc1bdceee )

FF(a ,b ,c ,d ,M4 ,7 ,0xf57c0faf )

FF(d ,a ,b ,c ,M5 ,12 ,0x4787c62a )

FF(c ,d ,a ,b ,M6 ,17 ,0xa8304613 )

FF(b ,c ,d ,a ,M7 ,22 ,0xfd469501)

FF(a ,b ,c ,d ,M8 ,7 ,0x698098d8 )

FF(d ,a ,b ,c ,M9 ,12 ,0x8b44f7af )

FF(c ,d ,a ,b ,M10 ,17 ,0xffff5bb1 )

FF(b ,c ,d ,a ,M11 ,22 ,0x895cd7be )

FF(a ,b ,c ,d ,M12 ,7 ,0x6b901122 )

FF(d ,a ,b ,c ,M13 ,12 ,0xfd987193 )

FF(c ,d ,a ,b ,M14 ,17 ,0xa679438e )

FF(b ,c ,d ,a ,M15 ,22 ,0x49b40821 )

第二轮

GG(a ,b ,c ,d ,M1 ,5 ,0xf61e2562 )

GG(d ,a ,b ,c ,M6 ,9 ,0xc040b340 )

GG(c ,d ,a ,b ,M11 ,14 ,0x265e5a51 )

GG(b ,c ,d ,a ,M0 ,20 ,0xe9b6c7aa )

GG(a ,b ,c ,d ,M5 ,5 ,0xd62f105d )

GG(d ,a ,b ,c ,M10 ,9 ,0x02441453 )

GG(c ,d ,a ,b ,M15 ,14 ,0xd8a1e681 )

GG(b ,c ,d ,a ,M4 ,20 ,0xe7d3fbc8 )

GG(a ,b ,c ,d ,M9 ,5 ,0x21e1cde6 )

GG(d ,a ,b ,c ,M14 ,9 ,0xc33707d6 )

GG(c ,d ,a ,b ,M3 ,14 ,0xf4d50d87 )

GG(b ,c ,d ,a ,M8 ,20 ,0x455a14ed )

GG(a ,b ,c ,d ,M13 ,5 ,0xa9e3e905 )

GG(d ,a ,b ,c ,M2 ,9 ,0xfcefa3f8 )

GG(c ,d ,a ,b ,M7 ,14 ,0x676f02d9 )

GG(b ,c ,d ,a ,M12 ,20 ,0x8d2a4c8a )

第三轮

HH(a ,b ,c ,d ,M5 ,4 ,0xfffa3942 )

HH(d ,a ,b ,c ,M8 ,11 ,0x8771f681 )

HH(c ,d ,a ,b ,M11 ,16 ,0x6d9d6122 )

HH(b ,c ,d ,a ,M14 ,23 ,0xfde5380c )

HH(a ,b ,c ,d ,M1 ,4 ,0xa4beea44 )

HH(d ,a ,b ,c ,M4 ,11 ,0x4bdecfa9 )

HH(c ,d ,a ,b ,M7 ,16 ,0xf6bb4b60 )

HH(b ,c ,d ,a ,M10 ,23 ,0xbebfbc70 )

HH(a ,b ,c ,d ,M13 ,4 ,0x289b7ec6 )

HH(d ,a ,b ,c ,M0 ,11 ,0xeaa127fa )

HH(c ,d ,a ,b ,M3 ,16 ,0xd4ef3085 )

HH(b ,c ,d ,a ,M6 ,23 ,0x04881d05 )

HH(a ,b ,c ,d ,M9 ,4 ,0xd9d4d039 )

HH(d ,a ,b ,c ,M12 ,11 ,0xe6db99e5 )

HH(c ,d ,a ,b ,M15 ,16 ,0x1fa27cf8 )

HH(b ,c ,d ,a ,M2 ,23 ,0xc4ac5665 )

第四轮

II(a ,b ,c ,d ,M0 ,6 ,0xf4292244 )

II(d ,a ,b ,c ,M7 ,10 ,0x432aff97 )

II(c ,d ,a ,b ,M14 ,15 ,0xab9423a7 )

II(b ,c ,d ,a ,M5 ,21 ,0xfc93a039 )

II(a ,b ,c ,d ,M12 ,6 ,0x655b59c3 )

II(d ,a ,b ,c ,M3 ,10 ,0x8f0ccc92 )

II(c ,d ,a ,b ,M10 ,15 ,0xffeff47d )

II(b ,c ,d ,a ,M1 ,21 ,0x85845dd1 )

II(a ,b ,c ,d ,M8 ,6 ,0x6fa87e4f )

II(d ,a ,b ,c ,M15 ,10 ,0xfe2ce6e0 )

II(c ,d ,a ,b ,M6 ,15 ,0xa3014314 )

II(b ,c ,d ,a ,M13 ,21 ,0x4e0811a1 )

II(a ,b ,c ,d ,M4 ,6 ,0xf7537e82 )

II(d ,a ,b ,c ,M11 ,10 ,0xbd3af235 )

II(c ,d ,a ,b ,M2 ,15 ,0x2ad7d2bb )

II(b ,c ,d ,a ,M9 ,21 ,0xeb86d391 )

所有这些完成之后，将a、b、c、d分别在原来基础上再加上A、B、C、D。

即a = a + A，b = b + B，c = c + C，d = d + D

然后用下一分组数据继续运行以上算法。

#### **输出**

最后的输出是a、b、c和d的级联。

当你按照我上面所说的方法实现MD5算法以后，你可以用以下几个信息对你做出来的程序作一个简单的测试，看看程序有没有错误。

MD5 ("") = d41d8cd98f00b204e9800998ecf8427e

MD5 ("a") = 0cc175b9c0f1b6a831c399e269772661

MD5 ("abc") = 900150983cd24fb0d6963f7d28e17f72

MD5 ("message digest") = f96b697d7cb7938d525a2f31aaf161d0

MD5 ("abcdefghijklmnopqrstuvwxyz") = c3fcd3d76192e4007dfb496cca67e13b

MD5 ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") =

f29939a25efabaef3b87e2cbfe641315

MD5 ("8a683566bcc7801226b3d8b0cf35fd97") =cf2cb5c89c5e5eeebef4a76becddfcfd



MD5加密字符串实例

现以字符串“jklmn”为例。

该字符串在内存中表示为：6A 6B 6C 6D 6E（从左到右为低地址到高地址，后同），信息长度为40 bits， 即0x28。

对其填充，填充至448位，即56字节。结果为：

6A 6B 6C 6D 6E 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00

剩下64位，即8字节填充填充前信息位长，按小端字节序填充剩下的8字节，结果为。

6A 6B 6C 6D 6E 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 28 00 00 00 00 00 00 00

（64字节，512 bits）

初始化A、B、C、D四个变量。

将这64字节填充后数据分成16个小组（程序中对应为16个数组），即：

M0：6A 6B 6C 6D （这是内存中的顺序，按照小端字节序原则，对应数组M(0)的值为0x6D6C6B6A，下同）

M1：6E 80 00 00

M2：00 00 00 00

.....

M14：28 00 00 00

M15：00 00 00 00

经过“**3. 分组数据处理**”后，a、b、c、d值分别为0xD8523F60、0x837E0144、0x517726CA、0x1BB6E5FE

在内存中为a：60 3F 52 D8

b：44 01 7E 83

c：CA 26 77 51

d：FE E5 B6 1B

a、b、c、d按内存顺序输出即为最终结果：603F52D844017E83CA267751FEE5B61B。这就是字符串“jklmn”的MD5值。

## SHA1

>MD5算法得出的MD5值长度为16个字节（8*16=128位） 
> SHA1算法得出的SHA1值长度为20个字节（8*20=160位）

### 算法

####  填充信息

和MD5算法类似，对信息的第一步也是填充信息直至满足条件。

填充的过程如下：
1.先判断文件（消息）的大小（长度） mod 512 == 448 mod 512 ，就是大小（长度）对512求余等于448。（这里的512、448是“位”为单位，转成“字节”就是64、56，即mod 64 == 56 mod 64）

2.如果大小（长度）满足 mod 512 == 448 mod 512，就在文件（消息）的末尾处添加64位（8字节）的值，值的内容是原消息的长度（以位为单位）

3.如果大小（长度）不满足要求，就执行以下操作：
（1）填充1个1
（2）填充0，直到满足满足过程的第一步。

注意：这里是以位为单位，假如是以字节为单位，第一个填充的是0x80（1000 0000），然后就填0x0
举例：消息内容为“gnubd”，就能得到以下内容

```reStructuredText
67 6E 62 75 64 80 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 28 
```

还需要注意到的是最后原消息的长度是以大端存储的方式存到内存中的，这里与MD5的存储是有区别的。

....

# 消息认证

## 作用&目的

- 验证信息来源的真实性
- 验证消息的完整性

## 认证函数实现

### 消息认证码(MAC)

消息认证码的输入包括任意长度的消息和一个发送者与接收者之间的共享的密钥，它可以输出固定长度的数据，这个数据成为**MAC值**。
 根据任意长度的雄性输出固定长度的数据，这一点和散列函数很类似。但是单向散列函数中计算散列值时不需要密钥，相对地，消息认证码中则需要使用发送者与接收者之间的共享密钥。
 要计算MAC必须持有共享密钥，没有共享密钥的人就无法计算MAC值，消息认证正是利用这一性质来完成认证的。此外，和单向散列函数的散列值一样，哪怕消息中发生1比特的变化，MAC值一会产生变化，消息认证码正是利用这一性质来确认完整性的。
 **消息认证码是一种与密钥相关联的单向散列函数**

### 基于DES消息认证码

### 基于Hash消息认证码

#### HMAC算法

....

# 公钥密码

## 提出原因

- 秘钥分发问题

1. 密钥更新共享的方式有以下几种类型：
   A 选择密钥并手工传递给 B,在这样的一个情境中，A 和 B都是确实存在且可信的。而在互联网环境中，A 和 B 之间要建立信任关系，会很困难。
2. 第三方 C 选择密钥分别手工传递给 A , B,在复杂的互联网环境中，C 如何将密钥安全的分发给 A和B，要保证其安全性也很困难。
3. 用 A , B 原有共享密钥传送新密钥,这是一种相对安全的方式，但是互联网环境中需要A和B要有一份复杂的密钥交换协议，才可以实现新密钥的共享。
4. 与 A , B 分别有共享密钥的第三方 C 传送新密钥给 A 和（或） B,此过程也需要一份复杂的密钥交换协议来确保C能够将密钥安全的分发给 A 和 B。

- 秘钥管理问题

  除了密钥的更新问题困难以外，还有对密钥管理的问题仍然存在。在对称密码算法中必须要对密钥进行管理，但是对密钥的管理又十分的困难。

  - 例如：

    N 个用户集需要 N(N-1)/2 个共享密钥，当用户量增大时，密钥空间急剧增大。

  - n = 100 时，  C(100,2) = 4,995
  - n = 5000时， C(5000,2) = 12,497,500

- 数字签名问题

  传统加密算法无法实现抗抵赖的需求。在对称加密算法中，共享的密钥是通信双方都知道的 ，所以无法使用共享的密钥来对对方的身份进行确认。

## 单向陷门函数

单向陷门函数可以被定义为如下函数f：

- 给出f的定义域中的任意元素x,  f(x)的计算是容易的；
- 给出y=f (x)中的y要计算x时，若知道设计函数f时结合进去的某种信息（该信息称为陷门），则容易计算；若不知道该信息，则难以计算。

目前人们主要是基于如下的数学上的困难问题来设计单向函数和公钥密码体制：

- 大整数分解问题(如公钥密码体制RSA)；
- 有限域上的离散对数问题(如公钥密码体制ElGamal):
- 椭圆曲线上的离散对数问题(如公钥密码体制ECC)。

## 为什么要用公钥密码

（1） 机密性的实现
发送方用接收方的公钥加密消息，接收方用自己的私钥来解密。
（2） 数字签名
发送方用自己的私钥来签名消息，接收方通过发送方对应的公钥来鉴别消息，并且发送方不能对自己的签名进行否认。
（3） 密钥分发和协商
发送方和接收方基于公钥密码系统容易实现在公开信道上的大规模的密钥分发和协商。

## DH秘钥交换

> DH，全称为“Diffie-Hellman”，这是一种确保共享KEY安全穿越不安全网络的方法，换句话说就是密钥一致协议，由公开密钥密码体制的奠基人Diffie和Hellman所提出的一种思想

简单的说就是允许两名用户在公开媒体上交换信息以生成“一致”的、可以共享的密钥。也就是由甲方产出一对密钥（公钥、私钥），乙方依照甲方公钥产生乙方密钥对（公钥、私钥）。它可以让双方在完全没有对方任何预先信息的条件下通过不安全信道建立起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。

### DH密钥交换模型分析

我们还是以甲乙双方发送数据为模型进行分析

- 甲方（消息发送方，下同）构建密钥对（公钥+私钥），甲方公布公钥给乙方（消息接收方，下同）
- 乙方以甲方发送过来的公钥作为参数构造密钥对（公钥+私钥），将构造出来的公钥公布给甲方
- 甲方用“甲方的私钥+乙方的公钥”构造本地密钥
- 乙方用“乙方的私钥+甲方的公钥”构造本地的密钥
- 这个时候，**甲乙两方本地新构造出来的密钥应该一样**，甲乙双方可以通过本地密钥进行数据的加密和解密
- 然后就可以**使用AES这类对称加密算法进行数据的安全传送**了。

### DH数学原理

有两个全局公开的参数，一个素数p和一个整数g，g是p的一个原根。

服务端的私钥和公钥分别是a和A，客户端的私钥和公钥分别是b和B；

服务端根据a、p、g，可以计算出公钥A；

服务端将g, p, A明文传送给客户端，客户端可以计算自己的公钥B，以及共享密钥K；

客户端将B明文发送给服务端，服务端也可以计算出共享密钥K。

![DH](/img/DH.png)

### 安全问题-中间人攻击

在最初的描述中，迪菲-赫尔曼密钥交换本身并没有提供通讯双方的身份验证服务，因此它很容易受到中间人攻击。 
一个中间人“丙”在信道的中央进行两次迪菲－赫尔曼密钥交换，一次和甲，另一次和乙，就能够成功的向甲假装自己是乙，反之亦然。
而攻击者可以解密（读取和存储）任何一个人的信息并重新加密信息，然后传递给另一个人。因此通常都需要一个能够验证通讯双方身份的机制来防止这类攻击。
**有很多种安全身份验证解决方案使用到了迪菲－赫尔曼密钥交换。例如当甲和乙共有一个公钥基础设施时，可以将他们的返回密钥进行签名。**

## RSA

RSA公钥算法是由 MIT (麻省理工学院, Massachusetts Institute of Technology) 的Rivest, Shamir和Adleman在1978年提出来的。RSA方案是被最广泛接受并实现的通用公开密钥密码算法，目前已成为公钥密码的国际标准。该算法的数学基础是初等数论中的欧拉定理，其安全性建立在大整数因子分解的困难性之上。

### 密钥的生成

- 选择两个大素数 `p`，`q`，（p，q为互异素数，需要保密）

- 计算

  

$$
n= p *q\\
\Phi(n)=(p-1)*(q-1)
$$



- 选择整数 `e` 使


$$
gcd(\phi(n),e)=1\\
1 < e <\phi(n)
$$


- 计算d


$$
d*e=1mod\phi(n)
$$


得到：公钥 为`{e,n}`； 私钥为`{d}`

### 加密

明文:M

密文:


$$
接受(e,n)\\
M分组,长度问L(L<log_{2}n)M=m_{1}m_{2}...\\
加密算法:c_{i}=m_{i}^{e}(modn)
$$


### 解密

$$
m_{i}=c^{d}_{i}mod(n)
$$



### 安全性

#### 攻击方式

- 因子分解

  ​	分解n

- 针对参数攻击

  1. 共模攻击
  2. 低指数攻击

## ElGamal

> 该算法安全性依赖于计算有限域上离散对数难题：求解离散对数(目前)是困难的,其逆运算指数运算简单。

### 秘钥生成

- 随机选取一个满足安全要求的大素数p,生成有限域z_{p}的一个生成元g

- 选取一个随机数x(1<x<p-1),计算:

  
  $$
  y=g^{x}(modp)
  $$
  

  `公钥为(y,g,p),私钥为x`

### 加密

- 接受(y,g,p)

- 消息m分组为长度为L(L<log_{2}p)的消息分组m=m_{1}m_{2}....

- 对第i块消息(1<=i<=t)随机选择整数r_{i},1<r_{i}<p-1

- 计算:

  
  $$
  c_{i}=g^{r_{i}}(modp)\\
  c^{'}_{i}=m_{i}y^{r_{i}}(modp)(1<=i<t)
  $$



- 将密文C=(c_{i},c^{'}_{1}).....发给接受方

### 解密

- 接受密文

- 计算:

  
  $$
  m_{i}=(c^{'}_{i}/c^{x}_{i})(mod p)\\
  (1<=i<=t)
  $$



- 得到明文:

  m=m1m2...

### 安全性

#### 小步大步算法

...

#### 指数积分法

....

## 椭圆曲线公钥加密

>椭圆曲线加密算法，即：Elliptic Curve Cryptography，简称ECC，是基于椭圆曲线数学理论实现的一种非对称加密算法。相比RSA，ECC优势是可以使用更短的密钥，来实现与RSA相当或更高的安全。据研究，160位ECC加密安全性相当于1024位RSA加密，210位ECC加密安全性相当于2048位RSA加密

一般情况下，椭圆曲线可用下列方程式来表示，其中a,b,c,d为系数。


$$
E:y^2=ax^3+ bx^2+c^x+d
$$


### 椭圆曲线的运算规则

### 加法

过曲线上的两点A、B画一条直线，找到直线与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A+B，即为加法。如下图所示：A + B = C

![加法](/img/加法.png)

### 二倍运算

上述方法无法解释A + A，即两点重合的情况。因此在这种情况下，将椭圆曲线在A点的切线，与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A + A，即2A，即为二倍运算。

![2倍](/img/2倍.png)

### 正负取反

将A关于x轴对称位置的点定义为-A，即椭圆曲线的正负取反运算。

### 无穷远点

如果将A与-A相加，过A与-A的直线平行于y轴，可以认为直线与椭圆曲线相交于无穷远点。

综上，定义了A+B、2A运算，因此给定椭圆曲线的某一点G，可以求出2G、3G（即G + 2G）、4G......。即：当给定G点时，已知x，求xG点并不困难。反之，已知xG点，求x则非常困难。此即为椭圆曲线加密算法背后的数学原理。



....

> 具体算法参考书籍

## 对称密码体制Vs公钥密码体制

对称密码体制的缺陷：

     密钥分配问题：通信双方要进行加密通信，需要通过秘密的安全信道协商加密密钥，而这种安全信道可能很难实现
     密钥管理问题：在有多个用户的网络中，任何两个用户之间都需要有共享的密钥，当网络中的用户n很大时，需要管理的密钥数目非常大，为n(n-1)/2
    没有签名功能：当主体A收到主体B的电子文挡(电子数据)时，无法向第三方证明此电子文档确实来源于B。

公钥密码体制重点考察三个领域的问题：

    密钥交换：通信双方交换会话密钥，以加密通信双方后续连接所传输的信息。每次逻辑连接使用一把新的会话密钥，用完就丢弃。
    通信保密：将公钥作为加密密钥，私钥作为解密密钥，通信双方不需要交换密钥就可以实现保密通信。
    数字签名：将私钥作为加密密钥，公钥作为解密密钥，可实现由一个用户对数据加密而使多个用户解读。

在公钥密码体制以前的整个密码学史中，所有的密码算法，包括古典密码和现代密码，都是基于替换和置换这两个基本工具。而公钥密码体制则为密码学的发展提供了新的理论和技术基础， 一方面公钥密码算法的基本工具不再是代换和置换，而是数学函数； 另一方面公钥密码算法是以非对称的形式使用两个密钥，两个密钥的使用对保密性、密钥分配、签名、认证等都有着深刻的意义。

公钥算法加密解密速度慢。误区：

    公开密钥密码算法更安全
    公开密钥密码使对称密钥密码过时了
# 数字签名

## 数字签名解决的问题

```
A发送消息给B：A（不可抵赖）——————>B（不可伪造）（不可重用）
(1)不可抵赖     (假如：A可以否认发过该消息，B无法证明A确实发了该消息)
(2)不可伪造 	    (假如：B伪造一个不同的消息，但声称是从A收到的）
(3)不可重用		(假如：签名没有和消息绑定)
```

## 安全模型,性质

...

## RSA签名算法以及存在的安全问题

如果不使用HASH函数

1.（存在性伪造）使用“已知消息攻击”
利用RSA的乘法特性，可以进行如下攻击
假设 y1=sigk(m1)和y2=sigk(m2) 是签名者曾经签署的有效签名，
那么 verk (m1m2 mod n, y1y2 mod n) = true


2. （选择性伪造）利用“选择消息攻击”
假设攻击者要对消息 m 伪造一个签名，m=m1m2mod n。
假设攻击者能请求签名者为 m1 和 m2 签名(结果分别为y1和y2)，
那么， y1 y2 mod n 就是消息 m 的有效签名

对抗攻击的方法：使用HASH函数
私钥签名，公钥验证

## ElGamal签名算法以及存在的安全问题

## 特殊的签名算法以及适应的应用场景

# 密码协议

# 秘钥管理

## 原则

- 区分秘钥管理的策略和机制
- 完全安全原则
- 最小权利原则
- 责任分离原则
- 秘钥分级原则
- 秘钥更换原则
- 秘钥有足够长度
- 密码体制不同,秘钥管理也不同



## 几类秘钥作用