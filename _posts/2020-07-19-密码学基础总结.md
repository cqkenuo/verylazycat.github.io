---
title: 密码学基础总结
tags: 安全
---
[toc]
# 基础概念

## 信息安全三要素（CIA）

- 机密性
- 完整性
- 可用性

扩展：

六要素：

- 机密性
- 所有权
- 完整性
- 可认证性
- 可用性
- 实用性

八要素：

- 机密性
- 完整性
- 可用性
- 隐私性
- 可认证性于可信任性
- 不可抵赖性
- 可说明性
- 可审计性

# 安全性攻击形式

- 被动攻击
  - 截取

- 主动攻击
  - 中断
  - 篡改
  - 伪造
  - 重放

# 密码编码学

## 保密体制

- 对称加密体制
- 非对称加密体制

## 认证体制

- 消息认证
  - 消息认证码体制
  - 数字签名
- 实体认证
  - 生份鉴别协议

# 对称与非对称加密体制

## 对称加密体制

实用的秘钥必须完全保密，且要求加密秘钥和解密秘钥相同或由其中一个可以很容易推出另外一个

- 优点

1. 速度快，有很高的吞吐率，软硬件易于实现
2. 秘钥相对较短
3. 对称保密体制密文长度往往与明文相同，或扩张较小

- 缺点

1. 秘钥分发需要安全通道
2. 秘钥量大，难管理
3. 难以解决不可否认性

## 非对称加密体制

秘钥有两个，一个对外公开，另外一个必须保密，不能从公钥推到私钥，或者是计算困难

- 优点

1. 秘钥分发容易
2. 秘钥管理简单
3. 可以有效实现数字签名

- 缺点

1. 速度慢
2. 同等安全下，非对称密码体制对秘钥位数要多一些
3. 非对称保密体制中，密文长度往往大于明文长度

# 柯克霍夫原则

> kerckhoffs princip

秘钥必须完全寓于秘钥中，即加密和解密算法的安全性取决于秘钥的安全性，而加密解密的过程和细节是公开的，只要秘钥是安全的，则攻击者无法推出明文

实际应用中，攻击者的能力还会受到进一步限制：

1. 破解密码系统的成本不超过被加密信息本身
2. 破译密码系统时间不超过被加密信息的有效生命周期

# 密码学加密系统的五元组

```
明文，密文，密钥，加密算法，解密算法
```

# 密码体制攻击类型

- 唯密文攻击（Ciphertext only）
   破译者已知：加密算法、待破译的密文  
- 已知明文攻击（Known plaintext）
   破译者已知：加密算法、一定数量的明文和对应的密文 
- 选择明文攻击（Chosen plaintext） 
  破译者已知：加密算法、选定的明文和对应的密文
- 选择密文攻击（Chosen ciphertext） 
  破译者已知：加密算法、选定的密文和对应的明文
- 选择文本攻击（Chosen text）
  破译者已知：加密算法、选定的明文和对应的密文、选定的密文和对应的明文

# 对加密系统的攻击类型（前四种）

```
1.已知明文攻击 （知道一些名密文对）
2选择明文攻击 （任意明文->密文）
3.唯密文攻击 （只知道一些密文）    
4选择密文攻击（任意密文->明文）
5.选择文本攻击（任意明文<->任意密文）
```

# 攻击常用方法

- 穷举
- 统计分析
- 数学分析

# 熵

*随机事件x发生的概率的对数的相反数定义为该随机事件的自信息量，记为I（xi），设xi发生的概率为p（xi），则自信息量为：*
$$
I(x)_{i} = - log_{2}p(x_{i})
$$
底数为2，信息量单位为比特，如果以e为底数，单位为奈特

# 古典密码

## 置换

置换：根据一定的规则重新排列明文，打破明文结构特性

### 列置换

> 明文按照秘钥规则按列换位并且得到密文

![置换密码](/img/置换密码.png)



### ![置换密码举例](/img/置换密码举例.png)

![列置换](/img/列置换.png)

![列置换2](/img/列置换2.png)

### 周期置换

> 将明文按照固定长度分组，然后对每组按照某种排列位置得到密文

**例子**:

-  明文：“State Key Laboratory of Networking and Switching”

- 加密的密钥：S=(1 5 6 2 3)；

- 将明文分为七组，每组6个字符，不足6个的用双方规定好的字符进行填充，比如空格。

​      P’ = (StateK)(eyLabo)(ratory)(ofNetw)(orking)(andSwi)(tching)

- 对每组的字符进行加密，根据密钥S，可知将第1个字符放在第5个字符的位置，第5个字符放在第6个字符的位置，第6个字符放在第2个字符的位置，第2个字符放在第3个字符的位置，第3个字符放在第1个字符的位置，置换后P'如下：

  P‘ = (aKttSe)(Loyaeb)(tyaorr)(Nwfeot)(kgrion)(dinSaw)(hgcitn)

  所以得到的最终密文Pm = "aKttSeLoyaebtyaorrNwfeotkgriondinSawhgcitn"

- 周期置换的解密方法就是加密的逆运算，只需求出密钥的逆置换即可。可以知道密钥S=(1 5 6 2 3)的逆置换S’ = (1 3 2 6 5)，所以只需将密文重新分组，通过S'的置换顺序就可以得出明文P

## 代换密码

代换，就是将明文中的一个字母由其它字母、数字或者符号替代的一种方法
代换密码建立一个代换表，加密时将需要加密的明文依次通过查表，替换为相应的字符，明文字符被逐个替换后，生成无任何意义的字符串，即密文。这样的代换表被称为密钥

### 单表代换密码

单表代换是指英文字母在进行密码编码替换的时候，有一张对照表，也就是说，对于每一个字母，都是唯一对应的，如：

26个源字母表为：abcdefghijklmnopqrstuvwxyz

代换的字母表为：qwertyuiopasdfghjklzxcvbnm

在加密时，按照设计好的对照表对每一个明文字母进行替换，如a替换为q，b替换为w等。

### 放射密码

加法密码和乘法密码结合就构成仿射密码，仿射密码的加密和解密算法是：
$$
C=EK(m)=(k_{1}m+k_{2})modn\\
M = DK(C)=k_{3}(C-k_{2})mod n\\
(k_{3}Xk_{1})mod 26=1\\
$$


仿射密码具有可逆性的条件是:

`gcd(k1, n)=1`. 当k1=1时，仿射密码变为加法密码，当k2=0时，仿射密码变为乘法密码。
仿射密码中的密钥空间的大小为`nφ(n)`，当`n`为`26`字母，`φ(n)=12`，因此仿射密码的密钥空间为12×26 = 312

#### 例子

设放射密码加密函数为：`e(x)=11x+6(mod 26)`,则有11^{-1}(mod26)=19,所以解密函数:`x=19[e(x)-6]=19e(x)+16(mod 26)`

设加密明文：`sorcery`，转换为数字：`18,14,17,2,4,17,24`





加密：
$$
11*
 \left[
 \begin{matrix}
   18 \\
   14 \\
   17\\
   2\\
   4\\
   17\\
   24\\
  \end{matrix}
  \right]
+
 \left[
 \begin{matrix}
   6 \\
   6 \\
   6\\
   6\\
   6\\
   6\\
   6\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   204 \\
   160\\
   193\\
  28\\
   50\\
   193\\
  270\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   22 \\
   4\\
   11\\
  2\\
   24\\
   11\\
  10\\
  \end{matrix}
  \right]
 (mod26)
< =>
 \left[
 \begin{matrix}
   W \\
   E\\
   L\\
   C\\
   y\\
   L\\
   K\\
  \end{matrix}
  \right]
$$
解密：
$$
19*
 \left[
 \begin{matrix}
   22 \\
   4 \\
   11\\
   2\\
   24\\
   11\\
   10\\
  \end{matrix}
  \right]
+
 \left[
 \begin{matrix}
   16 \\
   16 \\
   16\\
   16\\
   16\\
   16\\
   16\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   434 \\
   92\\
   225\\
  54\\
   472\\
   225\\
  206\\
  \end{matrix}
  \right]
  =
   \left[
 \begin{matrix}
   18\\
   14\\
   17\\
  2\\
   4\\
   17\\
  24\\
  \end{matrix}
  \right]
 (mod26)
< =>
 \left[
 \begin{matrix}
   s \\
   o\\
   r\\
   c\\
   e\\
   r\\
   y\\
  \end{matrix}
  \right]
$$



> 求逆元：**扩展欧几里得算法**

### 多表代换

#### 维吉尼亚密码

![多表代换](/img/多表代换.png)

例题：

p=data security , k = best

先将明文分解为长为4的序列：

data 			secu 			rity

每个序列用秘钥best加密

密文：EELT  	TIUN	  SMLR

#### Playfair密码

![维吉尼亚密码](/img/维吉尼亚密码.png)



![playfair2](/img/playfair2.png)

例题：

设秘钥为：PLAYFAIR IS A DIGRAM CIPHER



字母矩阵：
$$
\left[
 \begin{matrix}
  P&L &A &Y& F \\
   I/J&R&S&D&G\\
   M&C&H&E&B\\
   K&N&O&Q&T\\
   U&V&W&X&Z\\
  \end{matrix}
  \right]
$$


明文：pI ay fa ir ci ph er

密文: LA YF PY RS MR AM CD

#### 希尔密码

![希尔密码](/img/希尔密码.png)

例题：

明文：cyber，数字化：2,24,1,4,17

秘钥:
$$
\left[
\begin{matrix}
  10&5 &12 &0& 0 \\
   3&14&21&0&0\\
   8&9&11&0&0\\
   0&0&0&11&8\\
   0&0&0&3&7\\
  \end{matrix}
  \right]
$$
加密：
$$
c=(2,24,1,4,17)
\left[
\begin{matrix}
  10&5 &12 &0& 0 \\
   3&14&21&0&0\\
   8&9&11&0&0\\
   0&0&0&11&8\\
   0&0&0&3&7\\
  \end{matrix}
  \right]
  =
  \left[
\begin{matrix}
  100 \\
   355\\
   539\\
   95\\
   151\\
  \end{matrix}
  \right]^{T}
  (mod26)=
  \left[
\begin{matrix}
  22 \\
   17\\
   19\\
   17\\
   21\\
  \end{matrix}
  \right]^{T}
  <=>
  \left[
  \begin{matrix}
  W\\
  R\\
  T\\
  R\\
  V
  \end{matrix}
  \right]
$$
解密秘钥：
$$
K^{-1}=
\left[
\begin{matrix}
21&15&17&0&0\\
21&2&16&0&0\\
25&4&3&0&0\\
0&0&0&7&18\\
0&0&0&23&11
\end{matrix}
\right]
$$
解密：
$$
p=(22,17,19,17,21)
\left [
\begin{matrix}
21&15&17&0&0\\
21&2&16&0&0\\
25&4&3&0&0\\
0&0&0&7&18\\
0&0&0&23&11
\end{matrix}
\right ]
=
\left [
\begin{matrix}
1328\\
440\\
703\\
602\\
537
\end{matrix}
\right ]^{T}
(mod 26)
=
\left[
\begin{matrix}
2\\
24\\
1\\
4\\
17
\end{matrix}
\right ]
<=>
\left[
\begin{matrix}
c\\y\\
b\\
e\\
r
\end{matrix}
\right]^{T}
$$





# 分组密码

> 分组密码（block cipher）是现代密码学中的重要体制之一，也是应用最广泛、影响最大的一种密码体制。其主要任务是提供数据保密性，也可以用在伪随机数生成器、序列密码、认证码和哈希函数的构造
>
> 分组密码又称为对称密码，具有加解密速度快、安全性好的特点。得到许多密码芯片的支持，在许多研究和应用领域中得到了广泛的应用

![分组密码流程](/img/分组密码流程.png)

## 扩散＆混乱

- 扩散：打乱明文，每一位比特明文的变化尽可能影响输出的密文序列比特，使得明文和密文之间的统计关系尽量复杂，即从密文不能获得明文的统计特性
- 混乱：打乱明文，加密过程中，明文，密文，秘钥间的关系尽可能复制，使从密文中不能获得密钥的任何统计特性

## Feiste网络

> 用简单算法的乘积来近似表达复杂的替代变换

优点：

1. 加解密相似，只需要一个逆转的密钥编排算法，加解密算法部分完全一致
2. 轮函数不必可逆

### 原理

F表示轮函数,Ki表示每一轮的子秘钥

#### 加密

> i表示轮数

$$
将明文分割为左右两部分(L_{0},R_{0})\\
L_{i+1} = R_{i}\\
R_{i+1} = L_{i}\bigoplus F(R_{i},k_{i})\\
$$

#### 解密

> (i=n,n-1,...0)

$$
R_{i}  = L_{i+1}\\
l_{i} = R_{i+1}\bigoplus(L_{i+1},k_{i})\\
(L_{0},R_{0})为解密后的明文
$$

## 雪崩效应

![雪崩效应](/img/雪崩效应.png)

## SP网络

![sp网络](/img/sp网络.png)

SP网络具有雪崩效应

## 子秘钥生成方法

子秘钥生成是迭代分组算法的一个重要部分，轮函数Ｆ的功能是在子秘钥的参与和控制下实现的

子秘钥评价指标：

- 简单，速度快
- 种子秘钥的所有比特对每个子秘钥比特的影响大致相同
- 没有弱秘钥

## 轮函数Ｆ设计准则

- 非线性

  > 依赖Ｓ盒

- 可逆性

- 雪崩效应

# DES加密

## 概述

- 分组加密：明文密文为64位分组长度
- 密码算法：同一个算法
- 密钥长度：56位，存在弱秘钥，但是可以避开
- 采用混乱和扩散组合,每个组先代换后置换，共16轮
- 易于实现,速度快

## 流程

![des加密](/img/des加密.png)

## 初始置换(IP)

![初始置换](/img/初始置换.png)

## 轮变换

![轮变换](/img/轮变换.png)

## F函数

### 扩展置换

> 又叫E盒

扩展置置换目标是IP置换后获得的右半部分R0，将32位输入扩展为48位(分为4位×8组)输出。

扩展置换目的有两个：生成与密钥相同长度的数据以进行异或运算；提供更长的结果，在后续的替代运算中可以进行压缩。

![E盒](/home/admin233/Documents/verylazycat.github.io/img/E盒.png)

表中的数字代表位，两列黄色数据是扩展的数据，可以看出，扩展的数据是从相邻两组分别取靠近的一位，4位变为6位。靠近32位的位为1，靠近1位的位为32。表中第二行的4取自上组中的末位，9取自下组中的首位。

### 秘钥加

E扩展输出的49位与48位子秘钥逐位异或,输出48位数据

### 代换盒

> S盒
>
> 目的:非线性变换

压缩后的密钥与扩展分组异或以后得到48位的数据，将这个数据送人S盒，进行替代运算。替代由8个不同的S盒完成，每个S盒有6位输入4位输出。48位输入分为8个6位的分组，一个分组对应一个S盒，对应的S盒对各组进行代替操作。

![S盒](/home/admin233/Documents/verylazycat.github.io/img/S盒.png)

　一个S盒就是一个4行16列的表，盒中的每一项都是一个4位的数。S盒的6个输入确定了其对应的输出在哪一行哪一列，输入的高低两位做为行数H，中间四位做为列数L，在S-BOX中查找第H行L列对应的数据(<32)

> S盒代替时DES算法的关键步骤，所有的其他的运算都是线性的，易于分析，而S盒是非线性的，相比于其他步骤，提供了更好安全性。

### P盒置换

S盒代替运算的32位输出按照P盒进行置换。该置换把输入的每位映射到输出位，任何一位不能被映射两次，也不能被略去,映射规则如下表:

| 16   | 7    | 20   | 21   | 29   | 12   | 28   | 17   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 15   | 23   | 26   | 5    | 18   | 31   | 10   |
| 2    | 8    | 24   | 14   | 32   | 27   | 3    | 9    |
| 19   | 13   | 30   | 6    | 22   | 11   | 4    | 25   |

表中的数字代表原数据中此位置的数据在新数据中的位置，即原数据块的第16位放到新数据的第1位，第7位放到第2位，……依此类推，第25位放到第32位。

例如0x10A1 0001进行P盒置换后变为0x8000 0886。

最后，P盒置换的结果与最初的64位分组左半部分L0异或，然后左、右半部分交换，接着开始另一轮。

## IP-1末置换

末置换是初始置换的逆过程，DES最后一轮后，左、右两半部分并未进行交换，而是两部分合并形成一个分组做为末置换的输入。末置换规则如下表：

| 40   | 8    | 48   | 16   | 56   | 24   | 64   | 32   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 39   | 7    | 47   | 15   | 55   | 23   | 63   | 31   |
| 38   | 6    | 46   | 14   | 54   | 22   | 62   | 30   |
| 37   | 5    | 45   | 13   | 53   | 21   | 61   | 29   |
| 36   | 4    | 44   | 12   | 52   | 20   | 60   | 28   |
| 35   | 3    | 43   | 11   | 51   | 19   | 59   | 27   |
| 34   | 2    | 42   | 10   | 50   | 18   | 58   | 26   |
| 33   | 1    | 41   | 9    | 49   | 17   | 57   | 25   |

置换方法同上，此处省略。

## DES安全性

- 互补性
- 弱秘钥
- 迭代轮数
- 秘钥长度

## 3重DES

优点:

- 秘钥长度增加到112位或168为,有效克服穷举
- 相对于DES,增强了抗差分分析和线性分析
- DES升级到3重DES成本低
- 对密码分析攻击由很强的免疫力



不足:

- 处理速度慢
- 秘钥长度增加了,但是明文分组的长度没有变化,任为63位,就效率和安全性与秘钥的增长不匹配

## DES分析方法

- 穷举
- 差分分析
- 线性分析
- 积分攻击
- 中间相遇攻击
- 相关秘钥攻击
- 侧信道攻击

# AES

## AES的基本结构

AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：

| AES     | 密钥长度（32位比特字) | 分组长度(32位比特字) | 加密轮数 |
| ------- | --------------------- | -------------------- | -------- |
| AES-128 | 4                     | 4                    | 10       |
| AES-192 | 6                     | 4                    | 12       |
| AES-256 | 8                     | 4                    | 14       |

轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。
AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。

AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示：
![AES](/home/admin233/Documents/verylazycat.github.io/img/AES.png)

现在假设明文分组P为"abcdefghijklmnop"，则对应上面生成的状态矩阵图如下

![AES1](/home/admin233/Documents/verylazycat.github.io/img/AES1.png)

上图中，0x61为字符a的十六进制表示。可以看到，明文经过AES加密后，已经面目全非。

类似地，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示：

![AES2](/home/admin233/Documents/verylazycat.github.io/img/AES2.jpeg)

上图中，设K = “abcdefghijklmnop”，则K0 = a, K15 = p, W[0] = K0 K1 K2 K3 = “abcd”。

AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。

![](/home/admin233/Documents/verylazycat.github.io/img/AES.jpeg)

上图也展示了AES解密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作。

## 字节代换

AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒



![AES_s](/home/admin233/Documents/verylazycat.github.io/img/AES_s.png)

状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。状态矩阵经字节代换后的图如下：
![字节变换](/home/admin233/Documents/verylazycat.github.io/img/字节变换.png)

## 字节代换逆操作

逆字节代换也就是查逆S盒来变换,此处不展示

## 行移位

行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示：

![行位移](/home/admin233/Documents/verylazycat.github.io/img/行位移.jpeg)

## 行移位的逆变换

行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节。

## 列混合

列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：

![列混合](/home/admin233/Documents/verylazycat.github.io/img/列混合.png)

## 列混合逆运算

逆向列混合变换可由下图的矩阵乘法定义

![列混合逆](/home/admin233/Documents/verylazycat.github.io/img/列混合逆.png)

## 轮秘钥加

## 秘钥扩展

## AES解密