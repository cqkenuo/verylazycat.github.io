---
title: KMP算法
tags: 算法
---

[toc]

# BF

Brute-Force(BF) 算法又称naive算法，是对字符串子串搜索最简单明了的算法。其主旨就是：

- 不处理模式串
- 模式串从目标串**第一个元素**起逐一匹配
- 发现无法匹配，模式串匹配右移一位，从下一位目标串元素重新初始逐一元素匹配

![](/img/BF.gif)

虽然简单易懂，但是同时也导致了复杂度较高，最慢的情形其复杂度可以到达O（模式串长 * 目标串长）

![](/img/BF_LOW.webp)

# **KMP**

但是如果仔细观察，可以发现**模式串**本身是可以自带一些**可被预先计算出**的**可用于加速匹配的信息**的。

当模式串的第K位失配时，前K-1位必然是匹配的，如果直接整体后移一位重新从头开始匹配那之前的那些**已经匹配的信息**就被浪费了。于是我们可以寻找**最大的必定不需要再匹配的串**，那这个串是什么呢？

很显然，这个串就是[1,K-1]位串中**最大且相同**的**头尾**串（S）。当失配发生，可以直接**保持目标串中的失配元素不变**，移动模式串，K-1-S串长个单位重新匹配，这就是KMP算法。

![](/img/KMP.gif)

为什么要移动K-1-S串长个单位？失配元素前方一共有K-1个元素，最大相同头尾串长为S。

![](/img/KMP2.png)

若移动小于K-1-S长度(例如K-1-S-1 = K - 1 - (S+1))，则必然无法匹配，因为不存在**更大**的相同首尾串，如下图中（bab不是相同首尾串，故必然不匹配）。

![](/img/KMP3.png)

若移动大于K-1-S长度(例如K-1-S+1 = K - 1 - (S-1))，有可能匹配（当S-1同样是相同子串时），但是可能会因为多移动了位数而遗漏结果。

KMP算法本身比较好理解，而关于KMP的实现需要引入一个Next数组（由模式串预处理出的数组），Next数组的本身的算法则很难理解

# **Next数组**

Next数组的含义很直观，就是**第几个元素失配时应该右移模式串重新匹配第几个元素**（不同的教材采用的首元素索引序号不同有的是0有的是1，这也是Next数组算法难以理解的一大原因，所以文中讨论索引序号都直接使用的是**第**几个元素）。

Next数组的算法步骤如下图所示，在我们逐步讨论完其算法过程后再会看这张动图或许你会有更深刻地理解。

![](/img/next.webp)

### **逐步讨论**

对于模式串的首个元素的Next值，约定为**首元素索引值 - 1**，这么做仅仅是为了**方便实现递归算法**。这个值**不一定只为首元素的Next值**，经过优化后可能为其他元素的Next值，这个值（首元素索引 - 1）的含义是：

将**模式串**的**首元素**移动到**失配元素后一位**并从首元素开始，重新匹配。

![](/img/next2.webp)

# KMP实现

```c
// T 模式串， S目标串， pos第几个字符之后搜索
// 约定索引起始值为1
void Index_KMP(SString S, SString T, int pos){
   // i 目标串指针，j 模式串指针
    i = pos; j = 1;
    // 只要指针没有溢出对应的串
    while( i <= length(S) && j <= length(T)){
        // 如果将要和 目标串元素 匹配的元素是模式串首元素前一位的元素
        // 或者
        // 当前目标串元素 和 模式串元素可以匹配
        // if (j == first_indexof(T) - 1 || S[i] == T[j]){
        if(j == 0 || S[i] == T[j]){
           // 指针各自右移一位
            ++i;
            ++j;
        }else{
            // 发生了失配，查Next数组移动模式串指针
            j = next[j];
        }
    }
    if (j > length(T)){
        // 如果模式串指针溢出了（模式串指针匹配完毕了所有模式串中的元素）
       return i - length(T);
    }
    else return 0;
}
```

# next

```c
// T 模式串， next Next数组
// 约定索引起始值为1
void get_next(SString T, int &next[]){
    // i 计算每一个元素Next值的指针，它只可能右移用于计算下一个元素的Next值
    // j 用于指向 无法找到头尾串时 的递归回溯的元素 
    // 初始化第一个元素的Next值
    i = 1; next[1] = 0; j = 0;
    while(i < length(T)){
        // 如果递归回溯到第一个元素，它的next值为0，就无法继续回溯 -> 下一位元素的 Next值 就会等于 第一个元素的索引（1 即 0 + 1）
        // 如果 当前元素 等于 当前元素Next值对应的元素 -> 下一个元素的 Next值 就会等于 当前元素的Next值 + 1
        if (j == 0 || T[i] == T[j]){
            ++i; ++j; next[i] = j;
        }
        else{
            // 否则递归回溯j，将其指向更小的一个同首尾的子串的尾部 + 1
            j = next[j];
        }
    }
}
```

# **Nextval**

(以下的讨论假设不需要递归以简化讨论过程)

优化Next，当第`i+1`位失配的时候。通常，我们按照算法会比较 `T[i]` 和 `T[next[i]]`，若它们相同则将`Next[i+1]`设置成`Next[i] + 1`。但是，如果 `T[Next[i] + 1]`和失配元素（`T[i+1]`）相同时，这样设置则是多余的（Next元素的含义就是，某个元素失配时用哪个元素补充匹配，若补充匹配的元素和失配元素相同则这样设置是多余的）。所以，此时应该把`Next[i+1]`设置成`Next[Next[i] + 1]`，就是当`Next[i]+1`失配时应该用哪个元素补充匹配。

那为什么`T[Next[Next[i] + 1]]`不会等于`T[i+1]`呢？因为按照这样的算法**递推**是从第一个元素开始计算，可以确保除了当前失配的元素以外，**之前的任意一个元素（索引为m）**都不可能等于`T[Next[m]+1]`

```c
// T 模式串， next Next数组
// 约定索引起始值为1
void get_nextval(SString T, int &nextval[]){
    // i 计算每一个元素Next值的指针，它只可能右移用于计算下一个元素的Next值
    // j 用于指向 无法找到头尾串时 的递归回溯的元素 
    // 初始化第一个元素的Next值
    i = 1; nextval[1] = 0; j = 0;
    while(i < length(T)){
        // 如果递归回溯到第一个元素，它的next值为0，就无法继续回溯 
        // 如果 当前元素 等于 当前元素Next值对应的元素 
        if (j == 0 || T[i] == T[j]){
            ++i; ++j; 
            if(T[i] != T[j]){
                // 如果替补匹配的值不等于当前失配值,则设置它的索引为Next值
               nextval[i] = j;
            }
          else{
                // 否则设置它的Next值为当前失配值的Next值
                nextval[i] = next[j];
            }
        }
        else{
            // 否则递归回溯j，将其指向更小的一个同首尾的子串的尾部 + 1
            j = nextval[j];
        }
    }
}
```

![](/img/next3.webp)