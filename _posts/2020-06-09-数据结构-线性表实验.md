---
title: 数据结构－线性表
tags: 数据结构
---

[toc]

# 顺序表

## 要求

1. 输入一组整型元素序列(不少于 10 个)建立顺序表。
2. 在该顺序表中进行顺序查找某一元素,查找成功返回 1,否则返回 0。
3. 判断该顺序表中元素是否对称,对称返回 1,否则返回 0。
4. 实现把该表中所有奇数排在偶数之前,即表的前面为奇数,后面为偶数。
5. 输入整型元素序列(不少于 10 个),利用有序表插入算法建立一个有序表。
6. 利用算法 5 建立两个非递减有序表,并把它们合并成一个非递减有序表

## 结构体

```c
//元素最大个数
#define  MAXSIZE  15
//元素类型
typedef int ElemType;

typedef  struct List{
    ElemType elem[MAXSIZE];
    //当前长度
    int length;
}SqList;
```

## 创建顺序表

```c
/*
创建顺序表
lengthLimit:待创建SqList长度
*/
SqList *CreateSqList(const int lengthLimit){
    if (lengthLimit <= 0 || lengthLimit > MAXSIZE)
    {
        perror("lengthLimit");
        exit(EXIT_FAILURE);
    }
    SqList *res = NULL;
    res = (SqList *)malloc(sizeof(SqList));
    res->length = 0;
    if (res == NULL)
    {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    fprintf(stdout,"input %d numbers\n",lengthLimit);
    for (size_t i = 0; i < lengthLimit; i++)
    {
            scanf("%d",&(res->elem[i]));
            res->length++;
    }
    return res;
}
```

## 打印

```c
/*
displaySqList
打印
*/
void displaySqList(const SqList *inputSqList)
{
    if (inputSqList == NULL)
    {
        fprintf(stderr,"SqList is null");
        exit(EXIT_FAILURE);
    }
    
    for (size_t i = 0; i < inputSqList->length; i++)
    {
        fprintf(stdout,"%5d",inputSqList->elem[i]);
    }
    fprintf(stdout,"\n");
}
```

## 查找

```c
/*
search from SqList
key:要查找的值
inputSqList:输入的表
*/
int searchFromSqList(const int key,const SqList *inputSqList)
{
    if(key < INT_MIN || key > INT_MAX)
    {
        fprintf(stderr,"The key is out of INT\n");
        return 0;
    }
    if(inputSqList == NULL)
    {
        fprintf(stderr,"inputSqList is NULL\n");
        return 0;
    }
    for (size_t i = 0; i < inputSqList->length; i++)
    {
        if(key == inputSqList->elem[i])
        {
            fprintf(stdout,"find key,address :%p\n",&(inputSqList->elem[i]));
            return 1;
        }
    }
    return -1;
}
```

## 判断是否对称

```c
/*
IsSqListSymmetry
判断是否对称
*/
int IsSqListSymmetry(SqList *inputSqList)
{
    if(inputSqList == NULL)
    {
        fprintf(stderr,"inputSqList is NULL\n");
        return 0;
    }
    for (size_t i = 0; i < (inputSqList->length)/2; i++)
    {
        //elem[i] 和 elem[length  - i - 1]对称
        if(inputSqList->elem[i] != inputSqList->elem[(inputSqList->length) - i-1])
        {
            fprintf(stdout,"SqList is Not Symmetry\n");
            return 0;
        }
    }
    fprintf(stdout,"SqList is Symmetry\n");
    return 1;
}
```

## 奇数偶数分离

```c
/*
奇数偶数分离
奇数在前
偶数在后
OddEvenSeparationSqList
*/
void OddEvenSeparationSqList(SqList *inputSqlList)
{
    if (inputSqlList == NULL)
    {
        fprintf(stderr,"inputSqList is NULL\n");
        return ;
    }
    if (inputSqlList->length == 0)
    {
        return;
    }
    int tmp = 0;
    //效率不高,后续可以改进
    for (size_t i = 0; i < inputSqlList->length; i++)
    {
        //当前如果是奇数,直接跳过
        if (inputSqlList->elem[i] % 2 != 0)
        {
            continue;
        }
        for (size_t j = i+1; j < inputSqlList->length; j++)
        {
            //交换
            if (inputSqlList->elem[j] % 2 != 0)
            {
                tmp = inputSqlList->elem[i];
                inputSqlList->elem[i] = inputSqlList->elem[j];
                inputSqlList->elem[j] = tmp;
            }  
        }
    }
}

```

## 有序建立表

```c
/*
cmpstringp
实现qsort的辅助函数 
*/
// static int cmpstringp(const void *a,const void *b)
// {
//     return *(int *)a - *(int *)b;
// }
/*
有序建立表
*/
SqList *CreateSortSqList(const int lengthLimit){
    if (lengthLimit <= 0 || lengthLimit > MAXSIZE)
    {
        perror("lengthLimit");
        exit(EXIT_FAILURE);
    }
    SqList *res = NULL;
    res = (SqList *)malloc(sizeof(SqList));
    res->length = 0;
    if (res == NULL)
    {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    fprintf(stdout,"input %d numbers\n",lengthLimit);
    for (size_t i = 0; i < lengthLimit; i++)
    {
            scanf("%d",&(res->elem[i]));
            res->length++;
    }
    //排序
    //算法很多,可使用Linux自带的qsort
    //具体用法参考man page
    // qsort(res->elem,lengthLimit,sizeof(int *),cmpstringp);
    for (size_t i = 0; i < lengthLimit; i++)
    {
        for (size_t j = i; j < lengthLimit; j++)
        {
            if (res->elem[i] > res->elem[j])
            {
                int tmp = res->elem[i];
                res->elem[i] = res->elem[j];
                res->elem[j] = tmp;
            }
        }
    }
    return res;
}
```

## 链接两个有序表

```c
/*
链接两个有序表
LinkSortSqList
*/
SqList *LinkSortSqList(SqList *inputSqList1,SqList *inputSqList2)
{
    //异常
    if (inputSqList1->length != 0 && inputSqList2->length == 0)
    {
        return inputSqList1;
    }
    if (inputSqList1->length == 0 && inputSqList2->length != 0)
    {
        return inputSqList2;
    }
    if (inputSqList1->length == 0 && inputSqList2->length == 0)
    {
        return NULL;
    }
    if (inputSqList1 == NULL || inputSqList2 == NULL)
    {
        fprintf(stderr,"input is null\n");
        return NULL;   
    }
    SqList *res = NULL;
    res = (SqList *)malloc(sizeof(SqList));
    if (res == NULL)
    {
        perror("malloc();");
        exit(EXIT_FAILURE);
    }
    res->length = inputSqList1->length + inputSqList2->length;
    //用一个数组来存储两个顺序表元素和其出现的次数
    //用map更好
    // int temp[INT_MAX]  ={0}; ///INT_MAX分配不了这么大的内存
    int temp[100] = {0};//后续输入值在100内
    for (size_t i = 0; i < inputSqList1->length ; i++)
    {
        temp[inputSqList1->elem[i]]++;
    }
    for (size_t j = 0; j < inputSqList2->length; j++)
    {
        temp[inputSqList2->elem[j]]++;
    }
    int count = 0;
    for (size_t k = 0; k < 100; k++)
    {
        if (temp[k] == 0)
        {
            continue;
        }
        else
        {
            for (size_t g = 0; g < temp[k]; g++)
            {
                res->elem[count] = k;
                count++;
            }       
        }
    }
    return res;
}
```

